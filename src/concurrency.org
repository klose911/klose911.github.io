#+TITLE: Java并发基础
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/org.css" />
#+OPTIONS: num:nil timestamp:nil

* Java线程：概念与原理 
** 操作系统中线程和进程 
+ 进程：进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间 
+ 线程：线程是指进程中的一个执行流程。一个进程中可以运行多个线程 
    
** java中的线程
java.lang.Thread类的一个实例, 只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上
*** 线程的执行 
一个Java应用总是从main()方法开始运行，main()方法运行在一个线程内，它被称为主线程。一旦创建一个新的线程，就产生一个新的调用栈 
*** 线程的名字
一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是main，非主线程的名字不确定 \\
获取当前线程的对象的方法是：Thread.currentThread() 
*** 线程的启动
每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证, 当线程目标run()方法结束时该线程完成 \\
一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次 
*** 线程的调度
线程的调度是JVM的一部分，在一个CPU的机器上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的 
尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实
     
** 线程栈模型
线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的, 当调用Thread的start， 或者Runnable的run方法， 会增加一个调用栈 
    
** 线程状态
*** 新状态
线程对象已经创建，还没有在其上调用start()方法
*** 可运行状态
当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态
*** 运行状态
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式
*** 等待/阻塞/睡眠状态
这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态
*** 死亡态
当线程的run()方法完成时就认为它死去 
    
** 线程状态切换 
*** 睡眠
Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。 
+ 线程睡眠是帮助所有线程获得运行机会的最好方法
+ 线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态
+ sleep()是静态方法，只能控制当前正在运行的线程 
*** 让步
yield()方法：让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会
+ 使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的， 
*** 加入
Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。
+ join保证当前线程停止执行，直到该线程所加入的线程完成为止, 然而，如果它加入的线程没有存活，则当前线程不需要停止。 
*** 线程的run()方法完成
1. 在对象上调用wait()方法（不是在线程上调用）
2. 线程不能在对象上获得锁
3. 线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由
    
** 线程的同步与锁 
*** 对象锁
Java中每个对象都有一个内置锁
+ 当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。
+ 如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。释放锁是指持锁线程退出了synchronized同步方法或代码块。

对象锁细节
1. 只能同步方法/代码，而不能同步变量和类
2. 当提到同步时，应该清楚在哪个对象上同步
3. 类可以同时拥有同步和非同步方法
4. 如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法
5. 如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制
6. 线程睡眠时，它所持的任何锁都不会释放
7. 线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁
8. 同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块
9. 在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁  

*** 静态锁
要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class) 
+ 调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预
+ 调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上
+ 静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上
+ 对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞
*** 何时需要同步
在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。
*** 线程安全类
当一个类已经很好的同步以保护它的数据时 
*** 死锁
线程间相互等待锁锁 
    
** 线程的交互 
*** 接口 
    #+BEGIN_SRC java
 //唤醒在此对象监视器上等待的单个线程。 
 void notify()
 //唤醒在此对象监视器上等待的所有线程。 
 void notifyAll() 
 //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
 void wait() 
 //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。  
 void wait(long timeout) 
 //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法
 //或者其他某个线程中断当前线程，或者已超过某个实际时间量。
 void wait(long timeout, int nanos) 
    #+END_SRC 
+ 线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁
+ wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自“通知”
+ 线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止
+ 如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作
+ 当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁
+ 调用notify()时，如果线程仍然在完成同步代码，则线程在移出之前不会放弃锁。notify()并不意味着这时该锁变得可用
+ 多个线程在等待一个对象锁时候使用notifyAll() 
    
** 线程的调度 
*** 休眠
将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行 
     #+BEGIN_SRC java
       /**
         *哪个线程调用sleep，就休眠哪个线程
        **/
       Thread.sleep(long millis);
       Thread.sleep(long millis, int nanos);
     #+END_SRC
+ sleep方法不会释放锁
+ 不管怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制
*** 优先级：线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5
+ 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同
+ 优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。但优先级无法保障线程的执行顺序 
*** 让步：当前运行着线程让出CPU资源，但是然给谁不知道，仅仅是让出，线程状态回到可运行状态 
    #+BEGIN_SRC java
      /**
       ,** 暂停当前正在执行的线程对象，并执行其他线程
       ,**/
      Thread.yield();
    #+END_SRC
+ yield方法不会释放锁
*** 合并：将几个并行线程的线程合并为一个单线程执行。当一个线程必须等待另一个线程执行完毕才能执行时 
    #+BEGIN_SRC java
      /**
       ** 等待该线程终止
       **/
      void join();
      /**
       ** 等待该线程终止的时间最长为 millis 毫秒    
       **/
      void join(long millis);
      /**
       ** 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。
       **/
      void join(long millis, int nanos); 
      t.join(); // 线程t加入主线程， 开始执行线程t，线程t执行完毕，继续执行原来的主线程
    #+END_SRC 
*** 守护线程：JVM的垃圾回收、内存管理, 数据库连接池监控连接个数、超时时间、状态等
    #+BEGIN_SRC java
      /**
         将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。    
         该方法必须在启动线程前调用。
         该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。
         参数： 
         on - 如果为 true，则将该线程标记为守护线程。    
         抛出：    
         IllegalThreadStateException - 如果该线程处于活动状态。    
         SecurityException - 如果当前线程无法修改该线程。 
         另请参见： 
         isDaemon(), checkAccess()
      ,**/
      public final void setDaemon(boolean on);
    #+END_SRC
JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态!!!! 

** 线程的同步
*** 生产者-消费者-仓储模型
+ 生产者仅仅在仓储未满时候生产，仓满则停止生产
+ 消费者仅仅在仓储有产品时候才能消费，仓空则等待
+ 当消费者发现仓储没产品可消费时候会通知生产者生产
+ 生产者在生产出可消费产品时候，应该通知等待的消费者去消费

*** 生产者-消费者实现
- 生产/消费方法必须是synchronized或者包含synchronized的代码块
- synchronized的代码不应该调用sleep/yield, 因为不会释放锁，会有死锁的风险
- 当发现不能满足生产或者消费条件的时候，调用对象的wait方法, wait的作用是释放当前线程的所获得的锁
- 当生产/消费完成后，调用对象的notfiyAll方法, 通知该对象上其他等待线程, 但notfiyAll本身并不会释放锁 

* java5 多线程扩展 
** 线程池
开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理
1. 固定大小的线程池
2. 单任务线程池
3. 可变尺寸的线程池
4. 延迟连接池
5. 单任务延迟连接池
6. 自定义线程池
    #+BEGIN_SRC java
      /**
         用给定的初始参数和默认的线程工厂及处理程序创建新的 ThreadPoolExecutor。
         使用 Executors 工厂方法之一比使用此通用构造方法方便得多。
         @参数：
         corePoolSize - 池中所保存的线程数，包括空闲线程。
         maximumPoolSize - 池中允许的最大线程数。
         keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。
         unit - keepAliveTime 参数的时间单位。
         workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。
         @抛出：
         IllegalArgumentException - 如果 corePoolSize 或 keepAliveTime 小于零，
                                    或者 maximumPoolSize 小于或等于零，
                                    或者 corePoolSize 大于 maximumPoolSize。
         NullPointerException - 如果 workQueue 为 null
      **/
      public ThreadPoolExecutor(int corePoolSize,
                                int maximumPoolSize,
                                long keepAliveTime,
                                TimeUnit unit,
                                BlockingQueue<Runnable> workQueue);
    #+END_SRC

** Callable接口
有返回值的线程，执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object 

** Lock对象
方便的实现资源的封锁，用来控制对竞争资源并发访问的控制
*** Condition
将Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象
+ 通过将Condition与任意Lock实现组合使用，为每个对象提供多个等待set（wait-set）
*** Lock
提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作 
+ ReadWriteLock: 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作 

** 条件变量
更精细控制线程等待与唤醒！！！  
*** 通过一个Lock对象上调用newCondition()方法来获取的，条件就和一个锁对象绑定起来
*** 一个锁可以有多个条件，每个条件上可以有多个线程等待
+ 通过调用await()方法，可以让线程在该条件下等待
+ 当调用signalAll()方法，又可以唤醒该条件下的等待的线程 

** 信号量
一个功能完毕的计数器 
1. 监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目  
2. 但不能指出来有哪些在等待，哪些资源可用！！！

** 障碍器
多线程并发控制的一种手段，一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务
1. 创建java.util.concurrent.CyclicBarrier， 指定子线程任务个数，以及主线程任务 
2. 创建子线程任务，并注入创建好的java.util.concurrent.CyclicBarrier对象
3. 运行子线程任务，子线程任务完成后调用java.util.concurrent.CyclicBarrier#await()方法

** 多线程的数据结构
*** 阻塞队列
java.util.concurrent.BlockingQueue 先进先出
+ 一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止
+ 当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止 
*** 阻塞栈
java.util.concurrent.BlockingDeque 后进先出 


