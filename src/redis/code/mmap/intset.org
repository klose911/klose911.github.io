#+TITLE: 整数集合
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./mmap.html
#+OPTIONS: num:nil timestamp:nil ^:nil

*整数集合* _intset_ 用于 *有序*  *无重复* 地保存多个整数值， 根据元素的值， 自动选择该用什么长度的整数类型来保存元素
#+begin_example
  举个例子， 如果在一个 intset 里面， 最长的元素可以用 int16_t 类型来保存， 那么这个 intset 的所有元素都以 int16_t 类型来保存

  另一方面， 如果有一个新元素要加入到这个 intset ， 并且这个元素不能用 int16_t 类型来保存 比如说， 新元素的长度为 int32_t

  那么这个 intset 就会自动进行“升级”： 先将集合中现有的所有元素从 int16_t 类型转换为 int32_t 类型， 接着再将新元素加入到集合中
#+end_example

根据需要， intset 可以自动从 int16_t 升级到 int32_t 或 int64_t ， 或者从 int32_t 升级到 int64_t 
* 应用
Intset 是 _集合键_ 的底层实现之一，如果一个集合：
+ 只保存着 *整数* 元素
+ 元素的 *数量不多* 

那么 Redis 就会使用 intset 来保存集合元素
* 实现
以下是 _intset.h/intset_ 类型的定义：

#+begin_src c 
  typedef struct intset {
	  uint32_t encoding; // 保存元素所使用的类型的长度
	  uint32_t length; // 元素个数
	  int8_t contents[]; // 保存元素的数组
  } intset;
#+end_src

_encoding_ 的值可以是以下三个常量之一：

#+begin_src c 
  #define INTSET_ENC_INT16 (sizeof(int16_t))
  #define INTSET_ENC_INT32 (sizeof(int32_t))
  #define INTSET_ENC_INT64 (sizeof(int64_t))
#+end_src

_contents_ 数组是实际保存元素的地方，数组中的元素有以下两个特性：
+ 元素不重复
+ 元素在数组中由小到大排列

contents 数组的 int8_t 类型声明比较容易让人误解：
+ 实际上， intset 并不使用 int8_t 类型来保存任何元素，结构中的这个类型声明只是作为一个占位符使用
+ 在对 contents 中的元素进行读取或者写入时，程序并不是直接使用 contents 来对元素进行索引，而是 *根据 encoding 的值，对 contents 进行类型转换和指针运算，计算出元素在内存中的正确位置* 
+ 在添加新元素，进行内存分配时，分配的空间也是由 encoding 的值决定

下表列出了处理 intset 的一些主要操作，以及这些操作的算法复杂度：

#+CAPTION: intset API 
#+ATTR_HTML: :border 1 :rules all :frame boader
| 操作                 | 函数                | 复杂度  |
| 创建 intset          | intsetNew           | $O(1)$  |
| 删除 intset          | 无                  | 无      |
| 添加新元素（不升级） | intsetAdd           | $O(N)$  |
| 添加新元素（升级）   | intsetUpgradeAndAdd | $O(N)$  |
| 按索引获取元素       | _intsetGet          | $O(1)$  |
| 按索引设置元素       | _intsetSet          | $O(1)$  |
| 查找元素，返回索引   | intsetSearch        | $O(\log{N})$ |
| 删除元素             | intsetRemove        | $O(N)$  |

* 实例
使用一个 intset 的创建和添加过程，借此了解 intset 的运作方式

** 创建新 intset
_intset.c/intsetNew_ 函数创建一个新的 intset ，并设置初始化值：

#+begin_src c
  intset *is = intsetNew();

  // intset->encoding = INTSET_ENC_INT16;
  // intset->length 0;
  // intset->contents = [];
#+end_src

注意： encoding 使用 INTSET_ENC_INT16 作为初始值

** 添加新元素到 intset
创建 intset 之后，就可以对它添加新元素了。添加新元素到 intset 的工作由 _intset.c/intsetAdd_ 函数完成，需要处理以下三种情况：
1. 元素已存在于集合，不做动作
2. 元素不存在于集合，并且添加新元素并不需要升级
3. 元素不存在于集合，但是要在升级之后，才能添加新元素

并且， intsetAdd 需要维持 intset->contents 的以下性质：
+ 确保数组中没有重复元素
+ 确保数组中的元素按由小到大排序

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-1565e65522fdcd4245030f17b5074729033297d8.svg]]

接下来分别演示添加操作在升级和不升级两种情况下的执行过程

*** 添加新元素到 intset （不需要升级）
如果 intset 现有的编码方式适用于新元素， 则可直接将新元素添加到 intset ， 无须对 intset 进行升级。以下代码演示了将三个 int16_t 类型的整数添加到集合的过程， 以及在添加过程中，集合的状态：

#+begin_src c 
  intset *is = intsetNew();

  intsetAdd(is, 10, NULL);

  // is->encoding = INTSET_ENC_INT16;
  // is->length = 1;
  // is->contents = [10];

  intsetAdd(is, 5, NULL);

  // is->encoding = INTSET_ENC_INT16;
  // is->length = 2;
  // is->contents = [5, 10];

  intsetAdd(is, 12, NULL);

  // is->encoding = INTSET_ENC_INT16;
  // is->length = 3;
  // is->contents = [5, 10, 12]
#+end_src

#+begin_example
  因为添加的三个元素都可以表示为 int16_t ， 因此 is->encoding 一直都是 INTSET_ENC_INT16 

  另一方面， is->length 和 is->contents 的值，则随着新元素的加入而被修改
#+end_example

*** 添加新元素到 intset （需要升级）
当要添加新元素到 intset ，并且 intset 当前的编码，不适用于新元素的编码时，就需要对 intset 进行升级。以下代码演示了带升级的添加操作的执行过程：

#+begin_src c 
  intset *is = intsetNew();

  intsetAdd(is, 1, NULL);

  // is->encoding = INTSET_ENC_INT16;
  // is->length = 1;
  // is->contents = [1];                  // 所有值使用 int16_t 保存

  intsetAdd(is, 65535, NULL);

  // is->encoding = INTSET_ENC_INT32;     // 升级
  // is->length = 2;
  // is->contents = [1, 65535];           // 所有值使用 int32_t 保存

  intsetAdd(is, 70000, NULL);

  // is->encoding = INTSET_ENC_INT32;
  // is->length = 3;
  // is->contents = [1, 65535, 70000];

  intsetAdd(is, 4294967295, NULL);

  // is->encoding = INTSET_ENC_INT64;                 // 升级
  // is->length = 4;
  // is->contents = [1, 65535, 70000, 4294967295];    // 所有值使用 int64_t 保存
#+end_src

#+begin_example
  在添加 65535 和 4294967295 之后， encoding 属性的值，以及 contents 数组保存值的方式，都被改变了
#+end_example

* 升级
