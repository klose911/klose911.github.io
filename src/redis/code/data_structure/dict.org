#+TITLE: 字典
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./data_structure.html
#+HTML_LINK_UP: ./adlist.html
#+OPTIONS: num:nil timestamp:nil ^:nil

*字典* _dictionary_ ， 又名 *映射* _map_ 或 *关联数组*  _associative array_ ， 是一种抽象数据结构， 由一组 *键值对* _key-value pairs_ 组成， 各个键值对的键各不相同， 程序可以 _添加_ 新的键值对到字典中， 或者基于键进行 _查找_ 、 _更新_ 或 _删除_ 等操作 

#+BEGIN_EXAMPLE
  接下来先对字典在 Redis 中的应用进行介绍

  接着讲解字典的具体实现方式， 以及这个字典实现要解决的问题

  最后， 以对字典迭代器的介绍作为结束
#+END_EXAMPLE
* 应用
字典在 Redis 中的应用广泛， 使用频率可以说和 SDS 以及双端链表不相上下， 基本上各个功能模块都有用到字典的地方。其中， 字典的主要用途有以下两个：
+ 实现 *数据库键空间* _key space_
+ 用作 *Hash 类型键* 的底层实现之一
  
** 实现数据库键空间
Redis 是一个键值对数据库， 数据库中的 _键值对_ 由 *字典* 保存： 每个数据库都有一个对应的字典， 这个字典被称之为 *键空间* _key space_
+ 当用户添加一个键值对到数据库时（不论键值对是什么类型）， 程序就将该键值对添加到键空间
+ 当用户从数据库中删除键值对时， 程序就会将这个键值对从键空间中删除

举个例子，执行 _FLUSHDB_ 可以清空键空间里的所有键值对数据：

#+begin_src sh 
  redis> FLUSHDB
  OK
#+end_src

执行 _DBSIZE_ 则返回键空间里现有的键值对：

#+begin_src sh 
  redis> DBSIZE
  (integer) 0
#+end_src

#+begin_example
  后面章节会对键空间以及数据库的实现作详细的介绍

  大部分针对数据库的命令， 比如 DBSIZE 、 FLUSHDB 、 RANDOMKEY ， 等等， 都是构建于对字典的操作之上的

  而那些创建、更新、删除和查找键值对的命令， 也无一例外地需要在键空间上进行操作
#+end_example
** Hash 类型键的底层实现之一
Redis 的 Hash 类型键使用以下两种数据结构作为底层实现:
+ 字典
+ 压缩列表

  #+begin_example
    因为压缩列表比字典更节省内存， 所以程序在创建新 Hash 键时， 默认使用压缩列表作为底层实现

    当有需要时， 程序才会将底层实现从压缩列表转换到字典
  #+end_example

当用户操作一个 Hash 键时， 键值在底层就可能是一个哈希表：

#+begin_src sh 
  redis> HSET book name "The design and implementation of Redis"
  (integer) 1

  redis> HSET book type "source code analysis"
  (integer) 1

  redis> HSET book release-date "2013.3.8"
  (integer) 1

  redis> HGETALL book
  1) "name"
  2) "The design and implementation of Redis"
  3) "type"
  4) "source code analysis"
  5) "release-date"
  6) "2013.3.8"
#+end_src

#+begin_example
  以后《哈希表》章节给出了关于哈希类型键的更多信息， 并介绍了压缩列表和字典之间的转换条件
#+end_example
* 实现
实现字典的方法有很多种：
+ 最简单的就是使用 _链表_ 或 _数组_ ，但是这种方式只适用于 *元素个数不多* 的情况下：
+ 要 *兼顾高效和简单性* ，可以使用 _哈希表_
+ 如果追求更为稳定的性能特征，并希望 *高效地实现排序* 操作的话，则可使用更为复杂的 _平衡树_ 

#+begin_example
在众多可能的实现中， Redis 选择了高效、实现简单的哈希表，作为字典的底层实现
#+end_example

_dict.h/dict_ 给出了这个字典的定义：

#+begin_src c 
  /*
   ,* 字典
   ,*
   ,* 每个字典使用两个哈希表，用于实现渐进式 rehash
   ,*/
  typedef struct dict {
	  dictType *type; // 特定于类型的处理函数
	  void *privdata; // 类型处理函数的私有数据
	  dictht ht[2]; // 哈希表（2 个）
	  int rehashidx; // 记录 rehash 进度的标志，值为 -1 表示 rehash 未进行
	  int iterators; // 当前正在运作的安全迭代器数量
  } dict;
#+end_src

以下是用于处理 dict 类型的 API ， 它们的作用及相应的算法复杂度：

#+CAPTION: dict API 
#+ATTR_HTML: :border 1 :rules all :frame boader
| 操作                           | 函数                   | 算法复杂度 |
| 创建一个新字典                 | dictCreate             | $O$(1)       |
| 添加新键值对到字典             | dictAdd                | $O$(1)       |
| 添加或更新给定键的值           | dictReplace            | $O$(1)       |
| 在字典中查找给定键所在的节点   | dictFind               | $O$(1)       |
| 在字典中查找给定键的值         | dictFetchValue         | $O$(1)       |
| 从字典中随机返回一个节点       | dictGetRandomKey       | $O$(1)       |
| 根据给定键，删除字典中的键值对 | dictDelete             | $O$(1)       |
| 清空并释放字典                 | dictRelease            | $O$(N)       |
| 清空并重置（但不释放）字典     | dictEmpty              | $O$(N)       |
| 缩小字典                       | dictResize             | $O$(N)       |
| 扩大字典                       | dictExpand             | $O$(N)       |
| 对字典进行给定步数的 rehash    | dictRehash             | $O$(N)       |
| 在给定毫秒内，对字典进行rehash | dictRehashMilliseconds | $O$(N)       |

注意 dict 类型使用了两个指针，分别指向两个 _哈希表_ 。其中：
+ 0 号哈希表 _ht[0]_ 是字典主要使用的哈希表
+ 1 号哈希表 _ht[1]_ 则只有在程序对 0 号哈希表进行 _rehash_ 时才使用。

#+begin_example
接下来两个小节将对哈希表的实现，以及哈希表所使用的哈希算法进行介绍
#+end_example
** 哈希表实现
字典所使用的哈希表实现由 _dict.h/dictht_ 类型定义：

#+begin_src c 
  /*
   ,* 哈希表
   ,*/
  typedef struct dictht {
	  dictEntry **table; // 哈希表节点指针数组（俗称桶，bucket）
	  unsigned long size; // 指针数组的大小
	  unsigned long sizemask; // 指针数组的长度掩码，用于计算索引值
	  unsigned long used; // 哈希表现有的节点数量
  } dictht;
#+end_src

_table_ 属性是个数组， 数组的每个元素都是个指向 _dictEntry 结构_ 的 *指针* 。每个 dictEntry 都保存着一个 _键值对_ ， 以及一个指向 _另一个 dictEntry 结构_ 的 *指针* ：


#+begin_src c 
  /*
   ,* 哈希表节点
   ,*/
  typedef struct dictEntry {
	  void *key; // 键

	  union {
		  void *val;
		  uint64_t u64;
		  int64_t s64;
	  } v; // 值

	  struct dictEntry *next; // 链往后继节点
  } dictEntry;
#+end_src

next 属性指向另一个 dictEntry 结构， 多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， dictht 使用 _链地址法_ 来处理键碰撞： 当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。下图展示了一个由 dictht 和数个 dictEntry 组成的哈希表例子：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-c720caba6b4d02c54fe310c148f0d56316ee80a2.svg]]

如果再加上之前列出的 dict 类型，那么整个字典结构可以表示如下：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-6989792733a041b23cdc0b8f126434590c50a4e4.svg]]

#+begin_example
  在上图的字典示例中， 字典虽然创建了两个哈希表， 但正在使用的只有 0 号哈希表， 这说明字典未进行 rehash 状态
#+end_example
** 哈希算法
Redis 目前使用两种不同的哈希算法：
+ _MurmurHash2_ 32 bit 算法：这种算法的分布率和速度都非常好
  #+begin_example
    具体信息请参考 MurmurHash 的主页： http://code.google.com/p/smhasher/ 
  #+end_example
+ 基于 _djb 算法_ 实现的一个大小写无关散列算法
  #+begin_example
    具体信息请参考 http://www.cse.yorku.ca/~oz/hash.html 
  #+end_example

使用哪种算法取决于具体应用所处理的数据：
+ 命令表以及 Lua 脚本缓存都用到了算法 2
+ 算法 1 的应用则更加广泛：数据库、集群、哈希键、阻塞操作等功能都用到了这个算法
* 创建新字典
_dictCreate_ 函数创建并返回一个新字典：

#+begin_src c 
  dict *d = dictCreate(&hash_type, NULL);
#+end_src

d 的值可以用图片表示如下：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-ce90f2a0f396c0ab66b48c0eb83f18fa8f4754f0.svg]]

新创建的两个哈希表都没有为 _table 属性_ 分配任何空间：
+ _ht[0]->table_ 的空间分配将在 *第一次* 往字典 *添加键值对* 时进行
+ _ht[1]->table_ 的空间分配将在 *rehash* 开始时进行
* 添加键值对到字典
根据字典所处的状态， 将给定的键值对添加到字典可能会引起一系列复杂的操作：
+ 如果字典为未初始化（即字典的 0 号哈希表的 table 属性为空），则程序需要对 0 号哈希表进行 *初始化*
+ 如果在插入时发生了键碰撞，则程序需要处理 *碰撞* 
+ 如果插入新元素，使得字典满足了 rehash 条件，则需要启动相应的  *rehash* 程序

当程序处理完以上三种情况之后，新的键值对才会被真正地添加到字典上。整个添加流程可以用下图表示：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-68f4129c529e0c49d38cfe664cad48af4412770a.svg]]

接下来将分别看到，添加操作如何在以下三种情况中执行：
1. 字典为空
2. 添加新键值对时发生碰撞处理
3. 添加新键值对时触发了 rehash 操作
** 添加新元素到空白字典
当第一次往空字典里添加键值对时， 程序会根据 _dict.h/DICT_HT_INITIAL_SIZE_ 里指定的大小为 _d->ht[0]->table_  *分配空间*

#+begin_example
在目前的版本中， DICT_HT_INITIAL_SIZE 的值为 4 
#+end_example

以下是字典空白时的样子：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-ce90f2a0f396c0ab66b48c0eb83f18fa8f4754f0.svg]]

以下是往空白字典添加了第一个键值对之后的样子：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-5db645431193228424095abdcf1a3270c9da385e.svg]]
** 添加新键值对时发生碰撞处理
在哈希表实现中， 当两个不同的键拥有相同的哈希值时， 称这两个键发生 *碰撞* _collision_

#+begin_example
哈希表实现必须想办法对碰撞进行处理
#+end_example

字典哈希表所使用的碰撞解决方法被称之为 _链地址法_ ： 这种方法使用 *链表* 将多个哈希值相同的节点串连在一起， 从而解决冲突问题。假设现在有一个带有三个节点的哈希表，如下图：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-551247f8f670dc6b0eb2dbd6406aee607068249c.svg]]

对于一个新的键值对 _key4_ 和 _value4_ ， 如果 key4 的哈希值和 key1 的哈希值相同， 那么它们将在哈希表的 _0_ 号索引上发生碰撞。通过将 _key4-value4_ 和 _key1-value1_ 两个键值对用链表连接起来， 就可以解决碰撞的问题：
#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-f351812afbaf4b7c29731b38d17dc4a24f902069.svg]]

** 添加新键值对时触发了 rehash 操作
对于使用链地址法来解决碰撞问题的哈希表 dictht 来说， 哈希表的性能取决于 *大小*  _size属性_ 与 *保存节点数量* _used属性_ 之间的 *比率* ：
+ 哈希表的大小与节点数量，比率在 _1:1_ 时，哈希表的 *性能最好* 
+ 如果 *节点数量比哈希表的大小要大很多* 的话，那么哈希表就会退化成 _多个链表_ ，哈希表本身的性能优势便不复存在；

举个例子， 下面这个哈希表， 平均每次失败查找只需要访问 1 个节点（非空节点访问 2 次，空节点访问 1 次）：

#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-ff857f0c77749cd0213041b561bac0a6348f78e5.svg]]

而下面这个哈希表， 平均每次失败查找需要访问 5 个节点：
#+ATTR_HTML: image :width 90% 
[[file:../pic/graphviz-cbec5e98bba611d3021b57f5417b93538328af42.svg]]

#+begin_example
  为了在字典的键值对不断增多的情况下保持良好的性能， 字典需要对所使用的哈希表（ht[0]）进行 rehash 操作

  在不修改任何键值对的情况下，对哈希表进行扩容， 尽量将比率维持在 1:1 左右
#+end_example

dictAdd 在每次向字典添加新键值对之前， 都会对哈希表 ht[0] 进行检查， 对于 ht[0] 的 size 和 used 属性， 如果它们之间的比率 $ratio = used / size$ 满足以下任何一个条件的话， _rehash_ 过程就会被 *激活* ：
1. 自然 rehash ：  $ratio >= 1 ，且变量 \text{dict_can_resize} 为真$
2. 强制 rehash ：  $ratio 大于变量 \text{dict_force_resize_ratio}$
   #+begin_example
     目前版本中， dict_force_resize_ratio 的值为 5 
   #+end_example

#+begin_example
  什么时候 dict_can_resize 会为假?

  当 Redis 使用子进程对数据库执行后台持久化任务时（比如执行 BGSAVE 或 BGREWRITEAOF 时）

  为了最大化地利用系统的 copy on write 机制， 程序会暂时将 dict_can_resize 设为假

  避免执行自然 rehash ， 从而减少程序对内存的触碰。当持久化任务完成之后， dict_can_resize 会重新被设为真

  另一方面， 当字典满足了强制 rehash 的条件时， 即使 dict_can_resize 不为真（有 BGSAVE 或 BGREWRITEAOF 正在执行）， 这个字典一样会被 rehash 
#+end_example
*** Rehash 执行过程
# #+ATTR_HTML: image :width 90% 
# [[file:../pic/]]

*** 渐进式Rehash
