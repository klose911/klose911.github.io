#+TITLE: 服务器与客户端
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_UP: ./event.html
#+HTML_LINK_HOME: ./internal.html
#+OPTIONS: num:nil timestamp:nil ^:nil

服务器本身并没有多少需要介绍的新东西， 因为服务器除了维持服务器状态之外， 最重要的就是将各个功能模块组合起来。所以接下来将焦点放在服务器的初始化过程， 以及服务器对命令的处理过程上
1. 首先介绍服务器的 _初始化_ 操作， 观察一个 Redis 服务器从启动到可以接受客户端连接， 需要经过什么步骤
2. 接着介绍客户端是如何 _连接_ 到服务器的， 而服务器又是如何维持多个客户端的不同状态的
3. 最后介绍命令从 _发送_ 到 _处理_ 的整个过程， 并列举了一个 SET 命令的执行过程作为例子 
* 初始化服务器
从启动 Redis 服务器， 到服务器可以接受外来客户端的网络连接这段时间， Redis 需要执行一系列初始化操作。整个初始化过程可以分为以下六个步骤：
1. 初始化服务器全局状态
2. 载入配置文件
3. 创建 daemon 进程
4. 初始化服务器功能模块
5. 载入数据
6. 开始事件循环

以下将介绍 Redis 服务器初始化的各个步骤
** 初始化服务器全局状态
_redis.h/redisServer_ 结构记录了和服务器相关的所有数据， 这个结构主要包含以下信息：
+ 服务器中的 *所有数据库* 
+ *命令表* ：在执行命令时，根据字符来查找相应命令的实现函数
+ *事件* 状态
+ 服务器的 *网络连接信息* ：套接字地址、端口，以及套接字描述符
+ 所有 *已连接客户端* 的信息
+ _Lua 脚本的运行环境_ 及相关选项
+ 实现 *订阅与发布* _pub/sub_ 功能所需的数据结构
+ *日志*  _log_ 和慢查询日志 _slowlog_ 的选项和相关信息
+ 数据 *持久化*  _AOF_ 和 _RDB_ 的配置和状态
+ *服务器配置选项* ：
  + 要创建多少个数据库
  + 是否将服务器进程作为 daemon 进程来运行
  + 最大连接多少个客户端
  + 压缩结构 _zip structure_ 的实体数量
  + 。。。。。。。
+ 统计信息：
  + 键有多少次命令不命中
  + 服务器的运行时间
  + 内存占用
  + 。。。。。。


#+begin_example
  为了简洁起见，上面只列出了单机情况下的 Redis 服务器信息，不包含 SENTINEL 、 MONITOR 、 CLUSTER 等功能的信息
#+end_example

在这一步， 程序 *创建* 一个 *redisServer 结构的实例变量*  _server_ 用作服务器的 *全局状态* ， 并将 server 的各个属性初始化为 *默认值* 

#+begin_example
当 server 变量的初始化完成之后， 程序进入服务器初始化的下一步： 读入配置文件
#+end_example
** 载入配置文件
上一步中， 程序为 server 变量（也即是服务器状态）的各个属性设置了默认值， 但这些默认值有时候并不是最合适的：
+ 用户可能想使用 AOF 持久化，而不是默认的 RDB 持久化
+ 用户可能想用其他端口来运行 Redis ，以避免端口冲突
+ 用户可能不想使用默认的 16 个数据库，而是分配更多或更少数量的数据库
+ 用户可能想对默认的内存限制措施和回收策略做调整
+ 。。。。。。

为了让使用者按自己的要求配置服务器， Redis 允许用户在运行服务器时， 提供相应的 *配置文件* _config file_ 或者显式的 *选项*  _option_ ， Redis 在初始化完 server 变量之后， 会读入配置文件和选项， 然后根据这些配置来对 server 变量的属性值做相应的修改：
1. 如果单纯执行 redis-server 命令，那么服务器以默认的配置来运行 Redis

2. 另一方面， 如果给 Redis 服务器送入一个配置文件， 那么 Redis 将按配置文件的设置来更新服务器的状态
   #+begin_example
     比如说， 通过命令 redis-server /etc/my-redis.conf ， Redis 会根据 my-redis.conf 文件的内容来对服务器状态做相应的修改
   #+end_example
3. 除此之外， 还可以显式地给服务器传入选项， 直接修改服务器配置
   #+begin_example
     举个例子， 通过命令 redis-server --port 10086 ， 可以让 Redis 服务器端口变更为 10086
   #+end_example
4. 当然， 同时使用配置文件和显式选项也是可以的， 如果文件和选项有冲突的地方， 那么优先使用 *选项所指定的配置值*
   #+begin_example
     如果运行命令 redis-server /etc/my-redis.conf --port 10086 ， 并且 my-redis.conf 也指定了 port 选项

     那么服务器将优先使用 --port 10086 （实际上是选项指定的值覆盖了配置文件中的值）
   #+end_example
** 创建 daemon 进程
Redis 默认以 daemon 进程的方式运行。当服务器初始化进行到这一步时， 程序将 *创建* _daemon 进程_ 来运行 Redis ， 并 *创建* 相应的 _pid 文件_ 
** 初始化服务器功能模块
在这一步， 初始化程序完成两件事：
+ 为 _server 变量_ 的 _子属性_ *分配* _内存_
+ *初始化* 这些子属性

为数据结构分配内存， 并初始化这些数据结构， 等同于对相应的功能进行初始化
#+begin_example
  比如说， 当为订阅与发布所需的链表分配内存之后， 订阅与发布功能就处于就绪状态， 随时可以为 Redis 所用了
#+end_example

在这一步， 程序完成的主要动作如下：
+ 初始化 Redis 进程的 *信号* 功能
+ 初始化 *日志* 功能
+ 初始化 *客户端* 功能
+ 初始化 *共享* 对象
+ 初始化 *事件* 功能
+ 初始化 *数据库*
+ 初始化 *网络连接*
+ 初始化 *订阅与发布* 功能
+ 初始化各个 *统计变量*
+ 关联 *服务器定时操作* （cron job）到 _时间事件_ ，关联 *客户端应答处理器* 到 _文件事件_
+ 如果 AOF 功能已打开，那么打开或创建  _AOF 文件_
+ 设置 _内存限制_
+ 初始化 _Lua 脚本环境_
+ 初始化 _慢查询功能_
+ 初始化 _后台定时线程_

完成这一步之后， 服务器打印出 Redis 的 ASCII LOGO 、服务器版本等信息， 表示所有功能模块已经就绪， 可以等待被使用了：
#+begin_example
		_._
	    _.-``__ ''-._
       _.-``    `.  `_.  ''-._           Redis 2.9.7 (7a47887b/1) 32 bit
   .-`` .-```.  ```\/    _.,_ ''-._
  (    '      ,       .-`  | `,    )     Running in stand alone mode
  |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
  |    `-._   `._    /     _.-'    |     PID: 6717
   `-._    `-._  `-./  _.-'    _.-'
  |`-._`-._    `-.__.-'    _.-'_.-'|
  |    `-._`-._        _.-'_.-'    |           http://redis.io
   `-._    `-._`-.__.-'_.-'    _.-'
  |`-._`-._    `-.__.-'    _.-'_.-'|
  |    `-._`-._        _.-'_.-'    |
   `-._    `-._`-.__.-'_.-'    _.-'
       `-._    `-.__.-'    _.-'
	   `-._        _.-'
	       `-.__.-'
#+end_example

虽然所有功能已经就绪， 但这时服务器的数据库还是一片空白
#+begin_example
  程序还需要将服务器上一次执行时记录的数据载入到当前服务器中， 服务器的初始化才算真正完成
#+end_example
** 载入数据
在这一步， 程序需要将持久化在 RDB 或者 AOF 文件里的数据， 载入到服务器进程里面。
+ 如果服务器有 *启用* AOF 功能的话， 那么使用 AOF 文件来还原数据
+ 否则， 程序使用 RDB 文件来还原数据

当执行完这一步时， 服务器打印出一段载入完成信息：
#+begin_src sh 
  [6717] 22 Feb 11:59:14.830 * DB loaded from disk: 0.068 seconds
#+end_src
** 开始事件循环
到了这一步， 服务器的初始化已经完成， 程序打开事件循环， 开始 *接受* _客户端连接_ 。以下是服务器在这一步打印的信息：

#+begin_src sh 
  [6717] 22 Feb 11:59:14.830 * The server is now ready to accept connections on port 6379
#+end_src

初始化完成之后， 服务器状态和各个模块之间的关系图：

#+ATTR_HTML: image :width 90% 
[[file:../pic/server.png]]

* 客户端连接到服务器
