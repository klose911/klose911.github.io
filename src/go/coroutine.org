#+TITLE: 协程
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil  ^:nil

* 什么是协程

可以简单的认为：协程就是 *用户态的线程* ，但是 _上下文切换_ 的时机是靠 *调用方* 自身去控制的。同时，协程和 _用户态线程_ 非常接近，用户态线程之间的切换不需要陷入内核，但部分操作系统中用户态线程的切换需要内核态线程的辅助 

下面是一个简单的例子：

#+begin_src c++
  void A() {
    cout << 1 << " ";
    cout << 2 << " ";
    cout << 3 << " ";
  }

  void B() {
    cout << "x" << " ";
    cout << "y" << " ";
    cout << "z" << " ";
  }

  int main(void) {
    A();
    B();
  }
#+end_src

在单线程中，上述函数的输出为：
#+begin_src sh 
  1 2 3 x y z
#+end_src

如果用 libco 库将上面程序改造一下：

#+begin_src c++ 
  void A() {
    cout << 1 << " ";
    cout << 2 << " ";
    co_yield_ct();  // 切出到主协程
    cout << 3 << " ";
  }

  void B() {
    cout << "x" << " ";
    co_yield_ct();  // 切出到主协程
    cout << "y" << " ";
    cout << "z" << " ";
  }

  int main(void) {
    ...  // 主协程
      co_resume(A);  // 启动协程 A // 1, 2 hang 
    co_resume(B);  // 启动协程 B // x hang 
    co_resume(A);  // 从协程 A 切出处继续执行 // 3 finish 
    co_resume(B);  // 从协程 B 切出处继续执行 // y z finish 
  }
#+end_src

同样在单线程中，改造后的程序输出如下：
#+begin_src sh 
  1 2 x 3 y z
#+end_src

可以看出，切出操作是由 *co_yield_ct()* 函数实现的，而协程的启动和恢复是由 *co_resume()* 实现的。函数 A() 和 B() 并不是一个执行完才执行另一个，而是产生了 “交叉执行“ 的效果，这就是通过协程实现的！

* 协程的优点
#+begin_example
  线程挺好的，为什么需要协程呢？

  因为有些时候我们在执行一些操作（尤其是IO操作）时，不希望去做“创建一个新的线程”这种重量级的操作来异步处理
#+end_example


而是希望：*在当前线程执行中，暂时切换到其他任务中执行，同时在IO真正准备好了之后，再切换回来继续执行！* 相比于多开一个线程来操作，使用协程的好处：
+ 减少了线程的重复高频创建
+ 尽量避免线程的阻塞
+ 提升代码的可维护与可理解性

同时，下面是一些协程的特点：
+ 协程可以 *主动让出* _CPU 时间片_ 
  #+begin_example
    注意：不是当前线程让出 CPU 时间片，而是线程内的某个协程让出时间片供同线程内其他协程运行
  #+end_example
+ 协程可以 *恢复* _CPU 上下文_ ，当另一个协程继续执行时，其需要恢复 CPU 上下文环境
+ 协程有个 *管理者* ，管理者可以选择一个协程来运行，其他协程要么 _阻塞_ ，要么 _ready_ ，或者 _died_ 
+ 运行中的协程将 *占有* 当前线程的所有计算资源
+ 协程天生有栈属性，而且是 *lock free*

