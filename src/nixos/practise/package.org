#+TITLE: 软件打包
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_UP: config.html
#+HTML_LINK_HOME: practise.html

NixOS 的一大特点是，系统所有的二进制程序和库文件都在 /nix/store 目录中，由 Nix 包管理器管理

#+begin_example
  这也意味着，NixOS 不符合 Linux 的 FHS 标准

  它的 /lib 或 /lib64 目录下不存在类似 ld-linux-x86-64.so.2 之类的库文件动态加载器，更不存在 libc.so 之类的库文件

  因此，除非静态链接，否则为其它 Linux 下编译的二进制文件将完全无法在 NixOS 下运行
#+end_example

所以，要在 NixOS 上使用尚不存在于 Nixpkgs 仓库中的软件，最佳方案是自己用 Nix 语言写一份打包脚本，给这个软件打一个包，然后把打包定义加入 configuration.nix 中，从而安装到系统上

关于 NixOS 的软件打包，有三个好消息和两个坏消息。好消息是：
1. Nixpkgs，也就是 NixOS 的软件仓库，提供了大量的打包自动化函数
   #+begin_example
     对于很多使用常见编程语言的开源软件（包括 C/C++，Python，Go，Node.js，Rust 等，但不包括 Java）

     只需要调用现成的函数，指定一下源码的下载方式，Nixpkgs 就能自动检测软件的打包系统，自动传入合适的参数并完成软件打包
   #+end_example
2. 对于以二进制方式分发的软件（常见于闭源软件），Nixpkgs 也提供了现成的自动化解决方案：
   + 一种是 Autopatchelf，自动修改二进制文件中的库文件路径，将其指向 /nix/store 中
   + 另一种是 Bubblewrap，或者基于 Bubblewrap 的 steam-run，模拟一个符合 FHS 标准的运行环境
     #+begin_example
       顾名思义，steam-run 主要针对的是 Steam 游戏平台以及它上面的游戏，但它也可以用于其它闭源软件
     #+end_example
3. Nix 包管理器会在一个隔离的环境中进行软件打包，可以粗略地理解成一个断网，限制权限，只允许访问固定路径的 Docker 容器。在编译过程中，访问外部路径或者联网的尝试全部会失败，只能使用 Nix 编译脚本中事先指定的依赖
   #+begin_example
     因此，打包出来的程序将完全不依赖其它文件
   #+end_example

坏消息是：
1. 开发者不一定比打包者更懂 Linux
   #+begin_example
     开发者可能会在代码和编译脚本里写死各种路径，做出各种只符合 FHS 标准的假设

     此时就需要你手动写补丁，纠正这些路径，让程序可以在 NixOS 上正常编译运行
   #+end_example
2. 一旦遇到了不能使用现成函数的情况，包括下列情况，就得做好 “一杯茶，一包烟，一个 Bug 调一天“ 的准备：
   + 开发者使用了一些奇怪的源码目录结构，或者非标准的编译方式
     #+begin_example
       例如 osdlyrics
     #+end_example
   + 程序主动检测运行环境
     #+begin_example
       例如 UOS 版微信客户端
     #+end_example
   + 程序主动检测对它本身的修改
     #+begin_example
       例如 SVP 视频补帧软件
     #+end_example

   #+begin_example
     我在几个月前将日常使用的发行版从 Arch Linux 换成了 NixOS，在使用过程中打了很多 NixOS 软件包

     本文将从简单的打包开始一步步推进，介绍 NixOS 打包的方法，遇到的常见问题以及应对策略
   #+end_example
* 准备工作
首先，强烈建议安装好 NixOS 操作系统，并在 NixOS 上进行打包
+ 虽然在非 NixOS 的操作系统上也可以用 Nix 包管理器打包软件，但打包出的软件在运行过程中可能还会残留有对 FHS 标准目录的依赖，从而导致它们无法正常在 NixOS 上使用
  #+begin_example
    当然，如果你打包只是自用，只考虑自己的运行环境，那可以忽略这条
  #+end_example
+ 此外，要在非 NixOS 的操作系统上安装 Nix 打包的软件，需要使用 Home Manager，一个通过 Nix 语言的配置文件来管理你的 Home 目录下的软件配置文件的工具
  #+begin_example
    这需要自行研究，或者查阅其它人的相关文章
  #+end_example
** 使用 NUR 的打包模版
_NUR_ 是 Nix 的由 *用户自行管理* 的 _软件仓库_

#+begin_example
  这类似于 Arch Linux 的 AUR

  NUR 提供了一份现成的 Nix 仓库模版，你可以方便地统一添加、管理自己的软件包
#+end_example

在 GitHub 上，访问 [[https://github.com/nix-community/nur-packages-template][nur-packages-template]]，点击 _Use this template_ 用这个模版建立一个仓库。之后，可以将所有软件包统一保存在你新建的仓库。如果要将自己的软件包发布到 NUR，需要向 NUR 的主仓库发起 Pull Request，将自己的仓库地址加进去

#+begin_example
但即使不发 Pull Request，也完全可以直接使用自己的仓库
#+end_example

然后，把你的仓库 Clone 下来
+ 对于不使用 Nix Flake 的用户，运行以下命令可以对 example-package 这个模版自带的示例软件包进行打包：
  #+begin_src sh 
    nix-build -A example-package
  #+end_src
+ 对于使用 Flake 的用户，运行以下命令：
  #+begin_src sh 
    nix flake update # 可选，将 flake.lock 中的 Nixpkgs 等仓库更新到最新版
    nix build ".#example-package"
  #+end_src

接着，在你的 NixOS 配置中添加自己的仓库：
+ 对于不使用 Nix Flake 的用户，在 _configuration.nix_ 中添加如下定义：
  #+begin_src nix 
    nixpkgs.config.packageOverrides = pkgs: {
      myRepo = import (builtins.fetchTarball "https://github.com/nix-community/nur-packages-template/archive/master.tar.gz") {
	inherit pkgs;
      };
    };
  #+end_src
  #+begin_example
    将 https://github.com/nix-community/nur-packages-template 替换成你的仓库地址

    这样操作后，你就能用类似于 pkgs.myRepo.example-package 的方式使用你打的包了
  #+end_example
+ 对于使用 Nix Flake 的用户：
  1. 在 _flake.nix_ 中的 _inputs_ 一节中添加如下定义：
     #+begin_src nix 
       inputs = {
	 # ...
	 myRepo = {
	   url = "github:nix-community/nur-packages-template";
	   inputs.nixpkgs.follows = "nixpkgs";
	 };
	 # ...
       };
     #+end_src
     #+begin_example
       将 nix-community/nur-packages-template 替换成你的仓库地址
     #+end_example
  2. 在 _inputs_ 的 _nixosConfigurations_ 定义中，为每个系统添加一个 module：
     #+begin_src nix 
       outputs = { self, nixpkgs, ... }@inputs: {
	 nixosConfigurations."nixos" = nixpkgs.lib.nixosSystem {
	   system = "x86_64-linux";
	   modules = [
	     # 在 modules 的开头添加下面这几行
	     ({
		     nixpkgs.overlays = [
			     (final: prev: {
			       myRepo = inputs.myRepo.packages."${prev.system}";
			     })
		     ];
	     })
	     # 在 modules 的开头添加上面这几行

	     ./configuration.nix
	   ];
	 };
       };
     #+end_src

这样操作后，就能用类似于 pkgs.myRepo.example-package 的方式使用你打的包了
** 直接在 NixOS 配置文件中添加软件包
#+begin_example
  当然，也可以不使用 NUR 的模版，而是直接把打包定义和 NixOS 的配置文件放在一起
#+end_example

假设有这样一个打包定义，保存成 _example-package.nix_ ：（来自 [[https://github.com/nix-community/nur-packages-template/blob/master/pkgs/example-package/default.nix][default.nix]]）

#+begin_src nix 
  { stdenv }:

  stdenv.mkDerivation rec {
    name = "example-package-${version}";
    version = "1.0";
    src = ./.;
    buildPhase = "echo echo Hello World > example";
    installPhase = "install -Dm755 example $out";
  }
#+end_src

现在可以在 _configuration.nix_ 中使用 _pkgs.callPackage_ 函数来调用它：

#+begin_src nix 
  { config, pkgs, ... }:

  {
    # 直接使用这个包
    environment.systemPackages = [
      (pkgs.callPackage ./example-package.nix { })
    ];

    # 或者将这个包先定义成一个常量
    environment.systemPackages = let
      examplePackage = pkgs.callPackage ./example-package.nix { };
    in [
      examplePackage
    ];
  }
#+end_src

如果要单独尝试构建这个软件包，可以使用以下命令：

#+begin_src sh 
  nix-build -E 'with import <nixpkgs> {}; callPackage ./example-package.nix {}'
#+end_src
* 打包流程
虽然可以直接调用 Nix 包管理器内置的 _builtins.derivation_ 函数进行打包，但一般用更为方便的 _stdenv.mkDerivation_ 函数来生成一个 Nix 包管理器的打包定义。相比于 builtins.derivation，stdenv.mkDerivation 将打包过程分成了 7 个 *步骤* _Phase_ ：
1. 解压 _Unpack_ phase：
   + 在这一步中，stdenv.mkDerivation 会自动解压 _src_ 参数指定的 *源码包*
     #+begin_example
       例如 如果源码包是 .tar.gz 格式的，就会自动调用 tar xf
     #+end_example
   + 但 stdenv.mkDerivation 不能识别所有压缩格式，例如 .zip 就不行，需要手动指定解压命令：
     #+begin_src nix 
       nativeBuildInputs = [ unzip ];
       unpackPhase = ''
	 unzip $src
       '';
     #+end_src
   + stdenv.mkDerivation 要求 _源码包的顶层_ 是一个 _文件夹_ ，解压完成后会自动 _cd_ 进去 
2. 打补丁 _patch_ phase:
   + 在这一步中，stdenv.mkDerivation 会按顺序应用 _patches_ 列表中的 *所有补丁*
     #+begin_example
       这一步可以用来解决一部分软件和 NixOS 的不兼容问题
     #+end_example
3. 配置 _configure_ phase:
   + 这一步相当于运行 _./configure_ 或者 _cmake_
     #+begin_example
       stdenv.mkDerivation 会自动检测打包方案并调用相应命令，或者当相应配置文件不存在时，自动跳过这一步
     #+end_example
     + 注意：要调用 cmake，需要额外加一行 _nativeBuildInputs = [ cmake ];_  把 CMake 加入打包环境中
     + 可以用 _configureFlags_ 或者 _cmakeFlags_ 添加配置参数，例如启用/禁用软件的功能。
4. 编译 _build_ phase:
   + 这一步相当于运行 _make_ 。可以用 _makeFlags_ 添加传给 make 的参数
5. 测试 _test_ phase:
   + 这一步会运行源码中自带的测试用例，以保证软件功能正确
   + 可以用 _doCheck = false;_ 禁用这一步
6. 安装 _install_ phase:
   + 这一步相当于运行 _make install_ ，将编译结果复制到 Nix store 的相应文件夹中
     + 整个构建过程是在临时文件夹中，而不是 Nix store 中进行的，因此需要这一步将文件复制过去
     + 当手动指定安装命令时，*目标路径* 存在变量 _$out_ 中。$out 可以是存放有文件的文件夹，也可以直接是一个文件 
7. 额外修补 _fixup_ phase:
   + 这一步会对 Nix store 中的结果做一些清理
     #+begin_example
       例如去除调试符号等
       Autopatchelf Hook，一个自动替换闭源软件 .so 的路径的 Hook，就是在这一步运行的
     #+end_example
   + 可以用 _dontFixup = true;_ 禁用这一步

每一个步骤都可以手动指定对应的命令，或者在原有命令之前或之后额外增加命令。以安装这一步为例：
#+begin_src nix 
  preInstall = ''
    echo 这里指定在安装步骤之前运行的命令
  '';
  installPhase = ''
    # 运行 preInstall 的命令。默认的 installPhase 自带了下面这一行，但当你指定整个步骤的命令时，就需要自己加上，否则 preInstall 不会运行
    runHook preInstall

    echo 这里指定安装步骤的所有命令

    # 运行 postInstall 的命令，同理
    runHook postInstall
  '';
  postInstall = ''
    echo 这里指定在安装步骤之后运行的命令
  '';
#+end_src

#+begin_example
  只看这些步骤的解释可能有些抽象，因此接下来我会给出一些实例，并给出详细解释

  此外，实例中还会涉及 Nixpkgs 提供的对于几种常用编程语言的专用打包函数

  例如 Python 的 buildPythonPackage，Go 的 buildGoModule 等等

  这些实例都来自 NUR 软件源 https://github.com/xddxdd/nur-packages
#+end_example
* 实例
** 开源
*** 简单：LibOQS（C++，CMake，自动化构建）
#+begin_example
  首先我们来看一个最简单的例子：LibOQS

  LibOQS 提供了多种后量子加密算法的实现，可以用来给 OpenSSL 或 BoringSSL 提供后量子加密支持
#+end_example

LibOQS 使用 CMake 构建，并且本身没有任何依赖，因此基本上所有工作都可以由 stdenv.mkDerivations 自动完成，只需要为 CMake 指定几个额外的参数：

#+begin_src nix 
  # 当你使用 pkgs.callPackage 函数时，这里的参数会用 Nixpkgs 的软件包和函数自动填充（如果有对应的话）
  { lib
  , stdenv
  , fetchFromGitHub
  , cmake
  , ...
  } @ args:

  stdenv.mkDerivation rec {
    # 指定包名和版本
    pname = "liboqs";
    version = "0.7.1";

    # 从 GitHub 下载源代码
    src = fetchFromGitHub ({
      owner = "open-quantum-safe";
      repo = "liboqs";
      # 对应的 commit 或者 tag，注意 fetchFromGitHub 不能跟随 branch！
      rev = "0.7.1";
      # 下载 git submodules，绝大部分软件包没有这个
      fetchSubmodules = false;
      # 这里的 SHA256 校验码不会算怎么办？先注释掉，然后构建这个软件包，Nix 会报错，并提示你正确的校验码
      sha256 = "sha256-m20M4+3zsH40hTpMJG9cyIjXp0xcCUBS+cCiRVLXFqM=";
    });

    # 并行编译，大幅加快打包速度，默认是启用的。对于极少数并行编译会失败的软件包，才需要禁用。
    enableParallelBuilding = true;
    # 如果基于 CMake 的软件包在打包时出现了奇怪的错误，可以尝试启用此选项
    # 此选项禁用了对 CMake 软件包的一些自动修正
    dontFixCmake = true;

    # 将 CMake 加入编译环境，用来生成 Makefile
    nativeBuildInputs = [ cmake ];

    # 传给 CMake 的配置参数，控制 liboqs 的功能
    cmakeFlags = [
      "-DBUILD_SHARED_LIBS=ON"
      "-DOQS_BUILD_ONLY_LIB=1"
      "-DOQS_USE_OPENSSL=OFF"
      "-DOQS_DIST_BUILD=ON"
    ];

    # stdenv.mkDerivation 自动帮你完成其余的步骤
  }
#+end_src

然后运行下面这行命令，Nix 包管理器就会自动构建这个软件包，并把输出链接到当前目录的 results

#+begin_src sh 
  nix-build -E 'with import <nixpkgs> {}; callPackage ./liboqs.nix {}'
#+end_src
*** 中等：openssl-oqs-provider（C，增加依赖）
#+begin_example
  有了 LibOQS，可以再打包一个 OpenSSL OQS Provider

  一个 OpenSSL 3.0 的加解密引擎，可以把后量子加密算法加入 OpenSSL 3.0 中
#+end_example

#+begin_src nix 
  { lib
  , stdenv
  , fetchFromGitHub
  , cmake
  , liboqs
  , openssl_3_0
  , python3
  , ...
  } @ args:

  stdenv.mkDerivation rec {
    pname = "openssl-oqs-provider";
    version = "ec60cde5cc894814016f821a1162fe1a4b888a75";
    src = fetchFromGitHub ({
      owner = "open-quantum-safe";
      repo = "oqs-provider";
      rev = "ec60cde5cc894814016f821a1162fe1a4b888a75";
      fetchSubmodules = false;
      sha256 = "sha256-NyT5CpQeclSJ0b4Qr4McAJXwKgy6SWiUijkAgu6TTNM=";
    });

    enableParallelBuilding = true;
    dontFixCmake = true;

    # nativeBuildInputs 指定的是只有在构建时用到，运行时不会用到的软件包
    # 例如这里的用来生成 Makefile 的 CMake，和用来生成配置文件的 Python
    nativeBuildInputs = [
      cmake
      # 向打包环境加入 Python 和这几个包，preConfigure 中的命令需要用到
      (python3.withPackages (p: with p; [ jinja2 pyyaml tabulate ]))
    ];

    # buildInputs 指定的是运行时也会用到的软件包
    buildInputs = [
      liboqs
      openssl_3_0
    ];

    # 在配置步骤（Configure phase）之前运行的命令，用来启用所有的后量子加密算法
    preConfigure = ''
      cp ${sources.openssl-oqs.src}/oqs-template/generate.yml oqs-template/generate.yml
      sed -i "s/enable: false/enable: true/g" oqs-template/generate.yml
      LIBOQS_SRC_DIR=${sources.liboqs.src} python oqs-template/generate.py
    '';

    cmakeFlags = [ "-DCMAKE_BUILD_TYPE=Release" ];

    # 手动指定安装命令，把 oqsprovider.so 复制到 $out/lib 文件夹下
    # 一般来说可执行文件放在 $out/bin，库文件放在 $out/lib，菜单图标等放在 $out/share
    # 但并非强制，你在 $out 下随便放都可以，只不过在其它地方调用会麻烦一些
    installPhase = ''
      mkdir -p $out/lib
      install -m755 oqsprov/oqsprovider.so "$out/lib"
    '';
  }
#+end_src

这个包主要用来展示 _nativeBuildInputs_ 和 _buildInputs_ 的区别：
+ nativeBuildInputs 只有在 *构建* 时用到，一般用来生成一些配置文件或者编译脚本
  #+begin_example
    在交叉编译（给其它架构的设备编译软件）时，nativeBuildInputs 的架构会和运行编译的设备相同，而不是和目标设备相同

    例如用 x86 电脑给 ARM 树莓派编译时，nativeBuildInputs 的架构会是 x86
  #+end_example
+ buildInputs 在 *构建* 和 *最终运行* 软件时都会用到。所有的依赖库都会放到这里。这些依赖的架构和目标设备相同
  #+begin_example
    例如 openssl-oqs-provider 依赖的 liboqs 必然和它是同一架构的（都是 x86 或者都是 ARM）
  #+end_example
*** 困难：OSDLyrics（Python 和 C++，两轮构建）
接下来来看 [[https://github.com/osdlyrics/osdlyrics][OSDLyrics，一个桌面歌词软件]] 这个包表面上看起来很好打，官方给出的编译命令就是下面几行：

#+begin_src sh 
  ./autogen.sh
  ./configure --prefix=/usr PYTHON=/usr/bin/python3
  make
  sudo make install
#+end_src

#+begin_example
  但是编译命令里出现了 Python，这就比较麻烦了

  OSDLyrics 由 Python 和 C++ 两部分组成，其中 C++ 部分会调用 Python 的库

  因此，官方的编译脚本会把 OSDLyrics 的 Python 模块安装到 Python 的 site-packages 文件夹中

  但是在 Nix 中，对于 OSDLyrics 这个软件包来说，Python 的安装目录是只读的，自然无法安装这个模块
#+end_example

因此需要先给 Python 模块部分单独打个包：

#+begin_src nix 
  { python3Packages
  , fetchFromGitHub
  , writeText
  , ...
  }:

  python3Packages.buildPythonPackage rec {
    pname = "osdlyrics";
    version = "0.5.10";
    src = fetchFromGitHub ({
      owner = "osdlyrics";
      repo = "osdlyrics";
      rev = "0.5.10";
      fetchSubmodules = false;
      sha256 = "sha256-x9gIT1JkfPIc4RmmQJLv9rOG2WqAftoTK5uiRlS65zU=";
    });

    configurePhase =
      let
	# 原软件包的 Python 模块部分不符合 PIP 的打包格式，需要手动加入这两个配置文件
	setupPy = writeText "setup.py" ''
	  from setuptools import setup, find_packages
	  setup(
	    name='${pname}',
	    version='${version}',
	    packages=['osdlyrics', 'osdlyrics/dbusext'],
	  )
	'';
	initPy = writeText "__init__.py" ''
	  PROGRAM_NAME = 'OSD Lyrics'
	  PACKAGE_NAME = '${pname}'
	  PACKAGE_VERSION = '${version}'
	'';
      in
      # 把 Python 模块的文件夹改名并加入配置文件，以符合 PIP 规范
      ''
	ln -s ${setupPy} setup.py
	mv python osdlyrics
	ln -s ${initPy} osdlyrics/__init__.py
      '';

    # 禁用测试，原软件包中没有单元测试
    doCheck = false;
  }
#+end_src
然后把这个模块加入 OSDLyrics 最终使用的 Python 环境：

#+begin_src nix 
  { python3Packages
  , fetchFromGitHub
  , writeText
  , python3
  , ...
  }:

  let
    osdlyricsPython = python3Packages.buildPythonPackage rec {
      # ...
    };

    # 下面列出的包都是 OSDLyrics 要用到的
    python = python3.withPackages (p: with p; [
      chardet
      dbus-python
      future
      mpd2
      osdlyricsPython
      pycurl
      pygobject3
    ]);
  in
  # ...
#+end_src

最终才能打包它的 C++ 部分：

#+begin_src nix 
  { ... }:

  let
  # ...
  in
  stdenv.mkDerivation rec {
    pname = "osdlyrics";
    version = "0.5.10";
    src = fetchFromGitHub ({
      owner = "osdlyrics";
      repo = "osdlyrics";
      rev = "0.5.10";
      fetchSubmodules = false;
      sha256 = "sha256-x9gIT1JkfPIc4RmmQJLv9rOG2WqAftoTK5uiRlS65zU=";
    });

    nativeBuildInputs = [
      # 自动运行 autoconf，也就是 autogen.sh 做的事
      autoreconfHook
      # 生成语言文件的工具
      intltool
      # pkgconfig 被 autoconf 系列配置脚本用来查找依赖
      pkg-config
    ];
    # C++ 部分用到的依赖
    buildInputs = [
      dbus-glib
      gtk2
      libnotify
      # 注意这个 Python 是我们上面定义的，加了几个模块的版本
      python
    ];

    # 解决一些编译错误
    postPatch = ''
      sed -i 's/-Werror//g' configure.ac
    '';

    # autoreconfHook 会在构建步骤中加入一个 autoreconf phase，也有对应的前置/后置命令 Hook
    preAutoreconf = ''
      export AUTOPOINT=intltoolize
    '';

    # 指定用我们的加了模块的 Python
    makeFlags = [ "PYTHON=${python}/bin/python" ];

    # 删除结果中的 Python 模块部分（因为已经打包过了）
    postInstall = ''
      rm -rf $out/lib/python*
    '';
  }
#+end_src

整个完整的定义如下：

#+begin_src nix 
  { stdenv
  , lib
  , fetchFromGitHub
  , writeText
  , python3Packages
    # nativeBuildInputs
  , autoreconfHook
  , intltool
  , pkg-config
    # buildInputs
  , dbus-glib
  , gtk2
  , libnotify
  , python3
  , ...
  } @ args:

  let
    pname = "osdlyrics";
    version = "0.5.10";
    src = fetchFromGitHub ({
      owner = "osdlyrics";
      repo = "osdlyrics";
      rev = "0.5.10";
      fetchSubmodules = false;
      sha256 = "sha256-x9gIT1JkfPIc4RmmQJLv9rOG2WqAftoTK5uiRlS65zU=";
    });

    osdlyricsPython = python3Packages.buildPythonPackage rec {
      inherit pname version src;

      configurePhase =
	let
	  setupPy = writeText "setup.py" ''
	    from setuptools import setup, find_packages
	    setup(
	      name='${pname}',
	      version='${version}',
	      packages=['osdlyrics', 'osdlyrics/dbusext'],
	    )
	  '';
	  initPy = writeText "__init__.py" ''
	    PROGRAM_NAME = 'OSD Lyrics'
	    PACKAGE_NAME = '${pname}'
	    PACKAGE_VERSION = '${version}'
	  '';
	in
	''
	  ln -s ${setupPy} setup.py
	  mv python osdlyrics
	  ln -s ${initPy} osdlyrics/__init__.py
	'';

      doCheck = false;
    };

    python = python3.withPackages (p: with p; [
      chardet
      dbus-python
      future
      mpd2
      osdlyricsPython
      pycurl
      pygobject3
    ]);
  in
  stdenv.mkDerivation rec {
    inherit pname version src;
    nativeBuildInputs = [
      autoreconfHook
      intltool
      pkg-config
    ];
    buildInputs = [
      dbus-glib
      gtk2
      libnotify
      python
    ];
    postPatch = ''
      sed -i 's/-Werror//g' configure.ac
    '';
    preAutoreconf = ''
      export AUTOPOINT=intltoolize
    '';
    makeFlags = [ "PYTHON=${python}/bin/python" ];
    postInstall = ''
      rm -rf $out/lib/python*
    '';
  }
#+end_src

** 闭源
** 特殊
* 总结
