#+TITLE: 软件打包
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_UP: config.html
#+HTML_LINK_HOME: practise.html

NixOS 的一大特点是，系统所有的二进制程序和库文件都在 /nix/store 目录中，由 Nix 包管理器管理

#+begin_example
  这也意味着，NixOS 不符合 Linux 的 FHS 标准

  它的 /lib 或 /lib64 目录下不存在类似 ld-linux-x86-64.so.2 之类的库文件动态加载器，更不存在 libc.so 之类的库文件

  因此，除非静态链接，否则为其它 Linux 下编译的二进制文件将完全无法在 NixOS 下运行
#+end_example

所以，要在 NixOS 上使用尚不存在于 Nixpkgs 仓库中的软件，最佳方案是自己用 Nix 语言写一份打包脚本，给这个软件打一个包，然后把打包定义加入 configuration.nix 中，从而安装到系统上

关于 NixOS 的软件打包，有三个好消息和两个坏消息。好消息是：
1. Nixpkgs，也就是 NixOS 的软件仓库，提供了大量的打包自动化函数
   #+begin_example
     对于很多使用常见编程语言的开源软件（包括 C/C++，Python，Go，Node.js，Rust 等，但不包括 Java）

     只需要调用现成的函数，指定一下源码的下载方式，Nixpkgs 就能自动检测软件的打包系统，自动传入合适的参数并完成软件打包
   #+end_example
2. 对于以二进制方式分发的软件（常见于闭源软件），Nixpkgs 也提供了现成的自动化解决方案：
   + 一种是 Autopatchelf，自动修改二进制文件中的库文件路径，将其指向 /nix/store 中
   + 另一种是 Bubblewrap，或者基于 Bubblewrap 的 steam-run，模拟一个符合 FHS 标准的运行环境
     #+begin_example
       顾名思义，steam-run 主要针对的是 Steam 游戏平台以及它上面的游戏，但它也可以用于其它闭源软件
     #+end_example
3. Nix 包管理器会在一个隔离的环境中进行软件打包，可以粗略地理解成一个断网，限制权限，只允许访问固定路径的 Docker 容器。在编译过程中，访问外部路径或者联网的尝试全部会失败，只能使用 Nix 编译脚本中事先指定的依赖
   #+begin_example
     因此，打包出来的程序将完全不依赖其它文件
   #+end_example

坏消息是：
1. 开发者不一定比打包者更懂 Linux
   #+begin_example
     开发者可能会在代码和编译脚本里写死各种路径，做出各种只符合 FHS 标准的假设

     此时就需要你手动写补丁，纠正这些路径，让程序可以在 NixOS 上正常编译运行
   #+end_example
2. 一旦遇到了不能使用现成函数的情况，包括下列情况，就得做好 “一杯茶，一包烟，一个 Bug 调一天“ 的准备：
   + 开发者使用了一些奇怪的源码目录结构，或者非标准的编译方式
     #+begin_example
       例如 osdlyrics
     #+end_example
   + 程序主动检测运行环境
     #+begin_example
       例如 UOS 版微信客户端
     #+end_example
   + 程序主动检测对它本身的修改
     #+begin_example
       例如 SVP 视频补帧软件
     #+end_example

   #+begin_example
     我在几个月前将日常使用的发行版从 Arch Linux 换成了 NixOS，在使用过程中打了很多 NixOS 软件包

     本文将从简单的打包开始一步步推进，介绍 NixOS 打包的方法，遇到的常见问题以及应对策略
   #+end_example
* 准备工作
首先，强烈建议安装好 NixOS 操作系统，并在 NixOS 上进行打包
+ 虽然在非 NixOS 的操作系统上也可以用 Nix 包管理器打包软件，但打包出的软件在运行过程中可能还会残留有对 FHS 标准目录的依赖，从而导致它们无法正常在 NixOS 上使用
  #+begin_example
    当然，如果你打包只是自用，只考虑自己的运行环境，那可以忽略这条
  #+end_example
+ 此外，要在非 NixOS 的操作系统上安装 Nix 打包的软件，需要使用 Home Manager，一个通过 Nix 语言的配置文件来管理你的 Home 目录下的软件配置文件的工具
  #+begin_example
    这需要自行研究，或者查阅其它人的相关文章
  #+end_example
** 使用 NUR 的打包模版
_NUR_ 是 Nix 的由 *用户自行管理* 的 _软件仓库_

#+begin_example
  这类似于 Arch Linux 的 AUR

  NUR 提供了一份现成的 Nix 仓库模版，你可以方便地统一添加、管理自己的软件包
#+end_example

在 GitHub 上，访问 [[https://github.com/nix-community/nur-packages-template][nur-packages-template]]，点击 _Use this template_ 用这个模版建立一个仓库。之后，可以将所有软件包统一保存在你新建的仓库。如果要将自己的软件包发布到 NUR，需要向 NUR 的主仓库发起 Pull Request，将自己的仓库地址加进去

#+begin_example
但即使不发 Pull Request，也完全可以直接使用自己的仓库
#+end_example

然后，把你的仓库 Clone 下来
+ 对于不使用 Nix Flake 的用户，运行以下命令可以对 example-package 这个模版自带的示例软件包进行打包：
  #+begin_src sh 
    nix-build -A example-package
  #+end_src
+ 对于使用 Flake 的用户，运行以下命令：
  #+begin_src sh 
    nix flake update # 可选，将 flake.lock 中的 Nixpkgs 等仓库更新到最新版
    nix build ".#example-package"
  #+end_src

接着，在你的 NixOS 配置中添加自己的仓库：
+ 对于不使用 Nix Flake 的用户，在 _configuration.nix_ 中添加如下定义：
  #+begin_src nix 
    nixpkgs.config.packageOverrides = pkgs: {
      myRepo = import (builtins.fetchTarball "https://github.com/nix-community/nur-packages-template/archive/master.tar.gz") {
	inherit pkgs;
      };
    };
  #+end_src
  #+begin_example
    将 https://github.com/nix-community/nur-packages-template 替换成你的仓库地址

    这样操作后，你就能用类似于 pkgs.myRepo.example-package 的方式使用你打的包了
  #+end_example
+ 对于使用 Nix Flake 的用户：
  1. 在 _flake.nix_ 中的 _inputs_ 一节中添加如下定义：
     #+begin_src nix 
       inputs = {
	 # ...
	 myRepo = {
	   url = "github:nix-community/nur-packages-template";
	   inputs.nixpkgs.follows = "nixpkgs";
	 };
	 # ...
       };
     #+end_src
     #+begin_example
       将 nix-community/nur-packages-template 替换成你的仓库地址
     #+end_example
  2. 在 _inputs_ 的 _nixosConfigurations_ 定义中，为每个系统添加一个 module：
     #+begin_src nix 
       outputs = { self, nixpkgs, ... }@inputs: {
	 nixosConfigurations."nixos" = nixpkgs.lib.nixosSystem {
	   system = "x86_64-linux";
	   modules = [
	     # 在 modules 的开头添加下面这几行
	     ({
		     nixpkgs.overlays = [
			     (final: prev: {
			       myRepo = inputs.myRepo.packages."${prev.system}";
			     })
		     ];
	     })
	     # 在 modules 的开头添加上面这几行

	     ./configuration.nix
	   ];
	 };
       };
     #+end_src

这样操作后，就能用类似于 pkgs.myRepo.example-package 的方式使用你打的包了
** 直接在 NixOS 配置文件中添加软件包
#+begin_example
  当然，也可以不使用 NUR 的模版，而是直接把打包定义和 NixOS 的配置文件放在一起
#+end_example

假设有这样一个打包定义，保存成 _example-package.nix_ ：（来自 [[https://github.com/nix-community/nur-packages-template/blob/master/pkgs/example-package/default.nix][default.nix]]）

#+begin_src nix 
  { stdenv }:

  stdenv.mkDerivation rec {
    name = "example-package-${version}";
    version = "1.0";
    src = ./.;
    buildPhase = "echo echo Hello World > example";
    installPhase = "install -Dm755 example $out";
  }
#+end_src

现在可以在 _configuration.nix_ 中使用 _pkgs.callPackage_ 函数来调用它：

#+begin_src nix 
  { config, pkgs, ... }:

  {
    # 直接使用这个包
    environment.systemPackages = [
      (pkgs.callPackage ./example-package.nix { })
    ];

    # 或者将这个包先定义成一个常量
    environment.systemPackages = let
      examplePackage = pkgs.callPackage ./example-package.nix { };
    in [
      examplePackage
    ];
  }
#+end_src

如果要单独尝试构建这个软件包，可以使用以下命令：

#+begin_src sh 
  nix-build -E 'with import <nixpkgs> {}; callPackage ./example-package.nix {}'
#+end_src
* 打包流程
虽然可以直接调用 Nix 包管理器内置的 _builtins.derivation_ 函数进行打包，但一般用更为方便的 _stdenv.mkDerivation_ 函数来生成一个 Nix 包管理器的打包定义。相比于 builtins.derivation，stdenv.mkDerivation 将打包过程分成了 7 个 *步骤* _Phase_ ：
1. 解压 _Unpack_ phase：
   + 在这一步中，stdenv.mkDerivation 会自动解压 _src_ 参数指定的 *源码包*
     #+begin_example
       例如 如果源码包是 .tar.gz 格式的，就会自动调用 tar xf
     #+end_example
   + 但 stdenv.mkDerivation 不能识别所有压缩格式，例如 .zip 就不行，需要手动指定解压命令：
     #+begin_src nix 
       nativeBuildInputs = [ unzip ];
       unpackPhase = ''
	 unzip $src
       '';
     #+end_src
   + stdenv.mkDerivation 要求 _源码包的顶层_ 是一个 _文件夹_ ，解压完成后会自动 _cd_ 进去 
2. 打补丁 _patch_ phase:
   + 在这一步中，stdenv.mkDerivation 会按顺序应用 _patches_ 列表中的 *所有补丁*
     #+begin_example
       这一步可以用来解决一部分软件和 NixOS 的不兼容问题
     #+end_example
3. 配置 _configure_ phase:
   + 这一步相当于运行 _./configure_ 或者 _cmake_
     #+begin_example
       stdenv.mkDerivation 会自动检测打包方案并调用相应命令，或者当相应配置文件不存在时，自动跳过这一步
     #+end_example
     + 注意：要调用 cmake，需要额外加一行 _nativeBuildInputs = [ cmake ];_  把 CMake 加入打包环境中
     + 可以用 _configureFlags_ 或者 _cmakeFlags_ 添加配置参数，例如启用/禁用软件的功能。
4. 编译 _build_ phase:
   + 这一步相当于运行 _make_ 。可以用 _makeFlags_ 添加传给 make 的参数
5. 测试 _test_ phase:
   + 这一步会运行源码中自带的测试用例，以保证软件功能正确
   + 可以用 _doCheck = false;_ 禁用这一步
6. 安装 _install_ phase:
   + 这一步相当于运行 _make install_ ，将编译结果复制到 Nix store 的相应文件夹中
     + 整个构建过程是在临时文件夹中，而不是 Nix store 中进行的，因此需要这一步将文件复制过去
     + 当手动指定安装命令时，*目标路径* 存在变量 _$out_ 中。$out 可以是存放有文件的文件夹，也可以直接是一个文件 
7. 额外修补 _fixup_ phase:
   + 这一步会对 Nix store 中的结果做一些清理
     #+begin_example
       例如去除调试符号等
       Autopatchelf Hook，一个自动替换闭源软件 .so 的路径的 Hook，就是在这一步运行的
     #+end_example
   + 可以用 _dontFixup = true;_ 禁用这一步

每一个步骤都可以手动指定对应的命令，或者在原有命令之前或之后额外增加命令。以安装这一步为例：
#+begin_src nix 
  preInstall = ''
    echo 这里指定在安装步骤之前运行的命令
  '';
  installPhase = ''
    # 运行 preInstall 的命令。默认的 installPhase 自带了下面这一行，但当你指定整个步骤的命令时，就需要自己加上，否则 preInstall 不会运行
    runHook preInstall

    echo 这里指定安装步骤的所有命令

    # 运行 postInstall 的命令，同理
    runHook postInstall
  '';
  postInstall = ''
    echo 这里指定在安装步骤之后运行的命令
  '';
#+end_src

#+begin_example
  只看这些步骤的解释可能有些抽象，因此接下来我会给出一些实例，并给出详细解释

  此外，实例中还会涉及 Nixpkgs 提供的对于几种常用编程语言的专用打包函数

  例如 Python 的 buildPythonPackage，Go 的 buildGoModule 等等

  这些实例都来自 NUR 软件源 https://github.com/xddxdd/nur-packages
#+end_example
* 实例
** 开源
*** 简单：LibOQS（C++，CMake，自动化构建）
** 闭源
** 特殊
* 总结
