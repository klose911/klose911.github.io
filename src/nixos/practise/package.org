#+TITLE: 软件打包
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_UP: config.html
#+HTML_LINK_HOME: practise.html

NixOS 的一大特点是，系统所有的二进制程序和库文件都在 /nix/store 目录中，由 Nix 包管理器管理

#+begin_example
  这也意味着，NixOS 不符合 Linux 的 FHS 标准

  它的 /lib 或 /lib64 目录下不存在类似 ld-linux-x86-64.so.2 之类的库文件动态加载器，更不存在 libc.so 之类的库文件

  因此，除非静态链接，否则为其它 Linux 下编译的二进制文件将完全无法在 NixOS 下运行
#+end_example

所以，要在 NixOS 上使用尚不存在于 Nixpkgs 仓库中的软件，最佳方案是自己用 Nix 语言写一份打包脚本，给这个软件打一个包，然后把打包定义加入 configuration.nix 中，从而安装到系统上

关于 NixOS 的软件打包，有三个好消息和两个坏消息。好消息是：
1. Nixpkgs，也就是 NixOS 的软件仓库，提供了大量的打包自动化函数
   #+begin_example
     对于很多使用常见编程语言的开源软件（包括 C/C++，Python，Go，Node.js，Rust 等，但不包括 Java）

     只需要调用现成的函数，指定一下源码的下载方式，Nixpkgs 就能自动检测软件的打包系统，自动传入合适的参数并完成软件打包
   #+end_example
2. 对于以二进制方式分发的软件（常见于闭源软件），Nixpkgs 也提供了现成的自动化解决方案：
   + 一种是 Autopatchelf，自动修改二进制文件中的库文件路径，将其指向 /nix/store 中
   + 另一种是 Bubblewrap，或者基于 Bubblewrap 的 steam-run，模拟一个符合 FHS 标准的运行环境
     #+begin_example
       顾名思义，steam-run 主要针对的是 Steam 游戏平台以及它上面的游戏，但它也可以用于其它闭源软件
     #+end_example
3. Nix 包管理器会在一个隔离的环境中进行软件打包，可以粗略地理解成一个断网，限制权限，只允许访问固定路径的 Docker 容器。在编译过程中，访问外部路径或者联网的尝试全部会失败，只能使用 Nix 编译脚本中事先指定的依赖
   #+begin_example
     因此，打包出来的程序将完全不依赖其它文件
   #+end_example

坏消息是：
1. 开发者不一定比打包者更懂 Linux
   #+begin_example
     开发者可能会在代码和编译脚本里写死各种路径，做出各种只符合 FHS 标准的假设

     此时就需要你手动写补丁，纠正这些路径，让程序可以在 NixOS 上正常编译运行
   #+end_example
2. 一旦遇到了不能使用现成函数的情况，包括下列情况，就得做好 “一杯茶，一包烟，一个 Bug 调一天“ 的准备：
   + 开发者使用了一些奇怪的源码目录结构，或者非标准的编译方式
     #+begin_example
       例如 osdlyrics
     #+end_example
   + 程序主动检测运行环境
     #+begin_example
       例如 UOS 版微信客户端
     #+end_example
   + 程序主动检测对它本身的修改
     #+begin_example
       例如 SVP 视频补帧软件
     #+end_example

   #+begin_example
     我在几个月前将日常使用的发行版从 Arch Linux 换成了 NixOS，在使用过程中打了很多 NixOS 软件包

     本文将从简单的打包开始一步步推进，介绍 NixOS 打包的方法，遇到的常见问题以及应对策略
   #+end_example
* 准备工作
首先，强烈建议安装好 NixOS 操作系统，并在 NixOS 上进行打包
+ 虽然在非 NixOS 的操作系统上也可以用 Nix 包管理器打包软件，但打包出的软件在运行过程中可能还会残留有对 FHS 标准目录的依赖，从而导致它们无法正常在 NixOS 上使用
  #+begin_example
    当然，如果你打包只是自用，只考虑自己的运行环境，那可以忽略这条
  #+end_example
+ 此外，要在非 NixOS 的操作系统上安装 Nix 打包的软件，需要使用 Home Manager，一个通过 Nix 语言的配置文件来管理你的 Home 目录下的软件配置文件的工具
  #+begin_example
    这需要自行研究，或者查阅其它人的相关文章
  #+end_example
** 使用 NUR 的打包模版
_NUR_ 是 Nix 的由 *用户自行管理* 的 _软件仓库_

#+begin_example
  这类似于 Arch Linux 的 AUR

  NUR 提供了一份现成的 Nix 仓库模版，你可以方便地统一添加、管理自己的软件包
#+end_example

在 GitHub 上，访问 [[https://github.com/nix-community/nur-packages-template][nur-packages-template]]，点击 _Use this template_ 用这个模版建立一个仓库。之后，可以将所有软件包统一保存在你新建的仓库。如果要将自己的软件包发布到 NUR，需要向 NUR 的主仓库发起 Pull Request，将自己的仓库地址加进去

#+begin_example
但即使不发 Pull Request，也完全可以直接使用自己的仓库
#+end_example

然后，把你的仓库 Clone 下来
+ 对于不使用 Nix Flake 的用户，运行以下命令可以对 example-package 这个模版自带的示例软件包进行打包：
  #+begin_src sh 
    nix-build -A example-package
  #+end_src
+ 对于使用 Flake 的用户，运行以下命令：
  #+begin_src sh 
    nix flake update # 可选，将 flake.lock 中的 Nixpkgs 等仓库更新到最新版
    nix build ".#example-package"
  #+end_src

接着，在你的 NixOS 配置中添加自己的仓库：
+ 对于不使用 Nix Flake 的用户，在 _configuration.nix_ 中添加如下定义：
  #+begin_src nix 
    nixpkgs.config.packageOverrides = pkgs: {
      myRepo = import (builtins.fetchTarball "https://github.com/nix-community/nur-packages-template/archive/master.tar.gz") {
	inherit pkgs;
      };
    };
  #+end_src
  #+begin_example
    将 https://github.com/nix-community/nur-packages-template 替换成你的仓库地址

    这样操作后，你就能用类似于 pkgs.myRepo.example-package 的方式使用你打的包了
  #+end_example
+ 对于使用 Nix Flake 的用户：
  1. 在 _flake.nix_ 中的 _inputs_ 一节中添加如下定义：
     #+begin_src nix 
       inputs = {
	 # ...
	 myRepo = {
	   url = "github:nix-community/nur-packages-template";
	   inputs.nixpkgs.follows = "nixpkgs";
	 };
	 # ...
       };
     #+end_src
     #+begin_example
       将 nix-community/nur-packages-template 替换成你的仓库地址
     #+end_example
  2. 在 _inputs_ 的 _nixosConfigurations_ 定义中，为每个系统添加一个 module：
     #+begin_src nix 
       outputs = { self, nixpkgs, ... }@inputs: {
	 nixosConfigurations."nixos" = nixpkgs.lib.nixosSystem {
	   system = "x86_64-linux";
	   modules = [
	     # 在 modules 的开头添加下面这几行
	     ({
	       nixpkgs.overlays = [
		 (final: prev: {
		   myRepo = inputs.myRepo.packages."${prev.system}";
		 })
	       ];
	     })
	     # 在 modules 的开头添加上面这几行

	     ./configuration.nix
	   ];
	 };
       };
     #+end_src

这样操作后，就能用类似于 pkgs.myRepo.example-package 的方式使用你打的包了
** 直接在 NixOS 配置文件中添加软件包
#+begin_example
  当然，也可以不使用 NUR 的模版，而是直接把打包定义和 NixOS 的配置文件放在一起
#+end_example

假设有这样一个打包定义，保存成 _example-package.nix_ ：（来自 [[https://github.com/nix-community/nur-packages-template/blob/master/pkgs/example-package/default.nix][default.nix]]）

#+begin_src nix 
  { stdenv }:

  stdenv.mkDerivation rec {
    name = "example-package-${version}";
    version = "1.0";
    src = ./.;
    buildPhase = "echo echo Hello World > example";
    installPhase = "install -Dm755 example $out";
  }
#+end_src

现在可以在 _configuration.nix_ 中使用 _pkgs.callPackage_ 函数来调用它：

#+begin_src nix 
  { config, pkgs, ... }:

  {
    # 直接使用这个包
    environment.systemPackages = [
      (pkgs.callPackage ./example-package.nix { })
    ];

    # 或者将这个包先定义成一个常量
    environment.systemPackages = let
      examplePackage = pkgs.callPackage ./example-package.nix { };
    in [
      examplePackage
    ];
  }
#+end_src

如果要单独尝试构建这个软件包，可以使用以下命令：

#+begin_src sh 
  nix-build -E 'with import <nixpkgs> {}; callPackage ./example-package.nix {}'
#+end_src
* 打包流程
