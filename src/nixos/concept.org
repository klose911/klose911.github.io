#+TITLE: 伊始之章
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_UP: install.html
#+HTML_LINK_HOME: nixos.html
* 二进制分发与源码分发
+ 二进制分发：从字面意思上就很容易理解，软件包仓库开放预编译的二进制包，并供包管理器下载并部署到目标主机
+ 源码分发：从各处拉取源码，下载编译，再部署到目标主机
  #+begin_example
    看起来只是将编译步骤挪到了本地进行而已，但却给了软件包部署更多灵活性
  #+end_example
** 以 Debian 作为二进制分发的例子
Debian 是 GNU/Linux 世界中采用二进制分发的优秀发行版之一，APT 则是它最流行的包管理器之一

#+ATTR_HTML: image :width 90% 
[[file:pic/Apt.svg]] 


为了从远程获取预编译的二进制包，APT 需要从三个地方读取源列表：
+ /etc/apt/sources.list
+ /etc/apt/sources.list.d/*.list
+ /etc/apt/sources.list.d/*.source

然后访问源列表里面的 URL ，获取软件包的元数据（名称，版本，依赖信息等）。这些元数据通常被存储在 _/var/lib/apt/lists/_  。只要有元数据的协助，APT 很快就能推算出要下载的包依赖哪些其他的包，并从软件包仓库开始下载需要的一揽子软件包。这些包被缓存到 _/var/cache/apt/archives/_ 

#+begin_example
Deb 包里面只会包含二进制文件，以及控制这些二进制文件该释放至何处的描述文件
#+end_example

假如想对这个软件包搞点个性化定制，需要自己再克隆源码，修改源码，编译和打包一条龙。 *不能从官方包仓库的软件包直接衍生变体* 

#+begin_example
不同的打包方式带来了 Linux 软件包生态的分裂。你从 Debian 系发行版和 RHEL 系发行版就能观察到 “血脉兼容” 的现象
#+end_example
** 以 Gentoo 作为源码分发的例子
Gentoo 似乎是另一个极端。它的包管理器叫做 Portage，它从官方的软件仓库获取的是 _ebuild 文件_ ，而这些文件会被缓存到 _/var/db/repos/gentoo/_ 下
+ 可以将 ebuild 理解为一种构建软件的脚本。它包含了一些函数和变量，用来指定软件包的元数据、依赖关系、源码地址、编译选项、安装步骤等信息
+ Portage 会根据 ebuild 中的指令来下载、编译和安装软件包
#+ATTR_HTML: image :width 90% 
[[file:pic/Portage.svg]] 

#+begin_example
  https://gitweb.gentoo.org/repo/gentoo.git/tree/app-editors/neovim/neovim-9999.ebuild 是一个 ebuild 文件

  试图理解其中内容可以让这个解释更生动点
#+end_example

获取到源码以后，Portage 开始了繁忙的编译流程：它需要读取一些编译变量，而它们在 _/etc/portage/make.conf_ 这个配置文件里
+ 其中包括全局的 USE 标志、编译选项、镜像源、许可证等
+ 这些变量可以控制 Portage 的功能和性能，也可以根据用户的需求进行优化和定制 

#+begin_example
每一台 Gentoo 主机都可能有不同的编译选项，因此编译出来的产物也不一致，它们已经是一种变体了
#+end_example
另外，许多人喜欢 Gentoo 的原因就是可以更极致地压榨运行性能

#+begin_example
  但是频繁的编译是相当耗费时间的

  后面 Gentoo 又支持了分布式编译，可以让你的其他电脑分担工作量，不过依然是饮鸠止渴
#+end_example
** Nix之道
Nix 是 NixOS 的包管理器，它是跨平台的，可以在 Linux 平台和 Darwin 平台使用
#+begin_example
  二进制分发可以保持包的一致性，使本应正常依赖的包可以正常工作（不过需要包管理器控制版本）

  源码分发可以保持包的灵活性，可以自由拓展软件功能，衍生软件变体。有什么办法可以鱼与熊掌兼得呢？
#+end_example
Nix 则使用一种 _函数式语言_ 来 *描述* _软件包_ 及其 _依赖关系_ ， *每个软件包都被视为一个纯函数的输出* ，这个输出是 _/nix/store/ 下一个带有 *哈希值* 的目录_ :
+ /nix/store/ 下的哈希路径是根据 *软件包的表达式* _描述打包的 Nix 文件_ 和 *构建过程* _参与构建的参数_ 来 *计算* 出来的
+ _每个软件包_ 都有一个 *唯一的* _标识符_ ，它由一个 _哈希值_ 和一个 _包名_ 组成，例如：

  #+begin_src sh 
    /nix/store/7wzgkjk6l9ng015wnx7dbzq73v4yr97g-nyancat-1.5.2
  #+end_src

  其中， $7wzgkjk6l9ng015wnx7dbzq73v4yr97g$ 是一个 160 位的 SHA-256 哈希值，它是根据软件包的表达式和构建过程的所有输入参数计算出来的。这些输入参数包括：
  + 源码或二进制文件的 URL 和哈希值
  + 版本号和包名
  + 依赖关系和构建工具
  + 编译命令和参数
  + 补丁和修改
  + 元数据和测试

  这些 _输入参数_ 都会被 *转换* 成一个 _Nix 语言的表达式_ ，然后被 *序列化* 成一个 _字符串_ ，再用  _SHA-256 算法_ *计算* 出一个 _哈希值_

  #+begin_example
    这个哈希值可以保证软件包的一致性和可复现性，因为只要输入参数不变，就会得到相同的哈希值和相同的软件包
  #+end_example

#+ATTR_HTML: image :width 90% 
[[file:pic/HashPath.svg]]

而 _哈希路径下的文件夹_ *存放* 着 _软件包的所有文件_ ，包括 _可执行文件_ 、 _库文件_ 、 _配置文件_ 、 _文档文件_ 等。这些文件都存放在 */nix/store/* 目录下，而不是在系统的其他目录下，例如 /usr/bin/ 或 /bin/ 等

#+begin_example
  这样每个软件包之间都是隔离的，管理也是异常方便
#+end_example

#+ATTR_HTML: image :width 90% 
[[file:pic/SearchPackage.svg]]

#+begin_example
  即使是这样，还是没有解决编译时间久的问题
#+end_example

于是社区提供了许多缓存构建主机，包管理器会优先从上面下载已有的构建结果

#+begin_example
除非访问完了缓存主机列表也没找到需要的二进制缓存，才会自己拉取源码构建
#+end_example
* 如何让路径依赖的程序正常工作
** 一切皆是文件
#+begin_example
Linux 沿用了 Unix 的“一切皆是文件”理念。所有的输入/输出设备，包括硬盘、终端、打印机等，都被抽象为文件
#+end_example

而 *虚拟文件系统* _VFS_ 是这种理念的一个重要实现。VFS 提供了一个 _抽象层_ ，使得用户可以使用统一的接口来访问各种不同类型的文件系统
#+begin_example
在 Linux 中，VFS 不仅用于访问真实的文件系统（如 ext4、btrfs 等），还可以用于访问各种虚拟文件系统（procfs、sysfs 等）
#+end_example

当想操作它们的时候，只需要使用统一的 *文件操作 API* （如 _open_ 、 _read_ 、 _write_ 等）。这种设计 *简约且易用* ，广受赞誉 
** 文件组织规范
#+begin_example
我们在上面提到了 Linux 将一切抽象成文件，但是又如何组织这些文件呢？
#+end_example
于是有了 *FHS* _Filesystem Hierarchy Standard_ 来指导统一的文件组织方式：
+ /bin 基本用户指令，无需特殊权限
+ /boot 引导文件
+ /dev 设备文件
+ /etc 系统配置
+ /home 用户家目录
+ /lib 基本共享库与内核模块
+ /media 可移动媒体的挂载点
+ /mnt 临时文件系统挂载点
+ /opt 拓展或业务软件
+ /run 运行时变量数据
+ /root 超级用户的家目录
+ /sbin 系统库
+ /srv 为系统服务准备的数据
+ /tmp 临时文件

  FHS 规范了一种单根树形的文件组织方式，让不同发行版之间的程序移植变得可行，应用程序总是能找到它们期望的库文件或可执行程序

#+begin_example
  在上一节我们提到过 Nix 会将包文件释放在一个不重复的哈希路径里，而不是诸如 /usr/bin 之类的路径，这是妥妥的放弃了 FHS 了，它该如何保证那些有路径依赖的软件顺利运行呢？

  路径依赖”是指应用程序在运行时需要访问的文件或目录的具体位置

  例如，一个应用可能需要访问 /usr/lib 目录下的某个库文件，或者需要读取 /etc 目录下的配置文件

  这些路径通常在应用的源代码中被硬编码，因此应用对它们有所依赖
#+end_example
** 兼容办法
NixOS 会通过以下方式确保有路径依赖的软件正常运行
+ *包装脚本* （ _Wrapper Script_ ）：NixOS 会为一些应用生成包装脚本。在执行它们的时候，包装脚本会很自然的将环境变量（比如 _LD_LIBRARY_PATH_ ）传递进去（新进程会继承其父进程的环境），它们就能在被安排好的环境变量里找到自己的依赖库
  + PATH: 用于补充可执行程序的路径，让你在任何地方都能直接输入它们的名字以调用它们
  + LIBRARY_PATH: 用于在编译链接阶段查找动态链接库（*.so）和静态链接库（*.a）。这个环境变量只在 *编译* 链接阶段起作用，对运行时的库搜索路径有影响的是下一个环境变量
  + LD_LIBRARY_PATH: 用于指定动态链接器（ld）查找可执行文件运行时所依赖的动态链接库（*.so）的路径。即用于在程序 *运行* 期间查找动态链接库时，指定除标准路径 /usr/lib 之外的路径
+ *构建过程中的路径替换* ：Nix 能接触到构建软件这一环节，自然可以对硬编码的路径进行替换
+ *符号链接* ：NixOS 会将常见的目录或文件链接到存储在 /nix/store 中的相应文件
  #+begin_example
    因为根目录下面的组织几乎全是链接在实现，所以根目录下面文件的组织对 NixOS 来说并不是太重要
  #+end_example
** 可切换的系统状态
在 NixOS 中还有一个 *代* _generation_ 的概念，将 _不同的配置文件_ *生成的* _系统状态_ 称之为代，这些代实际上是 *链接* _不同的构建结果_ 构成的
#+begin_example
  我们在上面就已经说过根目录的组织对 NixOS 不是非常重要，因为每次生成代（系统状态）就会新建一个根，链接不同的构建结果

  也就是说，这个根是可以随时由 NixOS 根据配置重建的
#+end_example

#+ATTR_HTML: image :width 90% 
[[file:pic/generation.svg]]

在生成代以后，NixOS 会添加新的引导条目，指向不同代的根目录，这样就能引导不同的系统状态。当然也能使用命令行工具实时切换这些状态
* 配置是一幅描绘系统的蓝图
