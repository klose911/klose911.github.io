#+TITLE: 快速入门
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_HOME: nix.html

* 交互模式
以下交互式教程需要使用 _nix repl_ 命令调出交互命令模式：
#+begin_src sh
  $ nix repl
  Welcome to Nix 2.5.1. Type :? for help.
#+end_src

它有点像用于调试 JavaScript 的控制台或 Python 的交互模式

#+begin_src sh 
  nix-repl> 1 + 2  # 输入表达式
  3  # 输出结果
#+end_src

* 即时计算

#+begin_src sh 
  nix-repl> { a.b.c = 1; }
  { a = { ... }; }
#+end_src

#+begin_example
在上面的例子中，我们输入了一个匿名集合，而这个匿名集合包含 a 集合 
#+end_example

** 匿名集合
匿名集合是没有分配名称的集合，与之对立的是命名集合，例如 _foo = { bar };_ 
#+begin_example
  a 集合中的值并没有被这个匿名集合直接依赖

  自然顶级以下的集合不会被立刻求值，占位的变成了 ... 
#+end_example

在下面这个例子，将显式声明 qux 的直接依赖：

#+begin_src nix 
  let
    foo = { bar.qux = 1; };
    lax = foo.bar.qux;
  in
  lax  # 我们需要 lax，lax 需要 foo.bar.qux
#+end_src

** 惰性求值
Nix语言的求值是 *惰性的* ，这意味着 *表达式不会在被绑定到变量后立即求值，而是在该值 _被使用_ 时才求值* 

可以输入 _:p_ 启用 *即刻求值* ，所有表达式都将被立刻求值：

#+begin_src sh 
  nix-repl> :p { a.b.c = 1; }
  { a = { b = { c = 1; }; }; }
#+end_src

注意：
+ _:p_ 参数 *只能* 在 _交互_ 模式使用
+ 输入 _:q_ 可以 *退出* 交互模式 

* 文件求值
使用 _nix-instantiate --eval_ 对 _nix 文件_ 中存在的 _表达式_ 进行 *求值* ：

#+begin_src sh 
  echo 1 + 2 > file.nix  # 该命令会往 file.nix 中写入 1 + 2
  nix-instantiate --eval file.nix  # 文件求值
  3  # 输出结果
#+end_src

** 立即求值
在文件求值的情景下可以通过在命令行添加 _--strict_ 参数来启用立即求值：
#+begin_src sh 
  echo "{ a.b.c = 1; }" > file.nix
  nix-instantiate --eval --strict file.nix
  { a = { b = { c = 1; }; }; }
#+end_src

*** echo 命令
echo 是 Linux 中最常见的命令之一，主要作用是输出文本，追加文本，返回输出

* 代码风格
好的代码风格会让程序员身心愉悦，同时也增加了代码可维护性


** 格式化
_Alejandra_ 是一个新兴的 Nix 代码格式化工具，使用 Rust 编写


* 当心空格
空格用于分隔 *词法标记* _Lexical tokens_ ，在一些场景是必要的，不然会无法区分关键字

#+begin_example
  在许多中文资料中，混淆了 Lexical，Syntax 和 Grammar 三者的概念：

  Lexical（词法）：是指语言中单词的意义、形态和用法等方面的规则。词法规则定义了单词的基本形态和语法功能，例如名词、动词、形容词等。同时，它还规定了一些特殊单词的用法，例如冠词、介词、连词等

  Syntax（句法）：是指语言中标记（Token）之间的组合方式，以及这种组合方式所遵循的规则。通俗点说，语法规定了单词应该如何排列、组合成句子，以及这些句子之间的联系方式

  Grammar（语法）：是指语言中的规则体系，包括了语法规则、语义规则和语用规则等。它涉及到语言的整个结构和组成方式，而不仅仅是句子的构成
#+end_example

下面的两种示例是等价的：
#+begin_src nix 
  let
    x = 1;
    y = 2;
  in
  x + y
#+end_src

显然，下面的可读性比上面的差很多：
#+begin_src nix 
  let x=1;y=2;in x+y
#+end_src

* 名称和值
