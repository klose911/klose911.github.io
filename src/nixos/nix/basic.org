#+TITLE: 快速入门
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_HOME: nix.html

* 交互模式
以下交互式教程需要使用 _nix repl_ 命令调出交互命令模式：
#+begin_src sh
  $ nix repl
  Welcome to Nix 2.5.1. Type :? for help.
#+end_src

它有点像用于调试 JavaScript 的控制台或 Python 的交互模式

#+begin_src sh 
  nix-repl> 1 + 2  # 输入表达式
  3  # 输出结果
#+end_src

* 即时计算

#+begin_src sh 
  nix-repl> { a.b.c = 1; }
  { a = { ... }; }
#+end_src

#+begin_example
在上面的例子中，我们输入了一个匿名集合，而这个匿名集合包含 a 集合 
#+end_example

** 匿名集合
匿名集合是没有分配名称的集合，与之对立的是命名集合，例如 _foo = { bar };_ 
#+begin_example
  a 集合中的值并没有被这个匿名集合直接依赖

  自然顶级以下的集合不会被立刻求值，占位的变成了 ... 
#+end_example

在下面这个例子，将显式声明 qux 的直接依赖：

#+begin_src nix 
  let
    foo = { bar.qux = 1; };
    lax = foo.bar.qux;
  in
  lax  # 我们需要 lax，lax 需要 foo.bar.qux
#+end_src

** 惰性求值
Nix语言的求值是 *惰性的* ，这意味着 *表达式不会在被绑定到变量后立即求值，而是在该值 _被使用_ 时才求值* 

可以输入 _:p_ 启用 *即刻求值* ，所有表达式都将被立刻求值：

#+begin_src sh 
  nix-repl> :p { a.b.c = 1; }
  { a = { b = { c = 1; }; }; }
#+end_src

注意：
+ _:p_ 参数 *只能* 在 _交互_ 模式使用
+ 输入 _:q_ 可以 *退出* 交互模式 

* 文件求值
使用 _nix-instantiate --eval_ 对 _nix 文件_ 中存在的 _表达式_ 进行 *求值* ：

#+begin_src sh 
  echo 1 + 2 > file.nix  # 该命令会往 file.nix 中写入 1 + 2
  nix-instantiate --eval file.nix  # 文件求值
  3  # 输出结果
#+end_src

** 立即求值
在文件求值的情景下可以通过在命令行添加 _--strict_ 参数来启用立即求值：
#+begin_src sh 
  echo "{ a.b.c = 1; }" > file.nix
  nix-instantiate --eval --strict file.nix
  { a = { b = { c = 1; }; }; }
#+end_src

*** echo 命令
echo 是 Linux 中最常见的命令之一，主要作用是输出文本，追加文本，返回输出

* 代码风格
好的代码风格会让程序员身心愉悦，同时也增加了代码可维护性


** 格式化
_Alejandra_ 是一个新兴的 Nix 代码格式化工具，使用 Rust 编写


* 当心空格
空格用于分隔 *词法标记* _Lexical tokens_ ，在一些场景是必要的，不然会无法区分关键字

#+begin_example
  在许多中文资料中，混淆了 Lexical，Syntax 和 Grammar 三者的概念：

  Lexical（词法）：是指语言中单词的意义、形态和用法等方面的规则。词法规则定义了单词的基本形态和语法功能，例如名词、动词、形容词等。同时，它还规定了一些特殊单词的用法，例如冠词、介词、连词等

  Syntax（句法）：是指语言中标记（Token）之间的组合方式，以及这种组合方式所遵循的规则。通俗点说，语法规定了单词应该如何排列、组合成句子，以及这些句子之间的联系方式

  Grammar（语法）：是指语言中的规则体系，包括了语法规则、语义规则和语用规则等。它涉及到语言的整个结构和组成方式，而不仅仅是句子的构成
#+end_example

下面的两种示例是等价的：
#+begin_src nix 
  let
    x = 1;
    y = 2;
  in
  x + y
#+end_src

显然，下面的可读性比上面的差很多：
#+begin_src nix 
  let x=1;y=2;in x+y
#+end_src

* 名称和值
_原始数据类型_ ， _列表_ ， _属性集_ 与 _函数_ 都可以被当作 *值* ，可以使用 _=_ 为名称 *绑定* 值，然后用 _分号_ *分隔* _赋值_ 语句：


#+begin_src nix 
  let
    foo = "I am a fool";
    bar = "I am at the bar";
  in
    foo + bar
#+end_src
名称不等同常见编程语言中的变量，因为它 *一旦定义就无法修改* 。在概念上，它们更多地是形成了一种 _绑定_ 关系：
+ 一个值可以被多个名称绑定，一个名称只能绑定一个值
  #+begin_example
    这种赋值没有副作用

    传统的赋值会改变变量的状态，Nix 语言中的变量一旦赋值无法改变
  #+end_example

* 属性集
#+begin_example
  还记得我们在上面提到的集合吗？

  其实它真正的名字是属性集，没有过早引入属性集的概念是为了方便读者渐进式地理解
#+end_example

*属性集* 就是 *装载若干对名称与值的集合* ：
+ 集合内的 _名称_ 被称为这个集合的 *属性*
+ 集合内中由 _名称和值_ 组成的对则被称为该属性的 *元素*

  #+begin_src nix 
    {
      string = "hello";
      integer = 1;
      float = 3.141;
      bool = true;
      null = null;
      list = [ 1 "two" false ];
      attribute-set = {
	a = "hello";
	b = 2;
	c = 2.718;
	d = false;
      };  # 标准 json 不支持注释
    }
  #+end_src

  可能觉得莫名的像 json，下面是 json 的示例：
  #+begin_src js 
    {
      "string": "hello",
      "integer": 1,
      "float": 3.141,
      "bool": true,
      "null": null,
      "list": [1, "two", false],
      "object": {
	"a": "hello",
	"b": 1,
	"c": 2.718,
	"d": false
      }
    }
  #+end_src

  注意：
+ 属性不需要添加引号
+ 列表是用空格分隔的
** 递归属性集
当属性集内的属性需要访问该集合的另一个属性时，应当使用 *递归属性集* ：

#+begin_src nix 
  rec {
    one = 1;
    two = one + 1;  # 直接依赖于 one
    three = two + 1; # 直接依赖于 two，间接依赖于 one
  }
#+end_src

输出如下：
#+begin_src sh 
  { one = 1; three = 3; two = 2; }
#+end_src


#+begin_example
  元素的声明顺序并不决定元素在属性集中的排布顺序

  属性集中的元素排布顺序是由求值顺序决定的，优先被求值的被放在了前面
#+end_example
* let 绑定

