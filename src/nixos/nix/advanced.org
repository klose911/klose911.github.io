#+TITLE: 进阶手册
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil 
#+HTML_LINK_UP: basic.html
#+HTML_LINK_HOME: nix.html
* 数据类型
** 原始数据类型
*** 字符串
**** 单行字符串
与大多数编程语言的字符串一致，使用双引号闭合：

#+begin_src nix 
  "Hello, nix!\n"
#+end_src
**** 多行字符串
多行字符串是通过 *两个单引号* 闭合的

#+begin_src nix 
  ''
  This is the first line.
  This is the second line.
  This is the third line.
  ''
#+end_src

多行字符串往往会带有不同程度的缩进，会被进一步处理。也就是说对于以下字符串：
#+begin_src nix 
  ''
    This is the first line.
    This is the second line.
      This is the third line.
  ''
#+end_src

会被“智能缩进”处理，每一行都被前移了最小缩进数个字符。处理后的结果是：

#+begin_example
  This is the first line.
  This is the second line.
    This is the third line.
#+end_example

同时，假如第一行被占空了，也会对其进行处理：

#+begin_src nix 
  ''

  There's a row of spaces up there.
  ''
#+end_src

处理后的数据是：

#+begin_example

There's a row of spaces up there.
#+end_example
Nix 只会将自动处理后的字符串当作输入，而不是原始字符串 _raw string_
**** URL
为了书写简便， RFC 2396 规定了对于 URI 可以 *不使用* _引号_ 闭合：

#+begin_src nix 
  UriWithoutQuotes = http://example.org/foo.tar.bz2
  UriWithQuotes = "http://example.org/foo.tar.bz2"
#+end_src

两者是等价的
*** 数字
数字被分为
+ 浮点型
  #+begin_example
    比如 .114514
  #+end_example
+ 整型
  #+begin_example
    比如 2233
  #+end_example

#+begin_example
  数字是类型兼容的：纯整数运算总是返回整数，而任何涉及至少一个浮点数的运算都会返回一个浮点数
#+end_example
*** 路径
路径 *至少* 需要包含一个斜杠才能被识别为路径：

#+begin_src nix 
  /foo/bar/bla.nix
  ~/foo/bar.nix
  ../foo/bar/qux.nix
#+end_src

除了某些尖括号路径（比如 _<nixpkgs>_ ）外，其他路径都支持 _字符串插值_

#+begin_src nix 
  "${./foo.txt}"
#+end_src

*** 布尔
 *true* 或 *false* 

*** 空
字面意义上的 *null*

** 列表
列表使用 _中括号_ 闭合， _空格_ 分隔元素，一个列表允许包含 *不同类型* 的值：

#+begin_src  nix 
  [ 123 ./foo.nix "abc" (  x: x+1) ]
#+end_src

#+begin_example
此处如果不给 f { x = y; } 打上括号，就会把函数也当作此列表的值
#+end_example

** 属性集
属性集是用 _大括号_ 括起来的 _名称与值对_ （称为属性）的集合：
+ 属性名：可以是 _标识符_ 或 _字符串_ 
   + 标识符必须以字母或下划线开头，可以包含字母、数字、 _下划线_ 、 _单引号_  *'* 或 _连接符_  *-*  

#+begin_src nix 
  {
    x = 123;
    text = "Hello";
    y = { bla = 456; };
  }
#+end_src

使用  *.* 访问各个属性：

#+begin_src nix 
  { a = "Foo"; b = "Bar"; }.a  #"Foo"
#+end_src

使用 _or_ 关键字，可以在属性选择中提供 *默认值* ：

#+begin_src nix 
  { a = "Foo"; b = "Bar"; }.c or "Xyzzy" # ":Xyzzy" 
#+end_src

#+begin_example
因为属性 c 不在属性集里，故输出默认值
#+end_example

也可以用字符串去访问属性：
#+begin_src nix 
  { "$!@#?" = 123; }."$!@#?" # 123
#+end_src

属性名也支持字符串插值：

#+begin_src nix 
  let bar = "foo"; in { foo = 123; }.${bar} # 123

  let bar = "foo"; in { ${bar} = 123; }.foo # 123 
#+end_src

#+begin_example
两者的值都是123 
#+end_example

在特殊情况下，如果集合声明中的属性名求值为 null（这是错误的，因为 null 不能被强制为字符串），那么该属性将不会被添加到集合中：
#+begin_src nix 
  { ${if foo then "bar" else null} = true; }
#+end_src

#+begin_example
如果 foo 的值为 false，则其值为 {} 
#+end_example

如果一个集合的  *__functor* 属性的值是 _可调用的_ （即它本身是一个函数或是其中一个集合的 __functor 属性的值是可调用的），那么它就可以 *像函数一样被应用* ，首先传入的是集合本身，例如：

#+begin_src nix 
  let add = { __functor = self: x: x + self.x; }; # 定义 属性集 add 的 __functor 属性 
      inc = add // { x = 1; };  # inc属性集相当于把 { x = 1; } 属性集 传入 add，这样 inc 属性集里的  self.x = 1 
  in inc 2 #  3  这里传入的2 对应于 inc 里的x ，相当 x + self.x = 2 + 1 = 3
#+end_src

#+begin_example
  这可用于为函数附加元数据，而调用者无需对其进行特殊处理

  也可用于实现面向对象编程等形式
#+end_example

* 数据构造
