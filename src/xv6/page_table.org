#+TITLE: 虚拟内存
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: system_call.html   
#+HTML_LINK_HOME: xv6.html
#+OPTIONS: num:nil timestamp:nil ^:nil
* 为什么需要虚拟内存

#+begin_example
  假设shell进程由于bug,引发了随机写入某些内存地址，而这些内存地址可能是其他进程使用的

  这就可能影响内核或其他进程的执行
#+end_example

所以需要引入 *虚拟内存* 来实现 *隔离的* _进程的内存地址空间_ ：
+ 每个进程拥有自己的内存地址空间，它们能够读写自己的内存，但不能访问其他进程的内存

实现多个地址空间与物理内存之间多路复用的挑战在于如何保持隔离性
* 页表(page table)
xv6操作系统使用RISC-V架构的 *分页硬件* 来实现 *地址空间* _AS_ 。*页表* 提供了一个 _间接层_ 来处理 *地址映射* ：
+ *CPU* 通过 *内存管理单元* _MMU_ *映射* 到 *物理内存* _RAM_
+ *内核* 告诉 _MMU_ 如何将每个 *虚拟地址* _VA_ *映射* 到 *物理地址* _PA_ 

  #+ATTR_HTML: image :width 90% 
  [[file:pic/10803273-8154d26b87ebfbc5.png]] 

为了实现不同的地址空间，需要多个页表并在切换过程中更换页表：
+ MMU有一个 *satp寄存器* ，用于内核写入以更改页表
+ 页表存在于内存中，satp寄存器保存 *当前页表的物理地址*
+ MMU并不会保存page table，它只会从内存中 *读取* _page table_ ，然后完成 *翻译* 
** 页表的大小和结构

#+ATTR_HTML: image :width 90% 
[[file:pic/10803273-ca010ad9438b7c66.png]] 

+ RISC-V映射 _4KB_ 的 *页面* ，因此页表只需要为每个页面有一个条目
+ RISC-V使用了一个 _三级页表_ 结构来节省空间，通过 *索引位* 逐级查找 *页面表条目* _PTE_
  + 如果是直接映射，虽然只使用了一个page, 还是需要2^27个PTE（因为有27位用来索引）
    #+begin_example
      这个方案中，只需要3 * 512个PTE（3个9位来索引，512是2^9)，所需的空间大大减少了

      这是实际上硬件采用这种层次化的3级page directory结构的主要原因
    #+end_example
+ 每个PTE有64位，其中只有 _54位_ 被使用，包括 _44位_ *物理页面号* _PPN_ 和 _10位_ *标志位*
  + PTE中的标志位包括 *有效* _V_ 、 *可写* _W_ 、 *可读* _R_ 、 *可执行* _X_ 和 *用户* _U_
  + 如果 *V位* 未设置或 _尝试写入_ 时 *W位* 未设置，会触发 *页错误* _PAGE FAULT_ ，导致控制权转移到内核

** TLB
#+begin_example
对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高
#+end_example
实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：_Translation Lookside Buffer_ （通常翻译成 *页表缓存* ）
+ 当处理器第一次查找一个虚拟地址时，硬件通过3级page table得到最终的PPN，TLB会 *保存* _虚拟地址_ 到 _物理地址_ 的 *映射关系*
  #+begin_example
    这样下一次访问同一个虚拟地址时，处理器可以查看TLB，直接得到物理地址
  #+end_example
+ 如果 *切换* 了 _page table_ ，TLB中的缓存将不再有用，它们 *需要被清空*，否则地址翻译可能会出错
  + 所以操作系统知道TLB是存在的，要切换page table时，会发送清空TLB的指令， _sfence_vma_ 

* Kernel Pagetable 
#+ATTR_HTML: image :width 90% 
[[file:pic/10803273-a1f5dbe042a039c0.png]]
** 右半
图中的右半部分的结构完全由 _硬件设计者_ 决定

#+begin_example
如前面看到的一样，当操作系统启动时，会从地址0x80000000开始运行，这个地址其实也是由硬件设计者决定的
#+end_example
主板的设计人员决定了在完成了虚拟到物理地址的翻译之后
+ 如果得到的 _物理地址_ *大于* _0x80000000_ 会走向 _DRAM芯片_
+ 如果得到的 _物理地址_ *低于* _0x80000000_ 会走向不同的 _I/O设备_
  + PLIC *中断控制器* _Platform-Level Interrupt Controller_
  + CLINT _Core Local Interruptor_ 也是中断的一部分。多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数
  + UART0 _Universal Asynchronous Receiver/Transmitter_ 负责与Console和显示器交互
  + VIRTIO disk，与磁盘进行交互 
** 左半

当机器刚刚启动时，还没有可用的page，XV6操作系统会设置好内核使用的虚拟地址空间，也就是这张图左边的地址分布 
#+ATTR_HTML: image :width 90% 
[[file:pic/10803273-6226ad6a48fdbf0d.png]] 

实际上在内核空间里，虚拟地址和物理地址是等值映射
*** Guard Page 
有一些page在虚拟内存中的地址很靠后，比如kernel stack在虚拟内存中的地址就很靠后。这是因为在它之下有一个 *未被映射* 的 _Guard page_
+ 这个Guard page对应的PTE的 _Valid 标志位_ 没有设置
+ 如果kernel stack耗尽了，它会溢出到Guard page，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发page fault，这样的结果好过内存越界之后造成的数据混乱
  + 立即触发一个panic（也就是page fault），就 *知道* _kernel stack出错_ 
  + 同时也又不想 *浪费* _物理内存_ 给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址

*** 权限 
+ Kernel _text_ page 被标位 *R-X* ，意味着可以读它，也可以在这个地址段执行指令，但是不能向Kernel text写数据
+ Kernel _data_ page 需要能被写入，所以它的标志位是 *RW-* ，但是不能在这个地址段运行指令，所以它的X标志位未被设置

** User page table 

#+ATTR_HTML: image :width 90% 
[[file:pic/10803273-008c5f9250b51ab9.png]] 

+ 用户空间的虚拟地址从0开始
  #+begin_example
    这样做的好处在于可预测性和简化编译器生成代码的工作

    编译器可以假设所有地址都是从一个固定的基点开始的，这样可以生成更简洁的机器代码
  #+end_example
+ 这些地址是 *连续* 的，非常适合比如说大数组这样的数据结构
  #+begin_example
    虽然虚拟地址连续，但它们并不需要映射到连续的物理内存上，从而避免了内存碎片问题
  #+end_example
+ 用户地址空间提供了大量的地址范围以供扩展，这对于 *动态增长* 的数据结构来说非常有用

*** 跳板页
*跳板页* _trampoline_ 是一种特殊的内存页面，它既存在于用户空间的地址映射中，也存在于内核空间的地址映射中，虽然 *用户位* _U_ 没有被设置。这样的设置方便了用户空间与内核空间之间的转换：
+ 当用户程序需要进行系统调用，即从用户模式切换到内核模式时，通过跳板页可以更加顺畅地进行
#+begin_example
  因为切换了pagetable之后，理论上同样的VA会用不同的页表找到不同的PA

  但是这2块映射是一致的，那么不同的页表，也可以保证代码可以顺畅执行
#+end_example

*** 内核如何使用用户虚拟地址？
当用户程序调用如read()这样的系统调用时，它会将 *虚拟地址* 传递给 _内核_ 。内核不能直接使用这些用户虚拟地址，因为内核有自己的地址空间。因此，内核必须将这些用户虚拟地址转换为内核空间中的虚拟地址。这一过程：
1. 查询当前进程的页表，找到用户虚拟地址对应的物理地址
2. 通过内核的页表再将该物理地址映射回内核的虚拟地址
   
通过这种方式，内核可以安全地访问和操作用户程序传递过来的数据

* 页表代码
+ 内核页表设置在启动时 _kvminit()_ 由内核建立，大部分直接映射，允许内核使用物理地址作为虚拟地址
+ 每个进程都有自己的地址空间，内核为每个进程创建独立的页表。
  + fork(void) -> uvmcopy(p->pagetable, np->pagetable, p->sz)
  + exec() -> pagetable = proc_pagetable(p)
+ 用户地址空间的布局从0开始，为编译器生成代码提供了便利
+ 内核地址空间的设置：在内核启动时分页还未启用，所以地址是物理地址
+ _kvmmake()_ 函数在 vm.c 中 *创建* _内核的页表_
+ _kvmmap()_ 函数在构建页表时 *添加* _PTE_
+ _mappages()_ 函数在 vm.c 中为一系列 _虚拟地址_ *添加* 到相应 _物理地址_ 的映射
+ _walk()_ 函数 *模拟* 了 _寻址硬件_ *找到* 一个地址的 _PTE_ 的过程

#+begin_example
  kvm 作为前缀的函数都是对kernel页表的操作

  uvm 作为前缀的函数都是对userspace页表的操作
#+end_example

#+ATTR_HTML: :border 1 :rules all :frame boader
| [[file:trap.org][Next: 中断陷阱]] | [[file:system_call.org][Previous: 系统中断]] |  [[file:xv6.org][Home: xv6 解析]] |
