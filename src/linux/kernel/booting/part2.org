#+TITLE: 保护模式
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./booting.html
#+HTML_LINK_UP: ./part1.html
#+OPTIONS: num:nil timestamp:nil ^:nil
* 内核启动的第一步

#+begin_example
在 上一节 中开始接触到内核启动代码，并且分析了初始化部分，最后停在了对 arch/x86/boot/main.c 的 main 函数调用
#+end_example

接下来将继续对内核启动过程的研究：
+ 认识保护模式
+ 如何从实模式进入保护模式
+ 堆和控制台初始化
+ 内存检测，cpu验证，键盘初始化
+ 还有更多
  
* 保护模式

#+begin_example
在操作系统可以使用Intel 64位CPU的长模式之前，内核必须首先将CPU切换到保护模式运行

什么是保护模式？
#+end_example


[[https://en.wikipedia.org/wiki/Protected_mode][保护模式]] 于1982年被引入到Intel CPU家族，并且从那之后，直到Intel 64出现，保护模式都是Intel CPU的主要运行模式。淘汰实模式的主要原因是因为在实模式下，系统能够访问的内存非常有限

#+begin_example
在实模式下，系统最多只能访问1M内存，而且在很多时候，实际能够访问的内存只有640K
#+end_example

保护模式带来了很多的改变，不过主要的改变都集中在 *内存管理* 方法。在保护模式中，实模式的20位地址线被替换成32位地址线，因此系统可以访问多达 _4GB_ 的地址空间。另外，在保护模式中引入了 [[http://en.wikipedia.org/wiki/Paging][内存分页]] 功能。总之，保护模式提供了2种完全不同的内存管理机制：
+ 段式内存
+ 内存分页

** 段式内存
在实模式下，一个物理地址是由2个部分组成的：
+ 内存段的基地址
+ 从基地址开始的偏移
  
使用这2个信息，可以通过下面的公式计算出对应的物理地址：
#+begin_example
PhysicalAddress = Segment * 16 + Offset
#+end_example

在保护模式中，内存段的定义和实模式完全不同。在保护模式中，每个内存段不再是64K大小，段的 _大小_ 和 _起始位置_ 是通过一个叫做 *段描述符* 的数据结构进行描述。所有内存段的段描述符存储在一个叫做 *全局描述符表* _GDT_ 的内存结构中。全局描述符表这个内存数据结构在内存中的位置并不是固定的，它的地址保存在一个 *特殊寄存器* _GDTR_ 中

#+begin_example
马上将在Linux内核代码中看到全局描述符表的地址是如何被保存到 GDTR 中
#+end_example

具体的汇编代码看起来是这样的：

#+begin_src asm 
	  lgdt gdt
#+end_src

_lgdt_ 汇编代码将把全局描述符表的基地址和大小保存到 _GDTR 寄存器_ 中。GDTR 是一个 _48位_ 的寄存器，这个寄存器中的保存了2部分的内容:
+ 全局描述符表的大小 _16位_ 
+ 全局描述符表的基址 _32位_


*** 全局描述符
像前面说的，全局描述符表包含了所有内存段的描述符。每个段描述符长度是 _64位_ ，结构如下图描述：
#+begin_example
  31          24        19      16              7            0
  ------------------------------------------------------------
  |             | |B| |A|       | |   | |0|E|W|A|            |
  | BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 | 4
  |             | |D| |L| 19:16 | |   | |1|C|R|A|            |
  ------------------------------------------------------------
  |                             |                            |
  |        BASE 15:0            |       LIMIT 15:0           | 0
  |                             |                            |
  ------------------------------------------------------------

  粗粗一看，上面的结构非常吓人，不过实际上这个结构是非常容易理解的

  比如在上图中的 LIMIT 15:0 表示这个数据结构的0到15位保存的是内存段的大小的0到15位

  相似的 LIMITE 19:16 表示上述数据结构的16到19位保存的是内存段大小的16到19位

  从这个分析中，可以看出每个内存段的大小是通过20位进行描述的
#+end_example

下面将对这个数据结构进行仔细分析：
1. *Limit* [ _20位_ ] 被保存在上述内存结构的 _0-15_ 和 _48-51_ 位。根据上述内存结构中 _G位_ 的设置，这20位内存定义的 *内存长度* 是不一样的
   #+begin_example
     下面是一些具体的例子：

     如果G = 0, 并且Limit = 0， 那么表示段长度是1 byte

     如果G = 1, 并且Limit = 0, 那么表示段长度是4K bytes

     如果G = 0，并且Limit = 0xfffff，那么表示段长度是1M bytes

     如果G = 1，并且Limit = 0xfffff，那么表示段长度是4G bytes
   #+end_example
   + 如果 _G = 0_ , 那么 _内存段的长度_ 是按照 _1 byte_ 进行 *增长* 的 ，最大的内存段长度将是 _1M_ bytes
     #+begin_example
       Limit每增加1，段长度增加1 bytes
     #+end_example
   + 如果 _G = 1_ , 那么 _内存段的长度_ 是按照 _4K bytes_ 进行 *增长* 的，最大的内存段长度将是 _4G_ bytes
     #+begin_example
       Limit每增加1，段长度增加4K bytes 
     #+end_example
   + 段长度的计算公式：
     #+begin_example
       base_seg_length * ( LIMIT + 1)
     #+end_example
2. *Base* [ _32-bits_ ] 被保存在上述地址结构的 _16-31_ ，  _32-39_ 以及 _56-63_ 位。Base定义了 *段基址*
3. *Type/Attribute* ( _40-47 bits_ ) 定义了内存段的 *类型* 以及支持的 *操作* 。上述内存结构的 _第43位_ 决定了内存段是数据段还是代码段：
   #+begin_example
     |           Type Field        | Descriptor Type | Description
     |-----------------------------|-----------------|------------------
     | Decimal                     |                 |
     |             0    E    W   A |                 |
     | 0           0    0    0   0 | Data            | Read-Only
     | 1           0    0    0   1 | Data            | Read-Only, accessed
     | 2           0    0    1   0 | Data            | Read/Write
     | 3           0    0    1   1 | Data            | Read/Write, accessed
     | 4           0    1    0   0 | Data            | Read-Only, expand-down
     | 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed
     | 6           0    1    1   0 | Data            | Read/Write, expand-down
     | 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed
     |                  C    R   A |                 |
     | 8           1    0    0   0 | Code            | Execute-Only
     | 9           1    0    0   1 | Code            | Execute-Only, accessed
     | 10          1    0    1   0 | Code            | Execute/Read
     | 11          1    0    1   1 | Code            | Execute/Read, accessed
     | 12          1    1    0   0 | Code            | Execute-Only, conforming
     | 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed
     | 13          1    1    1   0 | Code            | Execute/Read, conforming
     | 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed
   #+end_example      
   + 如果 _S = 0_ ，说明是一个 *数据段* ，第 42，41，40位表示的是(E扩展，W可写，A可访问）
     + 如果 _E = 0_ ，数据段是 *向上扩展* _数据段_ ，反之为 向下扩展数据段
       #+begin_example
	 关于向上扩展和向下扩展数据段，可以参考链接 http://www.sudleyplace.com/dpmione/expanddown.html

	 在一般情况下，应该是不会使用向下扩展数据段的
       #+end_example
     + 如果 _W = 1_ ，说明这个数据段是 *可写的* ，否则不可写
       #+begin_example
	 所有数据段都是可读的
       #+end_example
     + _A位_ 表示该内存段是否 *已经被CPU访问*   
   + 如果 _S = 1_ 就是一个 *代码段* ， 第42，41，40位表示的是(C一致，R可读，A可访问）
     + 如果 _C = 1_ ，说明这个代码段 *可以被低优先级的代码访问* ，反之如果C = 0，说明只能同优先级的代码段可以访问
       #+begin_example
	 比如 C=1 可以被用户态代码访问
       #+end_example
     + 如果 _R = 1_ ，说明该代码段 *可读* 。代码段是 *永远没有写权限* 的
4. *DPL* [ _2-bits_ ] , bit _45_ 和 _46_ 定义了该段的 *优先级* 。具体数值是 _0-3_
5. *P* 标志 _bit 47_  说明该内存段是否已经 *存在* 于 _内存中_
   #+begin_example
     如果P = 0，那么在访问这个内存段的时候将报错
   #+end_example
6. *AVL* 标志 _bit 52_ 这个位在Linux内核中没有被使用
7. *L* 标志 _bit 53_ ：只对代码段有意义，如果 _L = 1_ ，说明该代码段需要 *运行* 在 _64位模式_ 下
8. *D/B* 标志 _bit 54_ ：根据段描述符描述的是一个可执行代码段、下扩数据段还是一个堆栈段，这个标志具有不同的功能
   + 可执行代码段：此时这个标志称为D标志并用于指出该段中的 *指令引用有效地址* 和 *操作数的默认长度* 
     + 如果该标志置位，则默认值是 _32位地址_ 和 _32位或8位的操作数_
     + 如果该标志为0，则默认值是 _16位地址_ 和 _16位或8位的操作数_ 
     #+begin_example
       指令前缀0x66可以用来选择非默认值的操作数大小

       前缀0x67可用来选择非默认值的地址大小
     #+end_example 
   + 栈段（由SS寄存器指向的数据段）：此时该标志称为 _B（Big）标志_ ，用于指明 _隐含堆栈操作（如PUSH、POP或CALL）_ 时的 *栈指针大小* ：
     + 如果该标志置位，则使用32位栈指针并存放在ESP寄存器中
     + 如果该标志为0，则使用16位栈指针并存放在SP寄存器中
     #+begin_example
       如果堆栈段被设置成一个下扩数据段，这个B标志也同时指定了堆栈段的上界限
     #+end_example
   + 下扩数据段：此时该标志称为 _B标志_ ，用于指明 *堆栈段的上界限* 
     + 如果设置了该标志，则堆栈段的上界限是 *0xFFFFFFFF* _4GB_ 
     + 如果没有设置该标志，则堆栈段的上界限是 *0xFFFF* _64KB_
   #+begin_example
     对于32位代码和数据段，这个标志应该总是设置为1

     对于16位代码和数据段，这个标志被设置为0
   #+end_example

*** 段选择子
在保护模式下，段寄存器保存的不再是一个内存段的基地址，而是一个称为 *段选择子*  的结构。每个段描述符都对应一个段选择子。段选择子是一个 _16位_ 的数据结构，下图显示了这个数据结构的内容：
#+begin_example
  -----------------------------
  |       Index    | TI | RPL |
  -----------------------------
#+end_example

+ Index : 在GDT中，对应 _段描述符的索引号_ 
+ TI : 在 _GDT_ 还是 _LDT_ 中查找对应的段描述符
+ RPL :  _请求者优先级_
  #+begin_example
    这个优先级将和段描述符中的优先级协同工作，共同确定访问是否合法
  #+end_example

在保护模式下，每个段寄存器实际上包含下面2部分内容：
+ 可见部分 ： 段选择子
+ 隐藏部分 ： 段描述符

*** 保护模式寻址过程
在保护模式中，cpu是通过下面的步骤来找到一个具体的物理地址的：
1. 代码必须将 _相应的段选择子_ *装入* _某个段寄存器_
2. CPU根据 _段选择子_ 从GDT中找到一个 *匹配的段描述符* ，然后将段描述符放入段寄存器的隐藏部分
3. 在没有使用向下扩展段的时候，那么在没有开启分页机制的情况下，这个内存的物理地址就是 *基地址 + 偏移*
   + 内存段的基地址就是段描述符中的基地址
   + 段描述符的limit + 1就是内存段的长度

#+ATTR_HTML: image :width 90% 
[[file:../pic/linear_address.png]]


*** 进入保护模式
当代码要从实模式进入保护模式的时候，需要执行下面的操作：
+ 禁止中断发生
+ 使用命令 lgdt 将GDT表装入 GDTR 寄存器
+ 设置CR0寄存器的PE位为1，使CPU进入保护模式
+ 跳转开始执行保护模式代码

#+begin_example
  在后面的章节中，将看到Linux 内核中完整的转换代码。不过在系统进入保护模式之前，内核有很多的准备工作需要进行

  先打开C文件 arch/x86/boot/main.c 这个文件包含了很多的函数，这些函数分别会执行 键盘初始化 ， 内存堆初始化 等等操作...
#+end_example

** 将启动参数拷贝到 zeropage
