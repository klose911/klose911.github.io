#+TITLE: 初始化中断
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./init.html
#+HTML_LINK_UP: ./part1.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  目前已经处于解压缩后的Linux内核中了，有了用于初期启动的基本的 分页 机制

  目标是在内核的主体代码执行前做好准备工作

  接下来会继续分析关于中断和异常处理部分的代码
#+end_example

上一部分最后来到了下面这个循环：

#+begin_src c 
  for (i = 0; i < NUM_EXCEPTION_VECTORS; i++)
  		set_intr_gate(i, early_idt_handler_array[i]);
#+end_src

这段代码位于 [[https://github.com/torvalds/linux/blob/v3.18/arch/x86/kernel/head64.c][arch/x86/kernel/head64.c]]

#+begin_example
在分析这段代码之前，先来了解一些关于中断和中断处理程序的知识
#+end_example
* 中断
*中断* 是一种由 _软件_ 或 _硬件_ 产生的、向 _CPU_ 发出的 *事件*
#+begin_example
  例如，如果用户按下了键盘上的一个按键时，就会产生中断
#+end_example

此时CPU将会暂停当前的任务，并且将控制流转到特殊的程序中 [[https://en.wikipedia.org/wiki/Interrupt_handler][中断处理程序]] _Interrupt Handler_ 。一个中断处理程序会对中断进行处理，然后将控制权交还给之前暂停的任务中。中断分为三类：
1. 软件中断：当一个软件可以向CPU发出信号，表明它需要系统内核的相关功能时产生
   #+begin_example
     这些中断通常用于系统调用
   #+end_example
2. 硬件中断：当一个硬件有任何事件发生时产生
   #+begin_example
     例如键盘的按键被按下
   #+end_example
3. 异常：当CPU检测到错误时产生
   #+begin_example
     例如 发生了除零错误或者访问了一个不存在的内存页
   #+end_example

每一个中断和异常都可以由一个数来表示，这个数叫做 *向量号* ，它可以取从 _0_ 到 _255_ 中的任何一个数
#+begin_example
通常在实践中前 32 个向量号用来表示异常，32 到 255 用来表示用户定义的中断
#+end_example

在上面的代码中， *NUM_EXCEPTION_VECTORS* 就定义为：

#+begin_src c 
  #define NUM_EXCEPTION_VECTORS 32
#+end_src

CPU会从 [[http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller][APIC]] 或者 CPU 引脚接收中断，并使用中断向量号作为 *中断描述符表* 的索引。下面的表中列出了 0-31 号异常：

#+CAPTION: 中断描述符表
#+ATTR_HTML: :border 1 :rules all :frame boader
| Vector | Mnemonic | Description          | Type  | Error Code | Source                                 |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      0 | #DE      | Divide Error         | Fault | NO         | DIV and IDIV                           |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      1 | #DB      | Reserved             | F/T   | NO         |                                        |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      2 | ---      | NMI                  | INT   | NO         | external NMI                           |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      3 | #BP      | Breakpoint           | Trap  | NO         | INT 3                                  |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      4 | #OF      | Overflow             | Trap  | NO         | INTO  instruction                      |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      5 | #BR      | Bound Range Exceeded | Fault | NO         | BOUND instruction                      |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      6 | #UD      | Invalid Opcode       | Fault | NO         | UD2 instruction                        |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      7 | #NM      | Device Not Available | Fault | NO         | Floating point or [F]WAIT              |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      8 | #DF      | Double Fault         | Abort | YES        | Ant instrctions which can generate NMI |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|      9 | ---      | Reserved             | Fault | NO         |                                        |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     10 | #TS      | Invalid TSS          | Fault | YES        | Task switch or TSS access              |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     11 | #NP      | Segment Not Present  | Fault | NO         | Accessing segment register             |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     12 | #SS      | Stack-Segment Fault  | Fault | YES        | Stack operations                       |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     13 | #GP      | General Protection   | Fault | YES        | Memory reference                       |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     14 | #PF      | Page fault           | Fault | YES        | Memory reference                       |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     15 | ---      | Reserved             |       | NO         |                                        |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     16 | #MF      | x87 FPU fp error     | Fault | NO         | Floating point or [F]Wait              |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     17 | #AC      | Alignment Check      | Fault | YES        | Data reference                         |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     18 | #MC      | Machine Check        | Abort | NO         |                                        |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     19 | #XM      | SIMD fp exception    | Fault | NO         | SSE[2,3] instructions                  |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|     20 | #VE      | Virtualization exc.  | Fault | NO         | EPT violations                         |
|--------+----------+----------------------+-------+------------+----------------------------------------|
|  21-31 | ---      | Reserved             | INT   | NO         | External interrupts                    |
|--------+----------+----------------------+-------+------------+----------------------------------------|

为了能够对中断进行处理，CPU使用了一种特殊的结构 *中断描述符表* _IDT_ 。IDT 是一个由 *描述符* 组成的数组，其中每个描述符都为 _8个字节_ ，与全局描述附表一致；不过不同的是，把IDT中的每一项叫做 *门* _gate_
+ 为了获得某一项描述符的起始地址，CPU 会把向量号乘以8，在64位模式中则会乘以16
+ CPU使用一个特殊的 GDTR 寄存器来存放全局描述符表的地址，中断描述符表也有一个类似的 *寄存器* _IDTR_ ，同时还有用于将基地址加载入这个寄存器的指令 *lidt*

64位模式下 IDT 的每一项的结构如下：
#+begin_example
  127                                                                             96
   --------------------------------------------------------------------------------
  |                                                                               |
  |                                Reserved                                       |
  |                                                                               |
   --------------------------------------------------------------------------------
  95                                                                              64
   --------------------------------------------------------------------------------
  |                                                                               |
  |                               Offset 63..32                                   |
  |                                                                               |
   --------------------------------------------------------------------------------
  63                               48 47      46  44   42    39             34    32
   --------------------------------------------------------------------------------
  |                                  |       |  D  |   |     |      |   |   |     |
  |       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
  |                                  |       |  L  |   |     |      |   |   |     |
   --------------------------------------------------------------------------------
  31                                   15 16                                      0
   --------------------------------------------------------------------------------
  |                                      |                                        |
  |          Segment Selector            |                 Offset 15..0           |
  |                                      |                                        |
   --------------------------------------------------------------------------------
#+end_example

其中:
+ Offset: 到中断处理程序入口点的偏移
+ DPL: 描述符特权级别
+ P: Segment Present 标志
+ Segment selector: 在GDT或LDT中的代码段选择子
+ IST: 用来为中断处理提供一个新的栈
+ Type 域描述了这一项的类型，中断处理程序共分为三种：
  + 任务描述符
  + 中断描述符：中断和陷阱描述符包含了一个指向中断处理程序的 *远* _far_ 指针。二者唯一的不同在于CPU处理 *IF 标志* 
    #+begin_example
      如果是由中断门进入中断处理程序的，CPU 会清除 IF 标志位

      这样当当前中断处理程序执行时，CPU 不会对其他的中断进行处理

      只有当当前的中断处理程序返回时，CPU 才在 iret 指令执行时重新设置 IF 标志位
    #+end_example
  + 陷阱描述符

接下来看一下 CPU 是如何处理中断的：
+ CPU 会在 _栈_ 上保存 *标志寄存器* 、 *cs段寄存器* 和 *程序计数器IP* 
+ 如果中断是由错误码引起的（比如 #PF）， CPU会在栈上保存 *错误码* 
+ 在中断处理程序执行完毕后，由 *iret* 指令返回
* 设置并加载 IDT
