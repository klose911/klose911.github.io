#+TITLE: Introducing RPi OS, or bare-metal "Hello, World!"
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./initialization.html
#+OPTIONS: num:nil timestamp:nil ^:nil

We are going to start our journey in OS development by writing a small, bare-metal "Hello, World" application. 
* Project structure
  Let's briefly describe the main components of this folder:
  1. _Makefile_ : We will use the make utility to build the kernel. make's behavior is configured by a Makefile, which contains instructions on how to compile and link the source code.
  2. _build.sh_ or _build.bat_ : You'll need these files if you want to build the kernel using Docker. You won't need to have the make utility or the compiler toolchain installed on your laptop.
  3. _src_ : This folder contains all of the source code.
  4. _include_ : All of the header files are placed here.
* Makefile
  Now let's take a closer look at the project Makefile. The primary purpose of the make utility is to automatically determine what pieces of a program need to be recompiled, and to issue commands to recompile them. If you are not familiar with make and Makefiles, I recommend that you read this article. The Makefile used in the first lesson can be found here. The whole Makefile is listed below:

  #+BEGIN_SRC sh 
  ARMGNU ?= aarch64-linux-gnu

  COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
  ASMOPS = -Iinclude 

  BUILD_DIR = build
  SRC_DIR = src

  all : kernel8.img

  clean :
      rm -rf $(BUILD_DIR) *.img 

  $(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
      mkdir -p $(@D)
      $(ARMGNU)-gcc $(COPS) -MMD -c $< -o $@

  $(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
      $(ARMGNU)-gcc $(ASMOPS) -MMD -c $< -o $@

  C_FILES = $(wildcard $(SRC_DIR)/*.c)
  ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
  OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
  OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)

  DEP_FILES = $(OBJ_FILES:%.o=%.d)
  -include $(DEP_FILES)

  kernel8.img: $(SRC_DIR)/linker.ld $(OBJ_FILES)
      $(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o $(BUILD_DIR)/kernel8.elf  $(OBJ_FILES)
      $(ARMGNU)-objcopy $(BUILD_DIR)/kernel8.elf -O binary kernel8.img
  #+END_SRC

  Now, let's inspect this file in detail:

  #+BEGIN_SRC sh 
  ARMGNU ?= aarch64-linux-gnu
  #+END_SRC

  The Makefile starts with a variable definition. _ARMGNU_ is a cross-compiler prefix. We need to use a cross-compiler because we are compiling the source code for the arm64 architecture on an x86 machine. So instead of gcc, we will use _aarch64-linux-gnu-gcc_ 

  #+BEGIN_SRC sh 
  COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
  ASMOPS = -Iinclude 
  #+END_SRC


  _COPS_ and _ASMOPS_ are options that we pass to the compiler when compiling C and assembler code, respectively. These options require a short explanation:
  + _-Wall_ : Show all warnings
  + _-nostdlib_ : Don't use the C standard library
    #+BEGIN_EXAMPLE
      Most of the calls in the C standard library eventually interact with the operating system

      We are writing a bare-metal program, and we don't have any underlying operating system

      so the C standard library is not going to work for us anyway
    #+END_EXAMPLE
  + _-nostartfiles_ Don't use standard startup files
    #+BEGIN_EXAMPLE
      Startup files are responsible for setting an initial stack pointer, initializing static data, and jumping to the main entry point

      We are going to do all of this by ourselves
    #+END_EXAMPLE
  + _-ffreestanding_ A freestanding environment is an environment in which the standard library may not exist, and program startup may not necessarily be at main
    #+BEGIN_EXAMPLE
      The option -ffreestanding directs the compiler to not assume that standard functions have their usual definition
    #+END_EXAMPLE
  + _-Iinclude_ : Search for header files in the include folder
  + _-mgeneral-regs-only_ : Use only general-purpose registers. ARM processors also have NEON registers. We don't want the compiler to use them because they add additional complexity 
    #+BEGIN_EXAMPLE
      for example, we will need to store the registers during a context switch
    #+END_EXAMPLE

  #+BEGIN_SRC sh 
  BUILD_DIR = build
  SRC_DIR = src
  #+END_SRC

  _SRC_DIR_ and _BUILD_DIR_ are directories that contain source code and compiled object files, respectively 

  #+BEGIN_SRC sh 
  all : kernel8.img

  clean :
      rm -rf $(BUILD_DIR) *.img 
  #+END_SRC

  Next, we define make targets. The first two targets are pretty simple: 
  + the all target is the default one, and it is executed whenever you type make without any arguments (make always uses the first target as the default). This target just redirects all work to a different target, kernel8.img
  + The clean target is responsible for deleting all compilation artifacts and the compiled kernel image 

  #+BEGIN_SRC sh 
  $(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
      mkdir -p $(@D)
      $(ARMGNU)-gcc $(COPS) -MMD -c $< -o $@

  $(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
      $(ARMGNU)-gcc $(ASMOPS) -MMD -c $< -o $@
  #+END_SRC

  The next two targets are responsible for compiling C and assembler files. If, for example, in the src directory we have _foo.c_ and _foo.S_ files, they will be compiled into _build/foo_c.o_ and _build/foo_s.o_ , respectively. *$<* and *$@* are substituted at runtime with the *input and output filenames* (foo.c and foo_c.o). Before compiling C files, we also create a build directory in case it doesn't exist yet 

  #+BEGIN_SRC sh 
  C_FILES = $(wildcard $(SRC_DIR)/*.c)
  ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
  OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
  OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)
  #+END_SRC

  Here we are building an array of all object files (OBJ_FILES) created from the concatenation of both C and assembler source files (see Substitution References).

  #+BEGIN_SRC sh 
  DEP_FILES = $(OBJ_FILES:%.o=%.d)
  -include $(DEP_FILES)
  #+END_SRC

  The next two lines are a little bit tricky. If you take a look at how we defined our compilation targets for both C and assembler source files, you will notice that we used the _-MMD_ parameter. This parameter instructs the gcc compiler to create a dependency file for each generated object file. A dependency file defines all of the dependencies for a particular source file. These dependencies usually contain a list of all included headers. We need to include all of the generated dependency files so that make knows what exactly to recompile in case a header changes 

  #+BEGIN_SRC sh 
  $(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o kernel8.elf  $(OBJ_FILES)
  #+END_SRC

  We use the _OBJ_FILES_ array to build the _kernel8.elf_ file. We use the linker script _src/linker.ld_ to define the *basic layout of the resulting executable image* 

  #+BEGIN_SRC sh 
  $(ARMGNU)-objcopy kernel8.elf -O binary kernel8.img
  #+END_SRC

  kernel8.elf is in the *ELF* format

  #+BEGIN_EXAMPLE
    The problem is that ELF files are designed to be executed by an operating system
  #+END_EXAMPLE

  To write a bare-metal program, we need to extract all executable and data sections from the ELF file and put them into the kernel8.img image. The trailing _8_ denotes ARMv8 which is a 64-bit architecture. This filename tells the firmware to *boot* the processor into _64-bit_ mode. You can also boot the CPU in the 64-bit mode by using _arm_control=0x200_ flag in the config.txt file

  #+BEGIN_EXAMPLE
    The RPi OS previously used this method, and you can still find it in some of the exercise answers

    However, arm_control flag is undocumented and it is preferable to use kernel8.img naming convention instead
  #+END_EXAMPLE
* The linker script
  The primary purpose of the linker script is to describe how the sections in the input object files ( _c.o_ and _s.o_ ) should be mapped into the output file ( _.elf_ )

  #+BEGIN_EXAMPLE
    More information about linker scripts can be found: https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts
  #+END_EXAMPLE

  Now let's take a look at the RPi OS linker script:

  #+BEGIN_SRC sh 
  SECTIONS
  {
      .text.boot : { *(.text.boot) }
      .text :  { *(.text) }
      .rodata : { *(.rodata) }
      .data : { *(.data) }
      . = ALIGN(0x8);
      bss_begin = .;
      .bss : { *(.bss*) } 
      bss_end = .;
  }
  #+END_SRC

  1. After startup, the Raspberry Pi loads _kernel8.img_ into memory and starts execution from the beginning of the file. That's why the _.text.boot section_ must be first
     #+BEGIN_EXAMPLE
       we are going to put the OS startup code inside this section
     #+END_EXAMPLE
  2. The _.text_ , _.rodata_ , and _.data_ sections contain *kernel-compiled* _instructions_ , _read-only data_ , and _normal data_ 
  3. The _.bss_ section contains data that should be initialized to 0:
     + By putting such data in a separate section, the compiler can save some space in the ELF binary
       #+BEGIN_EXAMPLE
	 only the section size is stored in the ELF header, but the section itself is omitted
       #+END_EXAMPLE
     + After loading the image into memory, we must initialize the .bss section to 0
       #+BEGIN_EXAMPLE
	 that's why we need to record the start and end of the section

	 hence the bss_begin and bss_end symbols
       #+END_EXAMPLE
     + align the section so that it starts at an address that is a _multiple_ of 8
       #+BEGIN_EXAMPLE
	 If the section is not aligned, it would be more difficult to use the str instruction to store 0 at the beginning of the bss section

	 because the str instruction can be used only with 8-byte-aligned addresses
       #+END_EXAMPLE
* Booting the kernel

  Now it is time to take a look at the _boot.S_ file. This file contains the kernel startup code:

  #+BEGIN_SRC asm 
  #include "mm.h"

  .section ".text.boot"

  .globl _start
  _start:
      mrs    x0, mpidr_el1        
      and    x0, x0,#0xFF        // Check processor id
      cbz    x0, master        // Hang for all non-primary CPU
      b    proc_hang

  proc_hang: 
      b proc_hang

  master:
      adr    x0, bss_begin
      adr    x1, bss_end
      sub    x1, x1, x0
      bl     memzero

      mov    sp, #LOW_MEMORY
      bl    kernel_main
  #+END_SRC

  Let's review this file in detail:

  #+BEGIN_SRC asm
  .section ".text.boot"
  #+END_SRC


  First, we specify that everything defined in boot.S should go in the _.text.boot_ section. Previously, we saw that this section is placed at the beginning of the kernel image by the linker script. So when the kernel is started, execution begins at the _start_ function: 

  #+BEGIN_SRC asm 
  .globl _start
  _start:
      mrs    x0, mpidr_el1        
      and    x0, x0,#0xFF        // Check processor id
      cbz    x0, master        // Hang for all non-primary CPU
      b    proc_hang
  #+END_SRC

  The first thing this function does is check the processor ID. The Raspberry Pi 3 has four core processors, and after the device is powered on, each core begins to execute the same code

  #+BEGIN_EXAMPLE
    However, we don't want to work with four cores

    we want to work only with the first one and put all of the other cores in an endless loop
  #+END_EXAMPLE

  This is exactly what the start function is responsible for. It gets the processor ID from the _mpidr_el1_ system register. If the current process ID is 0, then execution is transferred to the master function:

  #+BEGIN_SRC asm 
  master:
      adr    x0, bss_begin
      adr    x1, bss_end
      sub    x1, x1, x0
      bl     memzero
  #+END_SRC


  Here, we clean the _.bss_ section by calling _memzero_ 

  #+BEGIN_EXAMPLE
    We will define this function memzero later

    In ARMv8 architecture, by convention, the first seven arguments are passed to the called function via registers x0 ~ x6

    The memzero function accepts only two arguments: the start address (bss_begin) and the size of the section needed to be cleaned (bss_end - bss_begin) 
  #+END_EXAMPLE

  #+BEGIN_SRC asm 
     mov    sp, #LOW_MEMORY
      bl    kernel_main
  #+END_SRC

  After cleaning the .bss section, we *initialize* the _stack pointer_ and pass *execution* to the _kernel_main_ function. The Raspberry Pi loads the kernel at address _0_ 

  #+BEGIN_EXAMPLE
    that's why the initial stack pointer can be set to any location high enough so that stack will not override the kernel image when it grows sufficiently large
  #+END_EXAMPLE

  _LOW_MEMORY_ is defined in _mm.h_ and is equal to _4MB_ 

  #+BEGIN_EXAMPLE
    Our kernel's stack won't grow very large and the image itself is tiny

    so 4MB is more than enough for us
  #+END_EXAMPLE
** assembler instructions 
   For those of you who are not familiar with ARM assembler syntax, let me quickly summarize the instructions that we have used:
   + mrs: Load value from a system register to one of the general purpose registers x0 ~ x30
   + and: Perform the logical AND operation
     #+BEGIN_EXAMPLE
       We use this command to strip the last byte from the value we obtain from the mpidr_el1 register
     #+END_EXAMPLE
   + cbz: Compare the result of the previously executed operation to _0_ and *jump* (or branch in ARM terminology) to the provided label if the comparison yields _true_
   + b: Perform an unconditional branch to some label
   + adr: Load a label's relative address into the target register
     #+BEGIN_EXAMPLE
       In this case, we want pointers to the start and end of the .bss region
     #+END_EXAMPLE
   + sub: Subtract values from two registers
   + bl: perform an unconditional branch and store the *return address* in _x30_ (the link register)
     #+BEGIN_EXAMPLE
       Branch With a link:

       When the subroutine is finished, use the ret instruction to jump back to the return address
     #+END_EXAMPLE
   + mov: Move a value between registers or from a constant to a register
* The kernel_main function
  We have seen that the boot code eventually passes control to the _kernel_main_ function. Let's take a look at it:

  #+BEGIN_SRC c 
  #include "mini_uart.h"

  void kernel_main(void)
  {
	  uart_init();
	  uart_send_string("Hello, world!\r\n");

	  while (1) {
		  uart_send(uart_recv());
	  }
  }
  #+END_SRC

  This function is one of the simplest in the kernel. It works with the _Mini UART_ device to print to screen and read user input. The kernel just prints Hello, world! and then enters an infinite loop that reads characters from the user and sends them back to the screen
** Raspberry Pi devices
   Now we are going to dig into something specific to the Raspberry Pi

   #+BEGIN_EXAMPLE
     Before we begin, I recommend that you download the BCM2837 ARM Peripherals manual
   #+END_EXAMPLE

   _BCM2837_ is a board that is used by the Raspberry Pi 3 Models B, and B+

   #+BEGIN_EXAMPLE
     Sometime in our discussion, I will also mention BCM2835 and BCM2836 - those are names of the board used in older versions of the Raspberry Pi
   #+END_EXAMPLE

   Before we proceed to the implementation details, I want to share some basic concepts on how to work with *memory-mapped* devices. BCM2837 is a simple _SOC_ (System on a chip) board. In such a board, access to all devices is performed via memory-mapped registers. The Raspberry Pi 3 reserves the memory above address _0x3F000000_ for *devices* . To activate or configure a particular device, you need to write some data in one of the device's registers. A device register is just a _32-bit_ region of memory. The meaning of each bit in each device register is described in the BCM2837 ARM Peripherals manual

   #+BEGIN_EXAMPLE
     Take a look at section 1.2.3 ARM physical addresses in the manual and the surrounding documentation for more context on why we use 0x3F000000 as a base address

     even though 0x7E000000 is used throughout the manual
   #+END_EXAMPLE

   From the kernel_main function, you can guess that we are going to work with a Mini UART device. UART stands for _Universal asynchronous receiver-transmitter_ (通用异步接收器). This device is capable of converting values stored in one of its memory mapped registers to a sequence of high and low voltages. This sequence is passed to your computer via the _TTL-to-serial_ cable and is interpreted by your terminal emulator 

   #+BEGIN_EXAMPLE
     We are going to use the Mini UART to facilitate communication with our Raspberry Pi

     If you want to see the specification of the Mini UART registers, please go to page 8 of the BCM2837 ARM Peripherals manual
   #+END_EXAMPLE

   A Raspberry Pi has two UARTs:  _Mini UART_ and _PL011 UART_

   #+BEGIN_EXAMPLE
     There is, however, an optional exercise that shows how to work with PL011 UART

     You can refer to the official documentation if you want to find out more about Raspberry Pi UARTs and learn the difference between them
   #+END_EXAMPLE
*** GPIO 
    Another device that you need to familiarize yourself with is the *GPIO* _General-purpose input/output_ . GPIOs are responsible for controlling GPIO pins. You should be able to easily recognize them in the image below:

    #+ATTR_HTML: image :width 70% 
    [[file:../pic/gpio-pins.jpg]]

    The GPIO can be used to configure the behavior of different GPIO pins. For example, to be able to use the Mini UART, we need to activate _pins 14_ and _15_ and set them up to use this device. The image below illustrates how numbers are assigned to the GPIO pins:

    #+ATTR_HTML: image :width 70% 
    [[file:../pic/gpio-numbers.png]]
** Mini UART initialization

