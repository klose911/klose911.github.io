#+TITLE: Introducing RPi OS, or bare-metal "Hello, World!"
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./initialization.html
#+OPTIONS: num:nil timestamp:nil ^:nil

We are going to start our journey in OS development by writing a small, bare-metal "Hello, World" application. 
* Project structure
  Let's briefly describe the main components of this folder:
  1. _Makefile_ : We will use the make utility to build the kernel. make's behavior is configured by a Makefile, which contains instructions on how to compile and link the source code.
  2. _build.sh_ or _build.bat_ : You'll need these files if you want to build the kernel using Docker. You won't need to have the make utility or the compiler toolchain installed on your laptop.
  3. _src_ : This folder contains all of the source code.
  4. _include_ : All of the header files are placed here.
* Makefile
  Now let's take a closer look at the project Makefile. The primary purpose of the make utility is to automatically determine what pieces of a program need to be recompiled, and to issue commands to recompile them. If you are not familiar with make and Makefiles, I recommend that you read this article. The Makefile used in the first lesson can be found here. The whole Makefile is listed below:

  #+BEGIN_SRC sh 
  ARMGNU ?= aarch64-linux-gnu

  COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
  ASMOPS = -Iinclude 

  BUILD_DIR = build
  SRC_DIR = src

  all : kernel8.img

  clean :
      rm -rf $(BUILD_DIR) *.img 

  $(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
      mkdir -p $(@D)
      $(ARMGNU)-gcc $(COPS) -MMD -c $< -o $@

  $(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
      $(ARMGNU)-gcc $(ASMOPS) -MMD -c $< -o $@

  C_FILES = $(wildcard $(SRC_DIR)/*.c)
  ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
  OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
  OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)

  DEP_FILES = $(OBJ_FILES:%.o=%.d)
  -include $(DEP_FILES)

  kernel8.img: $(SRC_DIR)/linker.ld $(OBJ_FILES)
      $(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o $(BUILD_DIR)/kernel8.elf  $(OBJ_FILES)
      $(ARMGNU)-objcopy $(BUILD_DIR)/kernel8.elf -O binary kernel8.img
  #+END_SRC

  Now, let's inspect this file in detail:

  #+BEGIN_SRC sh 
  ARMGNU ?= aarch64-linux-gnu
  #+END_SRC

  The Makefile starts with a variable definition. _ARMGNU_ is a cross-compiler prefix. We need to use a cross-compiler because we are compiling the source code for the arm64 architecture on an x86 machine. So instead of gcc, we will use _aarch64-linux-gnu-gcc_ 

  #+BEGIN_SRC sh 
  COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
  ASMOPS = -Iinclude 
  #+END_SRC


  _COPS_ and _ASMOPS_ are options that we pass to the compiler when compiling C and assembler code, respectively. These options require a short explanation:
  + _-Wall_ : Show all warnings
  + _-nostdlib_ : Don't use the C standard library
    #+BEGIN_EXAMPLE
      Most of the calls in the C standard library eventually interact with the operating system

      We are writing a bare-metal program, and we don't have any underlying operating system

      so the C standard library is not going to work for us anyway
    #+END_EXAMPLE
  + _-nostartfiles_ Don't use standard startup files
    #+BEGIN_EXAMPLE
      Startup files are responsible for setting an initial stack pointer, initializing static data, and jumping to the main entry point

      We are going to do all of this by ourselves
    #+END_EXAMPLE
  + _-ffreestanding_ A freestanding environment is an environment in which the standard library may not exist, and program startup may not necessarily be at main
    #+BEGIN_EXAMPLE
      The option -ffreestanding directs the compiler to not assume that standard functions have their usual definition
    #+END_EXAMPLE
  + _-Iinclude_ : Search for header files in the include folder
  + _-mgeneral-regs-only_ : Use only general-purpose registers. ARM processors also have NEON registers. We don't want the compiler to use them because they add additional complexity 
    #+BEGIN_EXAMPLE
      for example, we will need to store the registers during a context switch
    #+END_EXAMPLE

  #+BEGIN_SRC sh 
  BUILD_DIR = build
  SRC_DIR = src
  #+END_SRC

  _SRC_DIR_ and _BUILD_DIR_ are directories that contain source code and compiled object files, respectively 

  #+BEGIN_SRC sh 
  all : kernel8.img

  clean :
      rm -rf $(BUILD_DIR) *.img 
  #+END_SRC

  Next, we define make targets. The first two targets are pretty simple: 
  + the all target is the default one, and it is executed whenever you type make without any arguments (make always uses the first target as the default). This target just redirects all work to a different target, kernel8.img
  + The clean target is responsible for deleting all compilation artifacts and the compiled kernel image 

  #+BEGIN_SRC sh 
  $(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
      mkdir -p $(@D)
      $(ARMGNU)-gcc $(COPS) -MMD -c $< -o $@

  $(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
      $(ARMGNU)-gcc $(ASMOPS) -MMD -c $< -o $@
  #+END_SRC

  The next two targets are responsible for compiling C and assembler files. If, for example, in the src directory we have _foo.c_ and _foo.S_ files, they will be compiled into _build/foo_c.o_ and _build/foo_s.o_ , respectively. *$<* and *$@* are substituted at runtime with the *input and output filenames* (foo.c and foo_c.o). Before compiling C files, we also create a build directory in case it doesn't exist yet 

  #+BEGIN_SRC sh 
  C_FILES = $(wildcard $(SRC_DIR)/*.c)
  ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
  OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
  OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)
  #+END_SRC

  Here we are building an array of all object files (OBJ_FILES) created from the concatenation of both C and assembler source files (see Substitution References).

  #+BEGIN_SRC sh 
  DEP_FILES = $(OBJ_FILES:%.o=%.d)
  -include $(DEP_FILES)
  #+END_SRC

  The next two lines are a little bit tricky. If you take a look at how we defined our compilation targets for both C and assembler source files, you will notice that we used the _-MMD_ parameter. This parameter instructs the gcc compiler to create a dependency file for each generated object file. A dependency file defines all of the dependencies for a particular source file. These dependencies usually contain a list of all included headers. We need to include all of the generated dependency files so that make knows what exactly to recompile in case a header changes 

  #+BEGIN_SRC sh 
  $(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o kernel8.elf  $(OBJ_FILES)
  #+END_SRC

  We use the _OBJ_FILES_ array to build the _kernel8.elf_ file. We use the linker script _src/linker.ld_ to define the *basic layout of the resulting executable image* 

  #+BEGIN_SRC sh 
  $(ARMGNU)-objcopy kernel8.elf -O binary kernel8.img
  #+END_SRC

  kernel8.elf is in the *ELF* format

  #+BEGIN_EXAMPLE
    The problem is that ELF files are designed to be executed by an operating system
  #+END_EXAMPLE

  To write a bare-metal program, we need to extract all executable and data sections from the ELF file and put them into the kernel8.img image. The trailing _8_ denotes ARMv8 which is a 64-bit architecture. This filename tells the firmware to *boot* the processor into _64-bit_ mode. You can also boot the CPU in the 64-bit mode by using _arm_control=0x200_ flag in the config.txt file

  #+BEGIN_EXAMPLE
    The RPi OS previously used this method, and you can still find it in some of the exercise answers

    However, arm_control flag is undocumented and it is preferable to use kernel8.img naming convention instead
  #+END_EXAMPLE
* The linker script

