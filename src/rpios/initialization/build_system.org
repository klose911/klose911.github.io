#+TITLE: Kernel build system
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./initialization.html
#+HTML_LINK_UP: ./linux.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  After we examined Linux kernel structure, it worth spending some time investigating how we can build and run it
#+end_example
Linux also uses _make_ utility to build the kernel, though Linux Makefile is much more complicated. Before we will take a look at the makefile, let's learn some important concepts about Linux build system, which is called _kbuild_
* A few essential kbuild concepts

Build process can be customized by using kbuild variables. Those variables are defined in _Kconfig_ files.
+ Here you can define the variables themselves and their default values
  + Variables can have different types, including string, boolean and integer
+ In a Kconfig file you can also define dependencies between variables
  #+begin_example
     for example, you can say that if variable X is selected then variable Y will be selected implicitly

    you can take a look at arm64 Kconfig file. This file defines all variables, specific for arm64 architecture
  #+end_example
+ Kconfig functionality is not part of the standard make and is implemented in the Linux makefile
+ Variables, defined in Kconfig are exposed to the kernel source code as well as to the nested makefiles
+ Variable values can be set during kernel configuration step
  #+begin_example
    for example, if you type make menuconfig a console GUI will be shown

    It allows you to customize values for all kernel variables and stores the values in .config

    Use make help command to view all possible options to configure the kernel
  #+end_example

Linux uses *recursive* build. This means that each subfolder of the Linux kernel can define it's own Makefile and Kconfig. Most of the nested Makefiles are very simple and just define what object files need to be compiled. Usually, such definitions have the following format:

#+begin_src makefile
  obj-$(SOME_CONFIG_VARIABLE) += some_file.o
#+end_src

This definition means that _some_file.c_ will be compiled and linked to the kernel only if _SOME_CONFIG_VARIABLE_ is *set* . If you want to compile and link a file unconditionally, you need to change the previous definition to look like this 

#+begin_src makefile
  obj-y += some_file.o
#+end_src

Before we move forward, you need to understand the structure of a basic make _rule_ and be comfortable with make _terminology_ . Common rule structure is illustrated in the following diagram:
#+begin_src makefile
  targets : prerequisites
  recipe
  â€¦
#+end_src
+ _targets_ : are file names, separated by spaces. Targets are *generated* after the rule is executed. Usually, there is only one target per rule
+ _prerequisites_ : are files that make trackes to see whether it needs to *update* the targets
+ _recipe_ is a *bash* script. Make calls it when some of the prerequisites have been updated. The recipe is responsible for *generating* the targets.

  #+begin_example
    Both targets and prerequisites can include wildcards (%). When wildcards are used the recipe is executed for each of the matched prerequisites separately

    In this case, you can use $< and $@ variables to refer to the prerequisite and the target inside the recipe 
  #+end_example

_make_ is very good in detecting whether any of the prerequisites have been changed and updating only targets that need to be rebuilt
#+begin_example
    However, if a recipe is dynamically updated, make is unable to detect this change

    One good example is when you change some configuration variable, which results in appending an additional option to the recipe

    By default, in this case, make will not recompile previously generated object files, because their prerequisites haven't been changed, only the recipe have been updated
#+end_example


To overcome this behavior Linux introduces _if_changed_ function. To see how it works let's consider the following example:
#+begin_src makefile 
  cmd_compile = gcc $(flags) -o $@ $<

  %.o: %.c FORCE
  $(call if_changed,compile)
#+end_src

Here for each .c file we build corresponding .o file by calling if_changed function with the argument compile. _if_changed_ then looks for _cmd_compile_ variable (it adds cmd_ prefix to the first argument) and checks whether this variable has been updated since the last execution, or any of the prerequisites has been changed:
+ If yes: cmd_compile command is executed and object file is regenerated

Our sample rule has 2 prerequisites: source .c file and _FORCE_
+ FORCE is a special prerequisite that forces the recipe to be called each time when make command is called
  #+begin_example
      Without it, the recipe would be called only if .c file was changed
  #+end_example
* Building the kernel

Now, that we learned some important concepts about the Linux build system, let's try to figure out what exactly is going on after you type make command. This process is very complicated and includes a lot of details, most of which we will skip. Our goal will be to answer 2 questions.
1. How exactly are source files compiled into object files?
2. How are object files linked into the OS image?

We are going to tackle the second question first.
** Link stage
As you might see from the output of _make help_ command, the default target, which is responsible for building the kernel, is called *vmlinux* and it looks like this:

#+begin_src makefile 
  cmd_link-vmlinux =                                                 \
  $(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) ;    \
  $(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)

  vmlinux: scripts/link-vmlinux.sh vmlinux_prereq $(vmlinux-deps) FORCE
  +$(call if_changed,link-vmlinux)
#+end_src

This target uses already familiar to us _if_changed_ function. Whenever some of the prerequsities are updated _cmd_link-vmlinux_ command is executed. This command executes _scripts/link-vmlinux.sh_ script

#+begin_example
  Note usage of $< automatic variable in the cmd_link-vmlinux command

  It also executes architecture specific postlink script, but we are not very interested in it
#+end_example

When _scripts/link-vmlinux.sh_ is executed it assumes that all required object files are already built and their locations are stored in 3 variables:
+ _KBUILD_VMLINUX_INIT_
+ _KBUILD_VMLINUX_MAIN_
+ _KBUILD_VMLINUX_LIBS_

_link-vmlinux.sh_ script first creates thin archive from all available object files. thin archive is a special object that contains references to a set of *object files* as well as their combined *symbol table* . This is done inside _archive_builtin_ function. In order to create thin archive this function uses *ar* utility. Generated thin archive is stored as _built-in.o_ file and has the format that is understandable by the linker, so it can be used as any other normal object file

Next _modpost_link_ is called. This function calls _linker_ and *generates* _vmlinux.o_ object file
#+begin_example
  We need this object file to perform Section mismatch analysis

  This analysis is performed by the modpost program
#+end_example

Next _kernel symbol table_ is generated. It contains information about all functions and global variables as well as their location in the vmlinux binary. The main work is done inside _kallsyms_ function:
1. This function first uses *nm* to extract all symbols from vmlinux binary
2. Then it uses _scripts/kallsyms_ utility to generate a special assembler file containing all symbols in a special format, understandable by the Linux kernel
3. Next, this assembler file is compiled and linked together with the original binary. Information from the kernel symbol table is used to generate _/proc/kallsyms_ file at runtime
   #+begin_example
     This process is repeated several times because after the final link addresses of some symbols can be changed
   #+end_example

Finally _vmlinux_ binary is ready and _System.map_ is build. System.map contains the same information as _/proc/kallsyms_ but this is *static* file and unlike /proc/kallsyms it is not generated at runtime. System.map is mostly used to *resolve* _addresses_ to _symbol names_ during kernel oops. The same *nm* utility is used to build System.map 
** Build stage
Now let's take one step backward and examine how source code files are compiled into object files. As you might remember one of the prerequisites of the vmlinux target is _$(vmlinux-deps)_ variable. Let me now copy a few relevant lines from the main Linux makefile to demonstrate how this variable is built

#+begin_src makefile 
  init-y        := init/
  drivers-y    := drivers/ sound/ firmware/
  net-y        := net/
  libs-y        := lib/
  core-y        := usr/

  core-y        += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/

  init-y        := $(patsubst %/, %/built-in.o, $(init-y))
  core-y        := $(patsubst %/, %/built-in.o, $(core-y))
  drivers-y    := $(patsubst %/, %/built-in.o, $(drivers-y))
  net-y        := $(patsubst %/, %/built-in.o, $(net-y))

  export KBUILD_VMLINUX_INIT := $(head-y) $(init-y)
  export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y2) $(drivers-y) $(net-y) $(virt-y)
  export KBUILD_VMLINUX_LIBS := $(libs-y1)
  export KBUILD_LDS          := arch/$(SRCARCH)/kernel/vmlinux.lds

  vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN) $(KBUILD_VMLINUX_LIBS)
#+end_src

It all starts with variables like _init-y_ , _core-y_ , etc., which combined contains all subfolders of the Linux kernel that contains buildable source code. Then _built-in.o_ is appended to all the subfolder names

#+begin_example
  for example, drivers/ becomes drivers/built-in.o. vmlinux-deps then just aggregates all resulting values

  This explains how vmlinux eventually becomes dependent on all built-in.o files
#+end_example

Next question is how all built-in.o objects are created? Once again, let me copy all relevant lines and explain how it all works:

#+begin_src makefile 
  $(sort $(vmlinux-deps)): $(vmlinux-dirs) ;

  vmlinux-dirs    := $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
  $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
  $(net-y) $(net-m) $(libs-y) $(libs-m) $(virt-y)))

  build := -f $(srctree)/scripts/Makefile.build obj               #Copied from `scripts/Kbuild.include`

  $(vmlinux-dirs): prepare scripts
  $(Q)$(MAKE) $(build)=$@

#+end_src

The first line tells us that _vmlinux-deps_ depends on _vmlinux-dirs_ . Next, we can see that _vmlinux-dirs_ is a variable that contains all direct root subfolders without / character at the end. And the most important line here is the recipe to build $(vmlinux-dirs) target. After substitution of all variables, this recipe will look like the following

#+begin_src sh 
  make -f scripts/Makefile.build obj=drivers
#+end_src

This line just calls another makefile (scripts/Makefile.build) and passes obj variable, which contains a folder to be compiled

#+begin_example
  we use drivers folder as an example, but this rule will be executed for all root subfolders
#+end_example

Next logical step is to take a look at _scripts/Makefile.build_ . The first important thing that happens after it is executed is that all variables from Makefile or Kbuild files, defined in the *current directory* , are included. By current directory I mean the _directory_ *referenced* by the _obj_ variable. The inclusion is done in the following 3 lines.

#+begin_src makefile 
  kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
  kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
  include $(kbuild-file)
#+end_src

Nested makefiles are mostly responsible for initializing variables like obj-y:
+ obj-y variable should contain list of all source code files, located in the current directory
+ Another important variable that is initialized by the nested makefiles is _subdir-y_ . This variable contains a list of all subfolders that need to be visited *before* the source code in the curent directory can be built
  #+begin_example
    subdir-y is used to implement recursive descending into subfolders
  #+end_example

When _make_ is called without specifying the target (as it is in the case when scripts/Makefile.build is executed) it uses the first target. The first target for scripts/Makefile.build is called *__build* and it can be found here Let's take a look at it

#+begin_src makefile
  __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
  $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
  $(subdir-ym) $(always)
  @:
#+end_src

As you can see __build target doesn't have a receipt, but it depends on a bunch of other targets. We are only interested in *$(builtin-target)*

#+begin_example
   it is responsible for creating built-in.o file, and $(subdir-ym)
#+end_example

Let's take a look at _subdir-ym_ : it is responsible for descending into nested directories. This variable is just a concatenation of _subdir-y_ and _subdir-m_ variables

#+begin_example
  subdir-m variable is similar to subdir-y, but it defines subfolders need to be included in a separate kernel module

  We skip the discussion of modules, for now, to keep focused
#+end_example

subdir-ym target should look familiar to you:

#+begin_src makefile 
  $(subdir-ym):
  $(Q)$(MAKE) $(build)=$@
#+end_src

#+begin_example
This target just triggers execution of the scripts/Makefile.build in one of the nested subfolders
#+end_example

Now it is time to examine the _builtin-target_ target. Once again I am copying only relevant lines here:

#+begin_src makefile 
  cmd_make_builtin = rm -f $@; $(AR) rcSTP$(KBUILD_ARFLAGS)
  cmd_make_empty_builtin = rm -f $@; $(AR) rcSTP$(KBUILD_ARFLAGS)

  cmd_link_o_target = $(if $(strip $(obj-y)),\
  $(cmd_make_builtin) $@ $(filter $(obj-y), $^) \
  $(cmd_secanalysis),\
  $(cmd_make_empty_builtin) $@)

  $(builtin-target): $(obj-y) FORCE
  $(call if_changed,link_o_target)
#+end_src

This target depends on _$(obj-y)_ target and obj-y is a list of all object files that need to be built in the current folder. After those files become ready _cmd_link_o_target_ command is executed:
+ In case if obj-y variable is *empty* _cmd_make_empty_builtin_ is called, which just creates an empty built-in.o
+ Otherwise, _cmd_make_builtin_ command is executed; it uses familiar to us _ar_ tool to create _built-in.o_ thin archive

Finally we got to the point where we need to compile something. You remember that our last unexplored dependency is _$(obj-y)_ and obj-y is just a list of object files. The target that compiles all object files from corresponding .c files is defined here. Let's examine all lines, needed to understand this target.

#+begin_src makefile 
  cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<

  define rule_cc_o_c
  $(call echo-cmd,checksrc) $(cmd_checksrc)              \
  $(call cmd_and_fixdep,cc_o_c)                      \
  $(cmd_modversions_c)                          \
  $(call echo-cmd,objtool) $(cmd_objtool)                  \
  $(call echo-cmd,record_mcount) $(cmd_record_mcount)
  endef

  $(obj)/%.o: $(src)/%.c $(recordmcount_source) $(objtool_dep) FORCE
  $(call cmd,force_checksrc)
  $(call if_changed_rule,cc_o_c)
#+end_src

Inside it's recipe this target calls _rule_cc_o_c_ . This rule is responsible for a lot of things, like:
+ checking the source code for some common errors _cmd_checksrc_
+ enabling versioning for exported module symbols _cmd_modversions_c_
+ using objtool to validate some aspects of generated object files
+ constructing a list of calls to mcount function so that ftrace can find them quickly

But most importantly it calls *cmd_cc_o_c* command that actually compiles all .c files to object files

#+ATTR_HTML: :border 1 :rules all :frame boader
| [[file:startup.org][Next: Startup sequence]] | [[file:linux.org][Previous: Project Structure]] | [[file:initialization.org][Home: Kernel Initialization]] |
