#+TITLE: 内核构建系统
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./initialization.html
#+HTML_LINK_UP: ./linux.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  Linux也使用make实用程序来构建内核, 尽管Linux makefile要复杂得多
#+end_example
在看makefile之前, 先学习一些有关Linux构建系统的重要概念 _Kbuild_ 
* 一些基本的kbuild概念

可以使用kbuild中的变量自定义构建过程。这些变量在 [[https://github.com/torvalds/linux/tree/v4.14/arch/arm64/Kconfig][Kconfig]] 文件中定义
+ 在这里, 可以定义变量本身及其默认值
  + 变量可以具有不同的类型, 包括字符串, 布尔值和整数
+ 在Kconfig文件中, 还可以定义变量之间的依赖关系
  #+begin_example
    例如, 如果选择了变量X, 则可以隐式选择变量Y

    也可以看一下 arm64 Kconfig文件. 该文件定义了所有变量, 特定于arm64体系结构
  #+end_example
+ Kconfig功能不是标准make的一部分, 而是在Linux makefile中实现的
+ 在 Kconfig 中定义的变量在 _内核源代码_ 以及 _嵌套的makefile_ 中都 *可见*  
+ 可以在内核配置的步骤中设置变量值
  #+begin_example
    例如, 如果键入make menuconfig, 则会显示一个控制台GUI

    它允许自定义所有内核变量的值并将这些值存储在 .config中 

    help 命令以查看所有可能的选项来配置内核
  #+end_example

Linux使用递归构建：这意味着Linux内核的每个子文件夹都可以定义它自己的Makefile和Kconfig. 大多数嵌套Makefile文件都非常简单, 只是定义文件需要编译什么对象
#+begin_src makefile
  obj-$(SOME_CONFIG_VARIABLE) += some_file.o
#+end_src

这意味着 _some_file.c_ 只会在 *设置* _SOME_CONFIG_VARIABLE_ 的情况下编译并链接到内核. 如果要无条件编译和链接文件, 则需要更改以前的定义, 如下所示.

#+begin_src makefile
  obj-y += some_file.o
#+end_src

在继续前进之前, 需要了解基本make规则的结构并熟悉make术语。下图说明了通用规则 _结构_ ：
#+begin_src makefile
  targets : prerequisites
  recipe
  …
#+end_src
+ _targets_ : 文件名, 用 _空格_ 分隔，执行规则后将生成 *目标* 文件。通常, 每个规则只有一个目标
+ _prerequisites_ : make _跟踪_ 的文件, 以查看是否需要 *更新* 目标文件
+ _recipe_ :  一个bash脚本，在某些prerequisites更新后进行调用。recipe负责 *生成* 目标文件

  #+begin_example
    targets 和 Prerequsites 都可以包含通配符(％)

    使用通配符时, 将分别对每个已匹配的prerequisites执行recipe，可以使用$< 和 $@变量来引用 recipe中的 prerequisites 和 targets
  #+end_example

  _make_ 可以很好地检测是否已更改任何prerequisites, 并且仅更新需要重建的目标文件. 但是, 如果recipe是动态更新的, 则 make 将无法检测到此更改
#+begin_example
  一个很好的例子是, 当更改一些配置变量时, 这会导致在recipe中添加一个附加选项

  默认情况下, make将不会重新编译以前生成的目标文件, 因为它们的prerequisites没有改变, 只是recipe已更新
#+end_example

为了解决此问题, Linux引入了 [[https://github.com/torvalds/linux/blob/v4.14/scripts/Kbuild.include#L264][if_changed]]  函数。要查看其工作原理, 请考虑以下示例：
#+begin_src makefile 
  cmd_compile = gcc $(flags) -o $@ $<

  %.o: %.c FORCE
  $(call if_changed,compile)
#+end_src

在这里对于每个.c文件, 通过使用带有compile参数的if_changed函数来构建相应的.o文件。if_changed查找 _cmd_compile_ 变量(在第一个参数后添加cmd_前缀), 并检查此变量自上次执行以来是否已更新, 或者任何prerequisites已更改：
+ 如果是, 则执行 cmd_compile 命令并重新生成目标文件

上面示例中的规则有两个prerequisites源 _.c文件_ 和 _FORCE_ 
+ FORCE 是一个特殊的prerequisites, 它强制每次调用 make 命令时都调用recipe
  #+begin_example
    没有FORCE, 只有在 .c 文件被更改的情况下才会调用 recipe 
  #+end_example
* 构建内核
现在, 当我们了解了有关Linux构建系统的一些重要概念时, 尝试弄清楚在键入make命令后到底发生了什么。这个过程非常复杂, 并且包含很多细节, 将跳过其中的大多数细节. 主要目标是回答2个问题：
1. 源文件如何精确地编译为目标文件？
2. 目标文件如何链接到OS映像中？

首先来解决第二个问题
** 链接阶段
从make help命令的输出中看到, 负责构建内核的默认目标称为 [[https://github.com/torvalds/linux/blob/v4.14/Makefile#L1004][vmlinux]] 并且看起来像这样

#+begin_src makefile 
  cmd_link-vmlinux =                                                 \
  $(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) ;    \
  $(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)

  vmlinux: scripts/link-vmlinux.sh vmlinux_prereq $(vmlinux-deps) FORCE
  +$(call if_changed,link-vmlinux)
#+end_src

这个目标使用了已经熟悉的 if_changed 函数。每当某些先决条件被更新时, 就执行 cmd_link-vmlinux 命令。 此命令执行 [[https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh][scripts/link-vmlinux.sh]] 脚本

#+begin_example
  注意 $< 为 cmd_link-vmlinux 命令中的自动变量

  它还执行特定于体系结构的 postlink脚本, 但我们对此并不十分感兴趣
#+end_example

执行 scripts /link-vmlinux.sh 时, 它假定所有必需的目标文件均已构建并且它们的位置存储在3个变量中：
+ _KBUILD_VMLINUX_INIT_
+ _KBUILD_VMLINUX_MAIN_
+ _KBUILD_VMLINUX_LIBS_

_link-vmlinux.sh_ 脚本首先从所有可用的目标文件里创建 thin archive。thin archive 是一个特殊的对象, 其中包含对一组 *目标文件* 及其组合 *符号表* 的引用. 这是在 [[https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh#L56][archive_builtin]] 函数内部完成的。使用 [[https://sourceware.org/binutils/docs/binutils/ar.html][ar]] 工具来创建thin archive。 产生的 thin archive 被储存在 _built-in.o_ 文件中并具有链接器可以理解的格式, 因此它可以用作任何其他普通目标文件


接下来 [[https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh#L69][modpost_link]] 被调用. 该函数调用 _链接器_ 并 *生成* _vmlinux.o_ 目标文件
#+begin_example
  需要这个vmlinux.o 目标文件来执行断面失配分析

  该分析由 modpost 程序组成
#+end_example

接下来生成 _内核符号表_ . 它包含有关所有 _函数_ 和 _全局变量_ 的信息, 以及它们在vmlinux二进制文件中的位置. 主要工作在 [[https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh#L146][kallsyms]]  函数内部完成。该函数： 
1. 首先使用 [[https://sourceware.org/binutils/docs/binutils/nm.html][nm]] 从 vmlinux 二进制文件中提取所有符号
2. 然后使用  [[https://github.com/torvalds/linux/blob/v4.14/scripts/kallsyms.c][scripts/kallsyms]] 脚本生成一个特殊的汇编器文件, 其中包含所有特殊的符号（可以被Linux内核理解的格式） 
3. 接着将编译此汇编器文件并将其与原始二进制文件链接在一起。来自内核符号表的信息用于在运行时生成 _/proc/kallsyms_ 文件
   #+begin_example
     因为某些符号的最终链接地址可能会被修改多次, 所以此过程也需要重复了多次
   #+end_example

最后, _vmlinux_ 二进制文件已经准备好, 并且 _System.map_ 已经构建

#+begin_example
  System.map 包含与 /proc/kallsyms 相同的信息, 但这是 静态 文件与 /proc/kallsyms 的不同, 它不是在运行时生成的
#+end_example

System.map主要用于在 [[https://en.wikipedia.org/wiki/Linux_kernel_oops][kernel oops]] 期间将 _地址_ *解析* 为 _符号名称_ 。相同的 [[https://sourceware.org/binutils/docs/binutils/nm.html][nm]] 程序用于构建System.map

** 编译阶段
现在向后退一步, 检查源代码文件如何编译为目标文件. 可能还记得, vmlinux目标的先决条件之一是 _$(vmlinux-deps)_ 变量. 现在, 从Linux 主makefile 中复制一些相关的行, 以演示如何构建此变量：
#+begin_src makefile 
  init-y        := init/
  drivers-y    := drivers/ sound/ firmware/
  net-y        := net/
  libs-y        := lib/
  core-y        := usr/

  core-y        += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/

  init-y        := $(patsubst %/, %/built-in.o, $(init-y))
  core-y        := $(patsubst %/, %/built-in.o, $(core-y))
  drivers-y    := $(patsubst %/, %/built-in.o, $(drivers-y))
  net-y        := $(patsubst %/, %/built-in.o, $(net-y))

  export KBUILD_VMLINUX_INIT := $(head-y) $(init-y)
  export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y2) $(drivers-y) $(net-y) $(virt-y)
  export KBUILD_VMLINUX_LIBS := $(libs-y1)
  export KBUILD_LDS          := arch/$(SRCARCH)/kernel/vmlinux.lds

  vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN) $(KBUILD_VMLINUX_LIBS)
#+end_src

所有这些都以变量 _init-y_ , _core-y_ 等开头. 它们组合在一起, 包含Linux内核的所有子文件夹, 这些子文件夹包含可构建的源代码. 然后, 在所有子文件夹名称后附加 _built-in.o_ 
#+begin_example
  例如, drivers/ 成为 drivers/built-in.o. 然后, vmlinux-deps会汇总所有结果值

  这解释了vmlinux最终如何依赖于所有build-in.o文件
#+end_example

下一个问题是如何创建所有 built-in.o 对象？再一次, 复制所有相关的行, 并说明其工作原理：
#+begin_src makefile 
  $(sort $(vmlinux-deps)): $(vmlinux-dirs) ;

  vmlinux-dirs    := $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
  $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
  $(net-y) $(net-m) $(libs-y) $(libs-m) $(virt-y)))

  build := -f $(srctree)/scripts/Makefile.build obj               #Copied from `scripts/Kbuild.include`

  $(vmlinux-dirs): prepare scripts
  $(Q)$(MAKE) $(build)=$@

#+end_src


第一行说明 _vmlinux-deps_ 依赖于 _vmlinux-dirs_ . 接下来, 可以看到 vmlinux-dirs 是一个 *变量* , 它包含所有直接的根子文件夹, 末尾没有 _/_ 字符。最重要的一行是构建 _$(vmlinux-dirs)_ 目标的方法. 替换所有变量后, 此配方如下所示

#+begin_src sh 
  make -f scripts/Makefile.build obj=drivers
#+end_src

这行仅调用另一个makefile [[https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build][scripts/Makefile.build]] 并传递 obj变量, 该变量包含要编译的文件夹

#+begin_example
  这里以drivers文件夹为例, 但是将对所有根子文件夹执行此规则
#+end_example

接下来的逻辑步骤是执行 _scripts/Makefile.build_ 。第一件事是 *定义* 包括当前目录中定义的Makefile或Kbuild文件中的所有变量. 当前目录是指 _obj变量引用的目录_ 。包含在以下 [[https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build#L43-L45][下面三行]] ：

#+begin_src makefile 
  kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
  kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
  include $(kbuild-file)
#+end_src

嵌套的makefile主要负责初始化诸如 _obj-y_ 之类的变量：
+ obj-y变量应包含位于当前目录中的所有源代码文件的列表
+ 初始化的另一个重要变量是 _subdir-y_ ：此变量包含在构建curent目录中的源代码之前需要访问的所有子文件夹的列表
  #+begin_example
    subdir-y用于实现递归到最终的子文件夹
  #+end_example

在不指定目标的情况下调用 make 时(例如在执行 scripts/Makefile.build 的情况下), 它将使用第一个目标。scripts /Makefile.build 的第一个目标称为 *__build* 
#+begin_src makefile
  __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
  $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
  $(subdir-ym) $(always)
  @:
#+end_src

, __build 目标没有receipe, 只取决于其他目标. 只对 _$(builtin-target)_ 感兴趣

#+begin_example
  ${builtin-target} 负责创建 built-in.o文件 和 $(subdir-ym)
#+end_example

而 _${subdir-ym)_ ：负责继续进入到字目录，此变量初始化 _subdir-y_ 和 _subdir-m_ 个变量

#+begin_example
  subdir-m 变量类似于 subdir-y, 但它定义了子文件夹需要包含在单独的kernel模块中

  现在跳过讨论模块, 以保持专注
#+end_example

subdir-ym 应该看起来很熟悉：
#+begin_src makefile 
  $(subdir-ym):
  $(Q)$(MAKE) $(build)=$@
#+end_src

#+begin_example
  这个目标只是触发嵌套子文件夹中的 scripts/Makefile.build 的执行
#+end_example

现在是时候观察 [[https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build#L467][builtin-target]] 了，再次在这里只复制相关行：
#+begin_src makefile 
  cmd_make_builtin = rm -f $@; $(AR) rcSTP$(KBUILD_ARFLAGS)
  cmd_make_empty_builtin = rm -f $@; $(AR) rcSTP$(KBUILD_ARFLAGS)

  cmd_link_o_target = $(if $(strip $(obj-y)),\
  $(cmd_make_builtin) $@ $(filter $(obj-y), $^) \
  $(cmd_secanalysis),\
  $(cmd_make_empty_builtin) $@)

  $(builtin-target): $(obj-y) FORCE
  $(call if_changed,link_o_target)
#+end_src

该目标取决于 _$(obj-y)_ 目标, 而obj-y是需要在当前文件夹中构建的所有目标文件的列表。这些文件准备就绪后, 将执行 _cmd_link_o_target_ 命令：
+ 如果 _obj-y_ 变量为 *空* , 则调用 _cmd_make_empty_builtin_ , 直到创建一个空的 _built-in.o_ 
+ 否则, 执行 _cmd_make_builtin_ 命令；它使用熟悉的 _ar_ 工具创建 _built-in.o_ thin archive 

最终到了需要编译一些东西的地步
#+begin_example
  最后一个没有查看过的依赖项是 $(obj-y) ，但是 不幸的是 obj-y 只是一份目标文件列表
#+end_example

因此在 [[https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build#L467][这里]] 定义了如何从相应的 .c 文件编译对应的二进制文件. 来看下对应的所有行：

#+begin_src makefile 
  cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<

  define rule_cc_o_c
  $(call echo-cmd,checksrc) $(cmd_checksrc)              \
  $(call cmd_and_fixdep,cc_o_c)                      \
  $(cmd_modversions_c)                          \
  $(call echo-cmd,objtool) $(cmd_objtool)                  \
  $(call echo-cmd,record_mcount) $(cmd_record_mcount)
  endef

  $(obj)/%.o: $(src)/%.c $(recordmcount_source) $(objtool_dep) FORCE
  $(call cmd,force_checksrc)
  $(call if_changed_rule,cc_o_c)
#+end_src

在此 recipe 内部, 此 target 称为 _rule_cc_o_c_ 。 这个规则负责很多事情：
+ 检查源代码中的一些常见错误 _cmd_checksrc_
+ 为导出的模块符号启用版本控制  _cmd_modversions_c_
+ 使用  [[https://github.com/torvalds/linux/tree/v4.14/tools/objtool][objtool]] 验证生成的二进制目标文件
+ 构建对mcount函数的调用列表以便  [[https://github.com/torvalds/linux/blob/v4.14/Documentation/trace/ftrace.txt][ftrace]] 可以很快找到他们
+ ....

但是最重​​要的是, 它调用 _cmd_cc_o_c_ 命令, 实际上是该命令将所有.c文件编译为二进制文件

#+ATTR_HTML: :border 1 :rules all :frame boader
| [[file:startup.org][Next 引导流程]]  | [[file:linux.org][Previous: 项目结构]] | [[file:initialization.org][Home: 内核初始化]] |
