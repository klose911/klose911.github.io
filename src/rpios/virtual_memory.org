#+TITLE: 虚拟内存
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: ./system_call.html
#+HTML_LINK_HOME: ./rpios.html
#+OPTIONS: num:nil timestamp:nil ^:nil

现在，RPi OS可以运行和调度用户进程，但它们之间的隔离并不完整：所有进程和内核本身共享同一块内存。这使得任何进程都可以轻易地访问其他进程甚至内核数据

#+begin_example
  即使假设所有的进程都不是恶意的，仍然存在另一个缺点：在分配内存之前，每个进程都需要知道哪些内存区域已被占用

  这使得进程的内存分配变得更加复杂
#+end_example
* 地址转换
接下来将通过引入 _虚拟内存_ 来解决上述所有问题。虚拟内存为每个进程提供了一个抽象，使其认为它占用了所有可用的内存。每当一个进程需要访问某个内存位置时，它使用虚拟地址，该地址会被转换为物理地址。转换的过程完全对进程透明，由一个特殊设备进行：*MMU*（ _内存映射单元_ ）。MMU使用 _转换表_ 来将虚拟地址转换为物理地址。转换的过程如下图所示：

#+begin_example
			     Virtual address                                                                 Physical Memory
  +-----------------------------------------------------------------------+                                +------------------+
  |         | PGD Index | PUD Index | PMD Index | PTE Index | Page offset |                                |                  |
  +-----------------------------------------------------------------------+                                |                  |
  63        47     |    38      |   29     |    20    |     11      |     0                                |     Page N       |
		   |            |          |          |             +--------------------+           +---->+------------------+
		   |            |          |          +---------------------+            |           |     |                  |
	    +------+            |          |                                |            |           |     |                  |
	    |                   |          +----------+                     |            |           |     |------------------|
  +------+  |        PGD        |                     |                     |            +---------------->| Physical address |
  | ttbr |---->+-------------+  |           PUD       |                     |                        |     |------------------|
  +------+  |  |             |  | +->+-------------+  |          PMD        |                        |     |                  |
	    |  +-------------+  | |  |             |  | +->+-------------+  |          PTE           |     +------------------+
	    +->| PUD address |----+  +-------------+  | |  |             |  | +->+--------------+    |     |                  |
	       +-------------+  +--->| PMD address |----+  +-------------+  | |  |              |    |     |                  |
	       |             |       +-------------+  +--->| PTE address |----+  +-------------_+    |     |                  |
	       +-------------+       |             |       +-------------+  +--->| Page address |----+     |                  |
				     +-------------+       |             |       +--------------+          |                  |
							   +-------------+       |              |          |                  |
										 +--------------+          +------------------+
#+end_example

以下事实对于理解这个图表和内存转换过程非常重要：
+ 进程的内存总是以 _页面_ 为单位分配的。页面是一个连续的内存区域，大小为 _4KB_
  #+begin_example
    ARM处理器支持更大的页面，但4KB是最常见的情况，这里将限制讨论在这个页面大小上
  #+end_example
+ _页表_ 具有 *分层* 结构。在任何一个表中的项目包含了层次结构中下一个表的地址
+ 表层次结构中有4个级别：
  + *PGD* :  _页全局目录_ (Page Global Directory)
  + *PUD* :  _页上级目录_ (Page Upper Directory)
  + *PMD* :  _页中间目录_ (Page Middle Directory)
  + *PTE* : _页表项_ (Page Table Entry) PTE是层次结构中的最后一个表，它指向 *物理内存* 中的 _实际页面_ 
+ 内存转换过程从 *定位*  _PGD_ （页全局目录）表的地址开始。该表的地址存储在 *ttbr0_el1寄存器* 中
+ *每个进程都有自己的所有页表的副本* ，包括 _PGD_ ，因此每个进程都必须保持其PGD地址。在 *上下文切换* 期间，将 _下一个进程_ 的 _PGD地址_ *加载* 到 _ttbr0_el1寄存器_ 中
+ 然后， _MMU_ 使用PGD指针和虚拟地址计算相应的物理地址。所有虚拟地址仅使用64位中的 _48位_ 。在进行转换时，MMU将地址分为4个部分：
  + *位[39-47]* : 包含 _PGD表中的索引_
    #+begin_example
      MMU使用此索引查找PUD的位置
    #+end_example
  + *位[30-38]* : 包含 _PUD表中的索引_
    #+begin_example
      MMU使用此索引查找PMD的位置
    #+end_example
  + *位[21-29]* : 包含 _PMD表中的索引_
    #+begin_example
      MMU使用此索引查找PTE的位置
    #+end_example
  + *位[12-20]* : 包含 _PTE表中的索引_
    #+begin_example
      MMU使用此索引在物理内存中找到一个页面
    #+end_example
  + *位[0-11]* : 包含 _物理页面中的偏移量_
    #+begin_example
      MMU使用此偏移量确定在之前找到的页面中与原始虚拟地址对应的确切位置 
    #+end_example

  #+begin_example
    现在，让我们进行一个小练习，计算页表的大小

    从上面的图表中，知道页表中的索引占据9位（对于所有的页表级别都是如此）: 这意味着每个页表包含2^9 = 512个条目

    每个页表中的条目是层次结构中下一个页表或者PTE情况下的物理页面的地址。由于使用的是64位处理器，每个地址必须是64位或8字节大小

    将所有这些放在一起，我们可以计算出一个页表的大小必须是512 * 8 = 4096字节或4 KB。这正是一个页面的大小！

    这可能会让你对为什么MMU设计者选择这样的数字产生直觉
  #+end_example
* 区段映射
有时候需要映射连续的大内存区域。在这种情况下，可以直接映射2 MB大小的块，称为 _区段_ 。这样可以省去一级的地址转换。在这种情况下，转换图如下所示：

#+begin_example
			     Virtual address                                               Physical Memory
  +-----------------------------------------------------------------------+              +------------------+
  |         | PGD Index | PUD Index | PMD Index |      Section offset     |              |                  |
  +-----------------------------------------------------------------------+              |                  |
  63        47     |    38      |   29     |    20            |           0              |    Section N     |
		   |            |          |                  |                    +---->+------------------+
		   |            |          |                  |                    |     |                  |
	    +------+            |          |                  |                    |     |                  |
	    |                   |          +----------+       |                    |     |------------------|
  +------+  |        PGD        |                     |       +------------------------->| Physical address |
  | ttbr |---->+-------------+  |           PUD       |                            |     |------------------|
  +------+  |  |             |  | +->+-------------+  |            PMD             |     |                  |
	    |  +-------------+  | |  |             |  | +->+-----------------+     |     +------------------+
	    +->| PUD address |----+  +-------------+  | |  |                 |     |     |                  |
	       +-------------+  +--->| PMD address |----+  +-----------------+     |     |                  |
	       |             |       +-------------+  +--->| Section address |-----+     |                  |
	       +-------------+       |             |       +-----------------+           |                  |
				     +-------------+       |                 |           |                  |
							   +-----------------+           |                  |
											 +------------------+
#+end_example

这里的区别在于 _PMD_ 现在包含指向 _物理区段的指针_ 。另外，偏移量占据了 _21位_ 而不是12位
#+begin_example
  因为需要21位来编码2MB的范围
#+end_example
* 页表描述符
#+begin_example
  可能会问MMU如何知道PMD项目是指向PTE还是物理2MB区段的？

  为了回答这个问题，需要更仔细地看一下页表项的结构
#+end_example

页表中的项目称为 _描述符_ 。描述符具有特殊的格式：

#+begin_example
			     Descriptor format
  `+------------------------------------------------------------------------------------------+
   | Upper attributes | Address (bits 47:12) | Lower attributes | Block/table bit | Valid bit |
   +------------------------------------------------------------------------------------------+
   63                 47                     11                 2                 1           0
#+end_example

关键是要理解每个描述符总是指向对齐的内容（可以是物理页、区段或层次结构中的下一个页表）。这意味着 _描述符中存储的地址_ 的 _最后12位_ *始终为0* 。这也意味着MMU可以使用这些位来存储更有用的信息，这正是它所做的

描述符中各位的含义：
+ *位 0*  ：对于所有 *有效* 的描述符，此位必须设置为 _1_
  #+begin_example
    如果在转换过程中MMU遇到非有效的描述符，将生成同步异常

    然后内核应处理此异常，分配一个新页并准备正确的描述符

    稍后将详细了解其工作原理
  #+end_example
+ *位 1* ： 指示当前描述符是指向层次结构中的 *下一个页表* 的描述符（称此类描述符为 _表描述符_ ），还是指向 *物理页或区段* 的描述符（称此类描述符为 _块描述符_ ）
+ *位 [11:2]* ：
  + 对于表描述符，这些位被忽略
  + 对于块描述符：它们包含一些属性，比如控制映射的页 _是否可缓存_ 、 _可执行_ 等
+ *位 [47:12]* ：存储描述符指向的 _地址_ 
  #+begin_example
    如前所述，只需存储地址的位 [47:12]，因为其他位始终为0
  #+end_example
+ *位 [63:48]* ：另一组属性位
* 页面属性配置

