#+TITLE: Linux 实现
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_UP: ./rpi-os.html
#+HTML_LINK_HOME: ./interrupt.html
#+OPTIONS: num:nil timestamp:nil ^:nil

* 底层异常处理
#+begin_example
  如何在庞大的Linux内核源代码, 找到负责中断处理的代码？

  这里提出一个想法，向量表的基地址应存储在vbar_el1 寄存器中, 因此, 如果搜索 vbar_el1, 则应该能够弄清楚向量表的初始化位置
#+end_example

搜索提供了一些这个寄存器的用法, 其中之一属于已经熟悉的 head.S 。 这段代码位于__primary_switched 函数内部，MMU 打开后执行此函数：

#+begin_src asm 
	  adr_l    x8, vectors            // load VBAR_EL1 with virtual
	  msr    vbar_el1, x8            // vector table address
#+end_src

从这段代码中, 可以推断出 _向量表_ 被称为 _vector_ , 应该能够轻松找到 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/entry.S#L367][定义]]

#+begin_src asm 
	  /*
	  ,* Exception vectors.
	  ,*/
	  .pushsection ".entry.text", "ax"

	  .align    11
	  ENTRY(vectors)
	  kernel_ventry    el1_sync_invalid        // Synchronous EL1t
	  kernel_ventry    el1_irq_invalid            // IRQ EL1t
	  kernel_ventry    el1_fiq_invalid            // FIQ EL1t
	  kernel_ventry    el1_error_invalid        // Error EL1t

	  kernel_ventry    el1_sync            // Synchronous EL1h
	  kernel_ventry    el1_irq                // IRQ EL1h
	  kernel_ventry    el1_fiq_invalid            // FIQ EL1h
	  kernel_ventry    el1_error_invalid        // Error EL1h

	  kernel_ventry    el0_sync            // Synchronous 64-bit EL0
	  kernel_ventry    el0_irq                // IRQ 64-bit EL0
	  kernel_ventry    el0_fiq_invalid            // FIQ 64-bit EL0
	  kernel_ventry    el0_error_invalid        // Error 64-bit EL0

	  #ifdef CONFIG_COMPAT
	  kernel_ventry    el0_sync_compat            // Synchronous 32-bit EL0
	  kernel_ventry    el0_irq_compat            // IRQ 32-bit EL0
	  kernel_ventry    el0_fiq_invalid_compat        // FIQ 32-bit EL0
	  kernel_ventry    el0_error_invalid_compat    // Error 32-bit EL0
	  #else
	  kernel_ventry    el0_sync_invalid        // Synchronous 32-bit EL0
	  kernel_ventry    el0_irq_invalid            // IRQ 32-bit EL0
	  kernel_ventry    el0_fiq_invalid            // FIQ 32-bit EL0
	  kernel_ventry    el0_error_invalid        // Error 32-bit EL0
	  #endif
	  END(vectors)
#+end_src

#+begin_example
  kernel_ventry宏与ventry在RPi OS中也有定义

  不过, 一个区别是 kernel_ventry 还负责检查是否发生了内核堆栈溢出

  如果设置了CONFIG_VMAP_STACK, 则启用此功能, 它是内核功能的一部分, 称为虚拟映射内核堆栈
#+end_example

** kernel_entry
kernel_entry宏 在 Linux 里要复杂得多：

#+begin_src asm 
	  .macro	kernel_entry, el, regsize = 64
	  .if	\regsize == 32
	  mov	w0, w0				// zero upper 32 bits of x0
	  .endif
	  stp	x0, x1, [sp, #16 * 0]
	  stp	x2, x3, [sp, #16 * 1]
	  stp	x4, x5, [sp, #16 * 2]
	  stp	x6, x7, [sp, #16 * 3]
	  stp	x8, x9, [sp, #16 * 4]
	  stp	x10, x11, [sp, #16 * 5]
	  stp	x12, x13, [sp, #16 * 6]
	  stp	x14, x15, [sp, #16 * 7]
	  stp	x16, x17, [sp, #16 * 8]
	  stp	x18, x19, [sp, #16 * 9]
	  stp	x20, x21, [sp, #16 * 10]
	  stp	x22, x23, [sp, #16 * 11]
	  stp	x24, x25, [sp, #16 * 12]
	  stp	x26, x27, [sp, #16 * 13]
	  stp	x28, x29, [sp, #16 * 14]

	  .if	\el == 0
	  mrs	x21, sp_el0
	  ldr_this_cpu	tsk, __entry_task, x20	// Ensure MDSCR_EL1.SS is clear,
	  ldr	x19, [tsk, #TSK_TI_FLAGS]	// since we can unmask debug
	  disable_step_tsk x19, x20		// exceptions when scheduling.

	  mov	x29, xzr			// fp pointed to user-space
	  .else
	  add	x21, sp, #S_FRAME_SIZE
	  get_thread_info tsk
	  /* Save the task's original addr_limit and set USER_DS (TASK_SIZE_64) */
	  ldr	x20, [tsk, #TSK_TI_ADDR_LIMIT]
	  str	x20, [sp, #S_ORIG_ADDR_LIMIT]
	  mov	x20, #TASK_SIZE_64
	  str	x20, [tsk, #TSK_TI_ADDR_LIMIT]
	  /* No need to reset PSTATE.UAO, hardware's already set it to 0 for us */
	  .endif /* \el == 0 */
	  mrs	x22, elr_el1
	  mrs	x23, spsr_el1
	  stp	lr, x21, [sp, #S_LR]

	  /*
	  ,* In order to be able to dump the contents of struct pt_regs at the
	  ,* time the exception was taken (in case we attempt to walk the call
	  ,* stack later), chain it together with the stack frames.
	  ,*/
	  .if \el == 0
	  stp	xzr, xzr, [sp, #S_STACKFRAME]
	  .else
	  stp	x29, x22, [sp, #S_STACKFRAME]
	  .endif
	  add	x29, sp, #S_STACKFRAME

	  #ifdef CONFIG_ARM64_SW_TTBR0_PAN
	  /*
	  ,* Set the TTBR0 PAN bit in SPSR. When the exception is taken from
	  ,* EL0, there is no need to check the state of TTBR0_EL1 since
	  ,* accesses are always enabled.
	  ,* Note that the meaning of this bit differs from the ARMv8.1 PAN
	  ,* feature as all TTBR0_EL1 accesses are disabled, not just those to
	  ,* user mappings.
	  ,*/
	  alternative_if ARM64_HAS_PAN
	  b	1f				// skip TTBR0 PAN
	  alternative_else_nop_endif

	  .if	\el != 0
	  mrs	x21, ttbr0_el1
	  tst	x21, #0xffff << 48		// Check for the reserved ASID
	  orr	x23, x23, #PSR_PAN_BIT		// Set the emulated PAN in the saved SPSR
	  b.eq	1f				// TTBR0 access already disabled
	  and	x23, x23, #~PSR_PAN_BIT		// Clear the emulated PAN in the saved SPSR
	  .endif

	  __uaccess_ttbr0_disable x21
  1:
	  #endif

	  stp	x22, x23, [sp, #S_PC]

	  /* Not in a syscall by default (el0_svc overwrites for real syscall) */
	  .if	\el == 0
	  mov	w21, #NO_SYSCALL
	  str	w21, [sp, #S_SYSCALLNO]
	  .endif

	  /*
	  ,* Set sp_el0 to current thread_info.
	  ,*/
	  .if	\el == 0
	  msr	sp_el0, tsk
	  .endif

	  /*
	  ,* Registers that may be useful after this macro is invoked:
	  ,*
	  ,* x21 - aborted SP
	  ,* x22 - aborted PC
	  ,* x23 - aborted PSTATE
	  ,*/
	  .endm
#+end_src

现在来详细研究这个宏
#+begin_src asm 
	  .macro    kernel_entry, el, regsize = 64
#+end_src

该宏接受2个参数： _el_ 和 _regsize_ :
+ el 可以是 0 或 1, 具体取决于是否在EL0或EL1上生成了异常
+ 如果来自32位EL0, 则 regsize 为32, 否则为64

#+begin_src asm 
	  .if    \regsize == 32
	  mov    w0, w0                // zero upper 32 bits of x0
	  .endif
#+end_src

在32位模式下, 使用32位通用寄存器(w0而不是x0)。w0在结构上映射到x0的下部

#+begin_example
  上面代码通过向自身写入w0来将x0寄存器的高32位清零
#+end_example

#+begin_src asm 
	  stp    x0, x1, [sp, #16 * 0]
	  stp    x2, x3, [sp, #16 * 1]
	  stp    x4, x5, [sp, #16 * 2]
	  stp    x6, x7, [sp, #16 * 3]
	  stp    x8, x9, [sp, #16 * 4]
	  stp    x10, x11, [sp, #16 * 5]
	  stp    x12, x13, [sp, #16 * 6]
	  stp    x14, x15, [sp, #16 * 7]
	  stp    x16, x17, [sp, #16 * 8]
	  stp    x18, x19, [sp, #16 * 9]
	  stp    x20, x21, [sp, #16 * 10]
	  stp    x22, x23, [sp, #16 * 11]
	  stp    x24, x25, [sp, #16 * 12]
	  stp    x26, x27, [sp, #16 * 13]
	  stp    x28, x29, [sp, #16 * 14]
#+end_src

将所有通用寄存器保存在堆栈中

#+begin_example
  请注意：在 kernel_ventry 中已经对堆栈指针进行了调整, 以适应所有需要被存储

  保存寄存器的顺序很重要, 因为在Linux中有一种特殊的结构pt_regs, 用于稍后在异常处理程序中访问保存的寄存器

  该结构不仅包含通用寄存器, 还包含其他一些信息, 这些信息大多数稍后会在kernel_entry宏中填充
#+end_example

#+begin_src asm 
	  .if    \el == 0
	  mrs    x21, sp_el0
#+end_src

_x21_ 现在包含被异常的堆栈指针

#+begin_example
  请注意, Linux中的一个进程对于用户和内核模式分别使用不同的堆栈

  在用户模式下, 可以使用 sp_el0 寄存器来计算异常产生时的堆栈指针值

  这行非常重要, 因为需要在上下文切换期间交换堆栈指针
#+end_example

#+begin_src asm 
	  ldr_this_cpu    tsk, __entry_task, x20    // Ensure MDSCR_EL1.SS is clear,
	  ldr    x19, [tsk, #TSK_TI_FLAGS]    // since we can unmask debug
	  disable_step_tsk x19, x20        // exceptions when scheduling.
#+end_src
_MDSCR_EL1.SS_ 位负责启用 *软件步骤异常* ：如果该位 _置1_ 并且调试异常未屏蔽, 则在执行任何指令后都会生成异常
#+begin_example
  这是调试器通常使用的
#+end_example

从用户模式获取异常时, 需要首先检查 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/include/asm/thread_info.h#L93][TIF_SINGLESTEP]] 标志为当前任务设置. 如果是, 则表明任务正在调试器下执行, 必须将 MDSCR_EL1.SS位清零

#+begin_example
  在Linux中, 每个进程或线程(稍后都会将它们称为“任务”)都有一个 task_struct 与其关联，该结构包含有关任务的所有元数据信息

  在arm64体系结构上task_struct中被放入另一个称为thread_info, 所以可以通过指向task_struct的指针来获取指向thread_info的指针

  thread_info 存储了很多底层值和标志位，这些会被 entry.S 所访问
#+end_example

#+begin_src asm 
	  mov    x29, xzr            // fp pointed to user-space
#+end_src

尽管 _x29_ 是通用寄存器, 但通常具有特殊含义，它用作 *frame pointer* 。编译函数时, 通常：

1. 在堆栈中存储旧的帧指针和链接寄存器值，x30被称为链接寄存器, 它包含一个由ret指令使用的“返回地址”
2. 然后分配一个新的堆栈帧, 以便它可以包含函数的所有局部变量, 并且帧指针寄存器设置为指向帧的底部

每当函数需要访问某些局部变量时, 它仅向帧指针添加硬编码的偏移量

#+begin_example
  现在想象一下发生了一个错误, 需要生成一个堆栈跟踪：

  可以使用当前帧指针在堆栈中查找所有局部变量, 并且可以使用链接寄存器来确定调用者的确切位置

  接下来, 利用以下事实：旧的帧指针和链接寄存器的值始终保存在堆栈帧的开头, 而我们可以从那里读取它们。一旦获取了调用者的帧指针之后, 现在反过来也可以访问调用者所有的局部变量

  不断递归地重复此过程, 直到到达堆栈顶部为止, 这称为“堆栈展开”。事实上 ptrace 系统调用就是使用了类似的算法
#+end_example

现在, 回到 kernel_entry 宏, 就很清楚为什么在从EL0中获取异常后需要清除x29寄存器。这是因为在Linux中, 每个任务在用户和内核模式下都使用不同的堆栈, 因此拥有通用堆栈跟踪没有任何意义

#+begin_src asm 
	  .else
	  add    x21, sp, #S_FRAME_SIZE
#+end_src

在 else子句中, 这意味着仅当处理从EL1提取的异常时, 在这种情况下, 将重用旧堆栈, 所以将 _原始sp值_ *保存* 在 _x21寄存器_ 中, 以备后用 

#+begin_src asm 
	  /* Save the task's original addr_limit and set USER_DS (TASK_SIZE_64) */
	  ldr    x20, [tsk, #TSK_TI_ADDR_LIMIT]
	  str    x20, [sp, #S_ORIG_ADDR_LIMIT]
	  mov    x20, #TASK_SIZE_64
	  str    x20, [tsk, #TSK_TI_ADDR_LIMIT]
#+end_src

任务的 _内存地址限制_ 指定了可以使用的最大虚拟内存地址：
+ 当用户进程以32位模式运行时, 此限制为 2^32
+ 对于64位内核, 它可以更大, 通常为2^48

如果碰巧从32位EL1中获取了异常, 则需要将此限制更改为 _TASK_SIZE_64_ 。此外, 还需要保存原始限制, 因为需要先还原该限制, 然后才能将执行返回到用户模式

#+begin_src asm 
	  mrs    x22, elr_el1
	  mrs    x23, spsr_el1
#+end_src

在开始处理异常之前, 必须先将 _elr_el1_ 和 _spsr_el1_ 保存在堆栈中

#+begin_example
  尚未在RPI OS中完成此操作, 因为到目前为止, 始终返回到发生异常的位置

  但是, 如果需要在处理异常时进行上下文切换, 就需要执行这些操作
#+end_example

#+begin_src asm 
	  stp    lr, x21, [sp, #S_LR]
#+end_src

把 _链接寄存器_ 和 _帧指针寄存器_ 保存在堆栈中

#+begin_example
  已经知道, 根据是从EL0还是从EL1提取异常, 帧指针的计算方式有所不同, 并且该计算的结果已存储在x21寄存器中
#+end_example

#+begin_src asm 
	  /*
	  ,* In order to be able to dump the contents of struct pt_regs at the
	  ,* time the exception was taken (in case we attempt to walk the call
	  ,* stack later), chain it together with the stack frames.
	  ,*/
	  .if \el == 0
	  stp    xzr, xzr, [sp, #S_STACKFRAME]
	  .else
	  stp    x29, x22, [sp, #S_STACKFRAME]
	  .endif
	  add    x29, sp, #S_STACKFRAME
#+end_src

这里填充了 _pt_regs_ 结构的 *stackframe 属性*

#+begin_example
  stackframe 属性还包含链接寄存器和帧指针, 尽管这里使用的是 elr_el1 的值(现在位于 x22 中) 而不是 lr

  stackframe 一般只用于 堆栈回溯 
#+end_example

#+begin_src asm 
	  #ifdef CONFIG_ARM64_SW_TTBR0_PAN
	  alternative_if ARM64_HAS_PAN
	  b    1f                // skip TTBR0 PAN
	  alternative_else_nop_endif

	  .if    \el != 0
	  mrs    x21, ttbr0_el1
	  tst    x21, #0xffff << 48        // Check for the reserved ASID
	  orr    x23, x23, #PSR_PAN_BIT        // Set the emulated PAN in the saved SPSR
	  b.eq    1f                // TTBR0 access already disabled
	  and    x23, x23, #~PSR_PAN_BIT        // Clear the emulated PAN in the saved SPSR
	  .endif

	  __uaccess_ttbr0_disable x21
  1:
	  #endif
#+end_src

_CONFIG_ARM64_SW_TTBR0_PAN_ 参数禁止内核直接访问用户空间内存

#+begin_example
  跳过对此工作原理的详细说明, 因为此类安全功能对于讨论而言已超出范围
#+end_example

#+begin_src asm 
	  stp    x22, x23, [sp, #S_PC]
#+end_src

这里, _elr_el1_ (x22) 和 _spsr_el1_ (x23) 被保存在堆栈中 

#+begin_src asm 
	  /* Not in a syscall by default (el0_svc overwrites for real syscall) */
	  .if    \el == 0
	  mov    w21, #NO_SYSCALL
	  str    w21, [sp, #S_SYSCALLNO]
	  .endif
#+end_src

pt_regs结构体有一个field, 指示当前异常是否为 _系统调用_ (syscall)

#+begin_src asm 
	  /*
	  ,* Set sp_el0 to current thread_info.
	  ,*/
	  .if    \el == 0
	  msr    sp_el0, tsk
	  .endif
#+end_src

在内核模式下执行任务时, 不需要 _sp_el0_

#+begin_example
  .其值先前已保存在堆栈中, 因此可以在kernel_exit宏中轻松恢复
#+end_example

从现在开始, sp_el0将用于持有 *指向* _当前task_struct_ 的 _指针_ 

** el1_irq 
接下来要研究的是负责处理从EL1提取的IRQ的处理程序。在向量表中, 可以轻松地发现该处理程序称为 _el1_irq_ 并在 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/entry.S#L562][此处]] 定义：

#+begin_src asm 
  el1_irq:
	  kernel_entry 1
	  enable_dbg
	  #ifdef CONFIG_TRACE_IRQFLAGS
	  bl    trace_hardirqs_off
	  #endif

	  irq_handler

	  #ifdef CONFIG_PREEMPT
	  ldr    w24, [tsk, #TSK_TI_PREEMPT]    // get preempt count
	  cbnz    w24, 1f                // preempt count != 0
	  ldr    x0, [tsk, #TSK_TI_FLAGS]    // get flags
	  tbz    x0, #TIF_NEED_RESCHED, 1f    // needs rescheduling?
	  bl    el1_preempt
  1:
	  #endif
	  #ifdef CONFIG_TRACE_IRQFLAGS
	  bl    trace_hardirqs_on
	  #endif
	  kernel_exit 1
	  ENDPROC(el1_irq)
#+end_src

在此函数内部执行以下操作：
1. 调用 _kernel_entry_ 和 _kernel_exit_ 宏来保存和恢复处理器状态：
   + 第一个参数指示异常来自EL1
2. 调用 _enable_dbg宏_ 可以 *取消屏蔽* _调试中断_
   #+begin_example
     此时, 这样做是安全的, 因为已经保存了处理器状态, 即使在中断处理程序的中间发生了调试异常, 也可以正确处理它
   #+end_example
3. _#ifdef CONFIG_TRACE_IRQFLAGS_ 块中的代码负责 *跟踪* _中断_ . 它记录2个事件：中断开始和结束
4. _#ifdef CONFIG_PREEMPT_ 中的代码 *阻止访问* _当前任务标志_ , 以检查是否需要调用调度程序
5. _irq_handler_ : 这是执行实际中断处理的地方 

irq_handler 是一个宏, 定义如下.

#+begin_src asm 
	  .macro    irq_handler
	  ldr_l    x1, handle_arch_irq
	  mov    x0, sp
	  irq_stack_entry
	  blr    x1
	  irq_stack_exit
	  .endm
#+end_src

irq_handler执行 _handle_arch_irq_ 函数，该函数通过特殊的堆栈( _irq堆栈_ )执行

#+begin_example
  为什么有必要切换到其他堆栈？ 例如, 在RPI OS中, 没有这样做

  但是如果不这么做, 将使用当前任务堆栈来处理中断, 而且永远无法确定当前任务堆栈中还有多少空间可以留给中断处理程序
#+end_example

接下来, 需要查看 handle_arch_irq。虽然他看起来像一个变量，而不是一个函数，实际上他是一个函数指针，并在 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/irq.c#L46][set_handle_irq]] 函数中设置

** 小结
#+begin_example
  至今为止已经研究了低级中断处理代码, 并从向量表一直跟踪到 handle_arch_irq ，这就是中断离开体系结构特定代码并开始由驱动程序代码处理的关键所在

  下一个目标是通过驱动程序代码来追踪计时器中断
#+end_example

* 中断控制器
#+begin_example
  接下来将大量讨论Linux驱动程序以及它们如何处理中断
#+end_example

先从驱动程序初始化代码开始, 然后看看 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/irq.c#L44][handle_arch_irq]] 函数 

** 使用设备树查找所需的设备和驱动程序
#+begin_example
  在RPi OS中实现中断时, 一直在使用2种设备：系统定时器和中断控制器

  现在, 我们的目标是了解相同设备在Linux中的工作方式

  需要做的第一件事是找到负责使用提到的设备的驱动程序
#+end_example

为了找到所需的驱动程序, 可以使用 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dots/bcm2837-rpi-3-b.dts][bcm2837-rpi-3-b.dts]] 设备树文件：这是特定于Raspberry Pi 3 Model B的顶级设备树文件, 它包含其他更常见的设备树文件, 这些文件在不同版本的Raspberry Pi之间共享. 如果遵循包含的链并搜索 timer 和 interrupt-controller , 则可以找到4个设备：
+ [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L11][本地中断控制器]]
+ [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L20][本地计时器]]
+ 全局中断控制器. 它被定义在 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L109][这里]]
+ [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L57][系统计时器]]

#+begin_example
  为什么有4个设备而不是2个？
#+end_example

** 本地与全局中断控制器
#+begin_example
  考虑多处理器系统中的中断处理时, 应该问自己几个问题：

  哪个内核应负责处理特定的中断？

  发生中断时, 是全部4个内核都中断了, 还是只有一个？

  是否可以将特定的中断路由到特定的内核？

  可能想知道的另一个问题是, 如果一个处理器需要向其传递一些信息, 该处理器如何通知另一个处理器？
#+end_example

_本地中断控制器_ 是可以帮助回答所有这些问题的设备，它负责以下任务：
+ 配置哪个内核应该接收特定的中断
+ 在内核之间发送中断. 这样的中断称为 _mailboxs_ , 并允许内核相互通信
+ 处理来自本地计时器和性能监视器中断(PMU)的中断

  #+begin_example
    BCM2836 ARM本地外围设备 手册中记录了本地中断控制器以及本地计时器的行为.

    为什么我们在系统中需要两个独立的计时器？使用本地计时器的主要用例是当要配置所有4个内核以同时接收计时器中断时。如果使用系统定时器, 则只能将中断路由到单个内核.

    使用RPi OS时, 既不使用本地中断控制器也不使用本地计时器：这是因为默认情况下, 本地中断控制器的配置方式是将所有外部中断都发送到第一个内核, 这正是我们所需要的. 所以没有使用本地计时器, 而是使用了系统计时器
  #+end_example

** 本地中断控制器
#+begin_example
根据 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L75][bcm2837.dtsi]] 全局中断控制器是本地中断控制器的子类型。 因此, 从本地控制器开始探索 
#+end_example

如果需要找到适用于特定设备的驱动程序, 则应使用 _compatible_ 属性。搜索该属性的值, 可以轻松地找到一个与RPi本地中断控制器兼容的[[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L315][驱动程序]] 

#+begin_src sh 
  IRQCHIP_DECLARE(bcm2836_arm_irqchip_l1_intc, "brcm,bcm2836-l1-intc",
		  bcm2836_arm_irqchip_l1_intc_of_init);
#+end_src

内核遍历设备树中的所有设备定义, 并且针对每个定义, 它使用 compatible 属性寻找匹配的驱动程序。如果找到驱动程序, 则调用其初始化函数。在设备注册过程中提供了初始化函数, 在本例中, 此函数是 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L280][bcm2836_arm_irqchip_l1_intc_of_init]]

#+begin_src c 
  static int __init bcm2836_arm_irqchip_l1_intc_of_init(struct device_node *node,
							struct device_node *parent)
  {
	  intc.base = of_iomap(node, 0);
	  if (!intc.base) {
		  panic("%pOF: unable to map local interrupt registers\n", node);
	  }

	  bcm2835_init_local_timer_frequency();

	  intc.domain = irq_domain_add_linear(node, LAST_IRQ + 1,
					      &bcm2836_arm_irqchip_intc_ops,
					      NULL);
	  if (!intc.domain)
		  panic("%pOF: unable to create IRQ domain\n", node);

	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPSIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPNSIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTHPIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTVIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_GPU_FAST,
					   &bcm2836_arm_irqchip_gpu);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_PMU_FAST,
					   &bcm2836_arm_irqchip_pmu);

	  bcm2836_arm_irqchip_smp_init();

	  set_handle_irq(bcm2836_arm_irqchip_handle_irq);
	  return 0;
  }
#+end_src
初始化函数采用2个参数：_node_ 和 _parent_ , 它们都是类型 _struct device_node_
+ node: 设备树中的当前节点, 在本例中, 它指向 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L11][这里]]
+ parent: 备树层次结构中的父节点, 对于本地中断控制器, 它指向 soc 元素
  #+begin_example
    soc 是最简单的总线, 可以直接映射所有设备寄存器到主内存
  #+end_example

节点可用于从当前设备树节点读取各种属性
#+begin_example
  例如, 函数 bcm2836_arm_irqchip_l1_intc_of_init 的第一行从 reg 读取设备基址属性

  但是, 此过程要复杂得多, 因为执行此功能时, 已启用MMU, 并且在能够访问物理内存的某个区域之前, 必须将该区域映射到某个虚拟地址
#+end_example

这正是 _of_iomap_ 函数的作用: 它 *读取* 提供的节点的 _reg_ 属性, 并将由reg属性描述的 _整个内存区域_ *映射* 到 _某个虚拟内存区域_ 

接下来调用 _bcm2835_init_local_timer_frequency_ 函数来初始化本地计时器的频率

#+begin_example
  此函数没有特别说明：它仅使用某些寄存器, 如BCM2836 ARM本地外围设备手册中所述, 以初始化本地计时器.
#+end_example

下一行需要一些解释：

#+begin_src c 
  intc.domain = irq_domain_add_linear(node, LAST_IRQ + 1,
				      &bcm2836_arm_irqchip_intc_ops,
				      NULL);
#+end_src

#+begin_example
  Linux为每个中断分配一个唯一的整数, 可以将此数字视为唯一的中断ID，每次想对中断执行操作时都会使用此ID(例如, 分配处理程序或分配哪个CPU应该处理它)

  每个中断还具有一个硬件中断号. 这通常是一个数字, 告诉触发了哪个中断线。BCM2837 ARM外设手册 的外设中断表位于第113页：以将此表中的索引视为硬件中断号

  显然 需要某种机制将Linux irq号映射到硬件irq号, 反之亦然

  如果只有一个中断控制器, 则可以使用一对一的映射, 但是通常情况下, 需要使用更复杂的机制
#+end_example

在Linux中 _struct irq_domain_ 实现了这种映射。每个中断控制器驱动程序应创建自己的irq域, 并注册该域可以处理的所有中断。注册函数返回Linux irq号, 该编号以后将用于处理中断

接下来的6行负责向irq域注册每个受支持的中断：

#+begin_src c 
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPSIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPNSIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTHPIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTVIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_GPU_FAST,
				   &bcm2836_arm_irqchip_gpu);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_PMU_FAST,
				   &bcm2836_arm_irqchip_pmu);
#+end_src

根据BCM2836 ARM本地外设 本地中断控制器处理10种不同的中断:
+ 0-3是本地计时器的中断
+ 4-7是邮箱中断, 用于进程间通信
+ 8对应于全局中断控制器生成的所有中断
+ 中断9是性能监视器中断

[[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L67][这里]] 会看到驱动程序定义了一组常量, 每个常量都包含 _硬件irq号_ 

#+begin_example
上面的注册代码注册所有中断, 但邮箱中断除外, 邮箱中断是单独注册的
#+end_example

为了更好地了解注册来看看 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L154][bcm2836_arm_irqchip_register_irq]] 函数

#+begin_src c 
  static void bcm2836_arm_irqchip_register_irq(int hwirq, struct irq_chip *chip)
  {
	  int irq = irq_create_mapping(intc.domain, hwirq);

	  irq_set_percpu_devid(irq);
	  irq_set_chip_and_handler(irq, chip, handle_percpu_devid_irq);
	  irq_set_status_flags(irq, IRQ_NOAUTOEN);
  }
#+end_src

1. 执行实际的中断注册. [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/irqdomain.c#L632][irq_create_mapping]] 将硬件中断号作为输入并返回 Linux irq号
2. [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/irqdesc.c#L849][irq_set_percpu_devid]] 将中断配置为 *当前CPU* , 因此只能在当前处理器上处理本地中断
   #+begin_example
     因为现在讨论的所有中断都是本地中断, 因此所有中断只能在当前CPU上处理
   #+end_example
3. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L608][irq_set_chip_and_handler]], 顾名思义, 设置irq芯片和irq处理程序
   + Irq芯片是一种特殊的结构, 需要由驱动程序创建, 该结构具有用于 _屏蔽_ 和 _取消屏蔽_ 特定中断的方法
     #+begin_example
       正在查看的驱动程序现在定义了3种不同的irq芯片: timer 芯片, PMU 芯片 和 GPU 芯片

       它控制由外部外围设备生成的所有中断
     #+end_example
   + 处理程序是负责处理中断的功能. 在这种情况下, 处理程序设置为通用 [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/chip.c#L859][handle_percpu_devid_irq]] 函数
     #+begin_example
	稍后, 该处理程序将由全局中断控制器驱动程序重写
     #+end_example
5. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L652][irq_set_status_flags]] 在这种特殊情况下, 设置一个标志, 指示应手动启用当前中断, 并且默认情况下不应启用 

现在回到 bcm2836_arm_irqchip_l1_intc_of_init 函数, 只剩下两个调用. 第一个是 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L243][bcm2836_arm_irqchip_smp_init]]  在此启用了邮箱中断, 从而允许处理器内核相互通信

最后一个函数调用非常重要：这是将 _低级异常处理代码_ *连接* 到 _驱动程序_ 的地方

#+begin_src c 
  set_handle_irq(bcm2836_arm_irqchip_handle_irq);
#+end_src

[[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/irq.c#L46][set_handle_irq]] 是在特定于体系结构的代码中定义的, 从上面的行中可以了解到 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L164][bcm2836_arm_irqchip_handle_irq]] 将由低级异常代码调用：

#+begin_src c 
  static void
  __exception_irq_entry bcm2836_arm_irqchip_handle_irq(struct pt_regs *regs)
  {
	  int cpu = smp_processor_id();
	  u32 stat;

	  stat = readl_relaxed(intc.base + LOCAL_IRQ_PENDING0 + 4 * cpu);
	  if (stat & BIT(LOCAL_IRQ_MAILBOX0)) {
  #ifdef CONFIG_SMP
		  void __iomem *mailbox0 = (intc.base +
					    LOCAL_MAILBOX0_CLR0 + 16 * cpu);
		  u32 mbox_val = readl(mailbox0);
		  u32 ipi = ffs(mbox_val) - 1;

		  writel(1 << ipi, mailbox0);
		  handle_IPI(ipi, regs);
  #endif
	  } else if (stat) {
		  u32 hwirq = ffs(stat) - 1;

		  handle_domain_irq(intc.domain, hwirq, regs);
	  }
  }
#+end_src

该函数读取 _LOCAL_IRQ_PENDING_ 寄存器, 以找出当前正在处理的中断

#+begin_example
  有4个 LOCAL_IRQ_PENDING 寄存器, 每个寄存器对应于其自己的处理器内核, 这就是为什么使用当前处理器索引来选择正确的寄存器的原因
#+end_example

邮箱中断和所有其他中断在if语句的2个不同子句中处理

#+begin_example
  多处理器系统的不同内核之间的交互超出了当前的讨论范围, 因此跳过邮箱中断处理部分
#+end_example

现在, 仅剩下以下两行没有解释：

#+begin_src c 
  u32 hwirq = ffs(stat) - 1;

			handle_domain_irq(intc.domain, hwirq, regs);
#+end_src

这是将中断传递给下一个处理程序的地方：
1. 首先计算硬件irq数，[[https://github.com/torvalds/linux/blob/v4.14/include/asm-generic/bitops/ffs.h#L13][ffs]] (Find first bit set) 函数用于执行此操作
2. [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/irqdesc.c#L622][handle_domain_irq]] 函数被调用：
   + 此函数使用irq域将硬件irq号码转换为Linux irq号码
   + 检查irq配置 (它存储在 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irqdesc.h#L55][irq_desc]] 结构)
   + 调用一个中断处理程序
     #+begin_example
       已经看到处理程序设置为 handle_percpu_devid_irq，但是, 此处理程序稍后将被子中断控制器覆盖。现在, 来检查一下这是如何发生的
     #+end_example

** 通用中断控制器
#+begin_example
  已经看到了如何使用设备树和compatible属性来查找与某个设备相对应的驱动程序, 因此将跳过这一部分, 直接跳转到通用中断控制器驱动程序源代码
#+end_example
可以在找到它在 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c][irq-bcm2835.c]] 文件。和往常一样, 将从初始化功能开始探索，这个函数是 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L141][armctrl_of_init]] :

#+begin_src c 
  static int __init armctrl_of_init(struct device_node *node,
				    struct device_node *parent,
				    bool is_2836)
  {
	  void __iomem *base;
	  int irq, b, i;

	  base = of_iomap(node, 0);
	  if (!base)
		  panic("%pOF: unable to map IC registers\n", node);

	  intc.domain = irq_domain_add_linear(node, MAKE_HWIRQ(NR_BANKS, 0),
					      &armctrl_ops, NULL);
	  if (!intc.domain)
		  panic("%pOF: unable to create IRQ domain\n", node);

	  for (b = 0; b < NR_BANKS; b++) {
		  intc.pending[b] = base + reg_pending[b];
		  intc.enable[b] = base + reg_enable[b];
		  intc.disable[b] = base + reg_disable[b];

		  for (i = 0; i < bank_irqs[b]; i++) {
			  irq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));
			  BUG_ON(irq <= 0);
			  irq_set_chip_and_handler(irq, &armctrl_chip,
						   handle_level_irq);
			  irq_set_probe(irq);
		  }
	  }

	  if (is_2836) {
		  int parent_irq = irq_of_parse_and_map(node, 0);

		  if (!parent_irq) {
			  panic("%pOF: unable to get parent interrupt.\n",
				node);
		  }
		  irq_set_chained_handler(parent_irq, bcm2836_chained_handle_irq);
	  } else {
		  set_handle_irq(bcm2835_handle_irq);
	  }

	  return 0;
  }
#+end_src

现在, 更详细地研究此函数：

#+begin_src c 
  void __iomem *base;
  int irq, b, i;

  base = of_iomap(node, 0);
  if (!base)
	  panic("%pOF: unable to map IC registers\n", node);

  intc.domain = irq_domain_add_linear(node, MAKE_HWIRQ(NR_BANKS, 0),
				      &armctrl_ops, NULL);
  if (!intc.domain)
	  panic("%pOF: unable to create IRQ domain\n", node);

#+end_src

此函数从读取设备基地址并初始化irq域的代码开始
#+begin_example
  应该已经熟悉此部分, 因为在本地irq控制器驱动程序中看到过类似的代码
#+end_example

#+begin_src c 
  for (b = 0; b < NR_BANKS; b++) {
	  intc.pending[b] = base + reg_pending[b];
	  intc.enable[b] = base + reg_enable[b];
	  intc.disable[b] = base + reg_disable[b];
#+end_src
接下来, 有一个循环遍历所有irq库。中断控制器具有3个irq bank, 由3个寄存器控制：
+ ENABLE_IRQS_1
+ ENABLE_IRQS_2
+ ENABLE_BASIC_IRQS

每个 Bank 都有其自己的 _启用_ ,  _禁用_ 和 _挂起_ 寄存器：
+ 启用和禁用寄存器可用于启用或禁用属于特定存储区的单个中断
+ 待处理寄存器用于确定正在等待处理的中断 

#+begin_src c 
  for (i = 0; i < bank_irqs[b]; i++) {
	  irq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));
	  BUG_ON(irq <= 0);
	  irq_set_chip_and_handler(irq, &armctrl_chip,
				   handle_level_irq);
	  irq_set_probe(irq);
  }
#+end_src
接下来, 有一个嵌套循环, 负责注册每个受支持的中断并设置irq芯片和处理程序.
+ [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L57][MAKE_HWIRQ]] 宏用于计算硬件irq号. 它是根据bank index和irq index 计算
+ [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/chip.c#L603][handle_level_irq]] 是同一级别类型的通用的中断处理程序
  #+begin_example
    此类中断将中断线设置为“高”, 直到确认该中断为止

    另外还有边缘类型中断以不同的方式工作
  #+end_example
+ [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L667][irq_set_probe]] 函数清除 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L64][IRQ_NOPROBE]] 中断标志, 有效地禁用中断自动探测
  #+begin_example
    中断自动探测是允许不同的驱动程序发现其设备连接到哪条中断线的过程

    Raspberry Pi不需要此功能, 因为此信息被编码在设备树中, 但是, 对于某些设备, 这可能很有用
  #+end_example

下一段代码对于BCM2836和BCM2835中断控制器的是不同的

#+begin_example
  BCM2836 对应于RPi模型2和3, BCM2835 对应于RPi模型1 
#+end_example

如果正在处理BCM2836, 则执行以下代码：

#+begin_src c 
  int parent_irq = irq_of_parse_and_map(node, 0);

  if (!parent_irq) {
	  panic("%pOF: unable to get parent interrupt.\n",
		node);
  }

  irq_set_chained_handler(parent_irq, bcm2836_chained_handle_irq);
#+end_src

设备树表明本地中断控制器是全局中断控制器的父级. 同时全局中断控制器已连接到本地控制器的中断线8, 这意味着父irq是硬件irq 8

#+begin_example
  这2个属性允许Linux内核找出父中断号(这是Linux中断号, 而不是硬件号)
#+end_example

最后 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L636][irq_set_chained_handler]] 函数将 父irq的处理程序替换为 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L246][bcm2836_chained_handle_irq]] 函数。而 bcm2836_chained_handle_irq 很简单：

#+begin_src c 
  static void bcm2836_chained_handle_irq(struct irq_desc *desc)
  {
	  u32 hwirq;

	  while ((hwirq = get_next_armctrl_hwirq()) != ~0)
		  generic_handle_irq(irq_linear_revmap(intc.domain, hwirq));
  }
#+end_src

1. [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L217][get_next_armctrl_hwirq]] 使用所有3个暂挂寄存器来确定触发了哪个中断
2. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irqdomain.h#L377][irq_linear_revmap]] 使用irq域将硬件irq号码转换为Linux irq号码
3. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irqdesc.h#L156][generic_handle_irq]] 执行irq处理程序
   + 在初始化中设置了Irq处理程序 它指向 [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/chip.c#L603][handle_level_irq]]
   + 最终执行与中断相关的所有irq动作 (这实际上是在 [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/handle.c#L135][这里]] 完成的
     #+begin_example
       然而, 所有支持的中断的irq操作列表为空

       对处理某些中断感兴趣的驱动程序应在列表中相应的条目中添加合适的内容

       接下来将以系统计时器为例来了解如何完成此操作
     #+end_example
  
* 计时器

