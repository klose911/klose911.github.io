#+TITLE: Linux 实现
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_UP: ./rpi-os.html
#+HTML_LINK_HOME: ./interrupt.html
#+OPTIONS: num:nil timestamp:nil ^:nil

* 底层异常处理
#+begin_example
  如何在庞大的Linux内核源代码, 找到负责中断处理的代码？

  这里提出一个想法，向量表的基地址应存储在vbar_el1 寄存器中, 因此, 如果搜索 vbar_el1, 则应该能够弄清楚向量表的初始化位置
#+end_example

搜索提供了一些这个寄存器的用法, 其中之一属于已经熟悉的 head.S 。 这段代码位于__primary_switched 函数内部，MMU 打开后执行此函数：

#+begin_src asm 
	  adr_l    x8, vectors            // load VBAR_EL1 with virtual
	  msr    vbar_el1, x8            // vector table address
#+end_src

从这段代码中, 可以推断出 _向量表_ 被称为 _vector_ , 应该能够轻松找到 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/entry.S#L367][定义]]

#+begin_src asm 
	  /*
	  ,* Exception vectors.
	  ,*/
	  .pushsection ".entry.text", "ax"

	  .align    11
	  ENTRY(vectors)
	  kernel_ventry    el1_sync_invalid        // Synchronous EL1t
	  kernel_ventry    el1_irq_invalid            // IRQ EL1t
	  kernel_ventry    el1_fiq_invalid            // FIQ EL1t
	  kernel_ventry    el1_error_invalid        // Error EL1t

	  kernel_ventry    el1_sync            // Synchronous EL1h
	  kernel_ventry    el1_irq                // IRQ EL1h
	  kernel_ventry    el1_fiq_invalid            // FIQ EL1h
	  kernel_ventry    el1_error_invalid        // Error EL1h

	  kernel_ventry    el0_sync            // Synchronous 64-bit EL0
	  kernel_ventry    el0_irq                // IRQ 64-bit EL0
	  kernel_ventry    el0_fiq_invalid            // FIQ 64-bit EL0
	  kernel_ventry    el0_error_invalid        // Error 64-bit EL0

	  #ifdef CONFIG_COMPAT
	  kernel_ventry    el0_sync_compat            // Synchronous 32-bit EL0
	  kernel_ventry    el0_irq_compat            // IRQ 32-bit EL0
	  kernel_ventry    el0_fiq_invalid_compat        // FIQ 32-bit EL0
	  kernel_ventry    el0_error_invalid_compat    // Error 32-bit EL0
	  #else
	  kernel_ventry    el0_sync_invalid        // Synchronous 32-bit EL0
	  kernel_ventry    el0_irq_invalid            // IRQ 32-bit EL0
	  kernel_ventry    el0_fiq_invalid            // FIQ 32-bit EL0
	  kernel_ventry    el0_error_invalid        // Error 32-bit EL0
	  #endif
	  END(vectors)
#+end_src

#+begin_example
  kernel_ventry宏与ventry在RPi OS中也有定义

  不过, 一个区别是 kernel_ventry 还负责检查是否发生了内核堆栈溢出

  如果设置了CONFIG_VMAP_STACK, 则启用此功能, 它是内核功能的一部分, 称为虚拟映射内核堆栈
#+end_example

** kernel_entry
kernel_entry宏 在 Linux 里要复杂得多：

#+begin_src asm 
	  .macro	kernel_entry, el, regsize = 64
	  .if	\regsize == 32
	  mov	w0, w0				// zero upper 32 bits of x0
	  .endif
	  stp	x0, x1, [sp, #16 * 0]
	  stp	x2, x3, [sp, #16 * 1]
	  stp	x4, x5, [sp, #16 * 2]
	  stp	x6, x7, [sp, #16 * 3]
	  stp	x8, x9, [sp, #16 * 4]
	  stp	x10, x11, [sp, #16 * 5]
	  stp	x12, x13, [sp, #16 * 6]
	  stp	x14, x15, [sp, #16 * 7]
	  stp	x16, x17, [sp, #16 * 8]
	  stp	x18, x19, [sp, #16 * 9]
	  stp	x20, x21, [sp, #16 * 10]
	  stp	x22, x23, [sp, #16 * 11]
	  stp	x24, x25, [sp, #16 * 12]
	  stp	x26, x27, [sp, #16 * 13]
	  stp	x28, x29, [sp, #16 * 14]

	  .if	\el == 0
	  mrs	x21, sp_el0
	  ldr_this_cpu	tsk, __entry_task, x20	// Ensure MDSCR_EL1.SS is clear,
	  ldr	x19, [tsk, #TSK_TI_FLAGS]	// since we can unmask debug
	  disable_step_tsk x19, x20		// exceptions when scheduling.

	  mov	x29, xzr			// fp pointed to user-space
	  .else
	  add	x21, sp, #S_FRAME_SIZE
	  get_thread_info tsk
	  /* Save the task's original addr_limit and set USER_DS (TASK_SIZE_64) */
	  ldr	x20, [tsk, #TSK_TI_ADDR_LIMIT]
	  str	x20, [sp, #S_ORIG_ADDR_LIMIT]
	  mov	x20, #TASK_SIZE_64
	  str	x20, [tsk, #TSK_TI_ADDR_LIMIT]
	  /* No need to reset PSTATE.UAO, hardware's already set it to 0 for us */
	  .endif /* \el == 0 */
	  mrs	x22, elr_el1
	  mrs	x23, spsr_el1
	  stp	lr, x21, [sp, #S_LR]

	  /*
	  ,* In order to be able to dump the contents of struct pt_regs at the
	  ,* time the exception was taken (in case we attempt to walk the call
	  ,* stack later), chain it together with the stack frames.
	  ,*/
	  .if \el == 0
	  stp	xzr, xzr, [sp, #S_STACKFRAME]
	  .else
	  stp	x29, x22, [sp, #S_STACKFRAME]
	  .endif
	  add	x29, sp, #S_STACKFRAME

	  #ifdef CONFIG_ARM64_SW_TTBR0_PAN
	  /*
	  ,* Set the TTBR0 PAN bit in SPSR. When the exception is taken from
	  ,* EL0, there is no need to check the state of TTBR0_EL1 since
	  ,* accesses are always enabled.
	  ,* Note that the meaning of this bit differs from the ARMv8.1 PAN
	  ,* feature as all TTBR0_EL1 accesses are disabled, not just those to
	  ,* user mappings.
	  ,*/
	  alternative_if ARM64_HAS_PAN
	  b	1f				// skip TTBR0 PAN
	  alternative_else_nop_endif

	  .if	\el != 0
	  mrs	x21, ttbr0_el1
	  tst	x21, #0xffff << 48		// Check for the reserved ASID
	  orr	x23, x23, #PSR_PAN_BIT		// Set the emulated PAN in the saved SPSR
	  b.eq	1f				// TTBR0 access already disabled
	  and	x23, x23, #~PSR_PAN_BIT		// Clear the emulated PAN in the saved SPSR
	  .endif

	  __uaccess_ttbr0_disable x21
  1:
	  #endif

	  stp	x22, x23, [sp, #S_PC]

	  /* Not in a syscall by default (el0_svc overwrites for real syscall) */
	  .if	\el == 0
	  mov	w21, #NO_SYSCALL
	  str	w21, [sp, #S_SYSCALLNO]
	  .endif

	  /*
	  ,* Set sp_el0 to current thread_info.
	  ,*/
	  .if	\el == 0
	  msr	sp_el0, tsk
	  .endif

	  /*
	  ,* Registers that may be useful after this macro is invoked:
	  ,*
	  ,* x21 - aborted SP
	  ,* x22 - aborted PC
	  ,* x23 - aborted PSTATE
	  ,*/
	  .endm
#+end_src

现在来详细研究这个宏
#+begin_src asm 
	  .macro    kernel_entry, el, regsize = 64
#+end_src

该宏接受2个参数： _el_ 和 _regsize_ :
+ el 可以是 0 或 1, 具体取决于是否在EL0或EL1上生成了异常
+ 如果来自32位EL0, 则 regsize 为32, 否则为64

#+begin_src asm 
	  .if    \regsize == 32
	  mov    w0, w0                // zero upper 32 bits of x0
	  .endif
#+end_src

在32位模式下, 使用32位通用寄存器(w0而不是x0)。w0在结构上映射到x0的下部

#+begin_example
  上面代码通过向自身写入w0来将x0寄存器的高32位清零
#+end_example

#+begin_src asm 
	  stp    x0, x1, [sp, #16 * 0]
	  stp    x2, x3, [sp, #16 * 1]
	  stp    x4, x5, [sp, #16 * 2]
	  stp    x6, x7, [sp, #16 * 3]
	  stp    x8, x9, [sp, #16 * 4]
	  stp    x10, x11, [sp, #16 * 5]
	  stp    x12, x13, [sp, #16 * 6]
	  stp    x14, x15, [sp, #16 * 7]
	  stp    x16, x17, [sp, #16 * 8]
	  stp    x18, x19, [sp, #16 * 9]
	  stp    x20, x21, [sp, #16 * 10]
	  stp    x22, x23, [sp, #16 * 11]
	  stp    x24, x25, [sp, #16 * 12]
	  stp    x26, x27, [sp, #16 * 13]
	  stp    x28, x29, [sp, #16 * 14]
#+end_src

将所有通用寄存器保存在堆栈中

#+begin_example
  请注意：在 kernel_ventry 中已经对堆栈指针进行了调整, 以适应所有需要被存储

  保存寄存器的顺序很重要, 因为在Linux中有一种特殊的结构pt_regs, 用于稍后在异常处理程序中访问保存的寄存器

  该结构不仅包含通用寄存器, 还包含其他一些信息, 这些信息大多数稍后会在kernel_entry宏中填充
#+end_example

#+begin_src asm 
	  .if    \el == 0
	  mrs    x21, sp_el0
#+end_src

_x21_ 现在包含被异常的堆栈指针

#+begin_example
  请注意, Linux中的一个进程对于用户和内核模式分别使用不同的堆栈

  在用户模式下, 可以使用 sp_el0 寄存器来计算异常产生时的堆栈指针值

  这行非常重要, 因为需要在上下文切换期间交换堆栈指针
#+end_example

#+begin_src asm 
	  ldr_this_cpu    tsk, __entry_task, x20    // Ensure MDSCR_EL1.SS is clear,
	  ldr    x19, [tsk, #TSK_TI_FLAGS]    // since we can unmask debug
	  disable_step_tsk x19, x20        // exceptions when scheduling.
#+end_src
_MDSCR_EL1.SS_ 位负责启用 *软件步骤异常* ：如果该位 _置1_ 并且调试异常未屏蔽, 则在执行任何指令后都会生成异常
#+begin_example
  这是调试器通常使用的
#+end_example

从用户模式获取异常时, 需要首先检查 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/include/asm/thread_info.h#L93][TIF_SINGLESTEP]] 标志为当前任务设置. 如果是, 则表明任务正在调试器下执行, 必须将 MDSCR_EL1.SS位清零

#+begin_example
  在Linux中, 每个进程或线程(稍后都会将它们称为“任务”)都有一个 task_struct 与其关联，该结构包含有关任务的所有元数据信息

  在arm64体系结构上task_struct中被放入另一个称为thread_info, 所以可以通过指向task_struct的指针来获取指向thread_info的指针

  thread_info 存储了很多底层值和标志位，这些会被 entry.S 所访问
#+end_example

#+begin_src asm 
	  mov    x29, xzr            // fp pointed to user-space
#+end_src

尽管 _x29_ 是通用寄存器, 但通常具有特殊含义，它用作 *frame pointer* 。编译函数时, 通常：

1. 在堆栈中存储旧的帧指针和链接寄存器值，x30被称为链接寄存器, 它包含一个由ret指令使用的“返回地址”
2. 然后分配一个新的堆栈帧, 以便它可以包含函数的所有局部变量, 并且帧指针寄存器设置为指向帧的底部

每当函数需要访问某些局部变量时, 它仅向帧指针添加硬编码的偏移量

#+begin_example
  现在想象一下发生了一个错误, 需要生成一个堆栈跟踪：

  可以使用当前帧指针在堆栈中查找所有局部变量, 并且可以使用链接寄存器来确定调用者的确切位置

  接下来, 利用以下事实：旧的帧指针和链接寄存器的值始终保存在堆栈帧的开头, 而我们可以从那里读取它们。一旦获取了调用者的帧指针之后, 现在反过来也可以访问调用者所有的局部变量

  不断递归地重复此过程, 直到到达堆栈顶部为止, 这称为“堆栈展开”。事实上 ptrace 系统调用就是使用了类似的算法
#+end_example

现在, 回到 kernel_entry 宏, 就很清楚为什么在从EL0中获取异常后需要清除x29寄存器。这是因为在Linux中, 每个任务在用户和内核模式下都使用不同的堆栈, 因此拥有通用堆栈跟踪没有任何意义

#+begin_src asm 
	  .else
	  add    x21, sp, #S_FRAME_SIZE
#+end_src

在 else子句中, 这意味着仅当处理从EL1提取的异常时, 在这种情况下, 将重用旧堆栈, 所以将 _原始sp值_ *保存* 在 _x21寄存器_ 中, 以备后用 

#+begin_src asm 
	  /* Save the task's original addr_limit and set USER_DS (TASK_SIZE_64) */
	  ldr    x20, [tsk, #TSK_TI_ADDR_LIMIT]
	  str    x20, [sp, #S_ORIG_ADDR_LIMIT]
	  mov    x20, #TASK_SIZE_64
	  str    x20, [tsk, #TSK_TI_ADDR_LIMIT]
#+end_src

任务的 _内存地址限制_ 指定了可以使用的最大虚拟内存地址：
+ 当用户进程以32位模式运行时, 此限制为 2^32
+ 对于64位内核, 它可以更大, 通常为2^48

如果碰巧从32位EL1中获取了异常, 则需要将此限制更改为 _TASK_SIZE_64_ 。此外, 还需要保存原始限制, 因为需要先还原该限制, 然后才能将执行返回到用户模式

#+begin_src asm 
	  mrs    x22, elr_el1
	  mrs    x23, spsr_el1
#+end_src

在开始处理异常之前, 必须先将 _elr_el1_ 和 _spsr_el1_ 保存在堆栈中

#+begin_example
  尚未在RPI OS中完成此操作, 因为到目前为止, 始终返回到发生异常的位置

  但是, 如果需要在处理异常时进行上下文切换, 就需要执行这些操作
#+end_example

#+begin_src asm 
	  stp    lr, x21, [sp, #S_LR]
#+end_src

把 _链接寄存器_ 和 _帧指针寄存器_ 保存在堆栈中

#+begin_example
  已经知道, 根据是从EL0还是从EL1提取异常, 帧指针的计算方式有所不同, 并且该计算的结果已存储在x21寄存器中
#+end_example

#+begin_src asm 
	  /*
	  ,* In order to be able to dump the contents of struct pt_regs at the
	  ,* time the exception was taken (in case we attempt to walk the call
	  ,* stack later), chain it together with the stack frames.
	  ,*/
	  .if \el == 0
	  stp    xzr, xzr, [sp, #S_STACKFRAME]
	  .else
	  stp    x29, x22, [sp, #S_STACKFRAME]
	  .endif
	  add    x29, sp, #S_STACKFRAME
#+end_src

这里填充了 _pt_regs_ 结构的 *stackframe 属性*

#+begin_example
  stackframe 属性还包含链接寄存器和帧指针, 尽管这里使用的是 elr_el1 的值(现在位于 x22 中) 而不是 lr

  stackframe 一般只用于 堆栈回溯 
#+end_example

#+begin_src asm 
	  #ifdef CONFIG_ARM64_SW_TTBR0_PAN
	  alternative_if ARM64_HAS_PAN
	  b    1f                // skip TTBR0 PAN
	  alternative_else_nop_endif

	  .if    \el != 0
	  mrs    x21, ttbr0_el1
	  tst    x21, #0xffff << 48        // Check for the reserved ASID
	  orr    x23, x23, #PSR_PAN_BIT        // Set the emulated PAN in the saved SPSR
	  b.eq    1f                // TTBR0 access already disabled
	  and    x23, x23, #~PSR_PAN_BIT        // Clear the emulated PAN in the saved SPSR
	  .endif

	  __uaccess_ttbr0_disable x21
  1:
	  #endif
#+end_src

_CONFIG_ARM64_SW_TTBR0_PAN_ 参数禁止内核直接访问用户空间内存

#+begin_example
  跳过对此工作原理的详细说明, 因为此类安全功能对于讨论而言已超出范围
#+end_example

#+begin_src asm 
	  stp    x22, x23, [sp, #S_PC]
#+end_src

这里, _elr_el1_ (x22) 和 _spsr_el1_ (x23) 被保存在堆栈中 

#+begin_src asm 
	  /* Not in a syscall by default (el0_svc overwrites for real syscall) */
	  .if    \el == 0
	  mov    w21, #NO_SYSCALL
	  str    w21, [sp, #S_SYSCALLNO]
	  .endif
#+end_src

pt_regs结构体有一个field, 指示当前异常是否为 _系统调用_ (syscall)

#+begin_src asm 
	  /*
	  ,* Set sp_el0 to current thread_info.
	  ,*/
	  .if    \el == 0
	  msr    sp_el0, tsk
	  .endif
#+end_src

在内核模式下执行任务时, 不需要 _sp_el0_

#+begin_example
  .其值先前已保存在堆栈中, 因此可以在kernel_exit宏中轻松恢复
#+end_example

从现在开始, sp_el0将用于持有 *指向* _当前task_struct_ 的 _指针_ 

** el1_irq 
接下来要研究的是负责处理从EL1提取的IRQ的处理程序。在向量表中, 可以轻松地发现该处理程序称为 _el1_irq_ 并在 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/entry.S#L562][此处]] 定义：

#+begin_src asm 
  el1_irq:
	  kernel_entry 1
	  enable_dbg
	  #ifdef CONFIG_TRACE_IRQFLAGS
	  bl    trace_hardirqs_off
	  #endif

	  irq_handler

	  #ifdef CONFIG_PREEMPT
	  ldr    w24, [tsk, #TSK_TI_PREEMPT]    // get preempt count
	  cbnz    w24, 1f                // preempt count != 0
	  ldr    x0, [tsk, #TSK_TI_FLAGS]    // get flags
	  tbz    x0, #TIF_NEED_RESCHED, 1f    // needs rescheduling?
	  bl    el1_preempt
  1:
	  #endif
	  #ifdef CONFIG_TRACE_IRQFLAGS
	  bl    trace_hardirqs_on
	  #endif
	  kernel_exit 1
	  ENDPROC(el1_irq)
#+end_src

在此函数内部执行以下操作：
1. 调用 _kernel_entry_ 和 _kernel_exit_ 宏来保存和恢复处理器状态：
   + 第一个参数指示异常来自EL1
2. 调用 _enable_dbg宏_ 可以 *取消屏蔽* _调试中断_
   #+begin_example
     此时, 这样做是安全的, 因为已经保存了处理器状态, 即使在中断处理程序的中间发生了调试异常, 也可以正确处理它
   #+end_example
3. _#ifdef CONFIG_TRACE_IRQFLAGS_ 块中的代码负责 *跟踪* _中断_ . 它记录2个事件：中断开始和结束
4. _#ifdef CONFIG_PREEMPT_ 中的代码 *阻止访问* _当前任务标志_ , 以检查是否需要调用调度程序
5. _irq_handler_ : 这是执行实际中断处理的地方 

irq_handler 是一个宏, 定义如下.

#+begin_src asm 
	  .macro    irq_handler
	  ldr_l    x1, handle_arch_irq
	  mov    x0, sp
	  irq_stack_entry
	  blr    x1
	  irq_stack_exit
	  .endm
#+end_src

irq_handler执行 _handle_arch_irq_ 函数，该函数通过特殊的堆栈( _irq堆栈_ )执行

#+begin_example
  为什么有必要切换到其他堆栈？ 例如, 在RPI OS中, 没有这样做

  但是如果不这么做, 将使用当前任务堆栈来处理中断, 而且永远无法确定当前任务堆栈中还有多少空间可以留给中断处理程序
#+end_example

接下来, 需要查看 handle_arch_irq。虽然他看起来像一个变量，而不是一个函数，实际上他是一个函数指针，并在 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/irq.c#L46][set_handle_irq]] 函数中设置

** 小结
#+begin_example
  至今为止已经研究了低级中断处理代码, 并从向量表一直跟踪到 handle_arch_irq ，这就是中断离开体系结构特定代码并开始由驱动程序代码处理的关键所在

  下一个目标是通过驱动程序代码来追踪计时器中断
#+end_example

* 中断控制器
#+begin_example
  接下来将大量讨论Linux驱动程序以及它们如何处理中断
#+end_example

先从驱动程序初始化代码开始, 然后看看 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/irq.c#L44][handle_arch_irq]] 函数 

** 使用设备树查找所需的设备和驱动程序
#+begin_example
  在RPi OS中实现中断时, 一直在使用2种设备：系统定时器和中断控制器

  现在, 我们的目标是了解相同设备在Linux中的工作方式

  需要做的第一件事是找到负责使用提到的设备的驱动程序
#+end_example

为了找到所需的驱动程序, 可以使用 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dots/bcm2837-rpi-3-b.dts][bcm2837-rpi-3-b.dts]] 设备树文件：这是特定于Raspberry Pi 3 Model B的顶级设备树文件, 它包含其他更常见的设备树文件, 这些文件在不同版本的Raspberry Pi之间共享. 如果遵循包含的链并搜索 timer 和 interrupt-controller , 则可以找到4个设备：
+ [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L11][本地中断控制器]]
+ [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L20][本地计时器]]
+ 全局中断控制器. 它被定义在 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L109][这里]]
+ [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L57][系统计时器]]

#+begin_example
  为什么有4个设备而不是2个？
#+end_example

** 本地与全局中断控制器
#+begin_example
  考虑多处理器系统中的中断处理时, 应该问自己几个问题：

  哪个内核应负责处理特定的中断？

  发生中断时, 是全部4个内核都中断了, 还是只有一个？

  是否可以将特定的中断路由到特定的内核？

  可能想知道的另一个问题是, 如果一个处理器需要向其传递一些信息, 该处理器如何通知另一个处理器？
#+end_example

_本地中断控制器_ 是可以帮助回答所有这些问题的设备，它负责以下任务：
+ 配置哪个内核应该接收特定的中断
+ 在内核之间发送中断. 这样的中断称为 _mailboxs_ , 并允许内核相互通信
+ 处理来自本地计时器和性能监视器中断(PMU)的中断

  #+begin_example
    BCM2836 ARM本地外围设备 手册中记录了本地中断控制器以及本地计时器的行为.

    为什么我们在系统中需要两个独立的计时器？使用本地计时器的主要用例是当要配置所有4个内核以同时接收计时器中断时。如果使用系统定时器, 则只能将中断路由到单个内核.

    使用RPi OS时, 既不使用本地中断控制器也不使用本地计时器：这是因为默认情况下, 本地中断控制器的配置方式是将所有外部中断都发送到第一个内核, 这正是我们所需要的. 所以没有使用本地计时器, 而是使用了系统计时器
  #+end_example

** 本地中断控制器
#+begin_example
根据 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L75][bcm2837.dtsi]] 全局中断控制器是本地中断控制器的子类型。 因此, 从本地控制器开始探索 
#+end_example

如果需要找到适用于特定设备的驱动程序, 则应使用 _compatible_ 属性。搜索该属性的值, 可以轻松地找到一个与RPi本地中断控制器兼容的[[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L315][驱动程序]] 

#+begin_src sh 
  IRQCHIP_DECLARE(bcm2836_arm_irqchip_l1_intc, "brcm,bcm2836-l1-intc",
		  bcm2836_arm_irqchip_l1_intc_of_init);
#+end_src

内核遍历设备树中的所有设备定义, 并且针对每个定义, 它使用 compatible 属性寻找匹配的驱动程序。如果找到驱动程序, 则调用其初始化函数。在设备注册过程中提供了初始化函数, 在本例中, 此函数是 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L280][bcm2836_arm_irqchip_l1_intc_of_init]]

#+begin_src c 
  static int __init bcm2836_arm_irqchip_l1_intc_of_init(struct device_node *node,
							struct device_node *parent)
  {
	  intc.base = of_iomap(node, 0);
	  if (!intc.base) {
		  panic("%pOF: unable to map local interrupt registers\n", node);
	  }

	  bcm2835_init_local_timer_frequency();

	  intc.domain = irq_domain_add_linear(node, LAST_IRQ + 1,
					      &bcm2836_arm_irqchip_intc_ops,
					      NULL);
	  if (!intc.domain)
		  panic("%pOF: unable to create IRQ domain\n", node);

	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPSIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPNSIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTHPIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTVIRQ,
					   &bcm2836_arm_irqchip_timer);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_GPU_FAST,
					   &bcm2836_arm_irqchip_gpu);
	  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_PMU_FAST,
					   &bcm2836_arm_irqchip_pmu);

	  bcm2836_arm_irqchip_smp_init();

	  set_handle_irq(bcm2836_arm_irqchip_handle_irq);
	  return 0;
  }
#+end_src
初始化函数采用2个参数：_node_ 和 _parent_ , 它们都是类型 _struct device_node_
+ node: 设备树中的当前节点, 在本例中, 它指向 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L11][这里]]
+ parent: 备树层次结构中的父节点, 对于本地中断控制器, 它指向 soc 元素
  #+begin_example
    soc 是最简单的总线, 可以直接映射所有设备寄存器到主内存
  #+end_example

节点可用于从当前设备树节点读取各种属性
#+begin_example
  例如, 函数 bcm2836_arm_irqchip_l1_intc_of_init 的第一行从 reg 读取设备基址属性

  但是, 此过程要复杂得多, 因为执行此功能时, 已启用MMU, 并且在能够访问物理内存的某个区域之前, 必须将该区域映射到某个虚拟地址
#+end_example

这正是 _of_iomap_ 函数的作用: 它 *读取* 提供的节点的 _reg_ 属性, 并将由reg属性描述的 _整个内存区域_ *映射* 到 _某个虚拟内存区域_ 

接下来调用 _bcm2835_init_local_timer_frequency_ 函数来初始化本地计时器的频率

#+begin_example
  此函数没有特别说明：它仅使用某些寄存器, 如BCM2836 ARM本地外围设备手册中所述, 以初始化本地计时器.
#+end_example

下一行需要一些解释：

#+begin_src c 
  intc.domain = irq_domain_add_linear(node, LAST_IRQ + 1,
				      &bcm2836_arm_irqchip_intc_ops,
				      NULL);
#+end_src

#+begin_example
  Linux为每个中断分配一个唯一的整数, 可以将此数字视为唯一的中断ID，每次想对中断执行操作时都会使用此ID(例如, 分配处理程序或分配哪个CPU应该处理它)

  每个中断还具有一个硬件中断号. 这通常是一个数字, 告诉触发了哪个中断线。BCM2837 ARM外设手册 的外设中断表位于第113页：以将此表中的索引视为硬件中断号

  显然 需要某种机制将Linux irq号映射到硬件irq号, 反之亦然

  如果只有一个中断控制器, 则可以使用一对一的映射, 但是通常情况下, 需要使用更复杂的机制
#+end_example

在Linux中 _struct irq_domain_ 实现了这种映射。每个中断控制器驱动程序应创建自己的irq域, 并注册该域可以处理的所有中断。注册函数返回Linux irq号, 该编号以后将用于处理中断

接下来的6行负责向irq域注册每个受支持的中断：

#+begin_src c 
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPSIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPNSIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTHPIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTVIRQ,
				   &bcm2836_arm_irqchip_timer);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_GPU_FAST,
				   &bcm2836_arm_irqchip_gpu);
  bcm2836_arm_irqchip_register_irq(LOCAL_IRQ_PMU_FAST,
				   &bcm2836_arm_irqchip_pmu);
#+end_src

根据BCM2836 ARM本地外设 本地中断控制器处理10种不同的中断:
+ 0-3是本地计时器的中断
+ 4-7是邮箱中断, 用于进程间通信
+ 8对应于全局中断控制器生成的所有中断
+ 中断9是性能监视器中断

[[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L67][这里]] 会看到驱动程序定义了一组常量, 每个常量都包含 _硬件irq号_ 

#+begin_example
上面的注册代码注册所有中断, 但邮箱中断除外, 邮箱中断是单独注册的
#+end_example

为了更好地了解注册来看看 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L154][bcm2836_arm_irqchip_register_irq]] 函数

#+begin_src c 
  static void bcm2836_arm_irqchip_register_irq(int hwirq, struct irq_chip *chip)
  {
	  int irq = irq_create_mapping(intc.domain, hwirq);

	  irq_set_percpu_devid(irq);
	  irq_set_chip_and_handler(irq, chip, handle_percpu_devid_irq);
	  irq_set_status_flags(irq, IRQ_NOAUTOEN);
  }
#+end_src

1. 执行实际的中断注册. [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/irqdomain.c#L632][irq_create_mapping]] 将硬件中断号作为输入并返回 Linux irq号
2. [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/irqdesc.c#L849][irq_set_percpu_devid]] 将中断配置为 *当前CPU* , 因此只能在当前处理器上处理本地中断
   #+begin_example
     因为现在讨论的所有中断都是本地中断, 因此所有中断只能在当前CPU上处理
   #+end_example
3. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L608][irq_set_chip_and_handler]], 顾名思义, 设置irq芯片和irq处理程序
   + Irq芯片是一种特殊的结构, 需要由驱动程序创建, 该结构具有用于 _屏蔽_ 和 _取消屏蔽_ 特定中断的方法
     #+begin_example
       正在查看的驱动程序现在定义了3种不同的irq芯片: timer 芯片, PMU 芯片 和 GPU 芯片

       它控制由外部外围设备生成的所有中断
     #+end_example
   + 处理程序是负责处理中断的功能. 在这种情况下, 处理程序设置为通用 [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/chip.c#L859][handle_percpu_devid_irq]] 函数
     #+begin_example
	稍后, 该处理程序将由全局中断控制器驱动程序重写
     #+end_example
5. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L652][irq_set_status_flags]] 在这种特殊情况下, 设置一个标志, 指示应手动启用当前中断, 并且默认情况下不应启用 

现在回到 bcm2836_arm_irqchip_l1_intc_of_init 函数, 只剩下两个调用. 第一个是 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L243][bcm2836_arm_irqchip_smp_init]]  在此启用了邮箱中断, 从而允许处理器内核相互通信

最后一个函数调用非常重要：这是将 _低级异常处理代码_ *连接* 到 _驱动程序_ 的地方

#+begin_src c 
  set_handle_irq(bcm2836_arm_irqchip_handle_irq);
#+end_src

[[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/irq.c#L46][set_handle_irq]] 是在特定于体系结构的代码中定义的, 从上面的行中可以了解到 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2836.c#L164][bcm2836_arm_irqchip_handle_irq]] 将由低级异常代码调用：

#+begin_src c 
  static void
  __exception_irq_entry bcm2836_arm_irqchip_handle_irq(struct pt_regs *regs)
  {
	  int cpu = smp_processor_id();
	  u32 stat;

	  stat = readl_relaxed(intc.base + LOCAL_IRQ_PENDING0 + 4 * cpu);
	  if (stat & BIT(LOCAL_IRQ_MAILBOX0)) {
  #ifdef CONFIG_SMP
		  void __iomem *mailbox0 = (intc.base +
					    LOCAL_MAILBOX0_CLR0 + 16 * cpu);
		  u32 mbox_val = readl(mailbox0);
		  u32 ipi = ffs(mbox_val) - 1;

		  writel(1 << ipi, mailbox0);
		  handle_IPI(ipi, regs);
  #endif
	  } else if (stat) {
		  u32 hwirq = ffs(stat) - 1;

		  handle_domain_irq(intc.domain, hwirq, regs);
	  }
  }
#+end_src

该函数读取 _LOCAL_IRQ_PENDING_ 寄存器, 以找出当前正在处理的中断

#+begin_example
  有4个 LOCAL_IRQ_PENDING 寄存器, 每个寄存器对应于其自己的处理器内核, 这就是为什么使用当前处理器索引来选择正确的寄存器的原因
#+end_example

邮箱中断和所有其他中断在if语句的2个不同子句中处理

#+begin_example
  多处理器系统的不同内核之间的交互超出了当前的讨论范围, 因此跳过邮箱中断处理部分
#+end_example

现在, 仅剩下以下两行没有解释：

#+begin_src c 
  u32 hwirq = ffs(stat) - 1;

			handle_domain_irq(intc.domain, hwirq, regs);
#+end_src

这是将中断传递给下一个处理程序的地方：
1. 首先计算硬件irq数，[[https://github.com/torvalds/linux/blob/v4.14/include/asm-generic/bitops/ffs.h#L13][ffs]] (Find first bit set) 函数用于执行此操作
2. [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/irqdesc.c#L622][handle_domain_irq]] 函数被调用：
   + 此函数使用irq域将硬件irq号码转换为Linux irq号码
   + 检查irq配置 (它存储在 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irqdesc.h#L55][irq_desc]] 结构)
   + 调用一个中断处理程序
     #+begin_example
       已经看到处理程序设置为 handle_percpu_devid_irq，但是, 此处理程序稍后将被子中断控制器覆盖。现在, 来检查一下这是如何发生的
     #+end_example

** 通用中断控制器
#+begin_example
  已经看到了如何使用设备树和compatible属性来查找与某个设备相对应的驱动程序, 因此将跳过这一部分, 直接跳转到通用中断控制器驱动程序源代码
#+end_example
可以在找到它在 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c][irq-bcm2835.c]] 文件。和往常一样, 将从初始化功能开始探索，这个函数是 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L141][armctrl_of_init]] :

#+begin_src c 
  static int __init armctrl_of_init(struct device_node *node,
				    struct device_node *parent,
				    bool is_2836)
  {
	  void __iomem *base;
	  int irq, b, i;

	  base = of_iomap(node, 0);
	  if (!base)
		  panic("%pOF: unable to map IC registers\n", node);

	  intc.domain = irq_domain_add_linear(node, MAKE_HWIRQ(NR_BANKS, 0),
					      &armctrl_ops, NULL);
	  if (!intc.domain)
		  panic("%pOF: unable to create IRQ domain\n", node);

	  for (b = 0; b < NR_BANKS; b++) {
		  intc.pending[b] = base + reg_pending[b];
		  intc.enable[b] = base + reg_enable[b];
		  intc.disable[b] = base + reg_disable[b];

		  for (i = 0; i < bank_irqs[b]; i++) {
			  irq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));
			  BUG_ON(irq <= 0);
			  irq_set_chip_and_handler(irq, &armctrl_chip,
						   handle_level_irq);
			  irq_set_probe(irq);
		  }
	  }

	  if (is_2836) {
		  int parent_irq = irq_of_parse_and_map(node, 0);

		  if (!parent_irq) {
			  panic("%pOF: unable to get parent interrupt.\n",
				node);
		  }
		  irq_set_chained_handler(parent_irq, bcm2836_chained_handle_irq);
	  } else {
		  set_handle_irq(bcm2835_handle_irq);
	  }

	  return 0;
  }
#+end_src

现在, 更详细地研究此函数：

#+begin_src c 
  void __iomem *base;
  int irq, b, i;

  base = of_iomap(node, 0);
  if (!base)
	  panic("%pOF: unable to map IC registers\n", node);

  intc.domain = irq_domain_add_linear(node, MAKE_HWIRQ(NR_BANKS, 0),
				      &armctrl_ops, NULL);
  if (!intc.domain)
	  panic("%pOF: unable to create IRQ domain\n", node);

#+end_src

此函数从读取设备基地址并初始化irq域的代码开始
#+begin_example
  应该已经熟悉此部分, 因为在本地irq控制器驱动程序中看到过类似的代码
#+end_example

#+begin_src c 
  for (b = 0; b < NR_BANKS; b++) {
	  intc.pending[b] = base + reg_pending[b];
	  intc.enable[b] = base + reg_enable[b];
	  intc.disable[b] = base + reg_disable[b];
#+end_src
接下来, 有一个循环遍历所有irq库。中断控制器具有3个irq bank, 由3个寄存器控制：
+ ENABLE_IRQS_1
+ ENABLE_IRQS_2
+ ENABLE_BASIC_IRQS

每个 Bank 都有其自己的 _启用_ ,  _禁用_ 和 _挂起_ 寄存器：
+ 启用和禁用寄存器可用于启用或禁用属于特定存储区的单个中断
+ 待处理寄存器用于确定正在等待处理的中断 

#+begin_src c 
  for (i = 0; i < bank_irqs[b]; i++) {
	  irq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));
	  BUG_ON(irq <= 0);
	  irq_set_chip_and_handler(irq, &armctrl_chip,
				   handle_level_irq);
	  irq_set_probe(irq);
  }
#+end_src
接下来, 有一个嵌套循环, 负责注册每个受支持的中断并设置irq芯片和处理程序.
+ [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L57][MAKE_HWIRQ]] 宏用于计算硬件irq号. 它是根据bank index和irq index 计算
+ [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/chip.c#L603][handle_level_irq]] 是同一级别类型的通用的中断处理程序
  #+begin_example
    此类中断将中断线设置为“高”, 直到确认该中断为止

    另外还有边缘类型中断以不同的方式工作
  #+end_example
+ [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L667][irq_set_probe]] 函数清除 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L64][IRQ_NOPROBE]] 中断标志, 有效地禁用中断自动探测
  #+begin_example
    中断自动探测是允许不同的驱动程序发现其设备连接到哪条中断线的过程

    Raspberry Pi不需要此功能, 因为此信息被编码在设备树中, 但是, 对于某些设备, 这可能很有用
  #+end_example

下一段代码对于BCM2836和BCM2835中断控制器的是不同的

#+begin_example
  BCM2836 对应于RPi模型2和3, BCM2835 对应于RPi模型1 
#+end_example

如果正在处理BCM2836, 则执行以下代码：

#+begin_src c 
  int parent_irq = irq_of_parse_and_map(node, 0);

  if (!parent_irq) {
	  panic("%pOF: unable to get parent interrupt.\n",
		node);
  }

  irq_set_chained_handler(parent_irq, bcm2836_chained_handle_irq);
#+end_src

设备树表明本地中断控制器是全局中断控制器的父级. 同时全局中断控制器已连接到本地控制器的中断线8, 这意味着父irq是硬件irq 8

#+begin_example
  这2个属性允许Linux内核找出父中断号(这是Linux中断号, 而不是硬件号)
#+end_example

最后 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irq.h#L636][irq_set_chained_handler]] 函数将 父irq的处理程序替换为 [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L246][bcm2836_chained_handle_irq]] 函数。而 bcm2836_chained_handle_irq 很简单：

#+begin_src c 
  static void bcm2836_chained_handle_irq(struct irq_desc *desc)
  {
	  u32 hwirq;

	  while ((hwirq = get_next_armctrl_hwirq()) != ~0)
		  generic_handle_irq(irq_linear_revmap(intc.domain, hwirq));
  }
#+end_src

1. [[https://github.com/torvalds/linux/blob/v4.14/drivers/irqchip/irq-bcm2835.c#L217][get_next_armctrl_hwirq]] 使用所有3个暂挂寄存器来确定触发了哪个中断
2. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irqdomain.h#L377][irq_linear_revmap]] 使用irq域将硬件irq号码转换为Linux irq号码
3. [[https://github.com/torvalds/linux/blob/v4.14/include/linux/irqdesc.h#L156][generic_handle_irq]] 执行irq处理程序
   + 在初始化中设置了Irq处理程序 它指向 [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/chip.c#L603][handle_level_irq]]
   + 最终执行与中断相关的所有irq动作 (这实际上是在 [[https://github.com/torvalds/linux/blob/v4.14/kernel/irq/handle.c#L135][这里]] 完成的
     #+begin_example
       然而, 所有支持的中断的irq操作列表为空

       对处理某些中断感兴趣的驱动程序应在列表中相应的条目中添加合适的内容

       接下来将以系统计时器为例来了解如何完成此操作
     #+end_example
  
* 计时器
#+begin_example
  前面已经阅读了关于全局中断控制器的代码, 这使得从计时器中断, 追踪到 bcm2836_chained_handle_irq 函数
#+end_example
下一步自然是查看计时器驱动程序如何处理此中断。但是, 在之前, 需要熟悉一些与计时器功能相关的重要概念。所有这些都在 [[https://github.com/torvalds/linux/blob/v4.14/Documentation/timers/timekeeping.txt][official kernel documentation]], 其中一些重要的概念：
1. *Clock sources* : 每次需要确切地确定现在是几点, 都在使用此框架
   #+begin_example
     通常, Clock Sources 被实现为原子 n位 计数器, 该计数器从 0 计数到 2^(n-1), 然后回绕到0并重新开始

     时钟源还提供了将计数器转换为纳秒级值的方法
   #+end_example
2. *Clock events* :引入此抽象是为了允许任何人订阅计时器中断。时钟事件框架被设计成：将下一个事件的时间作为输入, 并以此为基础计算 _计时器_ *硬件寄存器* 的 _适当值_ 
3. *sched_clock()* : 此函数返回从系统启动以来的纳秒数。通常通过直接读取定时器的寄存器来实现
   #+begin_example
     因为此函数频繁被调用, 所以必须针对性能进行优化
   #+end_example
   
#+begin_example
  接下来将了解如何使用系统定时器来实现时钟源, 时钟事件和 sched_clock 等功能
#+end_example

** BCM2835 系统计时器
#+begin_example
像往常一样, 通过在设备树中找到其位置来开始探索特定设备
#+end_example
系统计时器节点的定义在[[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L57][这里]]，接下来, 需要使用 compatible 属性来找出相应驱动程序的位置. 可以找到驱动程序在 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c][这里]]

首先来看下 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L42][bcm2835_timer]] 结构体：

#+begin_src c 
  struct bcm2835_timer {
	  void __iomem *control;
	  void __iomem *compare;
	  int match_mask;
	  struct clock_event_device evt;
	  struct irqaction act;
  };
#+end_src

该结构包含驱动程序运行所需的所有状态：
+ _control_ 和 _compare_ 字段保存相应的 *内存映射* _寄存器_ 的地址
+ _match_mask_ 用于确定将使用的 _4_ 个 _可用定时器中断_ 中的哪一个
+ _evt_  字段包含传递给时钟的结构 *事件框架*
+ _act_ 是一个irqaction(本质上是一个函数指针), 用于将当前 _驱动程序_ 与 _中断控制器_ *连接*

接下来, 将看一下 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L83][bcm2835_timer_init]], 它是驱动程序初始化函数。虽然它很长, 但并不是很难：

#+begin_src c 
  static int __init bcm2835_timer_init(struct device_node *node)
  {
	  void __iomem *base;
	  u32 freq;
	  int irq, ret;
	  struct bcm2835_timer *timer;

	  base = of_iomap(node, 0);
	  if (!base) {
		  pr_err("Can't remap registers\n");
		  return -ENXIO;
	  }

	  ret = of_property_read_u32(node, "clock-frequency", &freq);
	  if (ret) {
		  pr_err("Can't read clock-frequency\n");
		  goto err_iounmap;
	  }

	  system_clock = base + REG_COUNTER_LO;
	  sched_clock_register(bcm2835_sched_read, 32, freq);

	  clocksource_mmio_init(base + REG_COUNTER_LO, node->name,
				freq, 300, 32, clocksource_mmio_readl_up);

	  irq = irq_of_parse_and_map(node, DEFAULT_TIMER);
	  if (irq <= 0) {
		  pr_err("Can't parse IRQ\n");
		  ret = -EINVAL;
		  goto err_iounmap;
	  }

	  timer = kzalloc(sizeof(*timer), GFP_KERNEL);
	  if (!timer) {
		  ret = -ENOMEM;
		  goto err_iounmap;
	  }

	  timer->control = base + REG_CONTROL;
	  timer->compare = base + REG_COMPARE(DEFAULT_TIMER);
	  timer->match_mask = BIT(DEFAULT_TIMER);
	  timer->evt.name = node->name;
	  timer->evt.rating = 300;
	  timer->evt.features = CLOCK_EVT_FEAT_ONESHOT;
	  timer->evt.set_next_event = bcm2835_time_set_next_event;
	  timer->evt.cpumask = cpumask_of(0);
	  timer->act.name = node->name;
	  timer->act.flags = IRQF_TIMER | IRQF_SHARED;
	  timer->act.dev_id = timer;
	  timer->act.handler = bcm2835_time_interrupt;

	  ret = setup_irq(irq, &timer->act);
	  if (ret) {
		  pr_err("Can't set up timer IRQ\n");
		  goto err_iounmap;
	  }

	  clockevents_config_and_register(&timer->evt, freq, 0xf, 0xffffffff);

	  pr_info("bcm2835: system timer (irq = %d)\n", irq);

	  return 0;

  err_iounmap:
	  iounmap(base);
	  return ret;
  }
#+end_src

现在仔细检查下这个函数：

#+begin_src c 
  base = of_iomap(node, 0);
  if (!base) {
	  pr_err("Can't remap registers\n");
	  return -ENXIO;
  }
#+end_src

它从映射内存寄存器开始并获得寄存器基地址

#+begin_src c 
  ret = of_property_read_u32(node, "clock-frequency", &freq);
  if (ret) {
	  pr_err("Can't read clock-frequency\n");
	  goto err_iounmap;
  }

  system_clock = base + REG_COUNTER_LO;
  sched_clock_register(bcm2835_sched_read, 32, freq);
#+end_src

接下来, 初始化 _sched_clock_ 子系统，sched_clock每次执行时都需要计时器的计数器寄存器 :
+ [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L52][bcm2835_sched_read]] 作为第一个参数传递来协助完成此任务
+ 第二个参数：计时器的计数器的位数，用于计算计数器将回滚为0的时间
  #+begin_example
    在这里是32位
  #+end_example
+ 最后一个参数指定计时器频率: 它用于将计时器计数器的值转换为纳秒。计时器频率在设备树中的以下位置定义 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L65][这里]]


#+begin_src c 
  clocksource_mmio_init(base + REG_COUNTER_LO, node->name,
			freq, 300, 32, clocksource_mmio_readl_up);
#+end_src

下一行初始化时钟源框架。[[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/mmio.c#L52][clocksource_mmio_init]] 根据内存映射寄存器初始化一个简单的时钟源。在某些方面, 时钟源框架复制了 sched_clock 的功能, 并且需要访问相同的3个基本参数：
+ 计时器计数器寄存器的位置
+ 计数器中的有效位数
+ 计时器频率

另外3个参数包括：
+ 时钟源的名称
+ Rating：用于对时钟源设备进行rate
+ 可以读取定时器计数器寄存器的函数 

#+begin_src c 
  irq = irq_of_parse_and_map(node, DEFAULT_TIMER);
  if (irq <= 0) {
	  pr_err("Can't parse IRQ\n");
	  ret = -EINVAL;
	  goto err_iounmap;
  }
#+end_src

这段代码用于查找Linux IRQ号码：对应于计时器中断3（被硬编码成 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L108][DEFAULT_TIMER]]）
#+begin_example
  Raspberry Pi系统计时器具有4组独立的计时器寄存器, 这里使用第三个
#+end_example

如果回到设备树, 可以找到 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L60][interrupts]] 属性。此属性描述设备支持的所有中断, 以及这些中断如何映射到中断控制器线路。它是一个数组, 其中每个项代表一个中断。项目的格式特定于中断控制器

#+begin_example
  在例子中, 每个项目由2个数字组成：第一个指定一个中断 bank 号, 第二个指定一个bank内部的中断号
#+end_example

[[https://github.com/torvalds/linux/blob/v4.14/drivers/of/irq.c#L41][irq_of_parse_and_map]] 读取 interrupts 属性, 然后它使用第二个参数来查找感兴趣的中断, 并为请求的中断返回Linux irq号

#+begin_src c 
  timer = kzalloc(sizeof(*timer), GFP_KERNEL);
  if (!timer) {
	  ret = -ENOMEM;
	  goto err_iounmap;
  }
#+end_src

在这里分配了 _bcm2835_timer_ 结构的内存

#+begin_src c 
  timer->control = base + REG_CONTROL;
  timer->compare = base + REG_COMPARE(DEFAULT_TIMER);
  timer->match_mask = BIT(DEFAULT_TIMER);
#+end_src

然后, 设置 control 和 compare寄存器的地址, 并将 match_mask 设置为 BIT(DEFAULT_TIMER) 常量

#+begin_src c 
  timer->evt.name = node->name;
  timer->evt.rating = 300;
  timer->evt.features = CLOCK_EVT_FEAT_ONESHOT;
  timer->evt.set_next_event = bcm2835_time_set_next_event;
  timer->evt.cpumask = cpumask_of(0);
#+end_src

接着 [[https://github.com/torvalds/linux/blob/v4.14/include/linux/clockchips.h#L100][clock_event_device]] 属性 被初始化。这里最重要的是 _set_next_event_ , 它指向 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L57][bcm2835_time_set_next_event]] 函数

#+begin_example
时钟事件框架调用此函数来调度下一个中断
#+end_example

bcm2835_time_set_next_event 很简单：它更新比较寄存器, 以便在需要的时间间隔后安排中断

#+begin_example
这类似于在 RPi OS 的实现
#+end_example

#+begin_src c 
  timer->act.flags = IRQF_TIMER | IRQF_SHARED;
  timer->act.dev_id = timer;
  timer->act.handler = bcm2835_time_interrupt;
#+end_src

接下来, irq action 属性被初始化. 这里最重要的属性是 _handler_ , 它指向 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L67][bcm2835_time_interrupt]] 这是在触发中断后调用的函数

#+begin_example
  如果看一看, 会发现它会将所有工作重定向到由时钟事件框架注册的事件处理程序

  我们最后将会检查此事件处理程序
#+end_example

#+begin_src c 
  ret = setup_irq(irq, &timer->act);
  if (ret) {
	  pr_err("Can't set up timer IRQ\n");
	  goto err_iounmap;
  }
#+end_src

配置irq action后, 它将被添加到计时器中断的irq操作列表中

#+begin_src c 
  clockevents_config_and_register(&timer->evt, freq, 0xf, 0xffffffff);
#+end_src

最后, 调用初始化时钟事件框架 [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/clockevents.c#L504][clockevents_config_and_register]]
+ _evt 结构_ 和 _计时器频率_ 作为前两个参数传递
+ 后2个参数仅在 *单次* 计时器模式下使用, 与当前的讨论无关

#+begin_example
  现在, 已经跟踪到 bcm2835_time_interrupt 函数为止, 但是仍然没有找到完成实际工作的地方

  在下一部分中, 将更深入地研究并发现中断进入时钟事件框架后如何处理
#+end_example

** 在时钟事件框架中如何处理中断
前面已经看到处理计时器中断的实际工作已外包给 _时钟事件框架_ 。这是在 [[https://github.com/torvalds/linux/blob/v4.14/drivers/clocksource/bcm2835_timer.c#L74][bcm2835_time_interrupt]] 几行完成：

#+begin_src c 
  event_handler = ACCESS_ONCE(timer->evt.event_handler);
  if (event_handler)
	  event_handler(&timer->evt);
#+end_src

#+begin_example
  现在目标是弄清楚设置了 event_handler 以及调用后会发生什么
#+end_example

[[https://github.com/torvalds/linux/blob/v4.14/kernel/time/clockevents.c#L504][clockevents_config_and_register]] 函数是开始探索的好地方, 因为这是配置时钟事件框架的地方, 并且, 如果遵循此函数的逻辑, 最终找到如何设置 event_handler。现在, 展示函数调用链, 这些函数调用将引导至所需的位置：
1. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/clockevents.c#L504][clockevents_config_and_register]] 这是最上层初始化函数
2. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/clockevents.c#L449][clockevents_register_device]] 在此函数中, 计时器被添加到时钟事件设备的全局列表中
3. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/tick-common.c#L300][tick_check_new_device]] 此函数检查当前设备是否适合用作 *滴答* 设备
   + 如果是, 则将使用此类设备生成定期的滴答声, 内核的其余部分将使用这些滴答声来完成需要定期执行的所有工作
4. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/tick-common.c#L177][tick_setup_device]] 此功能启动设备配置
5. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/tick-common.c#L144][tick_setup_periodic]] 这是设备配置为周期性滴答的地方
6. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/tick-broadcast.c#L432][tick_set_periodic_handler]] 终于到达了分配处理程序的地方！

#+begin_example
  如果看一下调用链中的最后一个函数, 会发现Linux使用不同的处理程序, 具体取决于是否启用了广播

  Tick广播用于唤醒空闲的CPU, 这里将忽略它, 而专注于更通用的滴答处理程序
#+end_example

一般情况下紧接着 [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/tick-common.c#L99][tick_handle_periodic]] 之后 [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/tick-common.c#L79][tick_periodic]] 函数被调用，而这正是感兴趣的部分：

#+begin_src c 
  /*
   ,* Periodic tick
   ,*/
  static void tick_periodic(int cpu)
  {
	  if (tick_do_timer_cpu == cpu) {
		  write_seqlock(&jiffies_lock);

		  /* Keep track of the next tick event */
		  tick_next_period = ktime_add(tick_next_period, tick_period);

		  do_timer(1);
		  write_sequnlock(&jiffies_lock);
		  update_wall_time();
	  }

	  update_process_times(user_mode(get_irq_regs()));
	  profile_tick(CPU_PROFILING);
  }
#+end_src

此函数完成了一些重要的事情：
1. _tick_next_period_ 被用于计算并安排下一个滴答事件
2. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/timekeeping.c#L2200][do_timer]] 被调用, 负责设置 _jiffies_ ，
   #+begin_example
     jiffies是自上次系统重新启动以来的滴答声

     jiffies 在不需要纳秒精度的情况下, 可以与 sched_clock函数相同的方式使用
   #+end_example
3. [[https://github.com/torvalds/linux/blob/v4.14/kernel/time/timer.c#L1583][update_process_times]] 被调用。这里, 当前执行的进程有机会进行需要定期执行的所有工作
   #+begin_example
     例如, 运行本地进程计时器, 或者最重要的是, 将滴答事件通知调度程序
   #+end_example
   
* 结论 

#+begin_example
  虽然定时器中断的代码非常漫长, 但我们也一直从头追踪到尾

  最重要的事情之一是, 我们终于到达了调度程序的调用位置

  调度程序是任何操作系统中最关键的部分之一, 它严重依赖计时器中断。因此, 接下来就该讨论其实现了
#+end_example

| [[file:rpi-os.org][Previous：中断]] | [[file:interrupt.org][Home：中断处理]] |
