#+TITLE: Linux 实现
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_UP: ./rpi-os.html
#+HTML_LINK_HOME: ./processor.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  上次在 stext 函数哪里停止了对 Linux 内核的探索，这个函数是 arm64体系结构源码的起点

  这次，我们将更深入一点
#+end_example


可能会发现有些无聊, 因为它主要讨论了不同的ARM系统寄存器及其在Linux内核中的用法. 但是仍然它非常重要, 原因如下：
1. 有必要了解硬件提供给软件的接口
   #+begin_example
     只需了解此接口, 就可以在许多情况下解构如何实现特定的内核功能以及软件和硬件如何协作以实现此功能
   #+end_example
2. 系统寄存器中的不同选项通常与启用/禁用各种硬件功能有关
   #+begin_example
     如果了解ARM处理器使用了那些系统寄存器, 那么就已经知道它支持哪种功能
   #+end_example

好的, 现在来继续对 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S#L116][stext]] 函数的研究 
#+begin_src asm 
	  ENTRY(stext)
	  bl    preserve_boot_args
	  bl    el2_setup            // Drop to EL1, w0=cpu_boot_mode
	  adrp    x23, __PHYS_OFFSET
	  and    x23, x23, MIN_KIMG_ALIGN - 1    // KASLR offset, defaults to 0
	  bl    set_cpu_boot_mode_flag
	  bl    __create_page_tables
	  /*
	  ,* The following calls CPU setup code, see arch/arm64/mm/proc.S for
	  ,* details.
	  ,* On return, the CPU will be ready for the MMU to be turned on and
	  ,* the TCR will have been set.
	  ,*/
	  bl    __cpu_setup            // initialise processor
	  b    __primary_switch
	  ENDPROC(stext)
#+end_src
* preserve_boot_args
[[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S#L136][preserve_boot_args]] 函数负责 *保存* 由 _引导加载程序_ 传递给 _内核_ 的参数：

#+begin_src asm 
  preserve_boot_args:
	  mov    x21, x0                // x21=FDT

	  adr_l    x0, boot_args            // record the contents of
	  stp    x21, x1, [x0]            // x0 .. x3 at kernel entry
	  stp    x2, x3, [x0, #16]

	  dmb    sy                // needed before dc ivac with
	  // MMU off

	  mov    x1, #0x20            // 4 x 8 bytes
	  b    __inval_dcache_area        // tail call
	  ENDPROC(preserve_boot_args)
#+end_src

根据 [[https://github.com/torvalds/linux/blob/v4.14/Documentation/arm64/booting.txt#L150][kernel boot protocol]] 参数被通过 _x0-x3_ 寄存器传递给内核：
+ x0: 包含系统RAM中 _设备树Blob_ (.dtb)的 _物理地址_
+ x1 - x3: 保留供将来使用

该函数正在做的是将 x0-x3 寄存器的内容复制到 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/setup.c#L93][boot_args]] 数组接着 *清除* 数据缓存里的相应缓存

#+begin_example
  维护多处理器系统中的高速缓存本身就是一个大话题, 我们忽略它
#+end_example
* el2_setup
根据 [[https://github.com/torvalds/linux/blob/v4.14/Documentation/arm64/booting.txt#L159][arm64boot protocol]], 内核可以在EL1或EL2中引导. 在第二种情况下, 内核可以访问虚拟化扩展, 并且可以充当主机操作系统. 如果有幸可以在EL2中启动, [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S#L386][el2_setup]] 函数被调用. 它负责配置不同的参数(只能在EL2上访问), 并放到EL1上. 现在, 这个功能分成几个小部分, 并逐一解释：

#+begin_src asm 
	  msr    SPsel, #1            // We want to use SP_EL{1,2}
#+end_src

专用堆栈指针将同时用于EL1和EL2. 另一个选择是重用EL0的堆栈指针：

#+begin_src asm 
	  mrs    x0, CurrentEL
	  cmp    x0, #CurrentEL_EL2
	  b.eq    1f
#+end_src

只有当前EL为 EL2，并且处于标签 1 的 分支时, 否则无法继续进行 EL2 设置

#+begin_src asm 
	  mrs    x0, sctlr_el1
	  CPU_BE(    orr    x0, x0, #(3 << 24)    )    // Set the EE and E0E bits for EL1
	  CPU_LE(    bic    x0, x0, #(3 << 24)    )    // Clear the EE and E0E bits for EL1
	  msr    sctlr_el1, x0
	  mov    w0, #BOOT_CPU_MODE_EL1        // This cpu booted in EL1
	  isb
	  ret
#+end_src

如果发生这种情况, 将在 EL1执行, sctlr_el1 寄存器已更新, 以便CPU可以根据 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/Kconfig#L612][CPU_BIG_ENDIAN]] 的配置项自己选择在 little-endian 模式或 big-endian 模式下工作。然后退出 el2_setup 函数并返回 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/include/asm/virt.h#L55][BOOT_CPU_MODE_EL1]] 常量

#+begin_example
  根据 ARM64函数调用约定 返回值应放在x0寄存器中

  这里为w0. 可以将 w0 寄存器视为 x0 的前32位
#+end_example

#+begin_src asm 
  1:    mrs    x0, sctlr_el2
	  CPU_BE(    orr    x0, x0, #(1 << 25)    )    // Set the EE bit for EL2
	  CPU_LE(    bic    x0, x0, #(1 << 25)    )    // Clear the EE bit for EL2
	  msr    sctlr_el2, x0
#+end_src

如果是在EL2中启动的, 实际上也为EL2做相同的设置

#+begin_example
  请注意, 这次使用的是sctlr_el2寄存器, 而不是sctlr_el1
#+end_example

#+begin_src asm 
	  #ifdef CONFIG_ARM64_VHE
	  /*
	  ,* Check for VHE being present. For the rest of the EL2 setup,
	  ,* x2 being non-zero indicates that we do have VHE, and that the
	  ,* kernel is intended to run at EL2.
	  ,*/
	  mrs    x2, id_aa64mmfr1_el1
	  ubfx    x2, x2, #8, #4
	  #else
	  mov    x2, xzr
	  #endif
#+end_src

如果 [[https://developer.arm.com/products/architecture/a-profile/docs/100942/latest/aarch64-virtualization][虚拟主机扩展 (VHE)]] 已经通过 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/Kconfig#L926][ARM64_VHE]] 配置变量生效, 并且主机支持它们, 则将 x2 更新为非零值

#+begin_example
 x2 接下来将在同一函数中被用来检查是否启用了VHE
#+end_example

#+begin_src asm 
	  mov    x0, #HCR_RW            // 64-bit EL1
	  cbz    x2, set_hcr
	  orr    x0, x0, #HCR_TGE        // Enable Host Extensions
	  orr    x0, x0, #HCR_E2H
  set_hcr:
	  msr    hcr_el2, x0
	  isb
#+end_src

接下来设置 hcr_el2 寄存器

#+begin_example
  这和RPIOS中使用相同的寄存器为 EL1 设置 64位执行模式
#+end_example

同样, 如果 x2！= 0, 这意味着 VHE 可用并且 内核被配置为使用它, 因此 hcr_el2也被用来启用VHE

#+begin_src asm 
	  /*
	  ,* Allow Non-secure EL1 and EL0 to access physical timer and counter.
	  ,* This is not necessary for VHE, since the host kernel runs in EL2,
	  ,* and EL0 accesses are configured in the later stage of boot process.
	  ,* Note that when HCR_EL2.E2H == 1, CNTHCTL_EL2 has the same bit layout
	  ,* as CNTKCTL_EL1, and CNTKCTL_EL1 accessing instructions are redefined
	  ,* to access CNTHCTL_EL2. This allows the kernel designed to run at EL1
	  ,* to transparently mess with the EL0 bits via CNTKCTL_EL1 access in
	  ,* EL2.
	  ,*/
	  cbnz    x2, 1f
	  mrs    x0, cnthctl_el2
	  orr    x0, x0, #3            // Enable EL1 physical timers
	  msr    cnthctl_el2, x0
  1:
	  msr    cntvoff_el2, xzr        // Clear virtual offset
#+end_src

这段代码在上面的注释中得到了很好的解释

#+begin_src asm 
	  #ifdef CONFIG_ARM_GIC_V3
	  /* GICv3 system register access */
	  mrs    x0, id_aa64pfr0_el1
	  ubfx    x0, x0, #24, #4
	  cmp    x0, #1
	  b.ne    3f

	  mrs_s    x0, SYS_ICC_SRE_EL2
	  orr    x0, x0, #ICC_SRE_EL2_SRE    // Set ICC_SRE_EL2.SRE==1
	  orr    x0, x0, #ICC_SRE_EL2_ENABLE    // Set ICC_SRE_EL2.Enable==1
	  msr_s    SYS_ICC_SRE_EL2, x0
	  isb                    // Make sure SRE is now set
	  mrs_s    x0, SYS_ICC_SRE_EL2        // Read SRE back,
	  tbz    x0, #0, 3f            // and check that it sticks
	  msr_s    SYS_ICH_HCR_EL2, xzr        // Reset ICC_HCR_EL2 to defaults

  3:
	  #endif
#+end_src

这段代码只有当 GICv3可用并启用时, 才执行下一个代码段。GIC(Generic Interrupt Controller)代表 _通用中断控制器_

#+begin_example
  GIC规范的v3版本中增加了一些功能, 这些功能在虚拟化环境中特别有用

  例如, 使用GICv3, 就有可能使用 LPI(本地特定的外围设备中断)

  此类中断通过消息总线进行路由, 其配置保存在内存里的特殊表中
#+end_example

上面的代码负责启用 _SRE_ (System Register Interface 系统寄存器接口)

#+begin_example
  必须先执行此步骤, 然后才能使用 ICC_*_ELn 寄存器 并使用 GICv3 功能
#+end_example

#+begin_src asm 
	  /* Populate ID registers. */
	  mrs    x0, midr_el1
	  mrs    x1, mpidr_el1
	  msr    vpidr_el2, x0
	  msr    vmpidr_el2, x1
#+end_src

_midr_el1_ 和 _mpidr_el1_ 是 *标识寄存器组* 中的只读寄存器. 它们提供了有关 _处理器制造商_ ,  _处理器体系结构名称_ ,  _内核数量_ 以及其他一些信息的各种信息。这里, 使用从 midr_el1 和 mpidr_el1 获取的值 *填充* _vpidr_el2_ 和 _vmpidr_el2_

#+begin_example
  因此无论尝试从EL1还是更高级别的异常级别访问它, 此信息都是相同的
#+end_example

#+begin_src asm 
	  #ifdef CONFIG_COMPAT
	  msr    hstr_el2, xzr            // Disable CP15 traps to EL2
	  #endif
#+end_src

当处理器以32位模式执行时, 存在 _协处理器_ 的概念. 协处理器可用于访问通常在64位模式下通过系统寄存器访问的信息

#+begin_example
  官方文档可以了解那些内容可以被协处理器中访问
#+end_example

msr hstr_el2, xzr 指令允许从较低的异常级别时候使用协处理器

#+begin_example
  仅当启用兼容模式时才有意义

  在这种模式下, 内核可以在64位内核之上运行32位用户应用程序
#+end_example

#+begin_src asm 
	  /* EL2 debug */
	  mrs    x1, id_aa64dfr0_el1        // Check ID_AA64DFR0_EL1 PMUVer
	  sbfx    x0, x1, #8, #4
	  cmp    x0, #1
	  b.lt    4f                // Skip if no PMU present
	  mrs    x0, pmcr_el0            // Disable debug access traps
	  ubfx    x0, x0, #11, #5            // to EL2 and allow access to
  4:
	  csel    x3, xzr, x0, lt            // all PMU counters from EL1

	  /* Statistical profiling */
	  ubfx    x0, x1, #32, #4            // Check ID_AA64DFR0_EL1 PMSVer
	  cbz    x0, 6f                // Skip if SPE not present
	  cbnz    x2, 5f                // VHE?
	  mov    x1, #(MDCR_EL2_E2PB_MASK << MDCR_EL2_E2PB_SHIFT)
	  orr    x3, x3, x1            // If we don't have VHE, then
	  b    6f                // use EL1&0 translation.
  5:                        // For VHE, use EL2 translation
	  orr    x3, x3, #MDCR_EL2_TPMS        // and disable access from EL1
  6:
	  msr    mdcr_el2, x3            // Configure debug traps
#+end_src

这段代码负责配置 _mdcr_el2_ (Monitor Debug Configuration Register (EL2))，该寄存器负责设置与虚拟化扩展相关的调试陷阱门（一种中断类型）

#+begin_example
  这里不解释此代码块的详细信息, 因为调试和跟踪在讨论范围之外

  如果对细节感兴趣, 建议阅读 AArch64-Reference-Manual 第2810页 关于 mdcr_el2 寄存器的描述
#+end_example

#+begin_src asm 
	  /* Stage-2 translation */
	  msr    vttbr_el2, xzr
#+end_src

当操作系统启用 hypervisor 时, 应为其虚拟的操作系统提供完全的内存隔离。虚拟内存二次转换正是用于此目的：每个虚拟的 OS 都认为它拥有所有系统内存, 尽管实际上每个内存访问都是通过2次转换映射到物理内存的。 _vttbr_el2_ 存放2次转换后的翻译表的 *基地址* 。但当前, 虚拟内存二次转换暂时被禁用, 所以 vttbr_el2 应该设置为 0

#+begin_src asm 
	  cbz    x2, install_el2_stub

	  mov    w0, #BOOT_CPU_MODE_EL2        // This CPU booted in EL2
	  isb
	  ret
#+end_src

首先将 _x2_ 与 _0_ 进行比较, 以检查是否启用了VHE：
+ 如果是, 则跳转至 install_el2_stub 标签
+ 反之记录 处理器以 EL2 模式启动并退出 el2_setup 函数
  #+begin_example
    在后一种情况下, 处理器将继续以EL2模式运行, 并且将完全不使用EL1
  #+end_example

#+begin_src asm 
  install_el2_stub:
	  /* sctlr_el1 */
	  mov    x0, #0x0800            // Set/clear RES{1,0} bits
	  CPU_BE(    movk    x0, #0x33d0, lsl #16    )    // Set EE and E0E on BE systems
	  CPU_LE(    movk    x0, #0x30d0, lsl #16    )    // Clear EE and E0E on LE systems
	  msr    sctlr_el1, x0
#+end_src

如果代码运行达到这里, 则意味着不需要VHE, 并且将很快切换到EL1, 因此需要在此处开始进行的EL1初始化

#+begin_example
  这段代码段负责 "sctlr_el1"(系统控制寄存器)的初始化

  RPi OS 已经做了类似的工作
#+end_example

#+begin_src asm 
	  /* Coprocessor traps. */
	  mov    x0, #0x33ff
	  msr    cptr_el2, x0            // Disable copro. traps to EL2
#+end_src

该代码允许EL1访问 _cpacr_el1_ 寄存器, 从而控制对 _追踪(Trace)_ ,  _浮点_ 和 _高级SIMD_ 功能的访问

#+begin_src asm 
	  /* Hypervisor stub */
	  adr_l    x0, __hyp_stub_vectors
	  msr    vbar_el2, x0
#+end_src

#+begin_example
  尽管某些功能需要它, 但现在不打算使用EL2

  例如, 需要它来实现 kexec 系统调用, 该调用使您能够从当前运行的内核加载并引导到另一个内核
#+end_example


[[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/hyp-stub.S#L33][_hyp_stub_vectors]] 包含 _EL2_ 所有 *异常处理* 程序的地址

#+begin_example
  在详细讨论中断和异常处理之后, 将在下一章中为EL1实现异常处理功能
#+end_example

#+begin_src asm 
	  /* spsr */
	  mov    x0, #(PSR_F_BIT | PSR_I_BIT | PSR_A_BIT | PSR_D_BIT |\
	  PSR_MODE_EL1h)
	  msr    spsr_el2, x0
	  msr    elr_el2, lr
	  mov    w0, #BOOT_CPU_MODE_EL2        // This CPU booted in EL2
	  eret
#+end_src

最后, 需要在 EL1 处初始化处理器状态并切换异常级别

#+begin_example
  已经为 RPi OS 实现过类似的功能
#+end_example

唯一的新东西是如何初始化 _elr_el2_ : _lr_ *链接寄存器* 是 _x30_ 的别名。每当执行 bl(Branch Link)指令时, x30 都会自动填充当前指令的地址。这实际通常也被 ret 指令使用, 也是它能知道确切返回的位置

#+begin_example
  这里 lr 指向 https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S#L119

  通过这种方式, 来设置切换到 EL1 后要恢复执行的地方
#+end_example
* EL1 级别的处理器初始化
现在回到 stext 函数. 接下来的几行并不是很重要, 但是为了完整起见, 仍然解释一下：

#+begin_src asm 
	  adrp    x23, __PHYS_OFFSET
	  and    x23, x23, MIN_KIMG_ALIGN - 1    // KASLR offset, defaults to 0
#+end_src

KASLR (Kernel address space layout randomization), 是一种允许将内核放置在内存中随机地址处的技术

#+begin_example
  仅出于安全原因才需要这样做

  有关更多信息, 可以阅读https://lwn.net/Articles/569635/
#+end_example

#+begin_src asm 
	  bl    set_cpu_boot_mode_flag
#+end_src

将CPU引导模式保存到 [[https://github.com/torvalds/linux/blob/v4.14/arch/arm64/include/asm/virt.h#L74][__boot_cpu_mode]] 变量

#+begin_example
  执行此操作的代码与之前探讨的 preserve_boot_args 函数非常相似
#+end_example

#+begin_src asm 
	  bl    __create_page_tables
	  bl    __cpu_setup            // initialise processor
	  b    __primary_switch
#+end_src

最后3个功能非常重要, 但是它们都与 _虚拟内存管理_ 有关。现在只想简短地描述一下其中的含义：
+ *__create_page_tables*: 顾名思义, 它负责 *创建* _页表_
+ *__cpu_setup*:  初始化各种处理器设置, 主要针对 _虚拟内存_ *管理* 
+ *__primary_switch*: 启用 _MMU_ 并 *跳* 至 [[https://github.com/torvalds/linux/blob/v4.14/init/main.c#L509][start_kernel]] 函数
  #+begin_example
    这是与体系结构无关的起点
  #+end_example
* 结论

#+begin_example
  在本章中, 简要讨论了引导Linux内核时如何初始化处理器

  在下一章中, 将继续与ARM处理器紧密合作, 并研究任何OS的重要主题：中断处理
#+end_example

| [[file:rpi-os.org][Previous: 处理器初始化]] |  [[file:processor.org][Home: 处理器]] |
