#+TITLE: E1000网卡
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil
*  网卡架构概述
** 介绍
#+begin_example
  这一章将介绍PCI/PCI-X系列网卡（以下简称网卡）。接下来将介绍网卡功能、寄存器描述和初始化顺序、以及网卡的主要接口
#+end_example

设计准则如下：
1. 提供一个以太网接口，支持 _10/100/1000 Mb/s_ 物理层接口，同时也支持 _1000 Base-X_ 
2. 基于以下准则，提供高性能解决方案：
   + 提供对所有内存的直接访问，不使用映射寄存器
     #+begin_example
       映射寄存器：假设有一个网络接口卡（NIC），需要从内存中读取数据包以进行处理

       如果使用映射寄存器，首先需要将数据包的内存地址写入映射寄存器，然后处理器会根据映射寄存器中的值来读取实际的数据

       这个过程可能会减慢数据传输速度，因为每次访问都需要经过映射寄存器。

       如果是直接访问内存，NIC可以直接读取或写入内存。无需通过映射寄存器

       数据传输更加高效，因为减少了硬件层面的操作，从而降低了延迟并提高了整体性能

       这对于高速网络通信尤其重要，因为网络通信需要快速处理大量数据
     #+end_example
   + 尽量减少管理网卡所需的PCI 访问次数
     #+begin_example
       举例来说，假设需要发送一封电子邮件

       在这个过程中，CPU需要多次通过PCI接口与网卡通信：处理数据包的组装、发送以及状态的监控

       如果网卡设计得不够高效，会导致大量的PCI访问，从而增加系统的处理时间和延迟
     #+end_example
   + 尽量减少管理网卡所需的中断
   + 在网卡中直接完成简单任务（如TCP校验和计算），减轻CPU负担
   + 最大化PCI的效率和性能
   + 使用混合信号处理来确保物理层特性超过UTP铜介质的规格要求
3. 为基本操作提供简单的软件接口
4. 提供高度可配置的设计，可在不同环境中有效使用

PCI/PCI-X系列的网卡架构是82542和82543设计的衍生品。继承了前代产品的 *MAC* _媒体访问控制_ 功能和集成的 *铜质PHY* _物理层_ ，并为MAC1增加了基于_SMBus_ 的 *可管理性* 和 集成的 *ASF*  _自适应速度和双工_ 控制器功能。此外，82546GB/EB在一个集成的双端口解决方案中采用了这种架构，该解决方案由两个独立的MAC/PHY实例组成

#+ATTR_HTML: image :width 70% 
[[file:pic/image-20240319131216988.png]] 

** 微架构
与前代相比，PCI/PCI-X系列网卡的MAC增加了改进的 *数据包过滤* 功能，以支持基于SMBus的 *可管理性* ，以及传输基于SMBus的可管理性数据包的能力。此外，控制器的MAC集成了一个符合ASF标准的 *TCO* _透明冷却覆盖_ 控制器，用于降低成本的基本ASF可管理性

#+begin_example
注：82544GC/EI和82541ER不支持基于SMBus的可管理性
#+end_example
对于82546GB/EB，这些新功能被打包在一个集成的双端口组合中。该架构包括 *两个* _MAC和PHY_ 的实例以及一个*单一* 的 _PCI/PCI-X_ 接口。因此，每个逻辑局域网设备都表现为一个 *独立* 的 _PCI/PCI-X_ 总线设备

#+begin_example
接下来几节将描述硬件构成。图2-4展示内部微架构
#+end_example

#+ATTR_HTML: image :width 90% 
[[file:pic/image-20240319131713720.png]] 

*** PCI/PCI-X 核心接口
PCI/PCI-X核心提供了与 _33/66 MHz_ 、32/64位PCI总线或33/66/133 MHz、32/64位PCI-X总线完全无缝连接的接口。网卡提供了32或64位的寻址和数据，以及完整的控制接口，以便在32或64位的PCI或PCI-X总线上运行。在为网卡提供专用总线的系统中，这提供了足够的带宽来支持持续的1000 Mb/s全双工传输速率。在共享总线的系统中（特别是32位宽的接口），可能无法维持1000 Mb/s的速度，但可以维持数百兆每秒的传输速率 
+ 当网卡作为 _PCI目标设备_ 时，它 *遵循* _PCI配置规范_ ，允许在PCI系统 _初始化_ 时，所有对其的访问 *自动映射* 到 _空闲的内存和I/O空间_ 中
+ 在处理 _发送_ 和 _接收_ 的数据帧时，网卡在PCI总线上充当 _主设备_ 。作为主设备，PCI总线上的事务突发长度由多个因素决定
  + PCI延迟计时器的到期
  + 正在进行的总线传输类型
  + 数据传输的大小
  + 数据传输是由接收逻辑还是发送逻辑发起的

PCI/PCI-X总线与DMA引擎相连
*** DMA引擎和数据FIFO
_DMA引擎_ 负责处理 _主机内存_ 与 _片上内存_ 之间的 *接收* 和 *发送* _数据_ 以及 _描述符_ 的 *传输* 
+ 接收路径：DMA引擎将存储在 _接收数据FIFO缓冲区_ 中的数据 *传输* 到 _主机内存中的接收缓冲区_ ，具体位置由 _描述符中的地址指定_ 。同时，它还会 *获取* 并 *回写* _更新后的接收描述符_ 到 _主机内存_ 
+ 发送路径：DMA引擎将存储在 _主机内存缓冲区中的数据_ 传输到 _发送数据FIFO缓冲区_ 。它也会 *获取* 并 *回写* _更新后的发送描述符_ 

网卡有一个 *片上缓冲区* ，大小为 _64KB_ 。接收和发送缓冲区的大小可根据系统需求进行分配
#+begin_example
这个缓冲区为网卡接收或传输数据帧提供了一个临时的缓冲存储区域
#+end_example

DMA引擎和缓冲区经过优化，以最大化PCI总线的效率并减少处理器的使用，具体方法包括：
+ 在传输前 *缓冲* _整个待发送的数据包_ ，减轻瞬时接收带宽需求和消除发送欠流
+ 在 _发送缓冲区_ 中 *排队* _发送帧_ ，允许 *连续* 传输，最小化帧间间隔
+ 允许网卡 *承受* _长时间的PCI总线延迟_ ，而不会丢失接收数据或损坏发送数据
+ 允许 *调整* _发送缓冲区大小_ 。对系统性能的调整基于可用的PCI带宽、线速和延迟考虑
+ 在网卡上完成接收和发送的IP及TCP/UDP校验和计算
+ *直接* 从发送缓冲区重传失败的传输（碰撞检测、数据欠流），无需重新从主机内存访问这些数据。

*** 10/100/1000 Mb/s 接收和发送MAC模块
控制器的 _CSMA/CD单元_ 在*DMA* 和 *TBI/内部SerDes/MII/GMII接口* 模块之间处理所有IEEE 802.3 *接收* 和 *发送* _MAC功能_ 
#+begin_example
CSMA/CD单元支持10 Mb/s的IEEE 802.3、100 Mb/s的IEEE 802.3u以及1000 Mb/s的IEEE 802.3z和IEEE 802.3ab
#+end_example

以太网控制器支持 *半双工* 10/100 Mb/s _MII_ 或 _1000 Mb/s_ GMII模式，并在全双工操作中全面支持上述规范的所有方面。在半双工模式下，以太网控制器支持按照IEEE 802.3z规范规定的操作。在接收路径中，以太网控制器支持扩展的载波包和在包突发操作期间生成的包。在发送路径中，82554GC/EI还支持载波扩展的包，并且可以配置为以包突发模式发送。

以太网控制器提供各种过滤功能，以提供更好的性能和降低处理器利用率，具体如下：
+ 提供多达16个地址用于精确匹配单播/多播地址过滤
+ 提供基于4096位向量的多播地址过滤。同时支持混杂单播和混杂多播过滤
+ 以太网控制器剥离IEEE802.1q VLAN标签，并根据其VLAN ID过滤数据包。支持多达4096个VLAN标签
+ 在发送路径中，以太网控制器支持逐包插入VLAN标签信息

以太网控制器实现了IEEE 802.3x定义的流量控制功能，以及IEEE 802.3z定义的不对称流量控制的具体操作。以太网控制器还提供外部引脚，用于通过外部逻辑控制流量控制功能
*** MII/GMII/TBI/Internal SerDes接口模块
网卡提供以下串行接口：
+ AGMII/MII接口用于内部PHY
+ 内部SerDes接口（82546GB/EB和82545GM/EM）/ TenBit接口（TBI）用于82544GC/EI：
  + 网卡实现了802.3z PCS功能、自动协商功能和10位数据路径接口（TBI），用于接收和发送操作
  + 它用于1000BASE-SX、-LX和-CX配置，仅以1000 Mb/s全双工工作
  + 芯片上的PCS电路仅在链路接口配置为TBI模式时使用，并且在内部PHY模式下被绕过

#+begin_example
注意： 请参考扩展设备控制寄存器（位23:22）进行模式选择（请参阅第13.4.6节）
#+end_example
*** PHY接口
链路可以通过多种方法进行配置。软件可以通过将MAC设置为TBI模式（82546GB/EB和82545GM/EM的内部SerDes），或将PHY设置为内部PHY模式来强制链路设置为自动协商

内部PHY模式下的链路速度可以通过多种方法确定：
+ 基于PHY生成的接收时钟信号进行自动速度检测
+ 检测PHY链路速度指示
+ 软件强制配置链路速度
*** EEPROM接口
PCI/PCI-X系列网卡提供了一个与串行EEPROM设备（如93C46或兼容设备）直接连接的四线接口，用于存储产品配置信息。在复位后，网卡会自动访问EEPROM中的几个字，以在主机软件可以访问之前向网卡提供预启动配置数据。存储的其余信息由各种软件模块访问，用于报告产品配置、序列号和其他参数
*** 闪存存储器接口
网卡提供了一个外部并行接口，用于连接闪存设备。对闪存的访问由网卡控制，并可像对FLASH内存映射区域进行普通PCI读取或写入那样被软件访问。网卡支持最大容量为512 KB的闪存设备

82540EP/EM提供了一个外部接口，用于连接串行闪存或引导EEPROM设备
** DMA地址
在适当的系统中，网卡管理的地址都是 _64位的_ ，以支持拥有大于32位物理寻址的系统。提供64位地址消除了对特殊段寄存器的需求。
#+begin_example
  注：PCI 2.2或2.3规范要求，任何高32位全为0b的64位地址都应该表现为32位地址周期。以太网控制器符合PCI 2.2或2.3规范
#+end_example

PCI是 _little endian_ 的；然而，并非所有使用PCI的系统中的处理器都将内存视为 little endian。网络数据本质上是 *字节流* 。因此， _处理器_ 和以太网控制器就内存数据的表示达成一致非常重要。默认情况下是little endia模式

以下示例说明了 little endia 中的数据字节顺序。接收数据包的字节按 *从左到右* 的顺序到达
#+begin_src sh 
  01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e
#+end_src

数据包缓冲区地址没有对齐限制。主要字的字节地址如左侧所示。PCI总线的字节号和位号如顶部所示
#+ATTR_HTML: image :width 70% 
[[file:pic/image-20240319132832019.png]] 

#+begin_example
描述符访问不会字节交换
#+end_example
** 以太网寻址
网卡中的几个寄存器存储了 _以太网地址_ 。地址由 _两个32位_ 寄存器组成：一个称为“高”（high），另一个称为“低”（low）
#+begin_example
  例如，接收地址寄存器由接收地址高（RAH）和接收地址低（RAL）组成
#+end_example

存储在寄存器中的地址的 _最低有效字节_ 的 _最低有效位_ （例如RAL的位0）是 *多播位* ，LS _最低有效字节_ 是第一个出现在线上的字节。这种表示适用于所有地址寄存器，包括流量控制寄存器

#+ATTR_HTML: image :width 70% 
[[file:pic/image-20240319132858589.png]] 

图2-5展示了线上的位/字节地址顺序与唯一接收地址寄存器中的值之间的比较
** 中断
以太网控制器提供了一整套中断，允许进行高效的软件管理。中断结构的设计旨在实现以下目标：
+ 通过使用 _设置_ 和 _读后清除_ 操作而不是“读-修改-写”操作，使访问 *线程安全* 
+ *最小化* 完成工作所需的 _中断数量_
+ *最小化* 与每个中断相关的 _处理开销_ 

英特尔通过由 _四个中断寄存器_ 组成的中断逻辑实现了第一个目标。关于这些寄存器的更多细节在第13.4.17节到13.4.21节中有详细说明
+ 中断原因 *Read寄存器* 和 *Set寄存器*
  + Read寄存器记录中断的原因。在 _读取_ 时会被 *自动清除* 
  + 对于在Set寄存器中写入为 _1b_ 的每个位，会 *设置* _原因位_ ，如果硬件设置原因位和软件清除中断之间存在竞争，该位将保持设置
    #+begin_example
      在写入Set寄存器时不存在竞争条件，Set操作允许软件发布中断。Read操作自动清除，以避免昂贵的写操作

      大多数系统都有写缓冲，这最小化了开销，但通常需要一个读操作来保证写操作已经从发布的缓冲区中刷新

      如果没有自动清除，清除中断的成本可能高达两次读取和一次写入
    #+end_example
+ 中断屏蔽 *设置* （读）和 *清除* 寄存器
  + 只有在中断原因位为1b，且相应的中断屏蔽位也为1b时，中断才会出现在PCI上
  + 软件可以通过清除屏蔽寄存器中的位来阻止中断线的断言
    #+begin_example
      无论屏蔽位的状态如何，原因位都会存储中断事件

      清除和设置操作通过避免在屏蔽寄存器上执行“读-修改-写”操作，使这个寄存器更加“线程安全”
    #+end_example
  + 对于在设置寄存器中写入的每个位，屏蔽位被设置为1b，并在清除寄存器中写入的每个位被清除。读取设置寄存器将返回当前值

英特尔通过三个行动实现了第二个目标（最小化中断）：
+ 减少所有中断的频率（见第13.4.17节）。不适用于82544GC/EI
+ 在信号中断之前接受多个接收数据包（见第3.2.3节）
+ 消除（或至少减少）发送时对中断的需求（见第3.2.7节）

第三个目标是通过有一个中断寄存器合并所有中断信息来实现的。这消除了多次访问的需求
** 硬件加速能力
网卡提供了在传输时卸载IP、TCP和UDP校验和的功能。这些功能可以显著 *减少* _处理器的利用率_ ，通过将这些功能的负担从驱动程序转移到硬件来实现

#+begin_example
校验和卸载功能在以下章节中简要概述。关于所有硬件加速功能的更多详细信息，请参阅第3.2.9节
#+end_example
*** 校验和卸载
网卡提供了从软件设备驱动程序中 *卸载* _IP_ _TCP_ 和 _UDP_ 校验和要求的能力。对于常见的帧类型，硬件会自动计算、插入和检查通常由软件处理的适当的校验和值
+ 对于传输，在网卡可能会为每个以太网数据包计算并插入两个校验和
  #+begin_example
    通常情况下，这些将是IP校验和，以及TCP或UDP校验和
  #+end_example
  + 软件设备驱动程序指定了哪些部分的数据包包含在校验和计算中，并通过描述符指定了计算出的值的插入位置
    #+begin_example
      详情请参阅第3.3.5节
    #+end_example
+ 对于接收，在硬件识别数据包类型并自动执行校验和计算和错误检查
  + 校验和和错误信息通过接收描述符提供给软件
    #+begin_example
      详情请参阅第3.2.9节
    #+end_example
*** TCP分段
网卡实现了一个 _TCP分段_ 功能，用于传输，允许软件设备驱动程序将数据包分段和封装卸载到硬件。软件设备驱动程序可以将整个由网络操作系统 _NOS_ 发送的IP、TCP或UDP消息发送给网卡进行传输。网卡将数据包分段成合法的以太网帧并将它们传输到电缆上。通过处理分段任务，硬件 *减轻* 了软件处理某些帧处理责任的负担。这减少了CPU在传输过程中的开销，从而降低了整体CPU利用率
#+begin_example
详情请参见第3.5节
#+end_example

** 缓冲区和描述符结构
软件 *分配* _传输_ 和 _接收_ *缓冲区*，并形成 *包含* _指向_ 这些缓冲区以及其状态的 *描述符*

#+begin_example
  在缓冲区和描述符的硬件与驱动程序软件之间存在一个概念上的所有权边界

  软件将 接收缓冲区的所有权交给硬件，这些接收缓冲区存储着软件一旦收到有效数据包后所拥有的数据
#+end_example

对于传输，软件 *维护* 一个缓冲区队列。驱动程序软件拥有一个缓冲区，直到 _准备好进行传输_ 。然后，软件将缓冲区 *提交* 给硬件；硬件随后拥有该缓冲区，直到 _数据被加载_ 或 _传输到传输FIFO_ 中

描述符存储有关缓冲区的以下信息：
+ 物理地址
+ 长度
+ 关于引用缓冲区的状态和命令信息

描述符包含一个指示数据包的最后一个缓冲区的 _结束字段_ 。描述符还包含指示 _数据包类型_ 的特定于数据包的信息，以及在 _传输数据包的上下文_ 中执行的特定操作
#+begin_example
例如用于VLAN或校验和卸载的操作
#+end_example

* 发送和接收
#+ATTR_HTML: image :width 70% 
[[file:pic/]] 
