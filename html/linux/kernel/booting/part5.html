<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>解压内核</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./part4.html"> UP </a>
 |
 <a accesskey="H" href="./booting.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">解压内核</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf427a59">内核解压前的准备</a></li>
<li><a href="#orga6a0ed1">内核解压</a>
<ul>
<li><a href="#org8fcbabe">调用 extract_kernel</a></li>
<li><a href="#org11c02bb">extract_kernel</a></li>
<li><a href="#org47e7cf4">进入内核</a></li>
</ul>
</li>
<li><a href="#orgc4b47a8">内核地址随机化</a>
<ul>
<li><a href="#org8ec83bd">建立新的恒等映射内存页表</a></li>
<li><a href="#orgeff92d7">避开保留的内存范围</a></li>
<li><a href="#org7c18643">物理地址随机化</a></li>
<li><a href="#orgb774345">虚拟地址随机化</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example" id="org0dea5ee">
在这一部分回看到跳进内核代码的最后步骤：内核解压前的准备、重定位和直接内核解压
</pre>
<div id="outline-container-orgf427a59" class="outline-2">
<h2 id="orgf427a59">内核解压前的准备</h2>
<div class="outline-text-2" id="text-orgf427a59">
<p>
在之前的部分，已经在startup_32里面看到了到startup_64的跳转：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">pushl</span>   <span style="color: #00ffff;">$</span>__KERNEL_CS
<span style="color: #87cefa;">leal</span>    <span style="color: #00ffff;">startup</span>_64(<span style="color: #eedd82;">%ebp</span>), <span style="color: #eedd82;">%eax</span>
...
...
...
<span style="color: #87cefa;">pushl</span>   <span style="color: #00ffff;">%eax</span>
...
...
...
<span style="color: #87cefa;">lret</span>
</pre>
</div>

<p>
由于加载了新的全局描述符表并且在其他模式有CPU的模式转换（在这里是64位模式），可以在startup_64的开头看到数据段的建立：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ffff;">.code64</span>
<span style="color: #00ffff;">.org</span> 0x200
<span style="color: #87cefa;">ENTRY</span>(startup_64)
<span style="color: #87cefa;">xorl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%eax</span>
<span style="color: #87cefa;">movl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%ds</span>
<span style="color: #87cefa;">movl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%es</span>
<span style="color: #87cefa;">movl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%ss</span>
<span style="color: #87cefa;">movl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%fs</span>
<span style="color: #87cefa;">movl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%gs</span>
</pre>
</div>

<pre class="example" id="org92580de">
除cs之外的段寄存器，在进入长模式时已经重置
</pre>

<p>
计算 <span class="underline">内核编译时的位置</span> 和它 <span class="underline">被加载的位置</span> 的 <b>差</b> ：
</p>

<div class="org-src-container">
<pre class="src src-asm">        #ifdef CONFIG_RELOCATABLE
        <span style="color: #00ffff;">leaq</span>    startup_32(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rbp</span>
        <span style="color: #00ffff;">movl</span>    BP_kernel_alignment(<span style="color: #eedd82;">%rsi</span>), <span style="color: #eedd82;">%eax</span>
        <span style="color: #00ffff;">decl</span>    <span style="color: #eedd82;">%eax</span>
        <span style="color: #00ffff;">addq</span>    <span style="color: #eedd82;">%rax</span>, <span style="color: #eedd82;">%rbp</span>
        <span style="color: #00ffff;">notq</span>    <span style="color: #eedd82;">%rax</span>
        <span style="color: #00ffff;">andq</span>    <span style="color: #eedd82;">%rax</span>, <span style="color: #eedd82;">%rbp</span>
        <span style="color: #00ffff;">cmpq</span>    $LOAD_PHYSICAL_ADDR, <span style="color: #eedd82;">%rbp</span>
        <span style="color: #00ffff;">jge</span>     1f
        #endif
        <span style="color: #00ffff;">movq</span>    $LOAD_PHYSICAL_ADDR, <span style="color: #eedd82;">%rbp</span>
<span style="color: #87cefa;">1</span>:
        <span style="color: #00ffff;">movl</span>    BP_init_size(<span style="color: #eedd82;">%rsi</span>), <span style="color: #eedd82;">%ebx</span>
        <span style="color: #00ffff;">subl</span>    $_end, <span style="color: #eedd82;">%ebx</span>
        <span style="color: #00ffff;">addq</span>    <span style="color: #eedd82;">%rbp</span>, <span style="color: #eedd82;">%rbx</span>
</pre>
</div>

<p>
<span class="underline">rbp</span> 包含了解压后 <span class="underline">内核的起始地址</span> ，在这段代码执行之后 <span class="underline">rbx</span> 会包含用于解压的重定位内核代码的地址
</p>

<pre class="example" id="orgf9186c7">
前面已经在startup_32看到类似的代码（计算重定位地址），但是需要再做这个计算

因为引导加载器可以用64位引导协议，而startup_32在这种情况下不会执行
</pre>

<p>
接下来是 <span class="underline">栈指针</span> 的设置和 <span class="underline">标志寄存器</span> 的重置：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">leaq</span>    <span style="color: #00ffff;">boot</span>_stack_end(<span style="color: #eedd82;">%rbx</span>), <span style="color: #eedd82;">%rsp</span>

<span style="color: #87cefa;">pushq</span>   <span style="color: #00ffff;">$0</span>
<span style="color: #87cefa;">popfq</span>
</pre>
</div>

<p>
rbx寄存器包含了内核解压代码的起始地址，把这个地址的 <b>boot_stack_entry</b> 偏移地址相加放到表示栈顶指针的 <span class="underline">rsp寄存器</span> 。在这一步之后，栈就是正确的。可以在汇编源码文件 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/head_64.S">head_64.S</a>  的末尾找到 boot_stack_end 的定义：
</p>

<div class="org-src-container">
<pre class="src src-asm">        <span style="color: #00ffff;">.bss</span>
        <span style="color: #00ffff;">.balign</span> 4
<span style="color: #87cefa;">boot_heap</span>:
        <span style="color: #00ffff;">.fill</span> BOOT_HEAP_SIZE, 1, 0
<span style="color: #87cefa;">boot_stack</span>:
        <span style="color: #00ffff;">.fill</span> BOOT_STACK_SIZE, 1, 0
<span style="color: #87cefa;">boot_stack_end</span>:
</pre>
</div>

<pre class="example" id="org2722b5e">
它在.bss节的末尾，就在.pgtable前面

如果查看 arch/x86/boot/compressed/vmlinux.lds.S 链接脚本，会找到.bss和.pgtable的定义
</pre>

<p>
由于设置了栈，在计算了解压了的内核的重定位地址后，就可以复制压缩了的内核到以上地址。在查看细节之前，先看这段汇编代码：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">pushq</span>   <span style="color: #00ffff;">%rsi</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20026;&#36825;&#20010;&#23492;&#23384;&#22120;&#29616;&#22312;&#23384;&#25918;&#25351;&#21521;boot_params&#30340;&#25351;&#38024;</span>
<span style="color: #87cefa;">leaq</span>    (_bss-8)(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rsi</span> <span style="color: #ff4500;">//  </span><span style="color: #ff4500;">rsi&#21253;&#21547;_bss - 8&#30340;&#32477;&#23545;&#22320;&#22336;</span>
<span style="color: #87cefa;">leaq</span>    (_bss-8)(<span style="color: #eedd82;">%rbx</span>), <span style="color: #eedd82;">%rdi</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">rdi&#21253;&#21547;_bss - 8&#30340;&#37325;&#23450;&#20301;&#30340;&#30456;&#23545;&#22320;&#22336;</span>
<span style="color: #87cefa;">movq</span>    <span style="color: #00ffff;">$</span>_bss, <span style="color: #eedd82;">%rcx</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25335;&#36125;&#30340;&#22823;&#23567;&#25918;&#20837;rcx </span>
<span style="color: #87cefa;">shrq</span>    <span style="color: #00ffff;">$3</span>, <span style="color: #eedd82;">%rcx</span> <span style="color: #ff4500;">// </span>
<span style="color: #87cefa;">std</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35774;&#32622;&#20174;&#21518;&#21521;&#21069;&#25335;&#36125;&#25968;&#25454;</span>
<span style="color: #87cefa;">rep</span>     <span style="color: #00ffff;">movsq</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24320;&#22987;copy</span>
<span style="color: #87cefa;">cld</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#28165;&#31354;DF&#26631;&#24535;&#20301;</span>
<span style="color: #87cefa;">popq</span>    <span style="color: #00ffff;">%rsi</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22312;&#20195;&#30721;&#30340;&#32467;&#23614;&#65292;&#20250;&#37325;&#26032;&#24674;&#22797;&#25351;&#21521;boot_params&#30340;&#25351;&#38024;&#21040;rsi</span>
</pre>
</div>

<ol class="org-ol">
<li>把rsi压进栈，因为这个寄存器现在存放指向boot_params的指针，这是包含引导相关数据的实模式结构体。在代码的结尾，会重新恢复指向boot_params的指针到rsi</li>
<li><p>
两个leaq指令用 <span class="underline">_bss - 8偏移</span> 和 <span class="underline">rip</span> 和 <span class="underline">rbx</span> 计算有效地址并存放到 <span class="underline">rsi</span> 和 _rdi_。压缩了的代码镜像存放在从startup_32到当前的代码和解压了的代码之间。可以通过查看链接脚本 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/vmlinux.lds.S">arch/x86/boot/compressed/vmlinux.lds.S</a> 验证：
</p>
<div class="org-src-container">
<pre class="src src-sh">. = 0;
.head.text : {
    <span style="color: #eedd82;">_head</span> = . ;
    HEAD_TEXT
    <span style="color: #eedd82;">_ehead</span> = . ;
}
.rodata..compressed : {
    *(.rodata..compressed)
}
.text : {
    <span style="color: #eedd82;">_text</span> = .;  /* Text */
    *(.text)
    *(.text.*)
    <span style="color: #eedd82;">_etext</span> = . ;
}
</pre>
</div>
<ul class="org-ul">
<li><p>
<span class="underline">.head.text</span> 节包含了 <span class="underline">startup_32</span> . 可以从之前的部分回忆起它：
</p>
<div class="org-src-container">
<pre class="src src-sh">__HEAD
.code32
<span style="color: #87cefa;">ENTRY</span>(startup_32)
...
...
...
</pre>
</div></li>
<li><p>
<span class="underline">.text</span> 节包含 <b>解压代码</b> ：
</p>
<div class="org-src-container">
<pre class="src src-sh">.text
relocated:
...
...
...
/*
* Do the decompression, and jump to the new kernel..
*/
...
</pre>
</div></li>
<li><span class="underline">.rodata..compressed</span> 包含了 <b>压缩了的内核镜像</b></li>
</ul></li>
<li>把 <b>_bss的地址</b> 放到了 <span class="underline">rcx寄存器</span> 。正如在 vmlinux.lds.S链接脚本中看到了一样，它和设置/内核代码一起在所有节的末尾</li>
<li>现在可以开始用 <b>movsq</b> 指令每次 <span class="underline">8字节</span> 地从 <span class="underline">rsi</span> 到 <span class="underline">rdi</span> 复制代码</li>
<li><p>
注意: 在数据复制前有 <span class="underline">std</span> 指令：它设置DF标志，意味着rsi和rdi会递减
</p>
<pre class="example" id="org7b447d8">
换句话说，会从后往前复制这些字节
</pre></li>
<li>用 <span class="underline">cld</span> 指令清除DF标志，并恢复boot_params到rsi</li>
</ol>

<p>
拷贝完成后 跳转到 .text节的重定位后的地址
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">leaq</span>    <span style="color: #00ffff;">relocated</span>(<span style="color: #eedd82;">%rbx</span>), <span style="color: #eedd82;">%rax</span>
<span style="color: #87cefa;">jmp</span>     *<span style="color: #eedd82;">%rax</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga6a0ed1" class="outline-2">
<h2 id="orga6a0ed1">内核解压</h2>
<div class="outline-text-2" id="text-orga6a0ed1">
</div>
<div id="outline-container-org8fcbabe" class="outline-3">
<h3 id="org8fcbabe">调用 extract_kernel</h3>
<div class="outline-text-3" id="text-org8fcbabe">
<p>
<span class="underline">.text节</span> 从 <b>relocated</b> 标签开始。它做的第一件事是 <b>清空</b> <span class="underline">.bss节</span> ：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">xorl</span>    <span style="color: #00ffff;">%eax</span>, <span style="color: #eedd82;">%eax</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#28165;&#31354; eax </span>
<span style="color: #87cefa;">leaq</span>    _bss(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rdi</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25226;_bss&#30340;&#22320;&#22336;&#25918;&#21040;rdi</span>
<span style="color: #87cefa;">leaq</span>    _ebss(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rcx</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25226;_ebss&#25918;&#21040;rcx</span>
<span style="color: #87cefa;">subq</span>    <span style="color: #00ffff;">%rdi</span>, <span style="color: #eedd82;">%rcx</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25226;&#25972;&#20010; .bss &#21306; &#22635; 0 </span>
<span style="color: #87cefa;">shrq</span>    <span style="color: #00ffff;">$3</span>, <span style="color: #eedd82;">%rcx</span>
<span style="color: #87cefa;">rep</span>     <span style="color: #00ffff;">stosq</span>
</pre>
</div>

<pre class="example" id="orgab91116">
因为很快要跳转到C代码，所以要初始化.bss节
</pre>

<p>
最后，可以调用 <b>extract_kernel</b> 函数：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">pushq</span>   <span style="color: #00ffff;">%rsi</span>
<span style="color: #87cefa;">movq</span>    <span style="color: #00ffff;">%rsi</span>, <span style="color: #eedd82;">%rdi</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">rdi: &#25351;&#21521;boot_params&#32467;&#26500;&#20307;&#30340;&#25351;&#38024; </span>
<span style="color: #87cefa;">leaq</span>    <span style="color: #00ffff;">boot</span>_heap(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rsi</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">rsi: &#25351;&#21521;&#26089;&#26399;&#21551;&#21160;&#22534;&#30340;&#36215;&#22987;&#22320;&#22336; boot_heap</span>
<span style="color: #87cefa;">leaq</span>    <span style="color: #00ffff;">input</span>_data(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rdx</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">rdx: &#25351;&#21521;&#21387;&#32553;&#30340;&#20869;&#26680;&#30340;&#22320;&#22336;</span>
<span style="color: #87cefa;">movl</span>    <span style="color: #00ffff;">$z</span>_input_len, <span style="color: #eedd82;">%ecx</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">ecx: &#21387;&#32553;&#30340;&#20869;&#26680;&#30340;&#22823;&#23567;</span>
<span style="color: #87cefa;">movq</span>    <span style="color: #00ffff;">%rbp</span>, <span style="color: #eedd82;">%r8</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">r8: &#35299;&#21387;&#21518;&#20869;&#26680;&#30340;&#36215;&#22987;&#22320;&#22336;</span>
<span style="color: #87cefa;">movq</span>    <span style="color: #00ffff;">$z</span>_output_len, <span style="color: #eedd82;">%r9</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">r9: &#35299;&#21387;&#21518;&#20869;&#26680;&#30340;&#22823;&#23567;</span>
<span style="color: #87cefa;">call</span>    <span style="color: #00ffff;">extract</span>_kernel
<span style="color: #87cefa;">popq</span>    <span style="color: #00ffff;">%rsi</span>
</pre>
</div>

<ol class="org-ol">
<li>设置 <span class="underline">rdi</span> 为指向 <span class="underline">boot_params结构体</span> 的指针并把它保存到栈中</li>
<li>设置 <span class="underline">rsi</span> 指向用于 <span class="underline">内核解压的区域</span></li>
<li>准备extract_kernel的参数并调用这个解压内核的函数。extract_kernel函数在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a> 源文件定义并有六个参数：
<ul class="org-ul">
<li><p>
rmode: 指向 boot_params 结构体的指针
</p>
<pre class="example" id="org1b15e9f">
boot_params 被引导加载器填充或在早期内核初始化时填充
</pre></li>
<li>heap: 指向早期启动堆的起始地址 <span class="underline">boot_heap</span> 的指针</li>
<li>input_data: 指向压缩的内核，即 <span class="underline">arch/x86/boot/compressed/vmlinux.bin.bz2</span> 的指针</li>
<li>input_len: 压缩的内核的大小</li>
<li>output:解压后内核的起始地址</li>
<li>output_len: 解压后内核的大小</li>
</ul></li>
</ol>

<p>
所有参数根据 <a href="https://cs61.seas.harvard.edu/site/2024/pdf/x86-64-abi-20210928.pdf">System V Application Binary Interface</a> 通过寄存器传递
</p>
</div>
</div>
<div id="outline-container-org11c02bb" class="outline-3">
<h3 id="org11c02bb">extract_kernel</h3>
<div class="outline-text-3" id="text-org11c02bb">
<p>
extract_kernel函数 从图形/控制台初始化开始
</p>

<pre class="example" id="orga2d7909">
因为不知道是不是从实模式开始，或者是使用了引导加载器，或者引导加载器用了32位还是64位启动协议

所以这里还要再做一遍某些代码
</pre>

<p>
在最早的初始化步骤后，保存空闲内存的起始和末尾地址
</p>
<pre class="example" id="orgfa522e4">
free_mem_ptr     = heap;
free_mem_end_ptr = heap + BOOT_HEAP_SIZE;
</pre>

<p>
这里 heap 从 arch/x86/boot/compressed/head_64.S 传给 extract_kernel 函数的第二个参数：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">leaq</span>    <span style="color: #00ffff;">boot</span>_heap(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rsi</span>
</pre>
</div>

<p>
而 boot_heap 定义为：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">boot_heap</span>:
        <span style="color: #00ffff;">.fill</span> BOOT_HEAP_SIZE, 1, 0
</pre>
</div>

<pre class="example" id="orgcfbb468">
BOOT_HEAP_SIZE是一个展开为0x10000 (对bzip2内核是0x400000) 的宏，代表堆的大小 
</pre>

<p>
堆指针初始化后，下一步是从 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/kaslr.c#L425">arch/x86/boot/compressed/kaslr.c</a> 调用 <b>choose_random_location</b> 函数
</p>

<pre class="example" id="orgf565c72">
从函数名猜到，它选择内核镜像解压到的内存地址

因为Linux内核支持kASLR，为了安全，它允许解压内核到随机的地址

在这一部分，不会考虑Linux内核的加载地址的随机化，会在下一部分讨论
</pre>

<p>
回头看  <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/misc.c">misc.c</a>. 在获得内核镜像的地址后，需要有一些检查以确保获得的随机地址是正确对齐的，并且地址没有错误：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)output &amp; (MIN_KERNEL_ALIGN - 1))
                error(<span style="color: #ffa07a;">"Destination physical address inappropriately aligned"</span>);

<span style="color: #00ffff;">if</span> (virt_addr &amp; (MIN_KERNEL_ALIGN - 1))
                error(<span style="color: #ffa07a;">"Destination virtual address inappropriately aligned"</span>);

<span style="color: #00ffff;">if</span> (heap &gt; 0x3fffffffffffUL)
                error(<span style="color: #ffa07a;">"Destination address too large"</span>);

<span style="color: #00ffff;">if</span> (virt_addr + max(output_len, kernel_total_size) &gt; KERNEL_IMAGE_SIZE)
                error(<span style="color: #ffa07a;">"Destination virtual address is beyond the kernel mapping area"</span>);

<span style="color: #00ffff;">if</span> ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)output != LOAD_PHYSICAL_ADDR)
                error(<span style="color: #ffa07a;">"Destination address does not match LOAD_PHYSICAL_ADDR"</span>);

<span style="color: #00ffff;">if</span> (virt_addr != LOAD_PHYSICAL_ADDR)
                error(<span style="color: #ffa07a;">"Destination virtual address changed when not relocatable"</span>);
</pre>
</div>

<p>
通过所有这些检查后，可以看到熟悉的消息：
</p>

<pre class="example" id="org2df005c">
Decompressing Linux... 
</pre>

<p>
然后调用解压内核的 <b>__decompress</b> 函数：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">__decompress</span>(input_data, input_len, <span style="color: #7fffd4;">NULL</span>, <span style="color: #7fffd4;">NULL</span>, output, output_len, <span style="color: #7fffd4;">NULL</span>, error);
</pre>
</div>

<p>
__decompress函数的实现取决于在内核编译期间选择什么压缩算法：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #ff4500;">#</span><span style="color: #ff4500;">ifdef CONFIG_KERNEL_GZIP</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">include "../../../../lib/decompress_inflate.c"</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">endif</span>

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">ifdef CONFIG_KERNEL_BZIP2</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">include "../../../../lib/decompress_bunzip2.c"</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">endif</span>

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">ifdef CONFIG_KERNEL_LZMA</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">include "../../../../lib/decompress_unlzma.c"</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">endif</span>

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">ifdef CONFIG_KERNEL_XZ</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">include "../../../../lib/decompress_unxz.c"</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">endif</span>

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">ifdef CONFIG_KERNEL_LZO</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">include "../../../../lib/decompress_unlzo.c"</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">endif</span>

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">ifdef CONFIG_KERNEL_LZ4</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">include "../../../../lib/decompress_unlz4.c"</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">endif</span>
</pre>
</div>

<p>
在内核解压之后，最后两个函数是 <b>parse_elf</b> 和 <b>handle_relocations</b> 。这些函数的主要用途是把解压后的内核移动到正确的位置
</p>

<pre class="example" id="orgbaf317a">
实际上，解压过程会原地解压，还需要把内核移动到正确的地址

https://en.wikipedia.org/wiki/In-place_algorithm
</pre>

<p>
内核镜像是一个ELF可执行文件，所以parse_elf的主要目标是移动可加载的段到正确的地址。从 <span class="underline">readelf</span> 的输出看到可加载的段：
</p>

<div class="org-src-container">
<pre class="src src-sh">readelf -l vmlinux

Elf file type is EXEC (Executable file)
Entry point 0x1000000
There are 5 program headers, starting at offset 64

Program Headers:
Type           Offset             VirtAddr           PhysAddr
FileSiz            MemSiz              Flags  Align
LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000
0x0000000000893000 0x0000000000893000  R E    200000
LOAD           0x0000000000a93000 0xffffffff81893000 0x0000000001893000
0x000000000016d000 0x000000000016d000  RW     200000
LOAD           0x0000000000c00000 0x0000000000000000 0x0000000001a00000
0x00000000000152d8 0x00000000000152d8  RW     200000
LOAD           0x0000000000c16000 0xffffffff81a16000 0x0000000001a16000
0x0000000000138000 0x000000000029b000  RWE    200000
</pre>
</div>

<p>
parse_elf函数的目标是加载这些段到从 <b>choose_random_location</b> 函数得到的 <span class="underline">output地址</span> 。这个函数从检查ELF签名标志开始：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">Elf64_Ehdr</span> <span style="color: #eedd82;">ehdr</span>;
<span style="color: #98fb98;">Elf64_Phdr</span> *<span style="color: #eedd82;">phdrs</span>, *<span style="color: #eedd82;">phdr</span>;

memcpy(&amp;ehdr, output, <span style="color: #00ffff;">sizeof</span>(ehdr));

<span style="color: #00ffff;">if</span> (ehdr.e_ident[EI_MAG0] != ELFMAG0 ||
    ehdr.e_ident[EI_MAG1] != ELFMAG1 ||
    ehdr.e_ident[EI_MAG2] != ELFMAG2 ||
    ehdr.e_ident[EI_MAG3] != ELFMAG3) {
        error(<span style="color: #ffa07a;">"Kernel is not a valid ELF file"</span>);
        <span style="color: #00ffff;">return</span>;
}
</pre>
</div>

<ul class="org-ul">
<li>如果 ELF 签名无效的，它会打印一条错误消息并停机</li>
<li><p>
如果得到一个有效的ELF文件，从给定的ELF文件遍历所有程序头，并用正确的地址复制所有可加载的段到输出缓冲区：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; ehdr.e_phnum; i++) {
                phdr = &amp;phdrs[i];

                <span style="color: #00ffff;">switch</span> (phdr-&gt;p_type) {
                <span style="color: #00ffff;">case</span> PT_LOAD:
<span style="color: #7fffd4;">#ifdef</span> CONFIG_RELOCATABLE
                                dest = output;
                                dest += (phdr-&gt;p_paddr - LOAD_PHYSICAL_ADDR);
<span style="color: #7fffd4;">#else</span>
                                dest = (<span style="color: #98fb98;">void</span> *)(phdr-&gt;p_paddr);
<span style="color: #7fffd4;">#endif</span>
                                memmove(dest, output + phdr-&gt;p_offset, phdr-&gt;p_filesz);
                                <span style="color: #00ffff;">break</span>;
                <span style="color: #00ffff;">default</span>:
                                <span style="color: #00ffff;">break</span>;
                }
}
</pre>
</div></li>
</ul>

<pre class="example" id="orga3c31dc">
从现在开始，所有可加载的段都在正确的位置
</pre>

<p>
在parse_elf函数之后是调用 <b>handle_relocations</b> 函数。这个函数的实现依赖于 <b>CONFIG_X86_NEED_RELOCS</b> 内核配置选项。如果它被启用，这个函数调整内核镜像的地址
</p>

<pre class="example" id="orgd240514">
只有在内核配置时启用了CONFIG_RANDOMIZE_BASE配置选项才会调用
</pre>

<p>
handle_relocations函数的实现足够简单。这个函数从基准内核加载地址的值减掉LOAD_PHYSICAL_ADDR的值，从而获得内核链接后要加载的地址和实际加载地址的差值。在这之后我们可以进行内核重定位，因为我们知道内核加载的实际地址、它被链接的运行的地址和内核镜像末尾的重定位表
</p>
</div>
</div>
<div id="outline-container-org47e7cf4" class="outline-3">
<h3 id="org47e7cf4">进入内核</h3>
<div class="outline-text-3" id="text-org47e7cf4">
<p>
在内核重定位后，就从 extract_kernel 返回到 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> :
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">jmp</span>     *<span style="color: #eedd82;">%rax</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20869;&#26680;&#30340;&#22320;&#22336;&#22312;rax&#23492;&#23384;&#22120;</span>
</pre>
</div>

<pre class="example" id="orgdbaba86">
到此为止，就正式进入内核代码里
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4b47a8" class="outline-2">
<h2 id="orgc4b47a8">内核地址随机化</h2>
<div class="outline-text-2" id="text-orgc4b47a8">
<p>
Linux内核的入口点是 <a href="https://github.com/torvalds/linux/blob/v3.18/init/main.c">main.c</a> 的 <b>start_kernel</b> 函数，它在 <b>LOAD_PHYSICAL_ADDR</b> 地址开始执行。这个地址依赖于 <b>CONFIG_PHYSICAL_START</b> 内核配置选项，默认为 <span class="underline">0x1000000</span> :
</p>

<pre class="example" id="org9e0b7b0">
config PHYSICAL_START
	hex "Physical address where the kernel is loaded" if (EXPERT || CRASH_DUMP)
	default "0x1000000"
	---help---
	  This gives the physical address where the kernel is loaded.
      ...
      ...
      ...
</pre>

<p>
这个选项在内核配置时可以修改，使得加载地址可以选择为一个随机值。很多时候 CONFIG_RANDOMIZE_BASE内核配置选项在内核配置时应该启用
</p>

<pre class="example" id="orgf90714a">
在这种情况下，Linux内核镜像解压和加载的物理地址会被随机化

接下来考虑 为了安全原因，内核镜像的加载地址被随机化的情况
</pre>
<p>
<a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt">https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt</a>** 页表的初始化
在内核解压器要开始找随机的内核解压和加载地址之前，应该 <b>初始化恒等映射</b> （ <span class="underline">identity mapped</span> , 虚拟地址和物理地址相同）页表。如果 <a href="https://en.wikipedia.org/wiki/Booting">引导加载器</a> 使用 <a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt">16位或32位引导协议</a> ，那么已经有了页表
</p>

<pre class="example" id="org8d7bee5">
任何情况下，如果内核解压器选择它们之外的内存区域，需要新的页。这就是为什么需要建立新的恒等映射页表

在此之前，让我们回忆一下是怎么来到这里的
</pre>

<p>
前面已经看到了到长模式的转换，并跳转到了内核解压器的入口点 extract_kernel 函数。随机化从调用这个函数开始：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">choose_random_location</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">input</span>,
                            <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">input_size</span>,
                                        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> *<span style="color: #eedd82;">output</span>,
                            <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">output_size</span>,
                                        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> *<span style="color: #eedd82;">virt_addr</span>)
</pre>
</div>

<p>
这个函数有五个参数：
</p>
<ul class="org-ul">
<li>input</li>
<li>input_size</li>
<li>output</li>
<li>output_isze</li>
<li>virt_addr</li>
</ul>

<p>
第一个input参数来自源文件 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a> 里的extract_kernel函数：
</p>
<div class="org-src-container">
<pre class="src src-c">asmlinkage __visible <span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">extract_kernel</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">rmode</span>, <span style="color: #98fb98;">memptr</span> <span style="color: #eedd82;">heap</span>,
                                                          <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">input_data</span>,
                                                          <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">input_len</span>,
                                                          <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">output</span>,
                                                          <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">output_len</span>)
{
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
                choose_random_location((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)input_data, input_len,
                                                           (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> *)&amp;output,
                                                           max(output_len, kernel_total_size),
                                                           &amp;virt_addr);
        <span style="color: #ff4500;">//  </span><span style="color: #ff4500;">...</span>
}
</pre>
</div>

<p>
这个参数由 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> 的汇编代码传递：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">leaq</span>    <span style="color: #00ffff;">input</span>_data(<span style="color: #eedd82;">%rip</span>), <span style="color: #eedd82;">%rdx</span>
</pre>
</div>

<p>
<b>input_data</b> 由 <span class="underline">mkpiggy</span> 程序生成。如果编译过Linux内核源码，会找到这个程序生成的文件，它应该位于 <span class="underline">linux/arch/x86/boot/compressed/piggy.S</span> 。这个文件是这样的：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ffff;">.section</span> <span style="color: #ffa07a;">".rodata..compressed"</span>,<span style="color: #ffa07a;">"a"</span>,@progbits
<span style="color: #00ffff;">.globl</span> z_input_len
<span style="color: #87cefa;">z_input_len</span> = 6988196
<span style="color: #00ffff;">.globl</span> z_output_len
<span style="color: #87cefa;">z_output_len</span> = 29207032
<span style="color: #00ffff;">.globl</span> input_data, input_data_end
<span style="color: #87cefa;">input_data</span>:
<span style="color: #00ffff;">.incbin</span> <span style="color: #ffa07a;">"arch/x86/boot/compressed/vmlinux.bin.gz"</span>
<span style="color: #87cefa;">input_data_end</span>:
</pre>
</div>

<p>
它有四个全局符号：
</p>
<ul class="org-ul">
<li>前两个z_input_len和z_output_len是压缩的和解压后的vmlinux.bin.gz的大小</li>
<li>第三个是input_data，它指向二进制格式（去掉所有调试符号、注释和重定位信息）的Linux内核镜像</li>
<li>最后的input_data_end指向压缩的Linux镜像的末尾</li>
</ul>

<pre class="example" id="org8c9723d">
所以 choose_random_location函数的第一个参数是指向嵌入在piggy.o目标文件的压缩的内核镜像的指针
</pre>

<ul class="org-ul">
<li>choose_random_location函数的第二个参数是 刚刚看到的 <b>z_input_len</b></li>
<li>choose_random_location函数的第三和第四个参数分别是解压后的内核镜像的位置和长度
<ul class="org-ul">
<li>放置解压后内核的地址来自 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a>，并且它是 <b>startup_32</b> 对齐到 <span class="underline">2MB</span> 边界的地址</li>
<li>解压后的内核的大小来自同样的piggy.S，并且它是 <b>z_output_len</b></li>
</ul></li>
<li><p>
choose_random_location函数的最后一个参数是内核加载地址的虚拟地址。它和默认的物理加载地址相同：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">virt_addr</span> = LOAD_PHYSICAL_ADDR;
</pre>
</div>
<ul class="org-ul">
<li><p>
它依赖于内核配置：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">LOAD_PHYSICAL_ADDR</span> ((CONFIG_PHYSICAL_START \
                                + (CONFIG_PHYSICAL_ALIGN - 1)) \
                                &amp; ~(CONFIG_PHYSICAL_ALIGN - 1))
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org8ec83bd" class="outline-3">
<h3 id="org8ec83bd">建立新的恒等映射内存页表</h3>
<div class="outline-text-3" id="text-org8ec83bd">
<p>
这个函数从检查内核命令行的 <span class="underline">nokaslr</span> 选项开始：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (cmdline_find_option_bool(<span style="color: #ffa07a;">"nokaslr"</span>)) {
        warn(<span style="color: #ffa07a;">"KASLR disabled: 'nokaslr' on cmdline."</span>);
        <span style="color: #00ffff;">return</span>;
}
</pre>
</div>
<p>
如果有这个选项，那么就退出choose_random_location函数，并且内核的加载地址不会随机化。相关的命令行选项可以在 <a href="https://github.com/torvalds/linux/blob/v3.18/Documentation/kernel-parameters.txt">内核文档</a>找到：
</p>
<pre class="example" id="org8f6552f">
kaslr/nokaslr [X86]

Enable/disable kernel and module base offset ASLR
(Address Space Layout Randomization) if built into
the kernel. When CONFIG_HIBERNATION is selected,
kASLR is disabled by default. When kASLR is enabled,
hibernation will be disabled.
</pre>

<p>
假设没有把nokaslr传到内核命令行，并且CONFIG_RANDOMIZE_BASE启用了内核配置选项。下一步：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">initialize_identity_maps</span>();
</pre>
</div>

<p>
它在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/boot/compressed/pagetable.c">arch/x86/boot/compressed/pagetable.c</a> 定义。这个函数从初始化 <b>x86_mapping_info结构体</b> 的一个实例开始：
</p>
<div class="org-src-container">
<pre class="src src-c">mapping_info.alloc_pgt_page = alloc_pgt_page;
mapping_info.context = &amp;pgt_data;
mapping_info.page_flag = __PAGE_KERNEL_LARGE_EXEC | sev_me_mask;
mapping_info.kernpg_flag = _KERNPG_TABLE | sev_me_mask;
</pre>
</div>

<p>
x86_mapping_info结构体在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/include/asm/init.h">arch/x86/include/asm/init.h</a> 头文件定义：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">x86_mapping_info</span> {
        <span style="color: #98fb98;">void</span> *(*<span style="color: #87cefa;">alloc_pgt_page</span>)(<span style="color: #98fb98;">void</span> *); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20026;&#19968;&#20010;&#39029;&#34920;&#39033;&#20998;&#37197;&#31354;&#38388;&#26102;&#35843;&#29992;&#30340;&#22238;&#35843;&#20989;&#25968; </span>
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">context</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#36319;&#36394;&#24050;&#20998;&#37197;&#39029;&#34920;&#30340;alloc_pgt_data&#32467;&#26500;&#20307;&#30340;&#23454;&#20363;</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">page_flag</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">PMD&#25110;PUD&#34920;&#39033;&#30340;&#26631;&#24535;</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">offset</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20869;&#26680;&#34394;&#25311;&#22320;&#22336;&#21040;PMD&#32423;&#29289;&#29702;&#22320;&#22336;&#30340;&#20559;&#31227;</span>
        <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">direct_gbpages</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;&#22823;&#39029;&#30340;&#25903;&#25345;</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">kernpg_flag</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#26410;&#26469;&#34987;&#35206;&#30422;&#30340;&#20869;&#26680;&#39029;&#30340;&#26631;&#24535;</span>
};
</pre>
</div>

<pre class="example" id="org94a834a">
这个结构体提供了关于内存映射的信息

在前面的部分，已经建立了初始的从0到4G的页表，现在可能需要访问4G以上的内存来在随机的位置加载内核

所以，initialize_identity_maps函数初始化一个内存区域，它用于可能需要的新页表
</pre>

<ul class="org-ul">
<li>alloc_pgt_page: 为一个页表项分配空间时调用的回调函数</li>
<li>context: 用于跟踪已分配页表的alloc_pgt_data结构体的实例</li>
<li>page_flag: PMD或PUD表项的标志</li>
<li>kernpg_flag: 在之后被覆盖的内核页的标志</li>
<li>direct_gbpages: 对大页的支持</li>
<li>offset: 内核虚拟地址到PMD级物理地址的偏移</li>
</ul>

<p>
alloc_pgt_page 函数检查有一个新页的空间，从缓冲区分配新页并返回新页的地址：
</p>
<div class="org-src-container">
<pre class="src src-c">entry = pages-&gt;pgt_buf + pages-&gt;pgt_buf_offset;
pages-&gt;pgt_buf_offset += PAGE_SIZE;
</pre>
</div>

<p>
缓冲区在此结构体中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">alloc_pgt_data</span> {
                <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pgt_buf</span>;
                <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">pgt_buf_size</span>;
                <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">pgt_buf_offset</span>;
};
</pre>
</div>
<p>
initialize_identity_maps函数最后的目标是初始化 pgdt_buf_size 和 pgt_buf_offset. 由于只是在初始化阶段，initialize_identity_maps函数设置 pgt_buf_offset 为0:
</p>

<div class="org-src-container">
<pre class="src src-c">pgt_data.pgt_buf_offset = 0;
</pre>
</div>

<pre class="example" id="org8580ed9">
pgt_data.pgt_buf_size会根据引导加载器所用的引导协议（64位或32位）被设置为77824或69632
</pre>

<p>
pgt_data.pgt_buf也是一样。如果引导加载器从 <b>startup_32</b> 引导内核，pgdt_data.pgdt_buf会指向已经在 <a href="https://github.com/torvalds/linux/blob/master/v3.18/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> 初始化的页表的末尾：
</p>

<div class="org-src-container">
<pre class="src src-c">pgt_data.pgt_buf = _pgtable + BOOT_INIT_PGT_SIZE;
</pre>
</div>

<p>
_pgtable指向这个页表 <a href="https://github.com/torvalds/linux/blob/master/v3.18/x86/boot/compressed/vmlinux.lds.S">_pgtable</a> 的开头
</p>

<p>
另一方面，如果引导加载器用64位引导协议并在 <b>startup_64</b> 加载内核，早期页表应该由引导加载器建立，并且_pgtable会被重写：
</p>

<div class="org-src-container">
<pre class="src src-c">pgt_data.pgt_buf = _pgtable
</pre>
</div>

<pre class="example" id="orga85f7c5">
在新页表的缓冲区被初始化之下，回到 choose_random_location函数
</pre>
</div>
</div>
<div id="outline-container-orgeff92d7" class="outline-3">
<h3 id="orgeff92d7">避开保留的内存范围</h3>
<div class="outline-text-3" id="text-orgeff92d7">
<pre class="example" id="org4a7130c">
在恒等映射页表相关的数据被初始化之后，可以开始选择放置解压后内核的随机位置

但是正如你猜的那样，不能选择任意地址

在内存的范围中，有一些保留的地址。这些地址被重要的东西占用，如initrd, 内核命令行等等
</pre>

<p>
函数 <b>mem_avoid_init</b> 会做这件事。所有不安全的内存区域会收集到：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">mem_avoid_init</span>(input, input_size, *output);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">mem_vector</span> {
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">start</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">size</span>;
};

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">mem_vector</span> <span style="color: #eedd82;">mem_avoid</span>[MEM_AVOID_MAX];
</pre>
</div>

<p>
其中 <b>MEM_AVOID_MAX</b> 来自枚举类型 <b>mem_avoid_index</b> , 定义在源文件 <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/kaslr.c">arch/x86/boot/compressed/kaslr.c</a> 中，代表不同类型的保留内存区域：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">mem_avoid_index</span> {
                <span style="color: #eedd82;">MEM_AVOID_ZO_RANGE</span> = 0,
                <span style="color: #eedd82;">MEM_AVOID_INITRD</span>,
                <span style="color: #eedd82;">MEM_AVOID_CMDLINE</span>,
                <span style="color: #eedd82;">MEM_AVOID_BOOTPARAMS</span>,
                <span style="color: #eedd82;">MEM_AVOID_MEMMAP_BEGIN</span>,
                <span style="color: #eedd82;">MEM_AVOID_MEMMAP_END</span> = MEM_AVOID_MEMMAP_BEGIN + MAX_MEMMAP_REGIONS - 1,
                <span style="color: #eedd82;">MEM_AVOID_MAX</span>,
};
</pre>
</div>

<p>
mem_avoid_init 主要目标是在mem_avoid数组存放关于被mem_avoid_index枚举类型描述的保留内存区域的信息，并且在新的恒等映射缓冲区为这样的区域创建新页。函数里的几个部分很相似，先看看其中一个：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">mem_avoid</span>[MEM_AVOID_ZO_RANGE].start = input;
<span style="color: #98fb98;">mem_avoid</span>[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;
<span style="color: #87cefa;">add_identity_map</span>(<span style="color: #98fb98;">mem_avoid</span>[MEM_AVOID_ZO_RANGE].start,
                                 <span style="color: #98fb98;">mem_avoid</span>[MEM_AVOID_ZO_RANGE].size);
</pre>
</div>

<p>
mem_avoid_init函数的开头尝试避免用于 <b>当前内核解压的内存区域</b>
</p>
<ol class="org-ol">
<li>用这个区域的 <span class="underline">起始地址</span> 和 <span class="underline">大小</span> 填写 <b>mem_avoid数组</b> 的一项</li>
<li><p>
调用 <b>add_identity_map</b> 函数，它会为这个区域建立恒等映射页。add_identity_map函数同样在 <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/kaslr.c">arch/x86/boot/compressed/kaslr.c</a> 定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">add_identity_map</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">start</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">size</span>)
{
                <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">end</span> = start + size;

                start = round_down(start, PMD_SIZE);
                end = round_up(end, PMD_SIZE);
                <span style="color: #00ffff;">if</span> (start &gt;= end)
                                <span style="color: #00ffff;">return</span>;

                kernel_ident_mapping_init(&amp;mapping_info, (<span style="color: #98fb98;">pgd_t</span> *)top_level_pgt,
                                                                  start, end);
}
</pre>
</div>
<ul class="org-ul">
<li>它对齐内存到 2MB 边界并检查给定的起始地址和终止地址</li>
<li>调用 <b>kernel_ident_mapping_init</b> 函数，它在源文件 <a href="https://github.com/torvalds/linux/blob/master/arch/x86/mm/ident_map.c">arch/x86/mm/ident_map.c</a> 中，并传入 <span class="underline">初始化好的mapping_info实例</span> 、 <span class="underline">顶层页表的地址</span> 和建立 <span class="underline">新的恒等映射的内存区域的地址</span>
<ul class="org-ul">
<li><p>
为新页设置默认的标志，如果它们没有被给出：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (!info-&gt;kernpg_flag)
                info-&gt;kernpg_flag = _KERNPG_TABLE;
</pre>
</div></li>
<li><p>
建立新的2MB (因为mapping_info.page_flag中的PSE位) 给定地址相关的页表项（五级页表中的PGD -&gt; P4D -&gt; PUD -&gt; PMD或者四级页表中的PGD -&gt; PUD -&gt; PMD）
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (; addr &lt; end; addr = next) {
                <span style="color: #98fb98;">p4d_t</span> *<span style="color: #eedd82;">p4d</span>;

                next = (addr &amp; PGDIR_MASK) + PGDIR_SIZE; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25214;&#32473;&#23450;&#22320;&#22336;&#22312; &#39029;&#20840;&#23616;&#30446;&#24405; &#30340;&#19979;&#19968;&#39033; </span>
                <span style="color: #00ffff;">if</span> (next &gt; end) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#26524;&#23427;&#22823;&#20110;&#32473;&#23450;&#30340;&#20869;&#23384;&#21306;&#22495;&#30340;&#26411;&#22320;&#22336;end&#65292;&#25226;&#23427;&#35774;&#20026;end</span>
                                next = end; 

                p4d = (<span style="color: #98fb98;">p4d_t</span> *)info-&gt;alloc_pgt_page(info-&gt;context); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#29992;&#20043;&#21069;&#30475;&#36807;&#30340;x86_mapping_info&#22238;&#35843;&#20989;&#25968;&#20998;&#37197;&#19968;&#20010;&#26032;&#39029; </span>
                result = ident_p4d_init(info, p4d, addr, next); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">ident_p4d_init&#20989;&#25968;&#20570;&#21516;&#26679;&#30340;&#20107;&#24773;&#65292;&#20294;&#26159;&#29992;&#20110;&#20302;&#23618;&#30340;&#39029;&#30446;&#24405; (p4d -&gt; pud -&gt; pmd)</span>

                <span style="color: #00ffff;">return</span> result;
}
</pre>
</div></li>
</ul></li>
</ul></li>
</ol>

<pre class="example" id="org5b5d285">
这不是mem_avoid_init函数的末尾，但是其他部分类似

它建立用于 initrd、内核命令行等数据的页
</pre>
</div>
</div>
<div id="outline-container-org7c18643" class="outline-3">
<h3 id="org7c18643">物理地址随机化</h3>
<div class="outline-text-3" id="text-org7c18643">
<p>
在保留内存区域存储在mem_avoid数组并且为它们建立了恒等映射页之后，选择 <b>最小可用的地址</b> 作为解压内核的随机内存区域：
</p>

<div class="org-src-container">
<pre class="src src-c">min_addr = min(*output, 512UL &lt;&lt; 20);
</pre>
</div>

<pre class="example" id="org3da0cd9">
它应该小于512MB. 选择这个512MB的值只是避免低内存区域中未知的东西
</pre>

<p>
下一步是选择随机的物理和虚拟地址来加载内核。首先是物理地址：
</p>

<div class="org-src-container">
<pre class="src src-c">random_addr = find_random_phys_addr(min_addr, output_size);
</pre>
</div>

<p>
<b>find_random_phys_addr</b> 函数在 <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/kaslr.c">同一个</a> 源文件中定义：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">find_random_phys_addr</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">minimum</span>,
                                           <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">image_size</span>)
{
                minimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);

                <span style="color: #00ffff;">if</span> (process_efi_entries(minimum, image_size))
                                <span style="color: #00ffff;">return</span> slots_fetch_random();

                process_e820_entries(minimum, image_size);
                <span style="color: #00ffff;">return</span> slots_fetch_random();
}
</pre>
</div>

<p>
<b>process_efi_entries</b> 函数的主要目标是在整个可用的内存找到所有的合适的内存区域来加载内核。如果内核没有在支持EFI的系统中编译和运行，继续在 <a href="https://en.wikipedia.org/wiki/E820">e820</a> 区域中找这样的内存区域。所有找到的内存区域会存储 <b>slot_area</b> 数组中：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">slot_area</span> {
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">addr</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>;
};

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">MAX_SLOT_AREA</span> 100

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">slot_area</span> <span style="color: #eedd82;">slot_areas</span>[MAX_SLOT_AREA];
</pre>
</div>

<p>
内核解压器应该选择这个数组随机的索引，并且它会是内核解压的随机位置。这个选择会被 <b>slots_fetch_random</b> 函数执行：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#36890;&#36807;kaslr_get_random_long&#20989;&#25968;&#20174;slot_areas&#25968;&#32452;&#36873;&#25321;&#38543;&#26426;&#30340;&#20869;&#23384;&#33539;&#22260;</span>
slot = kaslr_get_random_long(<span style="color: #ffa07a;">"Physical"</span>) % slot_max; 
</pre>
</div>

<p>
kaslr_get_random_long函数在源文件 <a href="https://github.com/torvalds/linux/blob/master/arch/x86/lib/kaslr.c">arch/x86/lib/kaslr.c</a> 中定义，它返回一个随机数
</p>

<pre class="example" id="org062b9d0">
注意：这个随机数会通过不同的方式得到，取决于内核配置、系统机会（基于时间戳计数器的随机数、rdrand等等）
</pre>
</div>
</div>
<div id="outline-container-orgb774345" class="outline-3">
<h3 id="orgb774345">虚拟地址随机化</h3>
<div class="outline-text-3" id="text-orgb774345">
<p>
在内核解压器选择了随机内存区域后，新的恒等映射页会为这个区域按需建立：
</p>

<div class="org-src-container">
<pre class="src src-c">random_addr = find_random_phys_addr(min_addr, output_size);

<span style="color: #00ffff;">if</span> (*output != random_addr) {
                add_identity_map(random_addr, output_size);
                *output = random_addr;
}
</pre>
</div>

<pre class="example" id="org861db35">
此时 output 会存放内核将被解压的一个内存区域的基地址
</pre>
<p>
但是现在，只是随机化了物理地址。而在x86_64架构，虚拟地址也应该被随机化：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (IS_ENABLED(CONFIG_X86_64))
                random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);

*virt_addr = random_addr;
</pre>
</div>

<p>
<b>find_random_virt_addr</b> 函数计算可以保存内存镜像的虚拟内存范围的数量并且调用在尝试找到随机的物理地址的时候，之前已经看到的 kaslr_get_random_long函数 
</p>

<pre class="example" id="org9d14219">
对于非x86_64架构，随机化的虚拟地址和随机化的物理地址相同

到此为止同时有了用于解压内核的随机化的物理(*output)和虚拟(*virt_addr)基地址
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
