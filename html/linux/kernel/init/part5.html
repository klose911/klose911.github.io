<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>与系统架构有关的初始化</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./part4.html"> UP </a>
 |
 <a accesskey="H" href="./init.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">与系统架构有关的初始化</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org002b5c9">early_trap_init</a>
<ul>
<li><a href="#org668b6be">#DB 处理函数</a></li>
</ul>
</li>
<li><a href="#org941bd3c">早期ioremap初始化</a></li>
<li><a href="#orgde6fe95">获取根设备的主次设备号</a></li>
<li><a href="#org1cc7dd5">Memory Map设置</a></li>
<li><a href="#orgd6bb984">复制 BIOS 增强磁盘设备信息</a></li>
<li><a href="#org0e6ea38">内存描述符初始化</a></li>
</ul>
</div>
</div>
<pre class="example" id="org73688a9">
在之前的章节中， 讲到了与系统架构有关的 setup_arch 函数部分，本文会继续从这里开始
</pre>
<div id="outline-container-org002b5c9" class="outline-2">
<h2 id="org002b5c9">early_trap_init</h2>
<div class="outline-text-2" id="text-org002b5c9">
<pre class="example" id="org0ba851a">
为 initrd 预留了内存之后，下一步是执行 olpc_ofw_detect 函数检测系统是否支持 One Laptop Per Child support

这里不会考虑与平台有关的东西，且会忽略与平台有关的函数。所以继续往下看
</pre>
<p>
下一步是执行 <b>early_trap_init</b> 函数。这个函数会 <b>初始化</b> <span class="underline">调试功能</span> （#DB 当 TF 标志位和rflags被设置时会被使用）和 <b>int3</b> （#BP） <span class="underline">中断门</span> 
</p>

<p>
在 x86 架构中，INT，INT0 和 INT3 是支持任务显式调用中断处理函数的特殊指令。INT3 指令调用断点（#BP）处理函数。 之前已经看到过中断和异常概念：
</p>

<pre class="example" id="org65227dd">
----------------------------------------------------------------------------------------------
|Vector|Mnemonic|Description         |Type |Error Code|Source                                |
----------------------------------------------------------------------------------------------
|3     | #BP    |Breakpoint          |Trap |NO        |INT 3                                 |
----------------------------------------------------------------------------------------------
</pre>

<p>
调试中断 #DB 是激活调试器的重要方法。 <b>early_trap_init</b>  函数的定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> 中。这个函数用来设置 #DB 和 #BP 处理函数，并且实现重新加载 <a href="http://en.wikipedia.org/wiki/Interrupt_descriptor_table">IDT</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__init</span> early_trap_init(<span style="color: #98fb98;">void</span>)
{
        set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);
        set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);
        load_idt(&amp;idt_descr);
}
</pre>
</div>

<pre class="example" id="orgcc6334e">
之前中断相关章节中看到过 set_intr_gate 的实现
</pre>
<p>
这里的 <b>set_intr_gate_ist</b> 和 <b>set_system_intr_gate_ist</b> 也是类似的实现。 这两个函数都需要三个参数：
</p>
<ol class="org-ol">
<li>中断号</li>
<li>中断/异常处理函数的基地址</li>
<li>Interrupt Stack Table
<ul class="org-ul">
<li><p>
IST 是 <a href="http://en.wikipedia.org/wiki/Task_state_segment">TSS</a> 的部分内容，是 x86_64 引入的新机制。 在内核态处于活跃状态的线程拥有 16kb 的内核栈空间。但是在用户空间的线程的内核栈是空的
</p>
<pre class="example" id="orgddd0916">
除了线程栈，还有一些与每个 CPU 有关的特殊栈

可以查阅 linux 内核文档 https://www.kernel.org/doc/Documentation/x86/kernel-stacks 部分了解这些栈信息
</pre></li>
<li><p>
x86_64 提供了像在 <span class="underline">非屏蔽中断</span> 等类似事件中 <b>切换</b> <span class="underline">新的特殊栈</span> 的特性支持。这个特性的名字是 <span class="underline">Interrupt Stack Table</span> 。 每个CPU最多可以有 7 个 IST 条目，每个条目有自己特定的栈
</p>
<pre class="example" id="orgf0c5db1">
在这里使用的是 DEBUG_STACK
</pre></li>
</ul></li>
</ol>

<p>
set_intr_gate_ist 和 set_system_intr_gate_ist 与 set_intr_gate 的工作原理几乎一样，只有一个区别。 这些函数检查中断号并在内部调用 _set_gate ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">BUG_ON</span>((<span style="color: #98fb98;">unsigned</span>)n &gt; 0xFF);
<span style="color: #87cefa;">_set_gate</span>(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
</pre>
</div>

<ul class="org-ul">
<li>set_intr_gate 把 dpl 和 ist 置为 0 来调用 _set_gate</li>
<li>set_intr_gate_ist 和 set_system_intr_gate_ist 把 ist 设置为 DEBUG_STACK，并且 set_system_intr_gate_ist 把 dpl 设置为优先级最低的 0x3
<ul class="org-ul">
<li>当中断发生时，硬件加载这个描述符，然后硬件根据 IST 的值自动设置新的栈指针。 之后激活对应的中断处理函数。所有的特殊内核栈会在 <b>cpu_init</b> 函数中设置好</li>
</ul></li>
</ul>

<p>
当 #DB 和 #BP 门向 idt_descr 有写操作，会调用  <b>load_idt</b> 函数来执行 ldtr 指令来重新加载 IDT 表
</p>

<pre class="example" id="org3cd76c9">
接下来我们来了解下中断处理函数并尝试理解它的工作原理。当然，不可能在这本书中讲解所有的中断处理函数

会在这里讲解 debug 处理函数的实现。请自行学习其他的中断处理函数实现
</pre>
</div>
<div id="outline-container-org668b6be" class="outline-3">
<h3 id="org668b6be">#DB 处理函数</h3>
<div class="outline-text-3" id="text-org668b6be">
<p>
像上文中提到的，在 set_intr_gate_ist 中通过 <b>&amp;debug 的地址</b> 传送 #DB 处理函数。遗憾的是，我们找不到 debug 处理函数。只能在 arch/x86/include/asm/traps.h<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/traps.h">arch/x86/include/asm/traps.h</a> 中找到 debug 的定义：
</p>

<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">debug</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>

<p>
从 <span class="underline">asmlinkage</span> 属性可以知道 debug 是由 assembly 语言实现的函数。 和其他处理函数一样，#DB 处理函数的实现可以在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/entry_64.S">arch/x86/kernel/entry_64.S</a>文件中找到。 都是由 <b>idtentry 汇编宏</b> 定义的：
</p>

<div class="org-src-container">
<pre class="src src-c">idtentry debug <span style="color: #98fb98;">do_debug</span> <span style="color: #eedd82;">has_error_code</span>=0 paranoid=1 shift_ist=DEBUG_STACK
</pre>
</div>

<p>
idtentry 是一个定义中断/异常指令入口点的宏。它需要五个参数：
</p>
<ol class="org-ol">
<li>中断条目点的名字</li>
<li>中断处理函数的名字</li>
<li>是否有中断错误码</li>
<li>paranoid: 如果这个参数置为 1，则切换到特殊栈</li>
<li>shift_ist: 支持中断期间切换栈</li>
</ol>

<p>
现在来看下 idtentry 宏的实现。这个宏的定义也在相同的汇编文件中，并且定义了有 ENTRY 宏属性的 debug 函数
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ffff;">.macro</span> idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1
<span style="color: #87cefa;">ENTRY</span>(\sym)
<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Sanity check</span><span style="color: #ff4500;"> */</span>
<span style="color: #00ffff;">.if</span> \shift_ist != -1 &amp;&amp; \paranoid == 0
<span style="color: #00ffff;">.error</span> <span style="color: #ffa07a;">"using shift_ist requires paranoid=1"</span>
<span style="color: #00ffff;">.endif</span>

<span style="color: #00ffff;">.if</span> \has_error_code
<span style="color: #87cefa;">XCPT_FRAME</span>
<span style="color: #00ffff;">.else</span>
<span style="color: #87cefa;">INTR_FRAME</span>
<span style="color: #00ffff;">.endif</span>
...
...
...
</pre>
</div>
<ol class="org-ol">
<li>idtentry 宏检查所有的参数是否正确，是否需要切换到特殊栈</li>
<li><p>
检查中断返回的错误码
</p>
<pre class="example" id="org50f4acf">
例如本案例中的 #DB 不会返回错误码
</pre>
<ul class="org-ul">
<li><p>
如果有错误码返回，它会调用 INTR_FRAME 或者 XCPT_FRAM 宏
</p>
<pre class="example" id="org93f74c2">
其实 XCPT_FRAME 和 INTR_FRAME 宏什么也不会做，只是对中断初始状态编译的时候有用

它们使用 CFI 指令用来调试。可以查阅更多有关 CFI 指令的信息 https://sourceware.org/binutils/docs/as/CFI-directives.html

就像 arch/x86/kernel/entry_64.S 中解释：CFI 宏是用来产生更好的回溯的 dwarf2 的解开信息

它们不会改变任何代码。因此可以忽略它们
</pre></li>
</ul></li>
</ol>

<p>
当中断发生后经过初期的中断/异常处理，栈内的格式是这样的：
</p>
<pre class="example" id="org8482cd9">
    +-----------------------+
    |                       |
+40 |         SS            |
+32 |         RSP           |
+24 |        RFLAGS         |
+16 |         CS            |
+8  |         RIP           |
 0  |       Error Code      | &lt;---- rsp
    |                       |
    +-----------------------+
</pre>

<p>
idtentry 实现中的另外两个宏分别是:
</p>
<ul class="org-ul">
<li><p>
ASM_CLAC: 依赖于 CONFIG_X86_SMAP 这个配置项和考虑安全因素
</p>
<pre class="example" id="orgdebe589">
可以从 https://lwn.net/Articles/517475 了解更多内容
</pre></li>
<li><p>
PARAVIRT_ADJUST_EXCEPTION_FRAME: 用来处理 Xen 类型异常
</p>
<pre class="example" id="org082e476">
这里不会考虑虚拟化的内容
</pre></li>
</ul>

<p>
下一段代码会检查中断是否有错误码。如果没有则会把 <b>$-1</b> (在 x86_64 架构下值为 <span class="underline">0xffffffffffffffff</span> )压入栈：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ffff;">.ifeq</span> \has_error_code
<span style="color: #87cefa;">pushq_cfi</span> <span style="color: #00ffff;">$</span>-1                   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ORIG_RAX: no syscall to restart</span><span style="color: #ff4500;"> */</span>
<span style="color: #00ffff;">.endif</span>
</pre>
</div>

<pre class="example" id="orgda1c520">
为了保证对于所有中断的栈的一致性，会把它处理为 dummy 错误码
</pre>
<p>
下一步从栈指针中减去 <b>$ORIG_RAX-R15</b> ：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">subq</span> <span style="color: #00ffff;">$ORIG</span>_RAX-R15, <span style="color: #eedd82;">%rsp</span>
</pre>
</div>

<p>
其中，ORIG_RAX，R15 和其他宏都定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/calling.h">arch/x86/include/asm/calling.h</a> 中，ORIG_RAX-R15 是 <span class="underline">120 字节</span>
</p>
<pre class="example" id="orge4c6578">
在中断处理过程中需要把所有的寄存器信息存储在栈中，所有通用寄存器会占用这个 120 字节
</pre>

<p>
为通用寄存器设置完栈之后，下一步是检查从用户空间产生的中断：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">testl</span> <span style="color: #00ffff;">$3</span>, CS(<span style="color: #eedd82;">%rsp</span>) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#26597;&#30475;&#27573;&#23492;&#23384;&#22120; CS &#30340;&#21069;&#20004;&#20010;&#27604;&#29305;&#20301;</span>
<span style="color: #87cefa;">jnz</span> <span style="color: #00ffff;">1f</span>
</pre>
</div>

<p>
CS 寄存器包含段选择器，它的前两个比特是 RPL。所有的权限等级是0-3范围内的整数。 数字越小代表权限越高
</p>
<ul class="org-ul">
<li>因此当中断来自内核空间，会调用 <b>save_paranoid</b></li>
<li>如果不来自内核空间，我们会跳转到标签 1 处处理</li>
</ul>

<p>
在 save_paranoid 函数中，会把所有的通用寄存器存储到栈中，如果需要的话会用户态 gs 切换到内核态 gs：
</p>
<div class="org-src-container">
<pre class="src src-asm">        <span style="color: #00ffff;">movl</span> $1,<span style="color: #eedd82;">%ebx</span>
        <span style="color: #00ffff;">movl</span> $MSR_GS_BASE,<span style="color: #eedd82;">%ecx</span>
        <span style="color: #00ffff;">rdmsr</span>
        <span style="color: #00ffff;">testl</span> <span style="color: #eedd82;">%edx</span>,<span style="color: #eedd82;">%edx</span>
        <span style="color: #00ffff;">js</span> 1f
        <span style="color: #00ffff;">SWAPGS</span>
        <span style="color: #00ffff;">xorl</span> <span style="color: #eedd82;">%ebx</span>,<span style="color: #eedd82;">%ebx</span>
<span style="color: #87cefa;">1</span>:      <span style="color: #00ffff;">ret</span>
</pre>
</div>
<p>
接下来把 pt_regs 指针存在 rdi 中，如果存在错误码就把它存储到 rsi 中，然后调用中断处理函数
</p>

<pre class="example" id="orgba9abc2">
例如就像 arch/x86/kernel/trap.c中的 do_debug
</pre>
<p>
do_debug 像其他处理函数一样需要两个参数：
</p>
<ol class="org-ol">
<li>pt_regs: 是一个存储在进程内存区域的一组CPU寄存器</li>
<li>error code: 中断错误码</li>
</ol>

<p>
中断处理函数完成工作后会调用 <b>paranoid_exit</b> 还原栈区。如果中断来自用户空间则切换回用户态并调用 iret
</p>
<pre class="example" id="orgf46bb02">
这是用在 #DB 中断中的 idtentry 宏的基本介绍。所有的中断都和这个实现类似，都定义在 idtentry中

以后会在不同的章节继续深入分析中断
</pre>

<p>
early_trap_init 执行完后，下一个函数是 <b>early_cpu_init</b> 。 这个函数定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a> 中，负责收集 CPU 和其供应商的信息
</p>
</div>
</div>
</div>
<div id="outline-container-org941bd3c" class="outline-2">
<h2 id="org941bd3c">早期ioremap初始化</h2>
<div class="outline-text-2" id="text-org941bd3c">
<p>
下一步是初始化早期的 ioremap。通常有两种实现与设备通信的方式：
</p>
<ol class="org-ol">
<li><p>
I/O端口
</p>
<pre class="example" id="org7398829">
在 linux 内核启动过程中见过第一种方法（通过 outb/inb 指令实现）
</pre></li>
<li><p>
设备内存：把 <span class="underline">I/O 的物理地址</span> <b>映射</b> 到 <span class="underline">虚拟地址</span>
</p>
<pre class="example" id="org4a12dfe">
当 CPU 读取一段物理地址时，它可以读取到映射了 I/O 设备的物理 RAM 区域
</pre>
<ul class="org-ul">
<li>ioremap 就是用来把设备内存映射到内核地址空间的</li>
</ul></li>
</ol>


<pre class="example" id="orga6abdcd">
early_ioremap_init 可以在正常的像 ioremap 这样的映射函数可用之前，把 I/O 内存映射到内核地址空间以方便读取
</pre>
<p>
在初期的初始化代码中初始化临时的 ioremap 来映射 I/O 设备到内存区域。初期的 ioremap 实现在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/ioremap.c">arch/x86/mm/ioremap.c</a> 中可以找到
</p>

<p>
在 early_ioremap_init 的一开始可以看到 <b>pmd_t</b> 类型的 pmd 指针定义（代表 <span class="underline">页中间目录条目</span> ）
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {<span style="color: #98fb98;">pmdval_t</span> <span style="color: #eedd82;">pmd</span>; } <span style="color: #98fb98;">pmd_t</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20854;&#20013; pmdval_t &#26159;&#26080;&#31526;&#21495;&#38271;&#25972;&#22411;</span>
</pre>
</div>

<p>
然后检查 fixmap 是正确对齐的：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">pmd_t</span> *<span style="color: #eedd82;">pmd</span>;

<span style="color: #87cefa;">BUILD_BUG_ON</span>((fix_to_virt(0) + PAGE_SIZE) &amp; ((1 &lt;&lt; PMD_SHIFT) - 1));
</pre>
</div>

<p>
fixmap: 一段从 <b>FIXADDR_START</b> 到 <b>FIXADDR_TOP</b> 的固定虚拟地址映射区域。它在子系统需要知道虚拟地址的编译过程中会被使用
</p>

<p>
之后 early_ioremap_init 函数会调用 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/early_ioremap.c">mm/early_ioremap.c</a> 中的 <b>early_ioremap_setup</b> 函数。early_ioremap_setup 会填充 <span class="underline">512个</span> <b>临时的</b> 启动时 <span class="underline">固定映射表</span> 来完成 * <span class="underline">无符号长整型矩阵</span> slot_virt* 的初始化：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++)
                <span style="color: #98fb98;">slot_virt</span>[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);
</pre>
</div>

<ol class="org-ol">
<li><p>
获得了 <b>FIX_BTMAP_BEGIN</b> 的 <span class="underline">页中间目录条目</span> ，并把它赋值给了 pmd 变量
</p>
<div class="org-src-container">
<pre class="src src-c">pmd = early_ioremap_pmd(fix_to_virt(FIX_BTMAP_BEGIN));
</pre>
</div></li>
<li><p>
把启动时间页表 <b>bm_pte</b> 写满 0
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">memset</span>(bm_pte, 0, <span style="color: #00ffff;">sizeof</span>(bm_pte));
</pre>
</div></li>
<li><p>
调用 <b>pmd_populate_kernel</b> 函数设置给定的页中间目录的页表条目：
</p>
<div class="org-src-container">
<pre class="src src-c">pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);
</pre>
</div></li>
</ol>

<pre class="example" id="org2273c76">
如果仍然觉得困惑，不要担心

在 内核内存管理 会有单独一部分讲解 ioremap 和 fixmaps
</pre>
</div>
</div>
<div id="outline-container-orgde6fe95" class="outline-2">
<h2 id="orgde6fe95">获取根设备的主次设备号</h2>
<div class="outline-text-2" id="text-orgde6fe95">
<p>
ioremap 初始化完成后，紧接着是执行下面的代码：
</p>
<div class="org-src-container">
<pre class="src src-c">ROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);
</pre>
</div>

<p>
这段代码用来获取根设备的主次设备号。后面 <span class="underline">initrd</span> 会通过 <b>do_mount_root</b> 函数 <b>挂载</b> 到这个 <span class="underline">根设备</span> 上
</p>
<ul class="org-ul">
<li>主设备号：用来识别和这个设备有关的驱动。</li>
<li>次设备号：用来表示使用该驱动的各设备</li>
</ul>

<p>
注意 <b>old_decode_dev</b> 函数是从 <b>boot_params_structure</b> 中获取了一个参数。可以从 x86 linux 内核启动协议中查到：
</p>

<pre class="example" id="org3e0adb4">
Field name:	root_dev
Type:		modify (optional)
Offset/size:	0x1fc/2
Protocol:	ALL

  The default root device device number.  The use of this field is
  deprecated, use the "root=" option on the command line instead
</pre>

<p>
现在来看看 old_decode_dev 如何实现的。实际上它只是根据 <span class="underline">主次设备号</span> 调用了 <b>MKDEV</b> 来生成一个 <b>dev_t</b> 类型的设备。它的实现很简单：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">dev_t</span> <span style="color: #87cefa;">old_decode_dev</span>(<span style="color: #98fb98;">u16</span> <span style="color: #eedd82;">val</span>)
{
                <span style="color: #00ffff;">return</span> MKDEV((val &gt;&gt; 8) &amp; 255, val &amp; 255);
}
</pre>
</div>

<p>
其中 dev_t 是用来表示主/次设备号对的一个内核数据类型
</p>

<pre class="example" id="orgd72b51e">
但是这个奇怪的 old 前缀代表了什么呢？出于历史原因，有两种管理主次设备号的方法

第一种方法主次设备号占用 2 字节，可以在以前的代码中发现：主设备号占用 8 bit，次设备号占用 8 bit

但是这会引入一个问题：最多只能支持 256 个主设备号和 256 个次设备号
</pre>

<p>
因此后来引入了 <span class="underline">32 bit</span> 来表示主次设备号，其中 12 位用来表示主设备号，20 位用来表示次设备号。可以在 <b>new_decode_dev</b> 的实现中找到：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">dev_t</span> <span style="color: #87cefa;">new_decode_dev</span>(<span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">dev</span>)
{
                <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">major</span> = (dev &amp; 0xfff00) &gt;&gt; 8;
                <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">minor</span> = (dev &amp; 0xff) | ((dev &gt;&gt; 12) &amp; 0xfff00);
                <span style="color: #00ffff;">return</span> MKDEV(major, minor);
}
</pre>
</div>

<pre class="example" id="org4aafdcb">
如果 dev 的值是 0xffffffff，经过计算可以得到用来表示主设备号的 12 位值 0xfff，表示次设备号的20位值 0xfffff

因此经过 old_decode_dev 最终可以得到在 ROOT_DEV 中根设备的主次设备号
</pre>
</div>
</div>
<div id="outline-container-org1cc7dd5" class="outline-2">
<h2 id="org1cc7dd5">Memory Map设置</h2>
<div class="outline-text-2" id="text-org1cc7dd5">
<p>
下一步是调用 setup_memory_map 函数设置内存映射。但是在这之前需要设置与显示屏有关的参数，与 <span class="underline">拓展显示识别数据</span> ， <span class="underline">视频模式</span> ， <span class="underline">引导启动器类型</span> 等参数：
</p>

<div class="org-src-container">
<pre class="src src-c">screen_info = boot_params.screen_info;
edid_info = boot_params.edid_info;
saved_video_mode = boot_params.hdr.vid_mode;
bootloader_type = boot_params.hdr.type_of_loader;
<span style="color: #00ffff;">if</span> ((bootloader_type &gt;&gt; 4) == 0xe) {
                bootloader_type &amp;= 0xf;
                bootloader_type |= (boot_params.hdr.ext_loader_type+0x10) &lt;&lt; 4;
}
bootloader_version  = bootloader_type &amp; 0xf;
bootloader_version |= boot_params.hdr.ext_loader_ver &lt;&lt; 4;
</pre>
</div>

<pre class="example" id="org0fd9123">
可以从启动时候存储在 boot_params 结构中获取这些参数信息
</pre>

<p>
之后开始设置 I/O 内存
</p>

<pre class="example" id="org3409026">
众所周知，内核主要做的工作就是资源管理，其中一个资源就是内存

目前有通过 I/O 口和设备内存两种方法实现设备通信
</pre>

<p>
所有有关注册资源的信息可以通过  <b>/proc/ioports</b> 和 <b>/proc/iomem</b> 获得：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cat /proc/iomem

00000000-00000fff : reserved
00001000-0009d7ff : System RAM
0009d800-0009ffff : reserved
000a0000-000bffff : PCI Bus 0000:00
000c0000-000cffff : Video ROM
000d0000-000d3fff : PCI Bus 0000:00
000d4000-000d7fff : PCI Bus 0000:00
000d8000-000dbfff : PCI Bus 0000:00
000dc000-000dffff : PCI Bus 0000:00
000e0000-000fffff : reserved
000e0000-000e3fff : PCI Bus 0000:00
000e4000-000e7fff : PCI Bus 0000:00
000f0000-000fffff : System ROM
</pre>
</div>

<p>
根据不同属性划分为以十六进制符号表示的一段地址范围。linux 内核提供了用来管理所有资源的一种通用 API。全局资源（比如 PICs 或者 I/O 端口）可以划分为与硬件总线插槽有关的子集。 <b>resource</b> 的主要结构是：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">resource</span> {
        <span style="color: #98fb98;">resource_size_t</span> <span style="color: #eedd82;">start</span>;
        <span style="color: #98fb98;">resource_size_t</span> <span style="color: #eedd82;">end</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">flags</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">resource</span> *<span style="color: #eedd82;">parent</span>, *<span style="color: #eedd82;">sibling</span>, *<span style="color: #eedd82;">child</span>;
};
</pre>
</div>

<p>
这个结构提供了：
</p>
<ol class="org-ol">
<li><p>
资源占用的从 start 到 end 的地址范围
</p>
<pre class="example" id="org5fd8ccf">
resource_size_t 是 phys_addr_t 类型，在 x86_64 架构上是 u64
</pre></li>
<li><p>
资源名
</p>
<pre class="example" id="orga67c58b">
可以在 /proc/iomem 输出中看到
</pre></li>
<li>资源标记，定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/ioport.h">include/linux/ioport.h</a> 文件中</li>
<li><p>
最后三个是资源结构体指针，如下图所示：
</p>
<pre class="example" id="org9ca8a03">
+-------------+      +-------------+
|             |      |             |
|    parent   |------|    sibling  |
|             |      |             |
+-------------+      +-------------+
       |
       |
+-------------+
|             |
|    child    | 
|             |
+-------------+
</pre></li>
</ol>

<p>
每个资源子集有自己的 <b>根范围</b> 资源。iomem 的资源 <b>iomem_resource</b> 的定义是：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">resource</span> <span style="color: #eedd82;">iomem_resource</span> = {
        .name   = <span style="color: #ffa07a;">"PCI mem"</span>,
        .start  = 0,
        .end    = -1,
        .flags  = IORESOURCE_MEM,
};

<span style="color: #87cefa;">EXPORT_SYMBOL</span>(iomem_resource);
TODO EXPORT_SYMBOL
</pre>
</div>

<p>
iomem_resource 利用 <b>PCI mem</b> 作为 <span class="underline">名字</span> 和 <b>IORESOURCE_MEM</b> <span class="underline">0x00000200</span> <span class="underline">标记</span> 定义了 io 内存的根地址范围。就像上文提到的，目前的目的是设置 iomem 的结束地址，需要这样做：
</p>

<div class="org-src-container">
<pre class="src src-c">iomem_resource.end = (1ULL &lt;&lt; boot_cpu_data.x86_phys_bits) - 1; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;1&#24038;&#31227; boot_cpu_data.x86_phys_bits &#20301;</span>
</pre>
</div>

<pre class="example" id="orgeeee2c6">
boot_cpu_data 是在执行 early_cpu_init 的时候初始化的 cpuinfo_x86 结构

从字面理解，x86_phys_bits 代表系统可达到的最大内存地址时需要的比特数

另外，iomem_resource 是通过 EXPORT_SYMBOL 宏传递的

这个宏可以把指定的符号（例如 iomem_resource）做动态链接

换句话说，它可以支持动态加载模块的时候访问对应符号
</pre>

<p>
设置完根 iomem 的资源地址范围的结束地址后，下一步就是设置内存映射。它通过调用 <b>setup_memory_map</b> 函数实现：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__init</span> setup_memory_map(<span style="color: #98fb98;">void</span>)
{
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">who</span>;

        who = x86_init.resources.memory_setup();
        memcpy(&amp;e820_saved, &amp;e820, <span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">e820map</span>));
        printk(KERN_INFO <span style="color: #ffa07a;">"e820: BIOS-provided physical RAM map:\n"</span>);
        e820_print_map(who);
}
</pre>
</div>

<p>
首先，来看下 <b>x86_init.resources.memory_setup</b> 。x86_init 是一种 <b>x86_init_ops 类型</b> 的结构体，用来表示 <span class="underline">资源初始化</span> ，pci 初始化平台特定的一些设置函数。 x86_init 的初始化实现在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c">arch/x86/kernel/x86_init.c</a> 文件中。不会全部解释这个初始化过程，因为只关心一个地方：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">x86_init_ops</span> <span style="color: #eedd82;">x86_init</span> __initdata = {
                .resources = {
                                .probe_roms             = probe_roms,
                                .reserve_resources      = reserve_standard_io_resources,
                                .memory_setup           = default_machine_specific_memory_setup,
                },
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
}
</pre>
</div>

<p>
这里的 memory_setup 赋值为 <b>default_machine_specific_memory_setup</b> ，它是我们在对 内核启动 过程中的所有 <a href="https://en.wikipedia.org/wiki/E820">e820</a> 条目经过整理和把内存分区填入 <b>e820map</b> 结构体中获得的。 所有收集的内存分区会用 printk 打印出来。可以通过运行 dmesg 命令找到类似于下面的信息：
</p>

<pre class="example" id="org63c5aca">
[    0.000000] e820: BIOS-provided physical RAM map:
[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009d7ff] usable
[    0.000000] BIOS-e820: [mem 0x000000000009d800-0x000000000009ffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000000e0000-0x00000000000fffff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x00000000be825fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000be826000-0x00000000be82cfff] ACPI NVS
[    0.000000] BIOS-e820: [mem 0x00000000be82d000-0x00000000bf744fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000bf745000-0x00000000bfff4fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000bfff5000-0x00000000dc041fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000dc042000-0x00000000dc0d2fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000dc0d3000-0x00000000dc138fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000dc139000-0x00000000dc27dfff] ACPI NVS
[    0.000000] BIOS-e820: [mem 0x00000000dc27e000-0x00000000deffefff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000defff000-0x00000000deffffff] usable
...
...
...
</pre>
</div>
</div>
<div id="outline-container-orgd6bb984" class="outline-2">
<h2 id="orgd6bb984">复制 BIOS 增强磁盘设备信息</h2>
<div class="outline-text-2" id="text-orgd6bb984">
<p>
下面通过 <b>parse_setup_data</b> 函数解析 setup_data，并且把 BIOS 的 <span class="underline">EDD</span> 信息复制到安全的地方。 <b>setup_data</b> 是 <span class="underline">内核启动头</span> 中包含的字段，可以在 x86 的启动协议中了解：
</p>
<pre class="example" id="orgd391fae">
Field name:	setup_data
Type:		write (special)
Offset/size:	0x250/8
Protocol:	2.09+

  The 64-bit physical pointer to NULL terminated single linked list of
  struct setup_data. This is used to define a more extensible boot  
  parameters passing mechanism.

它用来存储不同类型的设置信息，例如设备树 blob，EFI 设置数据等等
</pre>


<p>
第二步是从 boot_params 结构里的 BIOS 的 EDD 信息 复制到 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/edd.c">arch/x86/boot/edd.c</a> 的 <b>edd 结构</b> 中
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__init</span> copy_edd(<span style="color: #98fb98;">void</span>)
{
                memcpy(edd.mbr_signature, boot_params.edd_mbr_sig_buffer,
                           <span style="color: #00ffff;">sizeof</span>(edd.mbr_signature));
                memcpy(edd.edd_info, boot_params.eddbuf, <span style="color: #00ffff;">sizeof</span>(edd.edd_info));
                edd.mbr_signature_nr = boot_params.edd_mbr_sig_buf_entries;
                edd.edd_info_nr = boot_params.eddbuf_entries;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0e6ea38" class="outline-2">
<h2 id="org0e6ea38">内存描述符初始化</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
