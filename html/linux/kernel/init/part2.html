<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>初始化中断</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./part1.html"> UP </a>
 |
 <a accesskey="H" href="./init.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">初始化中断</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2be97e5">中断</a></li>
<li><a href="#org46ac97d">设置并加载 IDT</a></li>
<li><a href="#orge5f066a">初期中断处理程序</a>
<ul>
<li><a href="#org7fba829">缺页中断处理程序</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example" id="orgac92379">
目前已经处于解压缩后的Linux内核中了，有了用于初期启动的基本的 分页 机制

目标是在内核的主体代码执行前做好准备工作

接下来会继续分析关于中断和异常处理部分的代码
</pre>

<p>
上一部分最后来到了下面这个循环：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
                <span style="color: #87cefa;">set_intr_gate</span>(i, <span style="color: #98fb98;">early_idt_handler_array</span>[i]);
</pre>
</div>

<p>
这段代码位于 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a>
</p>

<pre class="example" id="org4f87a28">
在分析这段代码之前，先来了解一些关于中断和中断处理程序的知识
</pre>
<div id="outline-container-org2be97e5" class="outline-2">
<h2 id="org2be97e5">中断</h2>
<div class="outline-text-2" id="text-org2be97e5">
<p>
<b>中断</b> 是一种由 <span class="underline">软件</span> 或 <span class="underline">硬件</span> 产生的、向 <span class="underline">CPU</span> 发出的 <b>事件</b>
</p>
<pre class="example" id="org7562a26">
例如，如果用户按下了键盘上的一个按键时，就会产生中断
</pre>

<p>
此时CPU将会暂停当前的任务，并且将控制流转到特殊的程序中 <a href="https://en.wikipedia.org/wiki/Interrupt_handler">中断处理程序</a> <span class="underline">Interrupt Handler</span> 。一个中断处理程序会对中断进行处理，然后将控制权交还给之前暂停的任务中。中断分为三类：
</p>
<ol class="org-ol">
<li><p>
软件中断：当一个软件可以向CPU发出信号，表明它需要系统内核的相关功能时产生
</p>
<pre class="example" id="orgfdf986d">
这些中断通常用于系统调用
</pre></li>
<li><p>
硬件中断：当一个硬件有任何事件发生时产生
</p>
<pre class="example" id="orga56ebd9">
例如键盘的按键被按下
</pre></li>
<li><p>
异常：当CPU检测到错误时产生
</p>
<pre class="example" id="orgbef04bf">
例如 发生了除零错误或者访问了一个不存在的内存页
</pre></li>
</ol>

<p>
每一个中断和异常都可以由一个数来表示，这个数叫做 <b>向量号</b> ，它可以取从 <span class="underline">0</span> 到 <span class="underline">255</span> 中的任何一个数
</p>
<pre class="example" id="org176a82d">
通常在实践中前 32 个向量号用来表示异常，32 到 255 用来表示用户定义的中断
</pre>

<p>
在上面的代码中， <b>NUM_EXCEPTION_VECTORS</b> 就定义为：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUM_EXCEPTION_VECTORS</span> 32
</pre>
</div>

<p>
CPU会从 <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> 或者 CPU 引脚接收中断，并使用中断向量号作为 <b>中断描述符表</b> 的索引。下面的表中列出了 0-31 号异常：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 中断描述符表</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Vector</th>
<th scope="col" class="org-left">Mnemonic</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Error Code</th>
<th scope="col" class="org-left">Source</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">#DE</td>
<td class="org-left">Divide Error</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">DIV and IDIV</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">#DB</td>
<td class="org-left">Reserved</td>
<td class="org-left">F/T</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-left">---</td>
<td class="org-left">NMI</td>
<td class="org-left">INT</td>
<td class="org-left">NO</td>
<td class="org-left">external NMI</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">#BP</td>
<td class="org-left">Breakpoint</td>
<td class="org-left">Trap</td>
<td class="org-left">NO</td>
<td class="org-left">INT 3</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-left">#OF</td>
<td class="org-left">Overflow</td>
<td class="org-left">Trap</td>
<td class="org-left">NO</td>
<td class="org-left">INTO  instruction</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-left">#BR</td>
<td class="org-left">Bound Range Exceeded</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">BOUND instruction</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">6</td>
<td class="org-left">#UD</td>
<td class="org-left">Invalid Opcode</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">UD2 instruction</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">7</td>
<td class="org-left">#NM</td>
<td class="org-left">Device Not Available</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">Floating point or [F]WAIT</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">8</td>
<td class="org-left">#DF</td>
<td class="org-left">Double Fault</td>
<td class="org-left">Abort</td>
<td class="org-left">YES</td>
<td class="org-left">Ant instrctions which can generate NMI</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">9</td>
<td class="org-left">---</td>
<td class="org-left">Reserved</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">10</td>
<td class="org-left">#TS</td>
<td class="org-left">Invalid TSS</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Task switch or TSS access</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">11</td>
<td class="org-left">#NP</td>
<td class="org-left">Segment Not Present</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">Accessing segment register</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">12</td>
<td class="org-left">#SS</td>
<td class="org-left">Stack-Segment Fault</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Stack operations</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">13</td>
<td class="org-left">#GP</td>
<td class="org-left">General Protection</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Memory reference</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">14</td>
<td class="org-left">#PF</td>
<td class="org-left">Page fault</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Memory reference</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">15</td>
<td class="org-left">---</td>
<td class="org-left">Reserved</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">16</td>
<td class="org-left">#MF</td>
<td class="org-left">x87 FPU fp error</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">Floating point or [F]Wait</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">17</td>
<td class="org-left">#AC</td>
<td class="org-left">Alignment Check</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Data reference</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">18</td>
<td class="org-left">#MC</td>
<td class="org-left">Machine Check</td>
<td class="org-left">Abort</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">19</td>
<td class="org-left">#XM</td>
<td class="org-left">SIMD fp exception</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">SSE[2,3] instructions</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">20</td>
<td class="org-left">#VE</td>
<td class="org-left">Virtualization exc.</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">EPT violations</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">21-31</td>
<td class="org-left">---</td>
<td class="org-left">Reserved</td>
<td class="org-left">INT</td>
<td class="org-left">NO</td>
<td class="org-left">External interrupts</td>
</tr>
</tbody>
</table>

<p>
为了能够对中断进行处理，CPU使用了一种特殊的结构 <b>中断描述符表</b> <span class="underline">IDT</span> 。IDT 是一个由 <b>描述符</b> 组成的数组，其中每个描述符都为 <span class="underline">8个字节</span> ，与全局描述附表一致；不过不同的是，把IDT中的每一项叫做 <b>门</b> <span class="underline">gate</span>
</p>
<ul class="org-ul">
<li>为了获得某一项描述符的起始地址，CPU 会把向量号乘以8，在64位模式中则会乘以16</li>
<li>CPU使用一个特殊的 GDTR 寄存器来存放全局描述符表的地址，中断描述符表也有一个类似的 <b>寄存器</b> <span class="underline">IDTR</span> ，同时还有用于将基地址加载入这个寄存器的指令 <b>lidt</b></li>
</ul>

<p>
64位模式下 IDT 的每一项的结构如下：
</p>
<pre class="example" id="org4c3118b">
127                                                                             96
 --------------------------------------------------------------------------------
|                                                                               |
|                                Reserved                                       |
|                                                                               |
 --------------------------------------------------------------------------------
95                                                                              64
 --------------------------------------------------------------------------------
|                                                                               |
|                               Offset 63..32                                   |
|                                                                               |
 --------------------------------------------------------------------------------
63                               48 47      46  44   42    39             34    32
 --------------------------------------------------------------------------------
|                                  |       |  D  |   |     |      |   |   |     |
|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
|                                  |       |  L  |   |     |      |   |   |     |
 --------------------------------------------------------------------------------
31                                   15 16                                      0
 --------------------------------------------------------------------------------
|                                      |                                        |
|          Segment Selector            |                 Offset 15..0           |
|                                      |                                        |
 --------------------------------------------------------------------------------
</pre>

<p>
其中:
</p>
<ul class="org-ul">
<li>Offset: 到中断处理程序入口点的偏移</li>
<li>DPL: 描述符特权级别</li>
<li>P: Segment Present 标志</li>
<li>Segment selector: 在GDT或LDT中的代码段选择子</li>
<li>IST: 用来为中断处理提供一个新的栈</li>
<li>Type 域描述了这一项的类型，中断处理程序共分为三种：
<ul class="org-ul">
<li>任务描述符</li>
<li><p>
中断描述符：中断和陷阱描述符包含了一个指向中断处理程序的 <b>远</b> <span class="underline">far</span> 指针。二者唯一的不同在于CPU处理 <b>IF 标志</b> 
</p>
<pre class="example" id="org70a21b1">
如果是由中断门进入中断处理程序的，CPU 会清除 IF 标志位

这样当当前中断处理程序执行时，CPU 不会对其他的中断进行处理

只有当当前的中断处理程序返回时，CPU 才在 iret 指令执行时重新设置 IF 标志位
</pre></li>
<li>陷阱描述符</li>
</ul></li>
</ul>

<p>
接下来看一下 CPU 是如何处理中断的：
</p>
<ul class="org-ul">
<li>CPU 会在 <span class="underline">栈</span> 上保存 <b>标志寄存器</b> 、 <b>cs段寄存器</b> 和 <b>程序计数器IP</b></li>
<li>如果中断是由错误码引起的（比如 #PF）， CPU会在栈上保存 <b>错误码</b></li>
<li>在中断处理程序执行完毕后，由 <b>iret</b> 指令返回</li>
</ul>
</div>
</div>
<div id="outline-container-org46ac97d" class="outline-2">
<h2 id="org46ac97d">设置并加载 IDT</h2>
<div class="outline-text-2" id="text-org46ac97d">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
                <span style="color: #87cefa;">set_intr_gate</span>(i, <span style="color: #98fb98;">early_idt_handler_array</span>[i]);
</pre>
</div>

<p>
这里循环内部调用了 <b>set_intr_gate</b> ，它接受两个参数：
</p>
<ol class="org-ol">
<li>中断号，即 <b>向量号</b></li>
<li>中断处理程序的地址</li>
</ol>

<p>
同时，这个函数还会将 <span class="underline">中断门</span> <b>插入</b> 至 <span class="underline">IDT</span> 表中，代码中的 <b>&amp;idt_descr 数组</b> 即为 IDT
</p>

<p>
首先来看一下 <b>early_idt_handler_array 数组</b> ，它定义在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/include/asm/segment.h">arch/x86/include/asm/segment.h</a> 头文件中，包含了前32个异常处理程序的地址：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">EARLY_IDT_HANDLER_SIZE</span>   9
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUM_EXCEPTION_VECTORS</span>   32

<span style="color: #00ffff;">extern</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">early_idt_handler_array</span>[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];
</pre>
</div>

<p>
<b>early_idt_handler_array</b> 是一个大小为 <span class="underline">288 字节</span> 的数组，每一项为 <span class="underline">9 个字节</span> ，其中
</p>
<ul class="org-ul">
<li>2个字节的备用指令：向栈中 <b>压入</b> <span class="underline">默认错误码</span> （如果异常本身没有提供错误码的话）</li>
<li>2个字节的指令：向栈中 <b>压入</b> <span class="underline">向量号</span></li>
<li>剩余5个字节： <b>跳转</b> 到 <span class="underline">异常处理程序</span></li>
</ul>

<pre class="example" id="org1edbb6b">
在上面的代码中，通过一个循环向 IDT 中填入了前32项内容，这是因为在整个初期设置阶段，中断是禁用的

early_idt_handler_array 数组中的每一项指向的都是同一个通用中断处理程序，定义在 arch/x86/kernel/head_64.S 
</pre>

<p>
先暂时跳过这个数组的内容，看一下 <b>set_intr_gate</b> 的定义。set_intr_gate 宏定义在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">set_intr_gate</span>(<span style="color: #eedd82;">n</span>, <span style="color: #eedd82;">addr</span>)                                          \
                <span style="color: #00ffff;">do</span> {                                                            \
                                BUG_ON((<span style="color: #98fb98;">unsigned</span>)n &gt; 0xFF);                             \
                                _set_gate(n, GATE_INTERRUPT, (<span style="color: #98fb98;">void</span> *)addr, 0, 0,        \
                                                  __KERNEL_CS);                                 \
                                _trace_set_gate(n, GATE_INTERRUPT, (<span style="color: #98fb98;">void</span> *)trace_##addr, \
                                                                0, 0, __KERNEL_CS);                     \
                } <span style="color: #00ffff;">while</span> (0)
</pre>
</div>

<pre class="example" id="org175ca26">
BUG_ON 宏确保了传入的中断向量号不会大于255，因为最多只有 256 个中断
</pre>

<p>
调用了 <b>_set_gate</b> 函数，它会将中断门写入 IDT：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">_set_gate</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gate</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">type</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>,
                                 <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">dpl</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">ist</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">seg</span>)
{
                <span style="color: #98fb98;">gate_desc</span> <span style="color: #eedd82;">s</span>;
                pack_gate(&amp;s, type, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)addr, dpl, ist, seg);
                write_idt_entry(idt_table, gate, &amp;s);
                write_trace_idt_entry(gate, &amp;s);
}
</pre>
</div>

<p>
在 _set_gate 函数的开始，它调用了 <b>pack_gate</b> 函数。这个函数会使用给定的参数填充 <b>gate_desc 结构</b> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pack_gate</span>(<span style="color: #98fb98;">gate_desc</span> *<span style="color: #eedd82;">gate</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">type</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">func</span>,
                             <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">dpl</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">ist</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">seg</span>)
{
        gate-&gt;offset_low        = PTR_LOW(func);
        gate-&gt;segment           = __KERNEL_CS;
        gate-&gt;ist               = ist;
        gate-&gt;p                 = 1;
        gate-&gt;dpl               = dpl;
        gate-&gt;zero0             = 0;
        gate-&gt;zero1             = 0;
        gate-&gt;type              = type;
        gate-&gt;offset_middle     = PTR_MIDDLE(func);
        gate-&gt;offset_high       = PTR_HIGH(func);
}
</pre>
</div>

<p>
这里把从主循环中得到的中断处理程序入口点地址拆成三个部分，填入门描述符中。下面的三个宏就用来做这个拆分工作：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">PTR_LOW</span>(<span style="color: #eedd82;">x</span>) ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)(x) &amp; 0xFFFF) 
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">PTR_MIDDLE</span>(<span style="color: #eedd82;">x</span>) (((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)(x) &gt;&gt; 16) &amp; 0xFFFF)
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">PTR_HIGH</span>(<span style="color: #eedd82;">x</span>) ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)(x) &gt;&gt; 32)
</pre>
</div>

<pre class="example" id="org4652492">
调用 PTR_LOW 可以得到 x 的低 2 个字节

调用 PTR_MIDDLE 可以得到 x 的中间 2 个字节

调用 PTR_HIGH 则能够得到 x 的高 4 个字节

接下来中断处理程序设置段选择子，即内核代码段 __KERNEL_CS

将 Interrupt Stack Table 和 描述符特权等级 （最高特权等级）设置为0

最后设置 GAT_INTERRUPT 类型
</pre>

<p>
现在已经设置好了IDT中的一项，那么通过调用 <b>native_write_idt_entry</b> 函数来把复制到 IDT：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">native_write_idt_entry</span>(<span style="color: #98fb98;">gate_desc</span> *<span style="color: #eedd82;">idt</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">entry</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">gate_desc</span> *<span style="color: #eedd82;">gate</span>)
{
        memcpy(&amp;idt[entry], gate, <span style="color: #00ffff;">sizeof</span>(*gate));
}
</pre>
</div>

<pre class="example" id="org803b35c">
主循环结束后，idt_table 就已经设置完毕了
</pre>

<p>
然后就可以通过下面的代码 <b>加载</b> <span class="underline">中断描述符表</span> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">load_idt</span>((<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">desc_ptr</span> *)&amp;idt_descr);
</pre>
</div>

<p>
<b>idt_descr</b> 为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">desc_ptr</span> <span style="color: #eedd82;">idt_descr</span> = { NR_VECTORS * 16 - 1, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>) idt_table };
</pre>
</div>

<p>
load_idt 函数只是执行了一下 <b>lidt</b> 指令：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">asm</span> <span style="color: #00ffff;">volatile</span>(<span style="color: #ffa07a;">"lidt %0"</span>::<span style="color: #ffa07a;">"m"</span> (*dtr));
</pre>
</div>

<pre class="example" id="org2edc28f">
在代码中还有对 _trace_* 函数的调用。这些函数会用跟 _set_gate 同样的方法对 IDT 门进行设置，但仅有一处不同

这些函数并不设置 idt_table ，而是 trace_idt_table ，用于设置追踪点（tracepoint，将会在其他章节介绍这一部分）。

好了，至此已经了解到，通过设置并加载 中断描述符表 ，能够让CPU在发生中断时做出相应的动作

下面来看一下如何编写中断处理程序
</pre>
</div>
</div>
<div id="outline-container-orge5f066a" class="outline-2">
<h2 id="orge5f066a">初期中断处理程序</h2>
<div class="outline-text-2" id="text-orge5f066a">
<p>
在上面的代码中，用 <b>early_idt_handler_array</b> 的地址来填充了 <span class="underline">IDT</span> ，这个 early_idt_handler_array 定义在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a>：
</p>

<div class="org-src-container">
<pre class="src src-asm">        <span style="color: #00ffff;">.globl</span> early_idt_handler_array
<span style="color: #87cefa;">early_idt_handlers</span>:
        <span style="color: #00ffff;">i</span> = 0
        <span style="color: #00ffff;">.rept</span> NUM_EXCEPTION_VECTORS
        <span style="color: #00ffff;">.if</span> (EXCEPTION_ERRCODE_MASK &gt;&gt; i) &amp; 1
        <span style="color: #00ffff;">pushq</span> $0
        <span style="color: #00ffff;">.endif</span>
        <span style="color: #00ffff;">pushq</span> $i
        <span style="color: #00ffff;">jmp</span> early_idt_handler_common
        <span style="color: #00ffff;">i</span> = i + 1
        <span style="color: #00ffff;">.fill</span> early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc
        <span style="color: #00ffff;">.endr</span>
</pre>
</div>

<p>
这段代码自动为前 32 个异常生成了中断处理程序：
</p>
<ol class="org-ol">
<li>首先，为了统一栈的布局，如果一个异常没有返回错误码，那么就手动在栈中压入一个 0</li>
<li>再在栈中压入中断向量号</li>
<li>跳转至通用的中断处理程序 <b>early_idt_handler_common</b></li>
</ol>

<p>
可以通过 objdump 命令的输出一探究竟：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ objdump -D vmlinux
...
...
...
ffffffff81fe5000 &lt;early_idt_handler_array&gt;:
ffffffff81fe5000:       6a 00                   pushq  $<span style="color: #eedd82;">0</span>x0
ffffffff81fe5002:       6a 00                   pushq  $<span style="color: #eedd82;">0</span>x0
ffffffff81fe5004:       e9 17 01 00 00          jmpq   ffffffff81fe5120 &lt;early_idt_handler_common&gt;
ffffffff81fe5009:       6a 00                   pushq  $<span style="color: #eedd82;">0</span>x0
ffffffff81fe500b:       6a 01                   pushq  $<span style="color: #eedd82;">0</span>x1
ffffffff81fe500d:       e9 0e 01 00 00          jmpq   ffffffff81fe5120 &lt;early_idt_handler_common&gt;
ffffffff81fe5012:       6a 00                   pushq  $<span style="color: #eedd82;">0</span>x0
ffffffff81fe5014:       6a 02                   pushq  $<span style="color: #eedd82;">0</span>x2
...
...
...
</pre>
</div>

<p>
由于在中断发生时，CPU 会自动在栈上压入 <span class="underline">标志寄存器</span> 、 <span class="underline">CS 段寄存器</span> 和 <span class="underline">RIP 寄存器</span> 的内容。因此在 early_idt_handler 执行前，栈的布局如下：
</p>

<pre class="example" id="orgadf3ebc">
|--------------------|
| %rflags            |
| %cs                |
| %rip               |
| rsp --&gt; error code |
|--------------------|
</pre>

<p>
下面来看一下 early_idt_handler_common 的实现。它也定义在  <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> 文件中。首先它会检查当前中断是否为 <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">不可屏蔽中断</a> <span class="underline">NMI</span> ，如果是则简单地忽略它们：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">cmpl</span> <span style="color: #00ffff;">$2</span>,(<span style="color: #eedd82;">%rsp</span>)
<span style="color: #87cefa;">je</span> .Lis_nmi
</pre>
</div>

<p>
其中 <b>is_nmi</b> 为:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">is_nmi</span>:
        <span style="color: #00ffff;">addq</span> $16,<span style="color: #eedd82;">%rsp</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20174;&#26632;&#39030;&#24377;&#20986;&#38169;&#35823;&#30721;&#21644;&#20013;&#26029;&#21521;&#37327;&#21495;</span>
        <span style="color: #00ffff;">INTERRUPT_RETURN</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35843;&#29992; INTERRUPT_RETURN &#65292;&#21363; iretq &#25351;&#20196;&#30452;&#25509;&#36820;&#22238;</span>
</pre>
</div>

<p>
如果当前中断不是 NMI ，则首先检查 <b>early_recursion_flag</b> 以避免在 early_idt_handler_common 程序中递归地产生中断。如果一切都没问题，就先在 <span class="underline">栈上</span> <b>保存</b> <span class="underline">通用寄存器</span> ，为了防止中断返回时寄存器的内容错乱：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%rax</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%rcx</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%rdx</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%rsi</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%rdi</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%r8</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%r9</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%r10</span>
<span style="color: #87cefa;">pushq</span> <span style="color: #00ffff;">%r11</span>
</pre>
</div>

<p>
然后检查栈上的 <span class="underline">段选择子</span> ：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">cmpl</span> <span style="color: #00ffff;">$</span>__KERNEL_CS,96(<span style="color: #eedd82;">%rsp</span>) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27573;&#36873;&#25321;&#23376;&#24517;&#39035;&#20026;&#20869;&#26680;&#20195;&#30721;&#27573;&#65292;&#22914;&#26524;&#19981;&#26159;&#21017;&#36339;&#36716;&#21040;&#26631;&#31614; 11 </span>
<span style="color: #87cefa;">jne</span> <span style="color: #00ffff;">11f</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#36755;&#20986; PANIC &#20449;&#24687;&#24182;&#25171;&#21360;&#26632;&#30340;&#20869;&#23481;</span>
</pre>
</div>


<p>
然后检查向量号，如果是 <b>#PF</b> 即 <a href="https://en.wikipedia.org/wiki/Page_fault">缺页中断</a> <span class="underline">Page Fault</span> ，那么就把 <b>cr2 寄存器</b> 中的值赋值给 <b>rdi</b> ，然后调用 <b>early_make_pgtable</b> ：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">cmpl</span> <span style="color: #00ffff;">$14</span>,72(<span style="color: #eedd82;">%rsp</span>)
<span style="color: #87cefa;">jnz</span> <span style="color: #00ffff;">10f</span>
<span style="color: #87cefa;">GET_CR2_INTO</span>(<span style="color: #eedd82;">%rdi</span>) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25226; cr2 &#23492;&#23384;&#22120;&#20013;&#30340;&#20540;&#36171;&#20540;&#32473; rdi</span>
<span style="color: #87cefa;">call</span> <span style="color: #00ffff;">early</span>_make_pgtable <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35843;&#29992; early_make_pgtable</span>
<span style="color: #87cefa;">andl</span> <span style="color: #00ffff;">%eax</span>,<span style="color: #eedd82;">%eax</span>
<span style="color: #87cefa;">jz</span> <span style="color: #00ffff;">20f</span>
</pre>
</div>

<p>
如果向量号不是 #PF ，那么就恢复通用寄存器：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%r11</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%r10</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%r9</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%r8</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%rdi</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%rsi</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%rdx</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%rcx</span>
<span style="color: #87cefa;">popq</span> <span style="color: #00ffff;">%rax</span>
</pre>
</div>

<p>
并调用 <b>iret</b> 从中断处理程序返回
</p>

<pre class="example" id="org3819375">
第一个中断处理程序到这里就结束了

由于它只是一个初期中段处理程序，因此只处理缺页中断

下面首先来看一下缺页中断处理程序，其他中断的处理程序之后再进行分析
</pre>
</div>
<div id="outline-container-org7fba829" class="outline-3">
<h3 id="org7fba829">缺页中断处理程序</h3>
<div class="outline-text-3" id="text-org7fba829">
<pre class="example" id="org337d961">
前面第一次见到了初期中断处理程序，它检查了缺页中断的中断号，并调用了 early_make_pgtable 来建立新的页表

接下来需要提供 #PF 中断处理程序，以便为之后将内核加载至 4G 地址以上，并且能访问位于4G以上的 boot_params 结构体
</pre>

<p>
early_make_pgtable 的实现在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a> ，它接受一个参数： <span class="underline">cr2 寄存器得到的地址</span> ，这个地址引发了 <b>内存中断</b> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">__init</span> early_make_pgtable(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> address)
{
                <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">physaddr</span> = address - __PAGE_OFFSET;
                <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">i</span>;
                <span style="color: #98fb98;">pgdval_t</span> <span style="color: #eedd82;">pgd</span>, *<span style="color: #eedd82;">pgd_p</span>;
                <span style="color: #98fb98;">pudval_t</span> <span style="color: #eedd82;">pud</span>, *<span style="color: #eedd82;">pud_p</span>;
                <span style="color: #98fb98;">pmdval_t</span> <span style="color: #eedd82;">pmd</span>, *<span style="color: #eedd82;">pmd_p</span>;
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
}
</pre>
</div>

<p>
首先它定义了一些 <b>val_t</b> 类型的变量。这些类型均为：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>   <span style="color: #98fb98;">pgdval_t</span>;
</pre>
</div>

<p>
这些类型都定义在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/include/asm/pgtable_types.h">arch/x86/include/asm/pgtable_types.h</a>，形式如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> { <span style="color: #98fb98;">pgdval_t</span> <span style="color: #eedd82;">pgd</span>; } <span style="color: #98fb98;">pgd_t</span>;
</pre>
</div>

<p>
例如：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">pgd_t</span> <span style="color: #eedd82;">early_level4_pgt</span>[PTRS_PER_PGD];
</pre>
</div>

<pre class="example" id="org8c417db">
这里的 early_level4_pgt 代表了 初期顶层页表目录 ，它是一个 pdg_t 类型的数组，

其中的 pgd 指向了 下一级页表
</pre>

<p>
在确认不是非法地址后，取得页表中包含引起 #PF 中断的地址的那一项，将其赋值给 pgd 变量：
</p>

<div class="org-src-container">
<pre class="src src-c">pgd_p = &amp;early_level4_pgt[pgd_index(address)].pgd;
pgd = *pgd_p;
</pre>
</div>

<p>
接下来检查一下 pgd ，如果它包含了正确的全局页表项的话，就把这一项的物理地址处理后赋值给 pud_p ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25226;&#20840;&#23616;&#39029;&#34920;&#20013;&#36825;&#19968;&#39033;&#30340;&#29289;&#29702;&#22320;&#22336;&#22788;&#29702;&#21518;&#36171;&#20540;&#32473; pud_p</span>
pud_p = (<span style="color: #98fb98;">pudval_t</span> *)((pgd &amp; PTE_PFN_MASK) + __START_KERNEL_map - phys_base); 
</pre>
</div>

<p>
其中 <b>PTE_PFN_MASK</b> 是一个宏：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">PTE_PFN_MASK</span>            ((<span style="color: #98fb98;">pteval_t</span>)PHYSICAL_PAGE_MASK)
</pre>
</div>

<p>
展开后将为：
</p>
<pre class="example" id="orgad96c4b">
(~(PAGE_SIZE-1)) &amp; ((1 &lt;&lt; 46) - 1) = 0b1111111111111111111111111111111111111111111111

它是一个46bit大小的页帧屏蔽值
</pre>

<p>
如果 pgd 没有包含有效的地址，就检查 <b>next_early_pgt</b> 与 <b>EARLY_DYNAMIC_PAGE_TABLES</b> (<span class="underline">64</span>)的大小。如果 next_early_pgt 比 EARLY_DYNAMIC_PAGE_TABLES 大，就用一个 <span class="underline">上层页目录指针</span> 指向 <span class="underline">当前的动态页表</span> ，并将它的 <b>物理地址</b> 与 <b>_KERNPG_TABLE 访问权限</b> 一起写入 <span class="underline">全局页目录表</span> ：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (next_early_pgt &gt;= EARLY_DYNAMIC_PAGE_TABLES) {
                reset_early_page_tables();
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">again</span>;
}

pud_p = (<span style="color: #98fb98;">pudval_t</span> *)<span style="color: #98fb98;">early_dynamic_pgts</span>[next_early_pgt++]; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#29992;&#19968;&#20010;&#19978;&#23618;&#39029;&#30446;&#24405;&#25351;&#38024;&#25351;&#21521;&#24403;&#21069;&#30340;&#21160;&#24577;&#39029;&#34920; </span>
<span style="color: #00ffff;">for</span> (i = 0; i &lt; PTRS_PER_PUD; i++)
                <span style="color: #98fb98;">pud_p</span>[i] = 0; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21021;&#22987;&#21270;&#24403;&#21069;&#21160;&#24577;&#39029;&#34920;</span>
*pgd_p = (<span style="color: #98fb98;">pgdval_t</span>)pud_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23558;&#23427;&#30340;&#29289;&#29702;&#22320;&#22336;&#19982; _KERPG_TABLE &#35775;&#38382;&#26435;&#38480;&#19968;&#36215;&#20889;&#20837;&#20840;&#23616;&#39029;&#30446;&#24405;&#34920;</span>
</pre>
</div>

<pre class="example" id="org082148d">
EARLY_DYNAMIC_PAGE_TABLES 它是一个固定大小的缓冲区，用来在需要的时候建立新的页表
</pre>

<p>
最后来修正上层页目录的地址：
</p>

<div class="org-src-container">
<pre class="src src-c">pud_p += pud_index(address);
pud = *pud_p;
</pre>
</div>

<p>
下面对 <b>中层页目录</b> 重复上面同样的操作
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (pud)
                pmd_p = (<span style="color: #98fb98;">pmdval_t</span> *)((pud &amp; PTE_PFN_MASK) + __START_KERNEL_map - phys_base);
<span style="color: #00ffff;">else</span> {
                <span style="color: #00ffff;">if</span> (next_early_pgt &gt;= EARLY_DYNAMIC_PAGE_TABLES) {
                                reset_early_page_tables();
                                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">again</span>;
                }

                pmd_p = (<span style="color: #98fb98;">pmdval_t</span> *)early_dynamic_pgts[next_early_pgt++];
                <span style="color: #00ffff;">for</span> (i = 0; i &lt; PTRS_PER_PMD; i++)
                                pmd_p[i] = 0;
                *pud_p = (<span style="color: #98fb98;">pudval_t</span>)pmd_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;
}

pmd = (physaddr &amp; PMD_MASK) + early_pmd_flags;
<span style="color: #98fb98;">pmd_p</span>[pmd_index(address)] = pmd;
</pre>
</div>

<pre class="example" id="org5e70844">
到此缺页中断处理程序就完成了它所有的工作

此时 early_level4_pgt 就包含了指向合法地址的项

接下来将会看到进入内核入口点 start_kernel 函数之前剩下所有的准备工作
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="part3.html">Next: 进入内核入口点之前最后的准备工作</a></td>
<td class="org-left"><a href="part1.html">Previous: 内核解压之后的首要步骤</a></td>
<td class="org-left"><a href="init.html">Home：内核初始化</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
