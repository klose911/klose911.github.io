<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>初始化中断</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./part1.html"> UP </a>
 |
 <a accesskey="H" href="./init.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">初始化中断</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2be97e5">中断</a></li>
<li><a href="#org46ac97d">设置并加载 IDT</a></li>
</ul>
</div>
</div>
<pre class="example" id="org6c836d7">
目前已经处于解压缩后的Linux内核中了，有了用于初期启动的基本的 分页 机制

目标是在内核的主体代码执行前做好准备工作

接下来会继续分析关于中断和异常处理部分的代码
</pre>

<p>
上一部分最后来到了下面这个循环：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
                <span style="color: #87cefa;">set_intr_gate</span>(i, <span style="color: #98fb98;">early_idt_handler_array</span>[i]);
</pre>
</div>

<p>
这段代码位于 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a>
</p>

<pre class="example" id="orgd82acc5">
在分析这段代码之前，先来了解一些关于中断和中断处理程序的知识
</pre>
<div id="outline-container-org2be97e5" class="outline-2">
<h2 id="org2be97e5">中断</h2>
<div class="outline-text-2" id="text-org2be97e5">
<p>
<b>中断</b> 是一种由 <span class="underline">软件</span> 或 <span class="underline">硬件</span> 产生的、向 <span class="underline">CPU</span> 发出的 <b>事件</b>
</p>
<pre class="example" id="orgf155516">
例如，如果用户按下了键盘上的一个按键时，就会产生中断
</pre>

<p>
此时CPU将会暂停当前的任务，并且将控制流转到特殊的程序中 <a href="https://en.wikipedia.org/wiki/Interrupt_handler">中断处理程序</a> <span class="underline">Interrupt Handler</span> 。一个中断处理程序会对中断进行处理，然后将控制权交还给之前暂停的任务中。中断分为三类：
</p>
<ol class="org-ol">
<li><p>
软件中断：当一个软件可以向CPU发出信号，表明它需要系统内核的相关功能时产生
</p>
<pre class="example" id="org40d6a33">
这些中断通常用于系统调用
</pre></li>
<li><p>
硬件中断：当一个硬件有任何事件发生时产生
</p>
<pre class="example" id="org9393058">
例如键盘的按键被按下
</pre></li>
<li><p>
异常：当CPU检测到错误时产生
</p>
<pre class="example" id="org6ad1687">
例如 发生了除零错误或者访问了一个不存在的内存页
</pre></li>
</ol>

<p>
每一个中断和异常都可以由一个数来表示，这个数叫做 <b>向量号</b> ，它可以取从 <span class="underline">0</span> 到 <span class="underline">255</span> 中的任何一个数
</p>
<pre class="example" id="org5c8565e">
通常在实践中前 32 个向量号用来表示异常，32 到 255 用来表示用户定义的中断
</pre>

<p>
在上面的代码中， <b>NUM_EXCEPTION_VECTORS</b> 就定义为：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUM_EXCEPTION_VECTORS</span> 32
</pre>
</div>

<p>
CPU会从 <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> 或者 CPU 引脚接收中断，并使用中断向量号作为 <b>中断描述符表</b> 的索引。下面的表中列出了 0-31 号异常：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 中断描述符表</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Vector</th>
<th scope="col" class="org-left">Mnemonic</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Error Code</th>
<th scope="col" class="org-left">Source</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">#DE</td>
<td class="org-left">Divide Error</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">DIV and IDIV</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">#DB</td>
<td class="org-left">Reserved</td>
<td class="org-left">F/T</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-left">---</td>
<td class="org-left">NMI</td>
<td class="org-left">INT</td>
<td class="org-left">NO</td>
<td class="org-left">external NMI</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">#BP</td>
<td class="org-left">Breakpoint</td>
<td class="org-left">Trap</td>
<td class="org-left">NO</td>
<td class="org-left">INT 3</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-left">#OF</td>
<td class="org-left">Overflow</td>
<td class="org-left">Trap</td>
<td class="org-left">NO</td>
<td class="org-left">INTO  instruction</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-left">#BR</td>
<td class="org-left">Bound Range Exceeded</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">BOUND instruction</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">6</td>
<td class="org-left">#UD</td>
<td class="org-left">Invalid Opcode</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">UD2 instruction</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">7</td>
<td class="org-left">#NM</td>
<td class="org-left">Device Not Available</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">Floating point or [F]WAIT</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">8</td>
<td class="org-left">#DF</td>
<td class="org-left">Double Fault</td>
<td class="org-left">Abort</td>
<td class="org-left">YES</td>
<td class="org-left">Ant instrctions which can generate NMI</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">9</td>
<td class="org-left">---</td>
<td class="org-left">Reserved</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">10</td>
<td class="org-left">#TS</td>
<td class="org-left">Invalid TSS</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Task switch or TSS access</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">11</td>
<td class="org-left">#NP</td>
<td class="org-left">Segment Not Present</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">Accessing segment register</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">12</td>
<td class="org-left">#SS</td>
<td class="org-left">Stack-Segment Fault</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Stack operations</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">13</td>
<td class="org-left">#GP</td>
<td class="org-left">General Protection</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Memory reference</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">14</td>
<td class="org-left">#PF</td>
<td class="org-left">Page fault</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Memory reference</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">15</td>
<td class="org-left">---</td>
<td class="org-left">Reserved</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">16</td>
<td class="org-left">#MF</td>
<td class="org-left">x87 FPU fp error</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">Floating point or [F]Wait</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">17</td>
<td class="org-left">#AC</td>
<td class="org-left">Alignment Check</td>
<td class="org-left">Fault</td>
<td class="org-left">YES</td>
<td class="org-left">Data reference</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">18</td>
<td class="org-left">#MC</td>
<td class="org-left">Machine Check</td>
<td class="org-left">Abort</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">19</td>
<td class="org-left">#XM</td>
<td class="org-left">SIMD fp exception</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">SSE[2,3] instructions</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">20</td>
<td class="org-left">#VE</td>
<td class="org-left">Virtualization exc.</td>
<td class="org-left">Fault</td>
<td class="org-left">NO</td>
<td class="org-left">EPT violations</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">21-31</td>
<td class="org-left">---</td>
<td class="org-left">Reserved</td>
<td class="org-left">INT</td>
<td class="org-left">NO</td>
<td class="org-left">External interrupts</td>
</tr>
</tbody>
</table>

<p>
为了能够对中断进行处理，CPU使用了一种特殊的结构 <b>中断描述符表</b> <span class="underline">IDT</span> 。IDT 是一个由 <b>描述符</b> 组成的数组，其中每个描述符都为 <span class="underline">8个字节</span> ，与全局描述附表一致；不过不同的是，把IDT中的每一项叫做 <b>门</b> <span class="underline">gate</span>
</p>
<ul class="org-ul">
<li>为了获得某一项描述符的起始地址，CPU 会把向量号乘以8，在64位模式中则会乘以16</li>
<li>CPU使用一个特殊的 GDTR 寄存器来存放全局描述符表的地址，中断描述符表也有一个类似的 <b>寄存器</b> <span class="underline">IDTR</span> ，同时还有用于将基地址加载入这个寄存器的指令 <b>lidt</b></li>
</ul>

<p>
64位模式下 IDT 的每一项的结构如下：
</p>
<pre class="example" id="org7d06286">
127                                                                             96
 --------------------------------------------------------------------------------
|                                                                               |
|                                Reserved                                       |
|                                                                               |
 --------------------------------------------------------------------------------
95                                                                              64
 --------------------------------------------------------------------------------
|                                                                               |
|                               Offset 63..32                                   |
|                                                                               |
 --------------------------------------------------------------------------------
63                               48 47      46  44   42    39             34    32
 --------------------------------------------------------------------------------
|                                  |       |  D  |   |     |      |   |   |     |
|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
|                                  |       |  L  |   |     |      |   |   |     |
 --------------------------------------------------------------------------------
31                                   15 16                                      0
 --------------------------------------------------------------------------------
|                                      |                                        |
|          Segment Selector            |                 Offset 15..0           |
|                                      |                                        |
 --------------------------------------------------------------------------------
</pre>

<p>
其中:
</p>
<ul class="org-ul">
<li>Offset: 到中断处理程序入口点的偏移</li>
<li>DPL: 描述符特权级别</li>
<li>P: Segment Present 标志</li>
<li>Segment selector: 在GDT或LDT中的代码段选择子</li>
<li>IST: 用来为中断处理提供一个新的栈</li>
<li>Type 域描述了这一项的类型，中断处理程序共分为三种：
<ul class="org-ul">
<li>任务描述符</li>
<li><p>
中断描述符：中断和陷阱描述符包含了一个指向中断处理程序的 <b>远</b> <span class="underline">far</span> 指针。二者唯一的不同在于CPU处理 <b>IF 标志</b> 
</p>
<pre class="example" id="org7f55543">
如果是由中断门进入中断处理程序的，CPU 会清除 IF 标志位

这样当当前中断处理程序执行时，CPU 不会对其他的中断进行处理

只有当当前的中断处理程序返回时，CPU 才在 iret 指令执行时重新设置 IF 标志位
</pre></li>
<li>陷阱描述符</li>
</ul></li>
</ul>

<p>
接下来看一下 CPU 是如何处理中断的：
</p>
<ul class="org-ul">
<li>CPU 会在 <span class="underline">栈</span> 上保存 <b>标志寄存器</b> 、 <b>cs段寄存器</b> 和 <b>程序计数器IP</b></li>
<li>如果中断是由错误码引起的（比如 #PF）， CPU会在栈上保存 <b>错误码</b></li>
<li>在中断处理程序执行完毕后，由 <b>iret</b> 指令返回</li>
</ul>
</div>
</div>
<div id="outline-container-org46ac97d" class="outline-2">
<h2 id="org46ac97d">设置并加载 IDT</h2>
<div class="outline-text-2" id="text-org46ac97d">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
                <span style="color: #87cefa;">set_intr_gate</span>(i, <span style="color: #98fb98;">early_idt_handler_array</span>[i]);
</pre>
</div>

<p>
这里循环内部调用了 <b>set_intr_gate</b> ，它接受两个参数：
</p>
<ol class="org-ol">
<li>中断号，即 <b>向量号</b></li>
<li>中断处理程序的地址</li>
</ol>

<p>
同时，这个函数还会将 <span class="underline">中断门</span> <b>插入</b> 至 <span class="underline">IDT</span> 表中，代码中的 <b>&amp;idt_descr 数组</b> 即为 IDT
</p>

<p>
首先来看一下 <b>early_idt_handler_array 数组</b> ，它定义在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/include/asm/segment.h">arch/x86/include/asm/segment.h</a> 头文件中，包含了前32个异常处理程序的地址：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">EARLY_IDT_HANDLER_SIZE</span>   9
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUM_EXCEPTION_VECTORS</span>   32

<span style="color: #00ffff;">extern</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">early_idt_handler_array</span>[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];
</pre>
</div>

<p>
<b>early_idt_handler_array</b> 是一个大小为 <span class="underline">288 字节</span> 的数组，每一项为 <span class="underline">9 个字节</span> ，其中
</p>
<ul class="org-ul">
<li>2个字节的备用指令：向栈中 <b>压入</b> <span class="underline">默认错误码</span> （如果异常本身没有提供错误码的话）</li>
<li>2个字节的指令：向栈中 <b>压入</b> <span class="underline">向量号</span></li>
<li>剩余5个字节：*跳转* 到 <span class="underline">异常处理程序</span></li>
</ul>

<pre class="example" id="org0871346">
在上面的代码中，通过一个循环向 IDT 中填入了前32项内容，这是因为在整个初期设置阶段，中断是禁用的

early_idt_handler_array 数组中的每一项指向的都是同一个通用中断处理程序，定义在 arch/x86/kernel/head_64.S 
</pre>

<p>
先暂时跳过这个数组的内容，看一下 <b>set_intr_gate</b> 的定义。set_intr_gate 宏定义在 <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">set_intr_gate</span>(<span style="color: #eedd82;">n</span>, <span style="color: #eedd82;">addr</span>)                                          \
                <span style="color: #00ffff;">do</span> {                                                            \
                                BUG_ON((<span style="color: #98fb98;">unsigned</span>)n &gt; 0xFF);                             \
                                _set_gate(n, GATE_INTERRUPT, (<span style="color: #98fb98;">void</span> *)addr, 0, 0,        \
                                                  __KERNEL_CS);                                 \
                                _trace_set_gate(n, GATE_INTERRUPT, (<span style="color: #98fb98;">void</span> *)trace_##addr, \
                                                                0, 0, __KERNEL_CS);                     \
                } <span style="color: #00ffff;">while</span> (0)
</pre>
</div>

<pre class="example" id="org7856119">
BUG_ON 宏确保了传入的中断向量号不会大于255，因为最多只有 256 个中断
</pre>

<p>
调用了 <b>_set_gate</b> 函数，它会将中断门写入 IDT：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">_set_gate</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gate</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">type</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>,
                                 <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">dpl</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">ist</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">seg</span>)
{
                <span style="color: #98fb98;">gate_desc</span> <span style="color: #eedd82;">s</span>;
                pack_gate(&amp;s, type, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)addr, dpl, ist, seg);
                write_idt_entry(idt_table, gate, &amp;s);
                write_trace_idt_entry(gate, &amp;s);
}
</pre>
</div>

<p>
在 _set_gate 函数的开始，它调用了 <b>pack_gate</b> 函数。这个函数会使用给定的参数填充 <b>gate_desc 结构</b> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pack_gate</span>(<span style="color: #98fb98;">gate_desc</span> *<span style="color: #eedd82;">gate</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">type</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">func</span>,
                             <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">dpl</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">ist</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">seg</span>)
{
        gate-&gt;offset_low        = PTR_LOW(func);
        gate-&gt;segment           = __KERNEL_CS;
        gate-&gt;ist               = ist;
        gate-&gt;p                 = 1;
        gate-&gt;dpl               = dpl;
        gate-&gt;zero0             = 0;
        gate-&gt;zero1             = 0;
        gate-&gt;type              = type;
        gate-&gt;offset_middle     = PTR_MIDDLE(func);
        gate-&gt;offset_high       = PTR_HIGH(func);
}
</pre>
</div>

<p>
这里把从主循环中得到的中断处理程序入口点地址拆成三个部分，填入门描述符中。下面的三个宏就用来做这个拆分工作：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">PTR_LOW</span>(<span style="color: #eedd82;">x</span>) ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)(x) &amp; 0xFFFF) 
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">PTR_MIDDLE</span>(<span style="color: #eedd82;">x</span>) (((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)(x) &gt;&gt; 16) &amp; 0xFFFF)
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">PTR_HIGH</span>(<span style="color: #eedd82;">x</span>) ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)(x) &gt;&gt; 32)
</pre>
</div>

<pre class="example" id="org2234a42">
调用 PTR_LOW 可以得到 x 的低 2 个字节

调用 PTR_MIDDLE 可以得到 x 的中间 2 个字节

调用 PTR_HIGH 则能够得到 x 的高 4 个字节

接下来中断处理程序设置段选择子，即内核代码段 __KERNEL_CS

将 Interrupt Stack Table 和 描述符特权等级 （最高特权等级）设置为0

最后设置 GAT_INTERRUPT 类型
</pre>

<p>
现在已经设置好了IDT中的一项，那么通过调用 <b>native_write_idt_entry</b> 函数来把复制到 IDT：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">native_write_idt_entry</span>(<span style="color: #98fb98;">gate_desc</span> *<span style="color: #eedd82;">idt</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">entry</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">gate_desc</span> *<span style="color: #eedd82;">gate</span>)
{
        memcpy(&amp;idt[entry], gate, <span style="color: #00ffff;">sizeof</span>(*gate));
}
</pre>
</div>

<pre class="example" id="orgf33a0f2">
主循环结束后，idt_table 就已经设置完毕了
</pre>

<p>
然后就可以通过下面的代码 <b>加载</b> <span class="underline">中断描述符表</span> ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">load_idt</span>((<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">desc_ptr</span> *)&amp;idt_descr);
</pre>
</div>

<p>
<b>idt_descr</b> 为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">desc_ptr</span> <span style="color: #eedd82;">idt_descr</span> = { NR_VECTORS * 16 - 1, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>) idt_table };
</pre>
</div>

<p>
load_idt 函数只是执行了一下 <b>lidt</b> 指令：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">asm</span> <span style="color: #00ffff;">volatile</span>(<span style="color: #ffa07a;">"lidt %0"</span>::<span style="color: #ffa07a;">"m"</span> (*dtr));
</pre>
</div>

<pre class="example" id="orgddb3e20">
在代码中还有对 _trace_* 函数的调用。这些函数会用跟 _set_gate 同样的方法对 IDT 门进行设置，但仅有一处不同

这些函数并不设置 idt_table ，而是 trace_idt_table ，用于设置追踪点（tracepoint，将会在其他章节介绍这一部分）。

好了，至此已经了解到，通过设置并加载 中断描述符表 ，能够让CPU在发生中断时做出相应的动作

下面来看一下如何编写中断处理程序
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
