<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>同步</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="exception.html"> UP </a>
 |
 <a accesskey="H" href="effj.html"> HOME </a>
</div><div id="content">
<h1 class="title">同步</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">访问共享的可变数据必须同步</a>
<ul>
<li><a href="#sec-1-1">共享总结</a></li>
</ul>
</li>
<li><a href="#sec-2">避免过度同步</a>
<ul>
<li><a href="#sec-2-1">难以预料的错误</a></li>
<li><a href="#sec-2-2">效率低下</a></li>
</ul>
</li>
<li><a href="#sec-3">并发工具优先于wait和notify</a>
<ul>
<li><a href="#sec-3-1">并发工具</a></li>
</ul>
</li>
<li><a href="#sec-4">线程安全性需要文档化</a>
<ul>
<li><a href="#sec-4-1">线程安全级别</a>
<ul>
<li><a href="#sec-4-1-1">私有成员加锁</a></li>
</ul>
</li>
<li><a href="#sec-4-2">线程安全文档的总结</a></li>
</ul>
</li>
<li><a href="#sec-5">谨慎使用延迟初始化</a>
<ul>
<li><a href="#sec-5-1">正常初始化</a></li>
<li><a href="#sec-5-2">实例成员延迟初始化</a>
<ul>
<li><a href="#sec-5-2-1">双重检查优化实例成员延迟访问的开销</a></li>
</ul>
</li>
<li><a href="#sec-5-3">静态成员延迟初始化</a></li>
<li><a href="#sec-5-4">延迟初始化总结</a></li>
</ul>
</li>
<li><a href="#sec-6">不要依赖于线程调度器</a></li>
<li><a href="#sec-7">永远不要使用线程组</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">访问共享的可变数据必须同步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步不仅是为了互斥，更是为了抱证修改的可见性
</p>

<p>
下面程序可能永远不会停止!
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Broken! - How long would you expect this program to run?</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">BrokenStopThread</span> {

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">stopRequested</span> = <span style="color: #7fffd4;">false</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
        <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">backgroundThread</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(() -&gt; {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
                <span style="color: #00ffff;">while</span> (!stopRequested) {
                    i++;
                }
            });
        backgroundThread.start();
        <span style="color: #7fffd4;">TimeUnit</span>.SECONDS.sleep(1);
        stopRequested = <span style="color: #7fffd4;">true</span>;
    }
}
</pre>
</div>

<p>
JVM可能会对循环进行优化。在缺少同步的情况下，一个线程修改了变量，其他线程或许永远无法读到修改后的值
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">while</span> (!done)
    i++;
<span style="color: #ff4500;">//</span><span style="color: #ff4500;">JVM&#20248;&#21270;&#25104;</span>
<span style="color: #00ffff;">if</span> (!done)
    <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>)
        i++;
</pre>
</div>

<p>
修复方法：使用synchronized方法代替变量
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Properly synchronized cooperative thread termination</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StopThread</span> {

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">stopRequested</span> = <span style="color: #7fffd4;">false</span>;

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">synchronized</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">requestStop</span>() {
        stopRequested = <span style="color: #7fffd4;">true</span>;
    }

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">synchronized</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">stopRequested</span>() {
        <span style="color: #00ffff;">return</span> stopRequested;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
        <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">backgroundThread</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(() -&gt; {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
                <span style="color: #00ffff;">while</span> (!stopRequested()) {
                    i++;
                }
            });
        backgroundThread.start();
        <span style="color: #7fffd4;">TimeUnit</span>.SECONDS.sleep(1);
        requestStop();
    }
}
</pre>
</div>

<p>
更好的解决方法:使用volatile变量
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Cooperative thread termination with a volatile field</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">VolatileStopThread</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">stopRequested</span> = <span style="color: #7fffd4;">false</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
        <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">backgroundThread</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(() -&gt; {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
                <span style="color: #00ffff;">while</span> (!stopRequested) {
                    i++;
                }
            });
        backgroundThread.start();
        <span style="color: #7fffd4;">TimeUnit</span>.SECONDS.sleep(1);
        stopRequested = <span style="color: #7fffd4;">true</span>;
    }
}
</pre>
</div>

<p>
然而volatile只保证了可见性，并没有保证互斥性，下面代码尽管在多线程环境下运行不会报错，但是结果很可能是错误的
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Broken - requires synchronization!</span>
<span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nextSerialNumber</span> = 0;
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">generateSerialNumber</span>() {
    <span style="color: #00ffff;">return</span> nextSerialNumber++;
}
</pre>
</div>

<p>
除了为generteSerialNumber添加synchronized关键字之外，可以使用Atomic变量代替volatile 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">AtomicLong</span> <span style="color: #eedd82;">nextSerialNum</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">AtomicLong</span>();
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">generateSerialNumber</span>() {
    <span style="color: #00ffff;">return</span> nextSerialNum.getAndIncrement();
}
</pre>
</div>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">共享总结</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>为了在线程之间进行可靠地通信，也为了互斥访问，同步是必要的
</li>
<li>如果读和写操作没有都被同步，同步就不会起作用，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步
</li>
<li>避免同步最好的办法：使用不可变对象把修改限制在单个线程中，然后通过volatile让所有线程可见
</li>
<li>volatile保证了可见性，但并没有保证互斥性
</li>
<li>安全发布：把变量保存到static成员，变量声明为volatile，变量声明为final，变量保存到同步集合内等
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">避免过度同步</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">难以预料的错误</h3>
<div class="outline-text-3" id="text-2-1">
<p>
编写Set的wrapper类
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ForwardingSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">E</span>&gt; {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">s</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">ForwardingSet</span>(<span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">s</span>) {
        <span style="color: #00ffff;">this</span>.s = s;
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">size</span>() {
        <span style="color: #00ffff;">return</span> s.size();
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isEmpty</span>() {
        <span style="color: #00ffff;">return</span> s.isEmpty();
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">contains</span>(<span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">o</span>) {
        <span style="color: #00ffff;">return</span> s.contains(o);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #87cefa;">iterator</span>() {
        <span style="color: #00ffff;">return</span> s.iterator();
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Object</span>[] <span style="color: #87cefa;">toArray</span>() {
        <span style="color: #00ffff;">return</span> s.toArray();
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> &lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #98fb98;">T</span>[] <span style="color: #87cefa;">toArray</span>(<span style="color: #98fb98;">T</span>[] <span style="color: #eedd82;">a</span>) {
        <span style="color: #00ffff;">return</span> s.toArray(a);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #00ffff;">return</span> s.add(e);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">remove</span>(<span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">o</span>) {
        <span style="color: #00ffff;">return</span> s.remove(o);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">containsAll</span>(<span style="color: #98fb98;">Collection</span>&lt;?&gt; <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> s.containsAll(c);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">addAll</span>(<span style="color: #98fb98;">Collection</span>&lt;? <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> s.addAll(c);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">retainAll</span>(<span style="color: #98fb98;">Collection</span>&lt;?&gt; <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> s.retainAll(c);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">removeAll</span>(<span style="color: #98fb98;">Collection</span>&lt;?&gt; <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> s.removeAll(c);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clear</span>() {
        s.clear();
    }

}
</pre>
</div>

<p>
定义观察者接口：当元素被添加时候，触发这个接口实现类中的added方法
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt; {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Invoked when an element is added to the observable set</span>
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">added</span>(
        <span style="color: #98fb98;">BrokenObservableSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">set</span>, <span style="color: #98fb98;">E</span> <span style="color: #eedd82;">element</span>);
}
</pre>
</div>

<p>
扩展ForwardingSet：添加观察者接口列表，并在添加元素的时候触发这个观察者的added方法
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">BrokenObservableSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">ForwardingSet</span>&lt;<span style="color: #98fb98;">E</span>&gt;{

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">BrokenObservableSet</span>(<span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">set</span>) {
        <span style="color: #00ffff;">super</span>(set);
    }

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt;&gt; <span style="color: #eedd82;">observers</span> =
        <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ArrayList</span>&lt;&gt;();

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addObserver</span>(<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">observer</span>) {
        <span style="color: #00ffff;">synchronized</span> (observers) {
            observers.add(observer);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">removeObserver</span>(<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">observer</span>) {
        <span style="color: #00ffff;">synchronized</span> (observers) {
            <span style="color: #00ffff;">return</span> observers.remove(observer);
        }
    }

    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notifyElementAdded</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">element</span>) {
        <span style="color: #00ffff;">synchronized</span> (observers) {
<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22312;&#21516;&#27493;&#20195;&#30721;&#22359;&#20013;&#35843;&#29992;&#30340;&#26159;&#23458;&#25143;&#21270;&#30340;&#26041;&#27861;&#65292;&#36825;&#20250;&#23548;&#33268;&#24847;&#22806;&#30340;&#38169;&#35823;!!!</span>
            <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">observer</span> : observers) {
                observer.added(<span style="color: #00ffff;">this</span>, element);
            }
        }
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">element</span>) {
        <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">added</span> = <span style="color: #00ffff;">super</span>.add(element);
        <span style="color: #00ffff;">if</span> (added) {
            notifyElementAdded(element);
        }
        <span style="color: #00ffff;">return</span> added;
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">addAll</span>(<span style="color: #98fb98;">Collection</span>&lt;? <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">c</span>) {
        <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">result</span> = <span style="color: #7fffd4;">false</span>;
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">calls notifyElementAdded</span>
        <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">element</span> : c) {
            result |= add(element); 
        }
        <span style="color: #00ffff;">return</span> result;
    }
}
</pre>
</div>

<p>
添加元素到BrokenObservableSet的时候，会触发遍历observers列表，而一旦同时删除这个列表的某个元素，后果抛出ConcurrentModificationException
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
    <span style="color: #98fb98;">BrokenObservableSet</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; <span style="color: #eedd82;">set</span>
        = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">BrokenObservableSet</span>&lt;&gt;(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">HashSet</span>&lt;&gt;());
<span style="color: #ff4500;">//        </span><span style="color: #ff4500;">set.addObserver(new SetObserver&lt;Integer&gt;() {</span>
<span style="color: #ff4500;">//            </span><span style="color: #ff4500;">@Override</span>
<span style="color: #ff4500;">//            </span><span style="color: #ff4500;">public void added(BrokenObservableSet&lt;Integer&gt; s, Integer e) {</span>
<span style="color: #ff4500;">//                </span><span style="color: #ff4500;">System.out.println(e);</span>
<span style="color: #ff4500;">//            </span><span style="color: #ff4500;">}</span>
<span style="color: #ff4500;">//        </span><span style="color: #ff4500;">});</span>

    set.addObserver(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">Integer</span>&gt;() {
            <span style="color: #7fffd4;">@Override</span>
            <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">added</span>(<span style="color: #98fb98;">BrokenObservableSet</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">Integer</span> <span style="color: #eedd82;">e</span>) {
                System.out.println(e);
                <span style="color: #00ffff;">if</span> (e == 23) {
                    s.removeObserver(<span style="color: #00ffff;">this</span>);
                }
            }
        });

    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 100; i++) {
        set.add(i);
    }
}
</pre>
</div>

<p>
下面代码比抛出异常错误更严重：新启动的线程会要求对observers加锁，而BrokenObservableSet已经获得这个列表的锁，同时BrokenObservableSet还在等待新启动线程返回，这就导致了死锁！
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Observer that uses a background thread needlessly</span>
set.addObserver(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">Integer</span>&gt;() {
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">added</span>(<span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ObservableSet</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">Integer</span> <span style="color: #eedd82;">e</span>) {
            System.out.println(e);
            <span style="color: #00ffff;">if</span> (e == 23) {
                <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">executor</span> =
                    Executors.newSingleThreadExecutor();
                <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; <span style="color: #eedd82;">observer</span> = <span style="color: #00ffff;">this</span>;
                <span style="color: #00ffff;">try</span> {
                    executor.submit(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Runnable</span>() {
                            <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
                                s.removeObserver(observer);
                            }
                        }).get();
                } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">ExecutionException</span> <span style="color: #eedd82;">ex</span>) {
                    <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">AssertionError</span>(ex.getCause());
                } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">ex</span>) {
                    <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">AssertionError</span>(ex.getCause());
                } <span style="color: #00ffff;">finally</span> {
                    executor.shutdown();
                }
            }
        }
    });
</pre>
</div>

<p>
解决方法：同步代码只是对观察者列表进行拷贝，客户端代码移除到同步块之外
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Alien method moved outside of synchronized block - open calls</span>
<span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notifyElementAdded</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">element</span>) {
    <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt;&gt; <span style="color: #eedd82;">snapshot</span> = <span style="color: #7fffd4;">null</span>;
    <span style="color: #00ffff;">synchronized</span>(observers) {
        snapshot = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ArrayList</span>&lt;<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt;&gt;(observers);
    }

    snapshot.forEach((observer) -&gt; {
            observer.added(<span style="color: #00ffff;">this</span>, element);
        });
}
</pre>
</div>

<p>
更好的解决办法：使用同步列表CopyOnWriteArrayList
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt;&gt; <span style="color: #eedd82;">observers</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">CopyOnWriteArrayList</span>&lt;&gt;();

<span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addObserver</span>(<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">observer</span>) {
    observers.add(observer);
}

<span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">removeObserver</span>(<span style="color: #98fb98;">SetObserver</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">observer</span>) {
    <span style="color: #00ffff;">return</span> observers.remove(observer);
}

<span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notifyElementAdded</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">element</span>) {
    observers.forEach((observer) -&gt; {
            observer.added(<span style="color: #00ffff;">this</span>, element);
        });
}
</pre>
</div>
<p>
总之：在一个被同步的方法或者代码块中，永远不要调用客户端允许覆盖的方法或者使用一个客户端可以继承的对象
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">效率低下</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>设计可变类时候，要考虑是否会被多线程环境使用。如果是的化，则在内部实现同步，尽量禁止客户端修改同步机制。反之在文档中明确写清楚并不是线程的，让使用者去做额外同步
</li>
<li>对于某个类的static成员，如果可能在多线程环境中被修改，必须考虑同步
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">并发工具优先于wait和notify</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">并发工具</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>Executor框架：Executor和Task优先于线程
</li>
<li>并发集合：并发集合中不可能排除并发活动；对它加锁没有什么作用，只会使程序速度变慢
</li>
<li>同步器
</li>
</ol>

<p>
对于间歇式的定时，始终应该优先使用System.nanoTime而不是System.currentTimeMills，System.nanoTime更加准确也更加精确，不受系统的实时时钟的调整所影响
</p>

<p>
即使使用wait, 也应该使用notifyAll，而不是notify
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">线程安全性需要文档化</h2>
<div class="outline-text-2" id="text-4">
<p>
JavaDoc并没有在输出中包含synchronized修饰符信息，因为这个属于实现的细节，而不是接口的一部分。事实上syncrhonized并不能完全等同于线程安全
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">线程安全级别</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>不可变：类的实例是不变的，无须客户端任何同步
</li>
<li>无条件的线程安全：虽然类的实例是可变的，但有着足够的内部同步。例如ConcurrentHashMap的实例可以安全地并发使用
</li>
<li>有条件的线程安全：某些方法为进行安全的并发使用必须要额外地进行外部同步
</li>
<li>非线程安全：客户必须自己外部同步包围每个方法调用，例如ArrayList和HashMap
</li>
<li>线程对立：即使所有的方法调用都被外部同步包围也不能安全地被多个线程并发使用。通常其根源在于无法同步地修改静态成员数据
</li>
</ul>

<p>
其中有条件的线程安全必须清楚说明哪些操作顺序需要加锁，以及对哪个对象进行加锁。这时候不仅要对方法注释线程安全，必要时还需要对成员进行注释。最后必须清楚指出在继承的情况下如何可以不破坏父类的线程安全约束　
</p>
</div>
<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">私有成员加锁</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
使用public对象（往往是对象本身）同步锁，会有意或无意地引发DDOS拒绝服务攻击。为了避免这个缺陷，有时候应该使用私有成员加锁
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Private lock object idiom - thwarts denial-of-service attack</span>
<span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">lock</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Object</span>();
<span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">foo</span>() {
    <span style="color: #00ffff;">synchronized</span>(lock) {
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">...</span>
    }
}
</pre>
</div>
<p>
lock对象如果不申明为final会导致灾难性的后果，这意味着实际上私有成员加锁就是无条件线程安全，客户端不能再做任何同步。私有成员加锁尤其适合面向继承的设计
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">线程安全文档的总结</h3>
<div class="outline-text-3" id="text-4-2">
<p>
每个类都应该精确地在文档中说明线程安全属性，请利用@Immuable, @ThreadSafe, @NotThreadSafe来指出线程安全级别
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">谨慎使用延迟初始化</h2>
<div class="outline-text-2" id="text-5">
<p>
延迟初始化：真正被使用的时候才开始初始化
</p>

<p>
这是为了权衡初始化和访问之间的开销。只有当某个成员实例初始化非常昂贵，但这个成员实例可能不是每次都必须被用到的情况下才值得。
</p>

<p>
如非必要请不要使用延迟初始化，因为延迟初始化的这个成员需要同步！　
</p>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">正常初始化</h3>
<div class="outline-text-3" id="text-5-1">
<p>
初始化开销不值一提的时候
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Normal initialization of an instance field</span>
<span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #eedd82;">field1</span> = computeFieldValue();
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">实例成员延迟初始化</h3>
<div class="outline-text-3" id="text-5-2">
<p>
使用synchronized修饰符为实例成员进行延迟初始化
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Lazy initialization of instance field - synchronized accessor</span>
<span style="color: #00ffff;">private</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #eedd82;">field2</span>;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">synchronized</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #87cefa;">getField2</span>() {
    <span style="color: #00ffff;">if</span> (field2 == <span style="color: #7fffd4;">null</span>) {
        field2 = computeFieldValue();
    }
    <span style="color: #00ffff;">return</span> field2;
                  }
</pre>
</div>
<p>
降低了初始化开销，但最大程度增加了访问时开销
</p>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">双重检查优化实例成员延迟访问的开销</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
引入局部变量result, 第一次检查并不加锁，第二次检查才加锁，这避免了初始化后的访问还需要同步的开销
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Double-check idiom for lazy initialization of instance fields</span>
<span style="color: #00ffff;">private</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #eedd82;">field4</span>;

<span style="color: #00ffff;">public</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #87cefa;">getField4</span>() {
    <span style="color: #98fb98;">FieldType</span> <span style="color: #eedd82;">result</span> = field4;
    <span style="color: #00ffff;">if</span> (result == <span style="color: #7fffd4;">null</span>) { <span style="color: #ff4500;">// </span><span style="color: #ff4500;">First check (no locking)</span>
        <span style="color: #00ffff;">synchronized</span> (<span style="color: #00ffff;">this</span>) {
            result = field4;
            <span style="color: #00ffff;">if</span> (result == <span style="color: #7fffd4;">null</span>) { <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Second check (with locking)</span>
                field4 = result = computeFieldValue();
            }
        }
    }
    <span style="color: #00ffff;">return</span> result;
}
</pre>
</div>
<p>
注意：被延迟初始化的实例变量必须被声明为volatile，这是为了保证多线程下的可见性！
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">静态成员延迟初始化</h3>
<div class="outline-text-3" id="text-5-3">
<p>
虽然对于静态成员延迟初始化只需要static修饰符号，但更好地方式是使用class holder
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">FieldHolder</span> {

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #eedd82;">FIELD</span> = computeFieldValue();
}

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">Lazy initialization holder class idiom for static fields</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">FieldType</span> <span style="color: #87cefa;">getField3</span>() {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">FieldHolder</span>.FIELD;
}
</pre>
</div>
<p>
只有首次读取FieldHolder.FIELD，才会导致私有静态类FieldHolder被初始化。现在的JVM会保证只有当某个类的成员被使用才会被初始化，而在初始化的过程中会保证成员的线程安全。这优雅地避免了额外同步
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">延迟初始化总结</h3>
<div class="outline-text-3" id="text-5-4">
<p>
谨慎使用延迟初始化，如果必须实例成员使用double check方式，静态成员使用holder class方式
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">不要依赖于线程调度器</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>任何依赖于线程调度器，线程优先级，以及Thread.yield来达到正确性或者性能要求的程序都是不可移植的，因为不同操作系统的JVM对其实现也不相同
</li>
<li>使用Thread.sleep(1)代替Thread.yield
</li>
<li>不要使用忙等待，这样的代码会导致其他线程无法获得CPU使用权，而不得不依赖线程调度器
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">永远不要使用线程组</h2>
<div class="outline-text-2" id="text-7">
<p>
线程组已经过时，永远不要使用线程组
</p>

<p>
<a href="methods.html">Next：方法</a>
</p>

<p>
<a href="exception.html">Previous：异常处理</a>
</p>

<p>
<a href="effj.html">Home：目录</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

     <br/>
    <div class='ds-thread'></div>
<script>
var duoshuoQuery = {short_name:'klose911'};
(function() {
	 var dsThread = document.getElementsByClassName('ds-thread')[0];
         dsThread.setAttribute('data-thread-key', document.title);
         dsThread.setAttribute('data-title', document.title);
         dsThread.setAttribute('data-url', window.location.href);
	 var ds = document.createElement('script');
	 ds.type = 'text/javascript';ds.async = true;
	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	 ds.charset = 'UTF-8';
	 (document.getElementsByTagName('head')[0] 
				       || document.getElementsByTagName('body')[0]).appendChild(ds);
				       })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
