<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>类和接口</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="common_method.html"> UP </a>
 |
 <a accesskey="H" href="effj.html"> HOME </a>
</div><div id="content">
<h1 class="title">类和接口</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">使可见性最低</a>
<ul>
<li><a href="#sec-1-1">信息隐藏</a></li>
<li><a href="#sec-1-2">封装规则</a></li>
</ul>
</li>
<li><a href="#sec-2">使可变性最小</a>
<ul>
<li><a href="#sec-2-1">不可变类的规则</a></li>
<li><a href="#sec-2-2">不可变类的优点</a>
<ul>
<li><a href="#sec-2-2-1">函数式风格</a></li>
</ul>
</li>
<li><a href="#sec-2-3">不可变类的缺点</a></li>
<li><a href="#sec-2-4">不可变类的总结</a></li>
</ul>
</li>
<li><a href="#sec-3">组合优先于继承</a>
<ul>
<li><a href="#sec-3-1">组合扩展</a></li>
</ul>
</li>
<li><a href="#sec-4">继承必须提供文档</a></li>
<li><a href="#sec-5">接口优先于抽象类</a>
<ul>
<li><a href="#sec-5-1">接口的优点</a></li>
<li><a href="#sec-5-2">接口的缺点</a></li>
<li><a href="#sec-5-3">抽象骨架实现类</a></li>
<li><a href="#sec-5-4">总结</a></li>
</ul>
</li>
<li><a href="#sec-6">接口只声明方法</a></li>
<li><a href="#sec-7">不要使用标签类</a></li>
<li><a href="#sec-8">用函数对象表达策略</a>
<ul>
<li><a href="#sec-8-1">函数对象</a></li>
<li><a href="#sec-8-2">策略接口</a></li>
<li><a href="#sec-8-3">内部匿名类</a></li>
<li><a href="#sec-8-4">静态成员类</a></li>
</ul>
</li>
<li><a href="#sec-9">优先考虑静态成员类</a>
<ul>
<li><a href="#sec-9-1">静态成员类</a></li>
<li><a href="#sec-9-2">非静态成员类</a></li>
<li><a href="#sec-9-3">内部匿名类</a>
<ul>
<li><a href="#sec-9-3-1">内部匿名类的限制</a></li>
</ul>
</li>
<li><a href="#sec-9-4">局部类</a></li>
<li><a href="#sec-9-5">嵌套类总结</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">使可见性最低</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">信息隐藏</h3>
<div class="outline-text-3" id="text-1-1">
<p>
设计良好的模块会隐藏所有的实现细节，把接口和实现清晰的分离开来。模块之间通过它们之间的接口进行调用，单个模块不需要知道其他模块的内部情况
</p>
<ul class="org-ul">
<li>有效的解除系统模块间的耦合，模块可以独立的开发、测试、优化、使用、理解和修改
</li>
<li>加快系统开发的速度，模块可以并发开发
</li>
<li>减轻了维护的负担，更快的理解代码，并且调试一个模块不影响其他的模块
</li>
<li>虽然信息隐藏本身无论是对内还是对外，都不会带来更好的性能，但是可以有效的方便优化性能：一旦完成一个系统，并通过剖析哪些模块影响了系统性能，可以进一步优化，而不影响到其他模块的正确性
</li>
<li>信息隐藏提高了可重用性，因为模块间并不紧密耦合，除了开发这些模块所使用的坏境之外，模块在其他坏境中往往也可用
</li>
<li>信息隐藏降低了构建大型系统的风险，因为即使整个系统不可用，但是独立的子模块却有可能是可用的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">封装规则</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>实例成员绝不能是public，包含public可变成员的类是线程不安全的
</li>
<li>public静态的final数组成员几乎总是错误的
</li>
<li>使共有数组变成私有的，并返回一个公有的不可变List
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Thing</span>[] <span style="color: #eedd82;">PRIVATE_VALUES</span> = {...};
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Thing</span>&gt; <span style="color: #eedd82;">VALUES</span> =
    Collecations.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25110;&#32773;</span>
<span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Thing</span>[] <span style="color: #eedd82;">PRIVATE_VALUES</span> = {...};
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Thing</span>[] <span style="color: #87cefa;">values</span>() {
    <span style="color: #00ffff;">return</span> PRIVATE_VALUES.clone;
}
</pre>
</div>
</li>
<li>如果类可以在它所在的包的外部被访问，就提供访问私有成员的方法
</li>
<li>如果类是包私有的，或者私有的嵌套类，直接暴露他的数据成员并不是本质的错误
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">使可变性最小</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">不可变类的规则</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>不要提供任何可修改对象状态的方法
</li>
<li>保证类不会被扩展
</li>
<li>使所有的成员都是final
</li>
<li>使所有的成员都成为private
</li>
<li>确保对于任何可变组件的互斥访问
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">不可变类的优点</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>不可变对象本质上是线程安全的，不要求同步
</li>
<li>不可变对象可以自由地共享，甚至可以共享对象的内部信息
</li>
<li>永远不需要进行保护性拷贝
</li>
<li>不可变对象对其他对象提供了大量的构件（building blocks）
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">函数式风格</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
修改对象状态的方法永远返回一个新的不可变对象
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">final</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Complex</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">re</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">im</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">Complex</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">re</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">im</span>) {
        <span style="color: #00ffff;">this</span>.re = re;
        <span style="color: #00ffff;">this</span>.im = im;
    }
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Accessors with no corresponding mutators</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">realPart</span>() {&#12288;<span style="color: #00ffff;">return</span> re;&#12288;}
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">imaginaryPart</span>() { <span style="color: #00ffff;">return</span> im;&#12288;}
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Complex</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">Complex</span> <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Complex</span>(re + c.re, im + c.im);
    }              
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Complex</span> <span style="color: #87cefa;">subtract</span>(<span style="color: #98fb98;">Complex</span> <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Complex</span>(re - c.re, im - c.im);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Complex</span> <span style="color: #87cefa;">multiply</span>(<span style="color: #98fb98;">Complex</span> <span style="color: #eedd82;">c</span>) {
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Complex</span>(re * c.re - im * c.im,
                   re * c.im + im * c.re);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Complex</span> <span style="color: #87cefa;">divide</span>(<span style="color: #98fb98;">Complex</span> <span style="color: #eedd82;">c</span>) {
        <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">tmp</span> = c.re * c.re + c.im * c.im;
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Complex</span>((re * c.re + im * c.im) / tmp,
                   (im * c.re - re * c.im) / tmp);
    }
}
</pre>
</div>
<p>
调用加减乘除计算方法每次都返回一个新的不可变的复数对象
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">不可变类的缺点</h3>
<div class="outline-text-3" id="text-2-3">
<p>
每一个值都需要一个单独的对象，加重了垃圾回收器的负担
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">不可变类的总结</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>除非有很好的理由让类成为可变的类，否则就应该是不可变
</li>
<li>尽量使成员变成final
</li>
<li>让类的所有构造器都变成私有的或者包级私有的，并添加public静态工厂来替代public构造器
</li>
<li>构造器应该创建完全初始化的对象，并建立起所有的约束关系。不要在构造器或者静态工厂之外再提供初始化方法
</li>
<li>如果类无法做成不可变的，但也应该尽量限制可变性
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">组合优先于继承</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>破化封装：子类依赖于其父类中特定功能的实现细节。而父类的实现有可能会随着发型版本的不同而发生改变，如果真的发生了变化，子类可能会遭到破坏，即使子类的代码完全没有改变
</li>
<li>暴露实现：继承的子类必须了解父类的实现细节，甚至可能无意识破坏父类的约束
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#24819;&#35201;&#20462;&#22797;bug&#65292;&#23601;&#24517;&#39035;&#20102;&#35299;HashSet&#20869;&#37096;&#23454;&#29616;</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">InstrumentedHashSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">HashSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; {
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">addCount</span> = 0;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">InstrumentedHashSet</span>() {
    }

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">InstrumentedHashSet</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">initCap</span>, <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">loadFactor</span>) {
        <span style="color: #00ffff;">super</span>(initCap, loadFactor);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">e</span>) {
        addCount++;
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">super</span>.add(e);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">addAll</span>(<span style="color: #98fb98;">Collection</span>&lt;? <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">c</span>) {
        addCount += c.size();
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">super</span>.addAll(c);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getAddCount</span>() {
        <span style="color: #00ffff;">return</span> addCount;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        <span style="color: #98fb98;">InstrumentedHashSet</span>&lt;<span style="color: #98fb98;">String</span>&gt; <span style="color: #eedd82;">s</span>
            = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">InstrumentedHashSet</span>&lt;&gt;();
        s.addAll(Arrays.asList(<span style="color: #ffa07a;">"Snap"</span>, <span style="color: #ffa07a;">"Crackle"</span>, <span style="color: #ffa07a;">"Pop"</span>));
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">it should be 3, but is 6 !</span>
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">the InstrumentedHashSet.addAll -&gt; HashSet.add -&gt; InstrumentedHashSet.add </span>
        System.out.println(
            String.format(<span style="color: #ffa07a;">"the elemet number of instrumented hash set : %d"</span>,
                      s.getAddCount()));
    }
}
</pre>
</div>
<ul class="org-ul">
<li>妨碍优化：继承限制了父类的实现，往往使得父类的性能优化变得极其困难
</li>
<li>is-a原则：只有当子类真正是父类的子类型（subtype）时，才适合用继承
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">组合扩展</h3>
<div class="outline-text-3" id="text-3-1">
<p>
不扩展现有的类，而是在新类中增加一个私有成员，这个私有成员引用现有类一个实例
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">WrappedInstrumentedSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">s</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">addCount</span> = 0;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">WrappedInstrumentedSet</span>(<span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">s</span>) {
        <span style="color: #00ffff;">this</span>.s = s;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">E</span> <span style="color: #eedd82;">e</span>) {
        addCount++;
        <span style="color: #00ffff;">return</span> s.add(e);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">addAll</span>(<span style="color: #98fb98;">Collection</span>&lt;? <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">E</span>&gt; <span style="color: #eedd82;">c</span>) {
        addCount += c.size();
        <span style="color: #00ffff;">return</span> s.addAll(c);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getAddCount</span>() {
        <span style="color: #00ffff;">return</span> addCount;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        <span style="color: #98fb98;">WrappedInstrumentedSet</span>&lt;<span style="color: #98fb98;">String</span>&gt; <span style="color: #eedd82;">s</span>
            = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">WrappedInstrumentedSet</span>&lt;&gt;(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">HashSet</span>&lt;&gt;());
        s.addAll(Arrays.asList(<span style="color: #ffa07a;">"Snap"</span>, <span style="color: #ffa07a;">"Crackle"</span>, <span style="color: #ffa07a;">"Pop"</span>));
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">the element number of instrumented set is 3</span>
        System.out.println(
            String.format(<span style="color: #ffa07a;">"the element number of wrapped instrumented set is %d"</span>,
                      s.getAddCount()));
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">继承必须提供文档</h2>
<div class="outline-text-2" id="text-4">
<p>
好的接口文档应该描述一个方法做了什么工作，而不是描述是如何做到的。但是如果设计时候允许被继承，则必须给出足够扩展的实现细节，否则就禁止继承
</p>
<ul class="org-ul">
<li>面向继承的文档必须精确地描述覆盖每个方法所带来的影响。对于每个public或受protected的方法或构造器，文档必须指明调用了哪些允许子类覆盖的方法，是以什么顺序调用的，每个调用的结果又是如何影响后续的处理过程的
</li>
<li>可以被继承的类往往提供适当的钩子（hook），以便子类能够进入父类的内部工作流程中，文档中必须说明这些精心选择的protected钩子方法
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">接口优先于抽象类</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">接口的优点</h3>
<div class="outline-text-3" id="text-5-1">
<p>
抽象类作为类型定义拥有极大的限制
</p>
<ul class="org-ul">
<li>已经实现的类可以更方便地实现新的接口。假设现有的类A继承于类C，而现有的类B继承于类D，要为A和B添加同一个抽象类E，就必须先让C和D继承于E，这会间接伤害类的层次关系
</li>
<li>接口是定义混合类型（mixin）的理想选择。类除了实现他的“基本类型”的行为之外，还可以表示提供了某些可供选择的行为
</li>
<li>接口允许构造非层次结构的类型框架
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">Singer</span> {
    <span style="color: #98fb98;">AudioClip</span> <span style="color: #87cefa;">sing</span>(<span style="color: #98fb98;">Song</span> <span style="color: #eedd82;">s</span>);
}

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">Songwriter</span> {
    <span style="color: #98fb98;">Song</span> <span style="color: #87cefa;">compose</span>(<span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">hit</span>);
}

<span style="color: #ffa07a;">/** &#20107;&#23454;&#19978;&#29616;&#23454;&#20013;&#30830;&#23454;&#26377;&#20154;&#26159;&#27468;&#25163;&#20860;&#20316;&#35789;&#32773; */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">SingerSongwriter</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Singer</span>, <span style="color: #98fb98;">Songwriter</span> {
    <span style="color: #98fb98;">AudioClip</span> <span style="color: #87cefa;">strum</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">actSensitive</span>();
}
</pre>
</div>
</li>
<li>使用接口可以通过组合模式更安全地增强类的功能，完全不用受到抽象类实现细节的干扰
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">接口的缺点</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>接口一旦被公开发行，并且被广泛实现，再想改变这个接口几乎是不可能的
</li>
<li>抽象类的修改比接口的修改要容易的多。抽象类可以增加非abstract的方法，而接口往往就需要在每个实现类实现同一个新增的方法（Java8之后接口也可以用default修饰符来添加某个方法的实现代码）
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">抽象骨架实现类</h3>
<div class="outline-text-3" id="text-5-3">
<p>
设计接口时候可以先确定哪些方法是最基本的（primitive），其他的方法可以根据他们来实现。基本方法将成为抽象骨架类（abstract skeletal implementation）中的抽象方法，其他方法则在抽象骨架类中提供默认实现。子类通常只需要继承这个抽象骨干类并实现这些抽象方法
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">总结</h3>
<div class="outline-text-3" id="text-5-4">
<p>
接口通常是定义允许多个实现的类型的最佳途径。如果演变的容易性比灵活性和功能更为重要的时候，应当选用抽象类，前提是必须理解并且可以接受这些局限性。考虑为每个重要接口都提供一个抽象的骨架实现类
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">接口只声明方法</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>常量接口是对接口的不良使用
</li>
<li>如果可能使用枚举定义常量
</li>
<li>如果不能使用枚举，请使用单例模式的工具类。使用static import，避免用类名修饰常量名
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">不要使用标签类</h2>
<div class="outline-text-2" id="text-7">
<p>
标签类冗长，易错，低效
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Tagged class - vastly inferior to a class hierarchy!</span>
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Figure</span> {
    <span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">Shape</span> { <span style="color: #eedd82;">RECTANGLE</span>, <span style="color: #eedd82;">CIRCLE</span> };
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Tag field - the shape of this figure</span>
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Shape</span> <span style="color: #eedd82;">shape</span>;
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">These fields are used only if shape is RECTANGLE</span>
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">length</span>;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">width</span>;
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">This field is used only if shape is CIRCLE</span>
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Constructor for circle</span>
    <span style="color: #87cefa;">Figure</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>) {
        shape = <span style="color: #7fffd4;">Shape</span>.CIRCLE;
        <span style="color: #00ffff;">this</span>.radius = radius;
    }

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Constructor for rectangle</span>
    <span style="color: #87cefa;">Figure</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">length</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">width</span>) {
        shape = <span style="color: #7fffd4;">Shape</span>.RECTANGLE;
        <span style="color: #00ffff;">this</span>.length = length;
        <span style="color: #00ffff;">this</span>.width = width;
    }

    <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">area</span>() {
        <span style="color: #00ffff;">switch</span>(shape) {
        <span style="color: #00ffff;">case</span> RECTANGLE:
            <span style="color: #00ffff;">return</span> length * width;
        <span style="color: #00ffff;">case</span> CIRCLE:
            <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">Math</span>.PI * (radius * radius);
        <span style="color: #00ffff;">default</span>:
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">AssertionError</span>();
        }
    }
}
</pre>
</div>

<p>
使用类层次来替代标签类
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Class hierarchy replacement for a tagged class</span>
<span style="color: #00ffff;">abstract</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Figure</span> {
    <span style="color: #00ffff;">abstract</span> <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">area</span>();
}

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Circle</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Figure</span> {
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>;
    <span style="color: #87cefa;">Circle</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>) { <span style="color: #00ffff;">this</span>.radius = radius; }
    <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">area</span>() { <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">Math</span>.PI * (radius * radius); }
}

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rectangle</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Figure</span> {
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">length</span>;
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">width</span>;
    <span style="color: #87cefa;">Rectangle</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">length</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">width</span>) {
        <span style="color: #00ffff;">this</span>.length = length;
        <span style="color: #00ffff;">this</span>.width = width;
    }
    <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">area</span>() { <span style="color: #00ffff;">return</span> length * width; }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">用函数对象表达策略</h2>
<div class="outline-text-2" id="text-8">
<p>
Java没有提供函数指针，lambda表达式等方式来调用函数，而是使用“函数对象”来模拟函数指针（Java8后开始支持lambda表达式）
</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">函数对象</h3>
<div class="outline-text-3" id="text-8-1">
<p>
通常情况下调用某个对象的方法是为了作用于这个对象。但是同样可以定义一个类，它有且仅有一个方法，这个方法是作用于传递给它的对象上，这种类就被称为“函数对象”
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StringLengthComparator</span>  { 
    <span style="color: #00ffff;">private</span> <span style="color: #87cefa;">StringLengthComparator</span>() { }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">StringLengthComparator</span> <span style="color: #eedd82;">INSTANCE</span> =
        <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">StringLengthComparator</span>();

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">s1</span>, <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">s2</span>) {
        <span style="color: #00ffff;">return</span> s1.length() - s2.length();
    }
}
</pre>
</div>
<p>
StringLengthComparator的对象引用就充当StringLengthComparator.compare这个方法的函数指针。换种说法StringLengthComparator是某种特定“字符串比较”策略的具体实现类
</p>
<ul class="org-ul">
<li>函数对象应该是无状态的
</li>
<li>函数对象最好是单例的
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">策略接口</h3>
<div class="outline-text-3" id="text-8-2">
<p>
提供给客户端调用的接口中需要一个类似函数指针的策略接口，而不是一个具体的函数对象类
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Strategy interface</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">Comparator</span>&lt;<span style="color: #98fb98;">T</span>&gt; {
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #98fb98;">T</span> <span style="color: #eedd82;">t1</span>, <span style="color: #98fb98;">T</span> <span style="color: #eedd82;">t2</span>);
}
</pre>
</div>
<p>
客户端实现某种具体策略
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StringLengthComparator</span>  <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Comparator</span>&lt;<span style="color: #98fb98;">String</span>&gt; { 
    <span style="color: #00ffff;">private</span> <span style="color: #87cefa;">StringLengthComparator</span>() { }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">StringLengthComparator</span> <span style="color: #eedd82;">INSTANCE</span> =
        <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">StringLengthComparator</span>();

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">s1</span>, <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">s2</span>) {
        <span style="color: #00ffff;">return</span> s1.length() - s2.length();
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">内部匿名类</h3>
<div class="outline-text-3" id="text-8-3">
<p>
具体的策略类往往使用匿名内部类定义
</p>
<div class="org-src-container">

<pre class="src src-java">Arrays.sort(stringArray,<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Comparator</span>&lt;<span style="color: #98fb98;">String</span>&gt;() {
        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">o1</span>, <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">o2</span>) {
            <span style="color: #00ffff;">return</span> 0;
        }
    });
</pre>
</div>
<p>
但是使用匿名类会导致每次调用都创建新的class对象和实例对象，如果频繁调用的话开销会比较大
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">静态成员类</h3>
<div class="outline-text-3" id="text-8-4">
<p>
使用静态成员类来缓存频繁调用的具体策略对象，可以有更好的性能
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Exporting a concrete strategy</span>
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Host</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StrLenCmp</span>
        <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Comparator</span>&lt;<span style="color: #98fb98;">String</span>&gt;, <span style="color: #98fb98;">Serializable</span> {
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">s1</span>, <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">s2</span>) {
            <span style="color: #00ffff;">return</span> s1.length() - s2.length();
        }
    }

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Returned comparator is serializable</span>
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Comparator</span>&lt;<span style="color: #98fb98;">String</span>&gt;
        <span style="color: #eedd82;">STRING_LENGTH_COMPARATOR</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">StrLenCmp</span>();
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Bulk of class omitted</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">优先考虑静态成员类</h2>
<div class="outline-text-2" id="text-9">
<p>
嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该是顶层类
</p>

<p>
嵌套类有4种，除了第四种都被称为内部类
</p>
<ol class="org-ol">
<li>静态成员类
</li>
<li>非静态成员类
</li>
<li>匿名类
</li>
<li>局部类
</li>
</ol>
</div>

<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">静态成员类</h3>
<div class="outline-text-3" id="text-9-1">
<p>
作为一个static属性被定义在一个类中，在这个类中可以访问外围类所有的（包括private）成员和方法。静态成员类的访问权限受到定义的修饰符的限制，比如定义为private static成员类，那它就不能被外围类之外的所有类访问
</p>

<ul class="org-ul">
<li>public静态成员类通常被用来定义对外暴露的但只能作用于这个外围类的常量类，比如可以为某个Calculator类定义只作用于它的public Operator枚举类，客户端可以用来传递Calculator.Operation.PLUS
</li>
<li>private静态成员类被用来定义外围类的组件，比如HashMap的私有静态成员Entry类
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">非静态成员类</h3>
<div class="outline-text-3" id="text-9-2">
<p>
非静态成员类和静态成员类的区别
</p>
<ul class="org-ul">
<li>非静态成员类是和外围类的一个实例对象关联的，这种关联是在外围类实例被创建的时候就建立的，而静态成员类是和整个外围类关联的
</li>
<li>非静态成员类可以引用外围类对象的this，静态成员类不可以
</li>
<li>每次创建外围类实例都会创建非静态成员类的class和实例对象，存储和垃圾回收器的开销很大，而静态成员类在jvm载入class代码时候就被创建，且只会被创建一次
</li>
</ul>

<p>
非静态成员类通常被用作adatper对象，使得外围类的实例对象可以被当成另一个类的实例对象来使用。比如java的集合类某个具体Set, List通常都会提供一个静态成员类Iterator来被外部当作iterator操作
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Typical use of a nonstatic member class</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">MySet</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">AbstractSet</span>&lt;<span style="color: #98fb98;">E</span>&gt; {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Bulk of the class omitted</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span>&lt;<span style="color: #98fb98;">E</span>&gt; <span style="color: #87cefa;">iterator</span>() {
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">MyIterator</span>();
    }
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">MyIterator</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Iterator</span>&lt;<span style="color: #98fb98;">E</span>&gt; {
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">...</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">内部匿名类</h3>
<div class="outline-text-3" id="text-9-3">
<p>
匿名类没有名字，也不是外围类的一个成员。内部匿名类可以被定义在任何合法的代码内
</p>

<p>
内部匿名类通常被用于创建函数对象，Java8后往往被lambda表达式替代
</p>
</div>
<div id="outline-container-sec-9-3-1" class="outline-4">
<h4 id="sec-9-3-1">内部匿名类的限制</h4>
<div class="outline-text-4" id="text-9-3-1">
<ul class="org-ul">
<li>在代码被调用的时候同时完成声明和初始化，无法在被声明的地方外初始化实例对象
</li>
<li>只有在非static的上下文中匿名类才能够访问外围类的this引用
</li>
<li>即使在static的上下文中，它也不能定义自己的static成员
</li>
<li>无法使用instance of
</li>
<li>无法同时实现多个接口，或者实现一个接口和扩展一个类
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">局部类</h3>
<div class="outline-text-3" id="text-9-4">
<p>
局部类被定义在某个方法内，和匿名类唯一的区别就是它有自己的名字而已，可以被多次用来创建不同的实例对象
</p>
</div>
</div>

<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5">嵌套类总结</h3>
<div class="outline-text-3" id="text-9-5">
<ol class="org-ol">
<li>如果内部类需要被当作一个成员从外部访问或者代码长到不能包含在一个方法内，就定义为成员类
</li>
<li>如果成员类每个实例对象都不需要引用某个外围类具体的实例对象，就定义为静态成员类，反之则非静态
</li>
<li>如果内部类被定义在某个方法中，并且只需要一次创建实例对象，就定义为内部匿名类，反之则局部类
</li>
</ol>

<p>
<a href="generics.html">Next：范型</a>
</p>

<p>
<a href="common_method.html">Previous：通用方法</a>
</p>

<p>
<a href="effj.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

     <br/>
    <div class='ds-thread'></div>
<script>
var duoshuoQuery = {short_name:'klose911'};
(function() {
	 var dsThread = document.getElementsByClassName('ds-thread')[0];
         dsThread.setAttribute('data-thread-key', document.title);
         dsThread.setAttribute('data-title', document.title);
         dsThread.setAttribute('data-url', window.location.href);
	 var ds = document.createElement('script');
	 ds.type = 'text/javascript';ds.async = true;
	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	 ds.charset = 'UTF-8';
	 (document.getElementsByTagName('head')[0] 
				       || document.getElementsByTagName('body')[0]).appendChild(ds);
				       })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
