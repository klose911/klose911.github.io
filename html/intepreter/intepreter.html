<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>如何写一个解释器</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">如何写一个解释器</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org395e963">什么是解释器</a></li>
<li><a href="#org5f5a931">抽象语法树</a></li>
<li><a href="#org6164a76">树遍历算法</a>
<ul>
<li><a href="#org2897488">模式匹配</a></li>
</ul>
</li>
<li><a href="#orga332a5c">计算器</a></li>
<li><a href="#orgb4fbfba">R2：一个很小的程序语言</a>
<ul>
<li><a href="#orge40c375">柯里化</a></li>
</ul>
</li>
<li><a href="#orge6bddec">R2 的解释器</a>
<ul>
<li><a href="#org8d0a8b3">基本算术操作</a></li>
<li><a href="#orgdbc8902">数字</a></li>
<li><a href="#org4d46c7a">变量</a>
<ul>
<li><a href="#org5da0203">环境</a>
<ul>
<li><a href="#org784c1b6">环境扩展</a></li>
</ul>
</li>
<li><a href="#org49990cd">变量的取值</a></li>
</ul>
</li>
<li><a href="#orgf082c36">绑定</a></li>
<li><a href="#org4e907d4">函数</a>
<ul>
<li><a href="#orgdce1f02">Lexical Scoping 和 Dynamic Scoping</a></li>
<li><a href="#org96669cf">函数定义</a></li>
</ul>
</li>
<li><a href="#orgfcbfc9f">调用</a>
<ul>
<li><a href="#orgc4928a2">dynamic scoping调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga002f48">缺点</a></li>
</ul>
</div>
</div>

<div id="outline-container-org395e963" class="outline-2">
<h2 id="org395e963">什么是解释器</h2>
<div class="outline-text-2" id="text-org395e963">
<p>
说白了，解释器跟计算器差不多。解释器是一个函数，你输入一个“表达式”，它就输出一个 “值”，像这样：
</p>

<div class="figure">
<p><img src="./pic/intepreter.png" alt="intepreter.png" width="60%" />
</p>
</div>

<p>
比如，你输入表达式 '(+ 1 2) ，它就输出值，整数3。表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。解释器从符号出发，得到它的意义，这也许就是它为什么叫做“解释器”
</p>

<p>
需要注意的是，表达式是一个数据结构，而不是一个字符串。我们用一种叫“S表达式”的结构来存储表达式。比如表达式 '(+ 1 2) 其实是一个链表（list），它里面的内容是三个符号（symbol）：+, 1 和 2，而不是字符串"(+ 1 2)"
</p>

<p>
从S表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取信息，麻烦而且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，这就是 Lisp 系统比 Unix 系统先进的地方之一
</p>

<p>
从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。事实上CPU也是一个解释器，它专门解释执行机器语言
</p>
</div>
</div>

<div id="outline-container-org5f5a931" class="outline-2">
<h2 id="org5f5a931">抽象语法树</h2>
<div class="outline-text-2" id="text-org5f5a931">
<p>
我们用S表达式所表示的代码，本质上是一种叫做“树”的数据结构。更具体一点，这叫做“抽象语法树”。下文为了简洁，我们省略掉“抽象”两个字，就叫它“语法树”
</p>

<p>
跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字，字符串，操作符，变量名。而子树是可以再细分的“结构”，比如算术表达式，函数定义，函数调用，等等
</p>

<p>
举个简单的例子，表达式 '(* (+ 1 2) (+ 3 4))，就对应如下的语法树结构：
</p>

<div class="figure">
<p><img src="./pic/abs-tree.png" alt="abs-tree.png" width="60%" />
</p>
</div>

<p>
其中，*，两个+，1，2，3，4 都是叶节点，而那三个红色节点，都表示子树结构：'(+ 1 2)，'(+ 3 4)，'(* (+ 1 2) (+ 3 4))
</p>
</div>
</div>

<div id="outline-container-org6164a76" class="outline-2">
<h2 id="org6164a76">树遍历算法</h2>
<div class="outline-text-2" id="text-org6164a76">
<p>
在基础的数据结构课程里，我们都学过二叉树的遍历操作，也就是所谓先序遍历，中序遍历和后序遍历。语法树跟二叉树，其实没有很大区别，所以你也可以在它上面进行遍历。解释器的算法，就是在语法树上的一种遍历操作。
</p>

<p>
下面这个函数，名叫tree-sum，它对二叉树进行“求和”，把所有节点里的数加在一起，返回它们的和
</p>
<div class="org-src-container">
<pre class="src src-racket"><span style="color: #00ffff;">#lang</span> <span style="color: #eedd82;">racket</span>

(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">tree-sum</span>
  (<span style="color: #00ffff;">lambda</span> (<span style="color: #b0c4de;">exp</span>)
    (<span style="color: #b0c4de;">match</span> <span style="color: #b0c4de;">exp</span>                         <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#23545;&#36755;&#20837;exp&#36827;&#34892;&#27169;&#24335;&#21305;&#37197;</span>
      [(? <span style="color: #b0c4de;">number?</span> x) x]                <span style="color: #ff4500;">; </span><span style="color: #ff4500;">exp&#26159;&#19968;&#20010;&#25968;x&#21527;&#65311;&#22914;&#26524;&#26159;&#65292;&#37027;&#20040;&#36820;&#22238;&#36825;&#20010;&#25968;x</span>
      [`(,e1 ,e2)                      <span style="color: #ff4500;">; </span><span style="color: #ff4500;">exp&#26159;&#19968;&#20010;&#21547;&#26377;&#20004;&#26869;&#23376;&#26641;&#30340;&#20013;&#38388;&#33410;&#28857;&#21527;&#65311;</span>
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (tree-sum e1)]        <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36882;&#24402;&#35843;&#29992;tree-sum&#33258;&#24049;&#65292;&#23545;&#24038;&#23376;&#26641;e1&#27714;&#20540;</span>
             [<span style="color: #eedd82;">v2</span> (tree-sum e2)])       <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36882;&#24402;&#35843;&#29992;tree-sum&#33258;&#24049;&#65292;&#23545;&#21491;&#23376;&#26641;e2&#27714;&#20540;</span>
         (<span style="color: #b0c4de;">+</span> v1 v2))])))                <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36820;&#22238;&#24038;&#21491;&#23376;&#26641;&#32467;&#26524;v1&#21644;v2&#30340;&#21644;</span>
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-racket">(tree-sum '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span>))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 3</span>
(tree-sum '(<span style="color: #2e8b57;">1</span> (<span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>)))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 6</span>
(tree-sum '((<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span>) <span style="color: #2e8b57;">3</span>))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 6</span>
(tree-sum '((<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span>) (<span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 10</span>
</pre>
</div>

<p>
注意：这是一颗二叉树，所以不会含有长度超过2的子树，你不需要考虑像 ((1 2) (3 4 5)) 这类情况。需要考虑的例子是像这样：(1 2)，(1 (2 3)), ((1 2) 3) ((1 2) (3 4))
</p>


<p>
这个算法很简单，我们可以把它用文字描述如下：
</p>
<ol class="org-ol">
<li>如果输入exp是一个数，那就返回这个数</li>
<li>如果exp是像 (,e1 ,e2) 这样的子树，那么分别对 e1 和 e2 递归调用 tree-sum，进行求和，得到 v1 和 v2，然后返回 v1 + v2 的和</li>
</ol>
</div>


<div id="outline-container-org2897488" class="outline-3">
<h3 id="org2897488">模式匹配</h3>
<div class="outline-text-3" id="text-org2897488">
<p>
上面的代码里面使用的是Racket的模式匹配。这个例子用if或者cond其实也可以，但要把这代码扩展成一个解释器，所以提前使用了模式匹配。这样跟后面的代码对比的时候，就更容易看出规律来
</p>

<p>
模式匹配的形式一般是这样：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #b0c4de;">match</span> x
  [&#27169;&#24335; &#32467;&#26524;]
  [&#27169;&#24335; &#32467;&#26524;]
   <span style="color: #00ffff;">...</span>   <span style="color: #00ffff;">...</span>
)    
</pre>
</div>
<p>
它先对x求值，然后根据值的结构来进行分支。每个分支由两部分组成，左边是一个模式，右边是一个结果。整个match语句的语义是这样：从上到下依次考虑，找到第一个可以匹配 x 的值的模式，返回它右边的结果。左边的模式在匹配之后，可能会绑定一些变量，这些变量可以在右边的表达式里使用
</p>

<p>
模式匹配是一种分支语句，它在逻辑上就是Scheme的cond表达式，或者Java的嵌套条件语句 if &#x2026; else if &#x2026; else &#x2026;。然而跟条件语句里的“条件”不同，每条 match 语句左边的模式，可以准确而形象地描述数据结构的形状，而且可以在匹配的同时，对结构里的成员进行“绑定”。这样我们可以在右边方便的访问结构成员，而不需要使用访问函数或者foo.x这样的属性语法。而且模式可以有嵌套的子结构，所以它能够一次性的表示复杂的数据结构
</p>

<p>
上面的代码里用了这样一个match表达式：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #b0c4de;">match</span> <span style="color: #b0c4de;">exp</span>
  [(? <span style="color: #b0c4de;">number?</span> x) x]
  [`(,e1 ,e2)
   (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (tree-sum e1)]
         [<span style="color: #eedd82;">v2</span> (tree-sum e2)])
     (<span style="color: #b0c4de;">+</span> v1 v2))])
</pre>
</div>
<p>
第二行里面的'(,e1 ,e2)是一个模式，它被用来匹配exp的值。如果exp是'(1 2)，那么它与'(,e1 ,e2)匹配的时候，就会把e1绑定到'1，把e2绑定到'2。这是因为它们结构相同：
</p>
<div class="org-src-container">
<pre class="src src-racket">`(,e1 ,e2)
'(  <span style="color: #2e8b57;">1</span>   <span style="color: #2e8b57;">2</span>)
</pre>
</div>
<p>
说白了，模式就是一个可以含有“名字”（像e1和e2）的结构，像'(,e1 ,e2)。我们拿这个带有名字的结构，去匹配实际数据，像'(1 2)。当它们一一对应之后，这些名字就被绑定到数据里对应位置的值
</p>

<p>
第一行的“模式”比较特殊，(? number? x)表示的，其实是一个普通的条件判断，相当于(number? exp)，如果这个条件成立，那么它把exp的值绑定到 x，这样右边就可以用x来指代exp。对于无法细分的结构（比如数字，布尔值），你只能用这种方式来“匹配”。看起来有点奇怪，不过习惯了就好了
</p>

<p>
模式匹配对解释器和编译器的书写相当有用，因为程序的语法树往往具有嵌套的结构。不用模式匹配的话，往往要写冗长，复杂，不直观的代码，才能描述出期望的结构。而且由于结构的嵌套比较深，很容易漏掉边界情况，造成错误。模式匹配可以直观的描述期望的结构，避免漏掉边界情况，而且可以方便的访问结构成员
</p>
</div>
</div>
</div>

<div id="outline-container-orga332a5c" class="outline-2">
<h2 id="orga332a5c">计算器</h2>
<div class="outline-text-2" id="text-orga332a5c">
<p>
计算器也是一种解释器，只不过它只能处理算术表达式。我们的下一个目标，就是写出一个计算器。如果你给它'(* (+ 1 2) (+ 3 4))，它就输出 21。可不要小看这个计算器，稍后我们把它稍加改造，就可以得到一个更多功能的解释器
</p>

<p>
上面的代码里，我们利用递归遍历，对树里的数字求和。那段代码里，其实已经隐藏了一个解释器的框架。你观察一下，一个算术表达式 '(* (+ 1 2) (+ 3 4))，跟二叉树 '((1 2) (3 4)) 有什么不同？发现没有，这个算术表达式比起二叉树，只不过在每个子树结构里多出了一个操作符：一个 * 和两个 + 。它不再是一棵二叉树，而是一种更通用的树结构
</p>

<p>
这点区别，也就带来了二叉树求和与解释器算法的区别。对二叉树进行求和的时候，在每个子树节点，我们都做加法。而对表达式进行解释的时候，在每一个子树节点，我们不一定进行加法。根据子树的“操作符”不同，我们可能会选择加，减，乘，除四种操作。
</p>

<p>
好了，下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果：
</p>
<div class="org-src-container">
<pre class="src src-racket"><span style="color: #00ffff;">#lang</span> racket                                  <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#22768;&#26126;&#29992; Racket &#35821;&#35328;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">calc</span>
  (<span style="color: #00ffff;">lambda</span> (<span style="color: #b0c4de;">exp</span>)
    (<span style="color: #b0c4de;">match</span> <span style="color: #b0c4de;">exp</span>                                <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#20998;&#25903;&#21305;&#37197;&#65306;&#34920;&#36798;&#24335;&#30340;&#20004;&#31181;&#24773;&#20917;</span>
      [(? <span style="color: #b0c4de;">number?</span> x) x]                       <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#26159;&#25968;&#23383;&#65292;&#30452;&#25509;&#36820;&#22238;</span>
      [`(,op ,e1 ,e2)                         <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#21305;&#37197;&#25552;&#21462;&#25805;&#20316;&#31526;op&#21644;&#20004;&#20010;&#25805;&#20316;&#25968;e1,e2</span>
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (calc e1)]                   <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36882;&#24402;&#35843;&#29992; calc &#33258;&#24049;&#65292;&#24471;&#21040; e1 &#30340;&#20540;</span>
             [<span style="color: #eedd82;">v2</span> (calc e2)])                  <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36882;&#24402;&#35843;&#29992; calc &#33258;&#24049;&#65292;&#24471;&#21040; e2 &#30340;&#20540;</span>
         (<span style="color: #b0c4de;">match</span> op                            <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#20998;&#25903;&#21305;&#37197;&#65306;&#25805;&#20316;&#31526; op &#30340; 4 &#31181;&#24773;&#20917;</span>
           [<span style="color: #2e8b57;">'+</span> (<span style="color: #b0c4de;">+</span> v1 v2)]                     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#22914;&#26524;&#26159;&#21152;&#21495;&#65292;&#36755;&#20986;&#32467;&#26524;&#20026; (+ v1 v2)</span>
           [<span style="color: #2e8b57;">'-</span> (<span style="color: #b0c4de;">-</span> v1 v2)]                     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#22914;&#26524;&#26159;&#20943;&#21495;&#65292;&#20056;&#21495;&#65292;&#38500;&#21495;&#65292;&#30456;&#20284;&#30340;&#22788;&#29702;</span>
           [<span style="color: #2e8b57;">'*</span> (<span style="color: #b0c4de;">*</span> v1 v2)]
           [<span style="color: #2e8b57;">'/</span> (<span style="color: #b0c4de;">/</span> v1 v2)]))])))
</pre>
</div>
<p>
测试结果：
</p>

<div class="org-src-container">
<pre class="src src-racket">(calc '(<span style="color: #b0c4de;">+</span> <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span>))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 3</span>
(calc '(<span style="color: #b0c4de;">*</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 6</span>
   (calc '(<span style="color: #b0c4de;">*</span> (<span style="color: #b0c4de;">+</span> <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span>) (<span style="color: #b0c4de;">+</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)))
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 21</span>
</pre>
</div>

<p>
跟之前的二叉树求和代码比较一下，你会发现它们惊人的相似，因为解释器本来就是一个树遍历算法。不过你发现它们有什么不同吗？它们的不同点在于：
</p>
<ol class="org-ol">
<li>算术表达式的模式里面，多出了一个“操作符”（op）叶节点：(,op ,e1 ,e2)</li>
<li><p>
对子树e1和e2分别求值之后，我们不是返回 (+ v1 v2)，而是根据op的不同，返回不同的结果：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #b0c4de;">match</span> op
  [<span style="color: #2e8b57;">'+</span> (<span style="color: #b0c4de;">+</span> v1 v2)]
  [<span style="color: #2e8b57;">'-</span> (<span style="color: #b0c4de;">-</span> v1 v2)]
  [<span style="color: #2e8b57;">'*</span> (<span style="color: #b0c4de;">*</span> v1 v2)]
  [<span style="color: #2e8b57;">'/</span> (<span style="color: #b0c4de;">/</span> v1 v2)])
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgb4fbfba" class="outline-2">
<h2 id="orgb4fbfba">R2：一个很小的程序语言</h2>
<div class="outline-text-2" id="text-orgb4fbfba">
<p>
实现了一个计算器，现在让我们过渡到一种更强大的语言。为了方便称呼，我给它起了一个叫R2。R2 起之前的计算器，只多出四个元素，它们分别是：变量，函数，绑定，调用。再加上之前介绍的算术操作，我们就得到一个很简单的程序语言，它只有5种不同的构造。用Scheme的语法，这5种构造看起来就像这样：
</p>
<ul class="org-ul">
<li>变量：x</li>
<li>函数：(lambda (x) e)</li>
<li>绑定：(let ([x e1]) e2)</li>
<li>调用：(e1 e2)</li>
<li>算术：(• e1 e2)</li>
</ul>
<p>
其中，• 是一个算术操作符，可以选择 +, -, *, / 其中之一
</p>

<p>
一般程序语言还有很多其它构造，可是一开头就试图去实现所有那些，只会让人糊涂。最好是把这少数几个东西搞清楚，确保它们正确之后，才慢慢加入其它元素
</p>

<p>
这些构造的语义，跟Scheme里面的同名构造几乎一模一样。如果你不清楚什么是”绑定“，那你可以把它看成是普通语言里的”变量声明“
</p>
</div>

<div id="outline-container-orge40c375" class="outline-3">
<h3 id="orge40c375">柯里化</h3>
<div class="outline-text-3" id="text-orge40c375">
<p>
需要注意的是，跟一般语言不同，我们的函数只接受一个参数。这不是一个严重的限制，因为在我们的语言里，函数可以被作为值传递，也就是所谓“first-class function”。所以你可以用嵌套的函数定义来表示有两个以上参数的函数
</p>

<p>
举个例子， (lambda (x) (lambda (y) (+ x y))) 是个嵌套的函数定义，它也可以被看成是有两个参数（x 和 y）的函数，这个函数返回 x 和 y 的和。当这样的函数被调用的时候，需要两层调用，就像这样：
</p>
<div class="org-src-container">
<pre class="src src-scheme">(((<span style="color: #00ffff;">lambda</span> (x) (<span style="color: #00ffff;">lambda</span> (y) (+ x y))) 1) 2)
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 3</span>
</pre>
</div>

<p>
这种做法在PL术语里面，叫做柯里化（currying）。看起来啰嗦，但这样我们的解释器可以很简单。等我们理解了基本的解释器，再实现真正的多参数函数也不迟。
</p>

<p>
另外，我们的绑定语法(let ([x e1]) e2)，比起Scheme的绑定也有一些局限。我们的let只能绑定一个变量，而Scheme可以绑定多个，像这样(let ([x 1] [y 2]) (+ x y))。这也不是一个严重的限制，因为可以啰嗦一点，用嵌套的 let 绑定：
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">let</span> ([x 1])
  (<span style="color: #00ffff;">let</span> ([y 2])
    (+ x y)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge6bddec" class="outline-2">
<h2 id="orge6bddec">R2 的解释器</h2>
<div class="outline-text-2" id="text-orge6bddec">
<p>
下面是我们今天要完成的解释器，它可以运行一个R2程序：
</p>
<div class="org-src-container">
<pre class="src src-racket"><span style="color: #00ffff;">#lang</span> <span style="color: #eedd82;">racket</span>

<span style="color: #ff4500;">;;; </span><span style="color: #ff4500;">&#20197;&#19979;&#19977;&#20010;&#23450;&#20041; env0, ext-env, lookup &#26159;&#23545;&#29615;&#22659;&#65288;environment&#65289;&#30340;&#22522;&#26412;&#25805;&#20316;&#65306;</span>

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#31354;&#29615;&#22659;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">env0</span> '())

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#25193;&#23637;&#12290;&#23545;&#29615;&#22659; env &#36827;&#34892;&#25193;&#23637;&#65292;&#25226; x &#26144;&#23556;&#21040; v&#65292;&#24471;&#21040;&#19968;&#20010;&#26032;&#30340;&#29615;&#22659;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">ext-env</span>
  (<span style="color: #00ffff;">lambda</span> (x v env)
    (<span style="color: #b0c4de;">cons</span> `(,x . ,v) env)))

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#26597;&#25214;&#12290;&#22312;&#29615;&#22659;&#20013; env &#20013;&#26597;&#25214; x &#30340;&#20540;&#12290;&#22914;&#26524;&#27809;&#25214;&#21040;&#23601;&#36820;&#22238; #f</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">lookup</span>
  (<span style="color: #00ffff;">lambda</span> (x env)
    (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">p</span> (<span style="color: #b0c4de;">assq</span> x env)])
      (<span style="color: #00ffff;">cond</span>
        [(<span style="color: #b0c4de;">not</span> p) <span style="color: #2e8b57;">#f</span>]
        [<span style="color: #00ffff;">else</span> (<span style="color: #b0c4de;">cdr</span> p)]))))

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#38381;&#21253;&#30340;&#25968;&#25454;&#32467;&#26500;&#23450;&#20041;&#65292;&#21253;&#21547;&#19968;&#20010;&#20989;&#25968;&#23450;&#20041; f &#21644;&#23427;&#23450;&#20041;&#26102;&#25152;&#22312;&#30340;&#29615;&#22659;</span>
(<span style="color: #00ffff;">struct</span> Closure (f env))

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#35299;&#37322;&#22120;&#30340;&#36882;&#24402;&#23450;&#20041;&#65288;&#25509;&#21463;&#20004;&#20010;&#21442;&#25968;&#65292;&#34920;&#36798;&#24335; exp &#21644;&#29615;&#22659; env&#65289;</span>
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#20849; 5 &#31181;&#24773;&#20917;&#65288;&#21464;&#37327;&#65292;&#20989;&#25968;&#65292;&#32465;&#23450;&#65292;&#35843;&#29992;&#65292;&#25968;&#23383;&#65292;&#31639;&#26415;&#34920;&#36798;&#24335;&#65289;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">interp</span>
  (<span style="color: #00ffff;">lambda</span> (<span style="color: #b0c4de;">exp</span> env)
    (<span style="color: #b0c4de;">match</span> <span style="color: #b0c4de;">exp</span>                                          <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#23545;exp&#36827;&#34892;&#27169;&#24335;&#21305;&#37197;</span>
      [(? <span style="color: #b0c4de;">symbol?</span> x)                                    <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#21464;&#37327;</span>
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v</span> (lookup x env)])
         (<span style="color: #00ffff;">cond</span>
           [(<span style="color: #b0c4de;">not</span> v)
            (<span style="color: #b0c4de;">error</span> <span style="color: #ffa07a;">"undefined variable"</span> x)]
           [<span style="color: #00ffff;">else</span> v]))]      
      [(? <span style="color: #b0c4de;">number?</span> x) x]                                 <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#25968;&#23383;</span>
      [`(<span style="color: #00ffff;">lambda</span> (,x) ,e)                                <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#20989;&#25968;</span>
       (Closure <span style="color: #b0c4de;">exp</span> env)]
      [`(<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">,x</span> ,e1]) ,e2)                            <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#32465;&#23450;</span>
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)])
         (interp e2 (ext-env x v1 env)))]
      [`(,e1 ,e2)                                       <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#35843;&#29992;</span>
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)]
             [<span style="color: #eedd82;">v2</span> (interp e2 env)])
         (<span style="color: #b0c4de;">match</span> v1
           [(Closure `(<span style="color: #00ffff;">lambda</span> (,x) ,e) env-save)
            (interp e (ext-env x v2 env-save))]))]
      [`(,op ,e1 ,e2)                                   <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#31639;&#26415;&#34920;&#36798;&#24335;</span>
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)]
             [<span style="color: #eedd82;">v2</span> (interp e2 env)])
         (<span style="color: #b0c4de;">match</span> op
           [<span style="color: #2e8b57;">'+</span> (<span style="color: #b0c4de;">+</span> v1 v2)]
           [<span style="color: #2e8b57;">'-</span> (<span style="color: #b0c4de;">-</span> v1 v2)]
           [<span style="color: #2e8b57;">'*</span> (<span style="color: #b0c4de;">*</span> v1 v2)]
           [<span style="color: #2e8b57;">'/</span> (<span style="color: #b0c4de;">/</span> v1 v2)]))])))

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#35299;&#37322;&#22120;&#30340;&#8220;&#29992;&#25143;&#30028;&#38754;&#8221;&#20989;&#25968;&#12290;&#23427;&#25226; interp &#21253;&#35013;&#36215;&#26469;&#65292;&#25513;&#30422;&#31532;&#20108;&#20010;&#21442;&#25968;&#65292;&#21021;&#22987;&#20540;&#20026; env0</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">r2</span>
  (<span style="color: #00ffff;">lambda</span> (<span style="color: #b0c4de;">exp</span>)
    (interp <span style="color: #b0c4de;">exp</span> env0)))
</pre>
</div>
</div>

<div id="outline-container-org8d0a8b3" class="outline-3">
<h3 id="org8d0a8b3">基本算术操作</h3>
<div class="outline-text-3" id="text-org8d0a8b3">
<p>
算术操作一般都是程序里最基本的构造，它们不能再被细分为多个步骤，所以我们先来看看对算术操作的处理。以下就是R2解释器处理算术的部分，它是interp的最后一个分支：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #b0c4de;">match</span> <span style="color: #b0c4de;">exp</span>
  <span style="color: #00ffff;">...</span> <span style="color: #00ffff;">...</span>
  [`(,op ,e1 ,e2)
   (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)]             <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36882;&#24402;&#35843;&#29992; interp &#33258;&#24049;&#65292;&#24471;&#21040; e1 &#30340;&#20540;</span>
         [<span style="color: #eedd82;">v2</span> (interp e2 env)])            <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#36882;&#24402;&#35843;&#29992; interp &#33258;&#24049;&#65292;&#24471;&#21040; e2 &#30340;&#20540;</span>
     (<span style="color: #b0c4de;">match</span> op                            <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#20998;&#25903;&#65306;&#22788;&#29702;&#25805;&#20316;&#31526; op &#30340; 4 &#31181;&#24773;&#20917;</span>
       [<span style="color: #2e8b57;">'+</span> (<span style="color: #b0c4de;">+</span> v1 v2)]                     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#22914;&#26524;&#26159;&#21152;&#21495;&#65292;&#36755;&#20986;&#32467;&#26524;&#20026; (+ v1 v2)</span>
       [<span style="color: #2e8b57;">'-</span> (<span style="color: #b0c4de;">-</span> v1 v2)]                     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#22914;&#26524;&#26159;&#20943;&#21495;&#65292;&#20056;&#21495;&#65292;&#38500;&#21495;&#65292;&#30456;&#20284;&#30340;&#22788;&#29702;</span>
       [<span style="color: #2e8b57;">'*</span> (<span style="color: #b0c4de;">*</span> v1 v2)]
       [<span style="color: #2e8b57;">'/</span> (<span style="color: #b0c4de;">/</span> v1 v2)]))])
</pre>
</div>
<p>
你可以看到它几乎跟刚才写的计算器一模一样，不过现在interp的调用多了一个参数 env 而已。这个env是所谓“环境”
</p>
</div>
</div>

<div id="outline-container-orgdbc8902" class="outline-3">
<h3 id="orgdbc8902">数字</h3>
<div class="outline-text-3" id="text-orgdbc8902">
<p>
对数字的解释很简单，把它们原封不动返回就可以了
</p>
<div class="org-src-container">
<pre class="src src-racket">[(? <span style="color: #b0c4de;">number?</span> x) x]
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d46c7a" class="outline-3">
<h3 id="org4d46c7a">变量</h3>
<div class="outline-text-3" id="text-org4d46c7a">
<p>
变量的产生，是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使函数的实现成为可能。比如数学函数f(x) = x * 2，其中x是一个变量，它把输入的值传递到函数体x * 2 里面。如果没有变量，函数就不可能实现
</p>

<p>
对变量最基本的操作，是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？ 拿上面的函数f(x)作为例子。当我们调用f(1)时，函数体里面的x等于1，所以x * 2的值是2，而当我们调用f(2)时，函数体里面的x等于2，所以x * 2的值是4。这里，两次对 f 的调用，分别对x进行了两次绑定。第一次x被绑定到了1，第二次被绑定到了2
</p>
</div>

<div id="outline-container-org5da0203" class="outline-4">
<h4 id="org5da0203">环境</h4>
<div class="outline-text-4" id="text-org5da0203">
<p>
我们的解释器只能一步一步的做事情。比如，当它需要求f(1)的值的时候，它分成两步操作：
</p>
<ol class="org-ol">
<li>把x绑定到1，这样函数体内才能看见这个绑定</li>
<li>进入f的函数体，对x * 2 进行求值</li>
</ol>

<p>
在我们的解释器里，用于处理环境的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-racket"><span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#31354;&#29615;&#22659;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">env0</span> '())

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#23545;&#29615;&#22659; env &#36827;&#34892;&#25193;&#23637;&#65292;&#25226; x &#26144;&#23556;&#21040; v</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">ext-env</span>
  (<span style="color: #00ffff;">lambda</span> (x v env)
    (<span style="color: #b0c4de;">cons</span> `(,x . ,v) env)))

<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">&#21462;&#20540;&#12290;&#22312;&#29615;&#22659;&#20013; env &#20013;&#26597;&#25214; x &#30340;&#20540;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">lookup</span>
  (<span style="color: #00ffff;">lambda</span> (x env)
    (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">p</span> (<span style="color: #b0c4de;">assq</span> x env)])
      (<span style="color: #00ffff;">cond</span>
        [(<span style="color: #b0c4de;">not</span> p) <span style="color: #2e8b57;">#f</span>]
        [<span style="color: #00ffff;">else</span> (<span style="color: #b0c4de;">cdr</span> p)]))))
</pre>
</div>
<p>
这里我们用一种最简单的数据结构，association list来表示环境。看起来像这个样子：((x . 1) (y . 2) (z . 5))。它是一个两元组（pair）的链表，左边的元素是key，右边的元素是value。写得直观一点就是：
</p>
<div class="org-src-container">
<pre class="src src-scheme">((x . 1)
 (y . 2)
 (z . 5))
</pre>
</div>
<p>
查表操作就是从头到尾搜索，如果左边的key是要找的变量，就返回整个pair。效率很低，但是足够完成我们现在的任务
</p>
</div>

<div id="outline-container-org784c1b6" class="outline-5">
<h5 id="org784c1b6">环境扩展</h5>
<div class="outline-text-5" id="text-org784c1b6">
<p>
扩展一个环境。比如，如果原来的环境env1是((y . 2) (x . 1)) 那么(ext-env x 3 env1)，就会返回((x . 3) (y . 2) (x . 1))。也就是把(x . 3)加到env1的最前面去
</p>

<p>
那我们什么时候需要扩展环境呢？当我们进行绑定的时候。绑定可能出现在函数调用时，也可能出现在let绑定时。我们选择的数据结构，使得环境自然而然的具有了作用域（scope）的特性
</p>

<p>
环境其实是一个堆栈。内层的绑定，会出现在环境的最上面，这就是在“压栈”。这样我们查找变量的时候，会优先找到最内层定义的变量：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">x</span> <span style="color: #2e8b57;">1</span>])         <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='()&#12290;&#32465;&#23450;x&#21040;1&#12290;</span>
  (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">y</span> <span style="color: #2e8b57;">2</span>])       <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='((x . 1))&#12290;&#32465;&#23450;y&#21040;2&#12290;</span>
    (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">x</span> <span style="color: #2e8b57;">3</span>])     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='((y . 2) (x . 1))&#12290;&#32465;&#23450;x&#21040;3&#12290;</span>
      (<span style="color: #b0c4de;">+</span> x y))))     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='((x . 3) (y . 2) (x . 1))&#12290;&#26597;&#25214;x&#65292;&#24471;&#21040;3&#65307;&#26597;&#25214;y&#65292;&#24471;&#21040;2&#12290;</span>
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 5</span>
</pre>
</div>
<p>
这段代码会返回5。这是因为最内层的绑定，把(x . 3)放到了环境的最前面，这样查找 x 的时候，我们首先看到(x . 3)，然后就返回值3。之前放进去的(x . 1) 仍然存在，但是我们先看到了最上面的那个(x . 3)，所以它被忽略了。
</p>

<p>
这并不等于说(x . 1) 就可以被改写或者丢弃，因为它仍然是有用的。你只需要看一个稍微不同的例子，就知道这是怎么回事：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">x</span> <span style="color: #2e8b57;">1</span>])          <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='()&#12290;&#32465;&#23450;x&#21040;1&#12290;</span>
  (<span style="color: #b0c4de;">+</span> (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">x</span> <span style="color: #2e8b57;">2</span>])     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='((x . 1))&#12290;&#32465;&#23450;x&#21040;2&#12290;</span>
       x)             <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='((x . 2) (x . 1))&#12290;&#26597;&#25214;x&#65292;&#24471;&#21040;2&#12290;</span>
     x))                <span style="color: #ff4500;">; </span><span style="color: #ff4500;">env='((x . 1))&#12290;&#26597;&#25214;x&#65292;&#24471;&#21040;1&#12290;</span>
<span style="color: #ff4500;">;; </span><span style="color: #ff4500;">=&gt; 3               ; &#20004;&#20010;&#19981;&#21516;&#30340;x&#30340;&#21644;&#65292;1+2&#31561;&#20110;3&#12290;</span>
</pre>
</div>
<p>
这个例子会返回3。它是第3行和第4行里面两个x的和。由于第3行的x处于内层let里面，那里的环境是((x . 2) (x . 1))，所以查找x的值得到2。第4行的x在内层let外面，但是在外层let里面，那里的环境是((x . 1))，所以查找x的值得到1。这很符合直觉，因为x总是找到最内层的定义
</p>

<p>
值得注意的是，环境被扩展以后，形成了一个新的环境，而原来的环境并没有被改变。比如，上面的((y . 2) (x . 1))并没有删除或者修改，只不过是被“引用”到一个更大的列表里去了
</p>

<p>
这样不对已有数据进行修改的数据结构，叫做“函数式数据结构”。函数式数据结构只生成新的数据，而不改变或者删除老的。它可能引用老的结构，然而却不改变老的结构。这种“不修改”的性质，在我们的解释器里是很重要的，因为当我们扩展一个环境，进入递归，返回之后，外层的代码必须仍然可以访问原来外层的环境
</p>

<p>
当然我们也可以用另外的，更高效的数据结构（比如平衡树，串接起来的哈希表）来表示环境。如果你学究一点，甚至可以用函数来表示环境。这里为了代码简单，我们选择了最笨，然而正确，容易理解的数据结构
</p>
</div>
</div>
</div>

<div id="outline-container-org49990cd" class="outline-4">
<h4 id="org49990cd">变量的取值</h4>
<div class="outline-text-4" id="text-org49990cd">
<p>
了解了变量，函数和环境，我们来看看解释器对变量的“取值”操作，也就是match的第一种情况：
</p>
<div class="org-src-container">
<pre class="src src-racket">[(? <span style="color: #b0c4de;">symbol?</span> x) (lookup x env)]
</pre>
</div>
<p>
这就是在环境中，沿着从内向外的“作用域顺序”，查找变量的值
</p>

<p>
这里的(? symbol? x)是一种特殊的模式，它使用函数symbol?来判断输入是否是一个符号，如果是，就把它绑定到x，然后你就可以在右边用x来指称这个输入
</p>
</div>
</div>
</div>

<div id="outline-container-orgf082c36" class="outline-3">
<h3 id="orgf082c36">绑定</h3>
<div class="outline-text-3" id="text-orgf082c36">
<p>
现在我们来看看对let绑定的解释：
</p>
<div class="org-src-container">
<pre class="src src-racket">[`(<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">,x</span> ,e1]) ,e2)                           
 (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)])              <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#35299;&#37322;&#21491;&#36793;&#34920;&#36798;&#24335;e1&#65292;&#24471;&#21040;&#20540;v1</span>
   (interp e2 (ext-env x v1 env)))]       <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#25226;(x . v1)&#25193;&#20805;&#21040;&#29615;&#22659;&#39030;&#37096;&#65292;&#23545;e2&#27714;&#20540;</span>
</pre>
</div>
<p>
通过代码里的注释，你也许已经可以理解它在做什么。我们先对表达式e1求值，得到v1。然后我们把(x . v1)扩充到环境里，这样(let ([x e1]) &#x2026;) 内部都可以看到x的值。然后我们使用这个扩充后的环境，递归调用解释器本身，对let的主体e2求值。它的返回值就是这个 let 绑定的值
</p>
</div>
</div>

<div id="outline-container-org4e907d4" class="outline-3">
<h3 id="org4e907d4">函数</h3>
<div class="outline-text-3" id="text-org4e907d4">
<p>
下面我们准备谈谈函数定义和调用。对函数的解释是一个微妙的问题，很容易弄错，这是由于函数体内也许会含有外层的变量，叫做“自由变量”。所以在分析函数的代码之前，我们来了解一下不同的“作用域”规则
</p>
</div>
<div id="outline-container-orgdce1f02" class="outline-4">
<h4 id="orgdce1f02">Lexical Scoping 和 Dynamic Scoping</h4>
<div class="outline-text-4" id="text-orgdce1f02">
<p>
我们举个例子来解释这个问题。下面这段代码，它的值应该是多少呢？
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">x</span> <span style="color: #2e8b57;">2</span>])
  (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">f</span> (<span style="color: #00ffff;">lambda</span> (y) (<span style="color: #b0c4de;">*</span> x y))])
    (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">x</span> <span style="color: #2e8b57;">4</span>])
      (f <span style="color: #2e8b57;">3</span>))))
</pre>
</div>
<p>
在这里，f函数体 (lambda (y) (* x y))里的那个 x，就是一个“自由变量”。x并不是这个函数的参数，也不是在这个函数里面定义的，所以我们必须到函数外面去找x的值。
</p>

<p>
我们的代码里面，有两个地方对x进行了绑定，一个等于2，一个等于4，那么x到底应该是指向哪一个绑定呢？这似乎无关痛痒，然而当我们调用(f 3)的时候，严重的问题来了。f的函数体是 (* x y)，我们知道y的值来自参数3，可是x的值是多少呢？ 它应该是2，还是4呢？
</p>

<p>
在历史上，这段代码可能有两种不同的结果，这种区别一直延续到今天。如果你在Racket里面写以上的代码，它的结果是6。而在emacs-lisp中它的结果是12
</p>

<p>
Racket的方式叫做lexical scoping，而Emacs的方式叫做dynamic scoping
</p>

<p>
那么哪一种方式更好呢？或者用哪一种都无所谓？答案：dynamic scoping是非常错误的做法。历史的教训告诉我们，它会带来许许多多莫名其妙的bug，导致dynamic scoping的语言几乎完全没法用。原因在于，像(let ((x 4)) …)这样的变量绑定，只应该影响它内部“看得见”的 x 的值。当我们看见(let ((x 4)) (f 3))的时候，并没有在let的内部看见任何叫“x” 的变量，所以我们“直觉”的认为，(let ((x 4)) …)对x的绑定，不应该引起(f 3)的结果变化。然而对于dynamic scoping，我们的直觉却是错误的。因为f的函数体里面有一个x，虽然我们没有在(f 3)这个调用里面看见它，然而它却存在于f定义的地方。要知道，f定义的地方也许隔着几百行代码，甚至在另外一个文件里面。而且调用函数的人凭什么应该知道， f的定义里面有一个自由变量，它的名字叫做x？所以 dynamic scoping在设计学的角度来看，是一个反人类的设计
</p>

<p>
相反，lexical scoping却是符合人们直觉的。虽然在(let ((x 4)) (f 3))里面，我们把x绑定到了4，然而f的函数体并不是在那里定义的，我们也没在那里看见任何x，所以f的函数体里面的x，仍然指向我们定义它的时候看得见的那个x，也就是最上面的那个(let ([x 2]) &#x2026;)，它的值是2。所以(f 3)的值应该等于6，而不是12
</p>
</div>
</div>

<div id="outline-container-org96669cf" class="outline-4">
<h4 id="org96669cf">函数定义</h4>
<div class="outline-text-4" id="text-org96669cf">
<p>
为了实现lexical scoping，我们必须把函数做成“闭包”。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。我们把闭包定义为一个Racket的struct结构：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #00ffff;">struct</span> Closure (f env))
</pre>
</div>

<p>
有了这个数据结构，我们对(lambda (x) e)的解释就可以写成这样：
</p>
<div class="org-src-container">
<pre class="src src-racket">[`(<span style="color: #00ffff;">lambda</span> (,x) ,e)
 (Closure <span style="color: #b0c4de;">exp</span> env)]
</pre>
</div>

<p>
注意：这里的 exp 就是 ``(lambda (,x) ,e)` 自己。
</p>

<p>
有意思的是，我们的解释器遇到(lambda (x) e)，几乎没有做任何计算。它只是把这个函数包装了一下，把它与当前的环境一起，打包放到一个数据结构Closure里面。这个闭包结构，记录了我们在函数定义的位置“看得见”的那个环境。稍候在调用的时候，我们就能从这个闭包的环境里面，得到函数体内的自由变量的值
</p>
</div>
</div>
</div>

<div id="outline-container-orgfcbfc9f" class="outline-3">
<h3 id="orgfcbfc9f">调用</h3>
<div class="outline-text-3" id="text-orgfcbfc9f">
<div class="org-src-container">
<pre class="src src-racket">[`(,e1 ,e2)                                            
 (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)]             <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#35745;&#31639;&#20989;&#25968; e1 &#30340;&#20540;</span>
       [<span style="color: #eedd82;">v2</span> (interp e2 env)])            <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#35745;&#31639;&#21442;&#25968; e2 &#30340;&#20540;</span>
   (<span style="color: #b0c4de;">match</span> v1
     [(Closure `(<span style="color: #00ffff;">lambda</span> (,x) ,e) env-save)      <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#29992;&#27169;&#24335;&#21305;&#37197;&#30340;&#26041;&#24335;&#21462;&#20986;&#38381;&#21253;&#37324;&#30340;&#21508;&#20010;&#23376;&#32467;&#26500;</span>
      (interp e (ext-env x v2 env-save))]))]    <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#22312;&#38381;&#21253;&#30340;&#29615;&#22659;env-save&#20013;&#25226;x&#32465;&#23450;&#21040;v2&#65292;&#35299;&#37322;&#20989;&#25968;&#20307;</span>
</pre>
</div>
<p>
函数调用都是(e1 e2)这样的形式，e1表示函数，e2是它的参数。我们需要先分别求出函数e1和参数e2的值
</p>

<p>
比如，当(lambda (x) (* x 2))被作用于1时，我们把x绑定到1，然后解释它的函数体(* x 2)。但是这里有一个问题，函数体内的自由变量应该取什么值呢？从上面闭包的讨论，你已经知道了，自由变量的值，应该从闭包的环境查询
</p>

<p>
操作数e1的值v1是一个闭包，它里面包含一个函数定义时保存的环境env-save。我们把这个环境env-save取出来，那我们就可以查询它，得到函数体内自由变量的值。然而函数体内不仅有自由变量，还有对函数参数的使用，所以我们必须扩展这个env-save 环境，把参数的值加进去。这就是为什么我们使用(ext-env x v2 env-save)，而不只是env-save
</p>
</div>

<div id="outline-container-orgc4928a2" class="outline-4">
<h4 id="orgc4928a2">dynamic scoping调用</h4>
<div class="outline-text-4" id="text-orgc4928a2">
<p>
你可能会奇怪，那么解释器的环境env难道这里就不用了吗？是的。我们通过env来计算e1和e2的值，是因为e1和e2里面的变量，在“当前环境”env里面看得见。可是函数体的定义，在当前环境下是看不见的。它的代码在别的地方，而那个地方看得见的环境，被我们存在闭包里了，它就是env-save。所以我们把v1里面的闭包环境env-save取出来，用于计算函数体的值
</p>

<p>
有意思的是，如果我们用env，而不是env-save来解释函数体，那我们的语言就变成了dynamic scoping。现在来实验一下：你可以把(interp e (ext-env x v2 env-save))里面的 env-save 改成 env，再试试我们之前讨论过的代码，它的输出就会变成12。那就是我们之前讲过的，dynamic scoping的结果
</p>

<p>
如果我们的语言是dynamic scoping，那就没必要使用闭包了，因为我们根本不需要闭包里面保存的环境。这样一来，dynamic scoping的解释器就可以写成这样：
</p>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #00ffff;">define</span> <span style="color: #eedd82;">interp</span>
  (<span style="color: #00ffff;">lambda</span> (<span style="color: #b0c4de;">exp</span> env)
    (<span style="color: #b0c4de;">match</span> <span style="color: #b0c4de;">exp</span>                                          
      <span style="color: #00ffff;">...</span> <span style="color: #00ffff;">...</span>
      [`(<span style="color: #00ffff;">lambda</span> (,x) ,e)                          <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#20989;&#25968;&#65306;&#30452;&#25509;&#36820;&#22238;&#33258;&#24049;&#30340;&#34920;&#36798;&#24335;</span>
       <span style="color: #b0c4de;">exp</span>]
      <span style="color: #00ffff;">...</span> <span style="color: #00ffff;">...</span>
      [`(,e1 ,e2)                                       
       (<span style="color: #00ffff;">let</span> ([<span style="color: #eedd82;">v1</span> (interp e1 env)]
             [<span style="color: #eedd82;">v2</span> (interp e2 env)])
         (<span style="color: #b0c4de;">match</span> v1
           [`(<span style="color: #00ffff;">lambda</span> (,x) ,e)                     <span style="color: #ff4500;">; </span><span style="color: #ff4500;">&#35843;&#29992;&#65306;&#30452;&#25509;&#20351;&#29992;&#20989;&#25968;&#30340;&#34920;&#36798;&#24335;&#26412;&#36523;</span>
            (interp e (ext-env x v2 env))]))]
      <span style="color: #00ffff;">...</span> <span style="color: #00ffff;">...</span>
      )))
</pre>
</div>
<p>
注意到这个解释器的函数有多容易实现吗？它就是这个函数的表达式自己，原封不动。用函数的表达式本身来表示它的值，是很直接很简单的做法，也是大部分人一开头就会想到的。然而这样实现出来的语言，就不知不觉地采用了dynamic scoping
</p>

<p>
这就是为什么很多早期的Lisp语言，比如Emacs Lisp，都使用dynamic scoping。这并不是因为它们的设计者在dynamic scoping和lexical scoping两者之中做出了选择，而是因为使用函数的表达式本身来作为它的值，是最直接，一般人都会首先想到的做法
</p>

<p>
另外，在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了
</p>

<p>
如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下很容易出错
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga002f48" class="outline-2">
<h2 id="orga002f48">缺点</h2>
<div class="outline-text-2" id="text-orga002f48">
<p>
现在你已经学会了如何写出一个简单的解释器，它可以处理一个相当强的，具有“first-class 函数”的语言。出于教学的考虑，这个解释器并没有考虑实用的需求，所以它并不能作为“工业应用”。在这里，我指出它的一些不足之处
</p>

<ol class="org-ol">
<li>缺少必要的语言构造。我们的语言里缺少好些实用语言必须的构造：递归，数组，赋值操作，字符串，自定义数据结构</li>
<li>不合法代码的检测和报告。一个实用的解释器，必须加入对代码格式进行全面检测，报告不合法的代码结构</li>
<li>低效率的数据结构。一个实用的解释器，需要更高效的数据结构。这种数据结构不一定非得是函数式的。你也可以用非函数式的数据结构（比如哈希表），经过一定的改造，达到同样的性质，却具有更高的效率。另外，你还可以把环境转化成一个数组。给环境里的每个变量分配一个下标（index），在这个数组里就可以找到它的值。如果你用数组表示环境，那么这个解释器就向编译器迈进了一步</li>
<li>S表达式的歧义问题。我们的解释器直接使用S表达式来表达语法树，用模式匹配来进行分支遍历。在实际的语言里，这种方式会带来比较大的问题。因为S表达式是一种通用的数据结构，用它表示的东西，看起来都差不多的样子。一旦程序的语法构造多起来，直接对S表达式进行模式匹配，会造成歧义。 ​</li>
</ol>

<p>
比如(,op ,e1 ,e2) ，你以为它只匹配二元算术操作，比如(+ 1 2)。但它其实也可以匹配一个let绑定： (let ([x 1]) (* x 2))。这是因为它们顶层元素的数目是一样的。为了消除歧义，你得小心的安排模式的顺序，比如你必须把(let ([,x ,e1]) ,e2)的模式放在 (,op ,e1, e2) 前面。所以最好的办法，是不要直接在S表达式上写解释器，而是先写一个“parser”，这个parser把S表达式转换成Racket的struct结构。然后解释器再在struct上面进行分支匹配。这样解释器不用担心歧义问题，而且会带来效率的提升
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
