<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>逻辑求值器</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">逻辑求值器</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orged3c7f9">逻辑式程序</a>
<ul>
<li><a href="#org830a03e">演绎信息检索</a>
<ul>
<li><a href="#orgb3413b5">简单数据库</a></li>
<li><a href="#org8826d90">简单查询</a>
<ul>
<li><a href="#org37bbe8f">总结</a></li>
</ul>
</li>
<li><a href="#org8b8caea">复合查询</a>
<ul>
<li><a href="#orged92fa8">and 查询</a></li>
<li><a href="#org34a849f">or 查询</a></li>
<li><a href="#org6d85160">not 查询</a></li>
<li><a href="#orge2d4b18">lisp-value</a></li>
</ul>
</li>
<li><a href="#org2c0d554">规则</a></li>
<li><a href="#org15196b6">逻辑程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org26e3d80">设计</a>
<ul>
<li><a href="#orgcaf1900">模式匹配</a>
<ul>
<li><a href="#org4464a31">简单查询</a></li>
<li><a href="#org8b1df31">and 查询</a></li>
<li><a href="#orgfcf76b3">or 查询</a></li>
<li><a href="#org9d7e3b6">not 查询</a></li>
<li><a href="#org2006086">lisp-value 查询</a></li>
</ul>
</li>
<li><a href="#org4d741dc">合一</a></li>
<li><a href="#org7aadbfb">规则应用</a></li>
<li><a href="#orgff56dc0">简单查询</a></li>
<li><a href="#org5cf0cba">查询求值器</a></li>
<li><a href="#org39b9c65">驱动循环</a></li>
</ul>
</li>
<li><a href="#orge59d02b">数理逻辑</a>
<ul>
<li><a href="#org61b8635">无穷循环</a></li>
<li><a href="#orgd6b0f72">not 问题</a></li>
</ul>
</li>
<li><a href="#orgd612082">实现</a>
<ul>
<li><a href="#org7d6755b">驱动循环和实例化</a></li>
<li><a href="#orgd3927f3">求值器</a>
<ul>
<li><a href="#org04a6a2d">简单查询</a></li>
<li><a href="#org88b3044">复合查询</a>
<ul>
<li><a href="#org133ea16">and 查询</a></li>
<li><a href="#org8417739">or查询</a></li>
</ul>
</li>
<li><a href="#org7cebb4b">过滤器</a>
<ul>
<li><a href="#org1a086f6">not 过滤器</a></li>
<li><a href="#org9b0f0bf">lisp-value 过滤器</a></li>
<li><a href="#orga3b5f94">always-true</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga7418b8">模式匹配</a>
<ul>
<li><a href="#org44923b1">基本匹配器</a></li>
<li><a href="#org1314b03">点号模式</a></li>
</ul>
</li>
<li><a href="#org7384cab">规则合一</a>
<ul>
<li><a href="#org3e8f12b">应用规则</a></li>
<li><a href="#org3b2e2fb">合一操作</a></li>
</ul>
</li>
<li><a href="#org66025b9">数据库操作</a>
<ul>
<li><a href="#org0854998">断言表示</a></li>
<li><a href="#org0ffc0e2">规则表示</a></li>
<li><a href="#org196c26e">添加操作</a></li>
</ul>
</li>
<li><a href="#orgaec05da">流操作</a></li>
<li><a href="#orgc9b7193">语法过程</a>
<ul>
<li><a href="#orgafbf657">类型表达式</a></li>
<li><a href="#org56676c1">断言</a></li>
<li><a href="#orgd2478f8">规则</a></li>
</ul>
</li>
<li><a href="#org3fc2280">框架和约束</a></li>
</ul>
</li>
<li><a href="#orga557968">总结</a></li>
</ul>
</div>
</div>
<p>
<b>数学</b> 处理 <span class="underline">说明式</span> 知识， <b>计算机</b> 科学处理 <span class="underline">命令式</span> 知识：
</p>
<ul class="org-ul">
<li>程序语言要求用 <span class="underline">算法的方式</span> 描述解决问题过程</li>
<li>实际上程序语言也常提供一些 <span class="underline">说明性描述</span> 方式：
<ul class="org-ul">
<li>用户可以省去计算过程的很多细节描述，例如输出函数的格式描述</li>
</ul></li>
</ul>

<pre class="example">
  多数程序语言要求用定义数学函数的方式组织程序：

  程序描述的是“怎么做”
  所描述的计算有明确方向，从输入到输出
  描述函数关系的表达式，也给出了计算出结果的方法
  定义的过程完成从参数到结果的计算
</pre>

<p>
同样也有些例外。比如：
</p>
<ul class="org-ul">
<li><span class="underline">约束传递</span> 系统中的计算对象是约束关系，没有明确的计算方向和顺序，其基础系统要做很多工作来支持计算</li>
<li><span class="underline">非确定性</span> 程序求值器里的表达式可有多个值，求值器设法根据表达式描述的关系找出满足要求的</li>
</ul>

<div id="outline-container-orged3c7f9" class="outline-2">
<h2 id="orged3c7f9">逻辑式程序</h2>
<div class="outline-text-2" id="text-orged3c7f9">
<p>
<b>逻辑程序设计</b> 可看作上面想法的一种推广，它基于 <span class="underline">关系模型</span> 和称为 <span class="underline">合一</span> 的重要操作，其编程就是用 <b>逻辑公式描述事物之间的约束关系</b> （属于“是什么”的范畴），支持 <b>多重结果和无确定方向</b> 的计算
</p>

<pre class="example">
    逻辑程序设计特别适合一些应用领域的需要

    如数据库查询语言 Datalog ，支持查询基于已有事实的隐含事实
</pre>

<p>
一个“是什么”的描述可能蕴涵许多“怎样做”的过程，比如：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">append</span> x y<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>null? x<span style="color: #696969;">)</span>
      y
      <span style="color: #696969;">(</span>cons <span style="color: #696969;">(</span>car x<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>append <span style="color: #696969;">(</span>cdr x<span style="color: #696969;">)</span> y<span style="color: #696969;">))))</span>
</pre>
</div>

<p>
可以认为，这个程序表达的是两条规则：
</p>
<ol class="org-ol">
<li>对任何一个表 y，空表与其拼接得到的表就是 y 本身</li>
<li>对任何表 u, v, y, z： <span class="underline">(cons u v)</span>  与 <span class="underline">y</span> 拼接得到 <span class="underline">(cons u z)</span> 的条件是 <b>v 与 y  的 <span class="underline">append</span>  是 z</b></li>
</ol>



<ul class="org-ul">
<li>append <span class="underline">过程</span> 定义和两条 <span class="underline">规则</span> 都可以回答下面问题：
<ul class="org-ul">
<li>找出 (a b) 和 (c d) 的 append</li>
</ul></li>
<li>然而这两条 <b>规则</b> 还可以回答下面问题（但 append  <span class="underline">过程</span> 不行）：
<ul class="org-ul">
<li>找出一个表 y 使 (a b) 与它的拼接能得到 (a b c d)</li>
<li>找出所有拼接起来能得到 (a b c d) 的表 x 和 y</li>
</ul></li>
</ul>

<p>
在逻辑式程序语言里，可以写出与上面两条规则直接对应的表达式，求值器可以基于它得到上述几个问题的解
</p>

<pre class="example">
    各种逻辑语言（包括下面介绍的）都有缺陷，简单提供“做什么”知识

    有时会使求值器陷入无穷循环或产生非用户希望的行为
</pre>
</div>

<div id="outline-container-org830a03e" class="outline-3">
<h3 id="org830a03e">演绎信息检索</h3>
<div class="outline-text-3" id="text-org830a03e">
<p>
逻辑式编程语言特别适合用作 <span class="underline">数据库接口</span> ，完成 <b>复杂的信息检索</b> 。 <span class="underline">查询语言</span> 就是为此设计的，先用一个实例展示逻辑式编程的使用：
</p>
</div>

<div id="outline-container-orgb3413b5" class="outline-4">
<h4 id="orgb3413b5">简单数据库</h4>
<div class="outline-text-4" id="text-orgb3413b5">
<p>
设 Microshaft 公司（位于波士顿的高科技公司）需要人事数据库，逻辑式语言不仅能做数据导向的信息访问，还能基于已有数据做推理
</p>

<p>
数据库内容是有关公司人事的断言，有许多描述各种事实的断言。Ben 是公司的计算机专家，关于他的断言如下：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Slumerville <span style="color: #696969;">(</span>Ridge Road<span style="color: #696969;">)</span> 10<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer wizard<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">)</span> 60000<span style="color: #696969;">)</span>
</pre>
</div>

<ul class="org-ul">
<li>在形式上，每个断言是一个表，其元素还可以是表</li>
<li>一个断言描述一个客观事实</li>
</ul>

<p>
Ben 管理公司的计算机分部，管理两个程序员和一个计算机技师：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Cambridge <span style="color: #696969;">(</span>Mass Ave<span style="color: #696969;">)</span> 78<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">)</span> 40000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Fect Cy D<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Cambridge <span style="color: #696969;">(</span>Ames Street<span style="color: #696969;">)</span> 3<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Fect Cy D<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Fect Cy D<span style="color: #696969;">)</span> 35000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Fect Cy D<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Tweakit Lem E<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Boston <span style="color: #696969;">(</span>Bay State Road<span style="color: #696969;">)</span> 22<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Tweakit Lem E<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer technician<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Tweakit Lem E<span style="color: #696969;">)</span> 25000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Tweakit Lem E<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">))</span>
</pre>
</div>

<p>
Hacker Alyssa 管着一个实习程序员：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Reasoner Louis<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Slumerville <span style="color: #696969;">(</span>Pine Tree Road<span style="color: #696969;">)</span> 80<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Reasoner Louis<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer programmer trainee<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Reasoner Louis<span style="color: #696969;">)</span> 30000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Reasoner Louis<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">))</span>
</pre>
</div>

<pre class="example">
      计算机分部所有人员的职务的第一个符号都是 computer
</pre>

<p>
Ben 是公司的高级雇员，其上司是公司大老板 Oliver：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Warbucks Oliver<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Warbucks Oliver<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Swellesley <span style="color: #696969;">(</span>Top Heap Road<span style="color: #696969;">)))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Warbucks Oliver<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>administration big wheel<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Warbucks Oliver<span style="color: #696969;">)</span> 150000<span style="color: #696969;">)</span>
</pre>
</div>

<p>
公司有一个财务分部，人员包括一个主管会计和一个助手：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Scrooge Eben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Weston <span style="color: #696969;">(</span>Shady Lane<span style="color: #696969;">)</span> 10<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Scrooge Eben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>accounting chief accountant<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Scrooge Eben<span style="color: #696969;">)</span> 75000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Scrooge Eben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Warbucks Oliver<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Cratchet Robert<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Allston <span style="color: #696969;">(</span>N Harvard Street<span style="color: #696969;">)</span> 16<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Cratchet Robert<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>accounting scrivener<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Cratchet Robert<span style="color: #696969;">)</span> 18000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Cratchet Robert<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Scrooge Eben<span style="color: #696969;">))</span>
</pre>
</div>

<p>
老板有一个秘书：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>address <span style="color: #696969;">(</span>Aull DeWitt<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Slumerville <span style="color: #696969;">(</span>Onion Square<span style="color: #696969;">)</span> 5<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Aull DeWitt<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>administration secretary<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>salary <span style="color: #696969;">(</span>Aull DeWitt<span style="color: #696969;">)</span> 25000<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>supervisor <span style="color: #696969;">(</span>Aull DeWitt<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>Warbucks Oliver<span style="color: #696969;">))</span>
</pre>
</div>

<p>
还有一些断言说明各种人能从事的工作之间的关系：
</p>
<ul class="org-ul">
<li>计算机专家可以做程序员和技师的工作：</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>can-do-job <span style="color: #696969;">(</span>computer wizard<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>can-do-job <span style="color: #696969;">(</span>computer wizard<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer technician<span style="color: #696969;">))</span>
</pre>
</div>
<ul class="org-ul">
<li>程序员可以做实习程序员的工作：</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>can-do-job <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">)</span>
            <span style="color: #696969;">(</span>computer programmer trainee<span style="color: #696969;">))</span>
</pre>
</div>
<ul class="org-ul">
<li>秘书可以做老板的工作：</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>can-do-job <span style="color: #696969;">(</span>administration secretary<span style="color: #696969;">)</span>
            <span style="color: #696969;">(</span>administration big wheel<span style="color: #696969;">))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8826d90" class="outline-4">
<h4 id="org8826d90">简单查询</h4>
<div class="outline-text-4" id="text-org8826d90">
<p>
要查询数据库里的信息，只需在提示符下输入查询。如：
</p>
<pre class="example">
;;; Query input:
(job ?x (computer programmer))

;;; Query results:
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
</pre>

<ul class="org-ul">
<li>查询语句描述要 <b>查询信息的模式</b> ，其中有些项是 <span class="underline">具体信息</span> ： 
<ul class="org-ul">
<li><span class="underline">问号开头的模式变量</span> 项（上面 ?x ）可与任何东西匹配</li>
</ul></li>
<li>系统响应查询时，给出 <b>数据库里与查询模式 <span class="underline">匹配的所有</span> 条目</b></li>

<li>需要区分 <span class="underline">多个匹配</span> 和 <span class="underline">同一匹配的多次</span> 出现，因此 <b>模式变量需要名字</b> ：</li>
</ul>
<pre class="example">
(address ?x ?y) : 系统列出所有雇员的地址条目
</pre>

<ul class="org-ul">
<li>如果查询中没有变量，就相当于问相应事实是否存在</li>
<li>同一模式变量可在一个查询里出现多次，表示需要 <span class="underline">同一匹配</span> ：</li>
</ul>
<pre class="example">
(supervisor ?x ?x) ：要求给出所有自己管自己的雇员的条目
</pre>

<p>
列出所有从事计算机工作的雇员：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer ?type<span style="color: #696969;">))</span>
</pre>
</div>

<p>
系统响应是：
</p>
<pre class="example">
(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
</pre>

<p>
由于 <span class="underline">?type</span> 只能匹配一个项，他不匹配：
</p>
<pre class="example">
(job (Reasoner Louis) (computer programmer trainee))
</pre>

<p>
如果希望匹配第一个元素是 <span class="underline">computer</span>  的 <b>所有条目</b> ，应写：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer . ?type<span style="color: #696969;">))</span>
</pre>
</div>

<p>
<b>(computer . ?type)</b> 能匹配 <span class="underline">(computer programmer trainee)</span> ，也能匹配 <span class="underline">(computer technician)</span> 和 <span class="underline">(computer)</span>  
</p>
</div>

<div id="outline-container-org37bbe8f" class="outline-5">
<h5 id="org37bbe8f">总结</h5>
<div class="outline-text-5" id="text-org37bbe8f">
<ul class="org-ul">
<li>设法找出使查询语句中的模式变量满足查询模式的所有赋值，即找出这些变量的所有可能指派（具体表达式），使得把模式中的变量代换为具体表达式后得到的条目在数据库里</li>
<li>对查询的响应是列出数据库里所有满足模式的条目，用找到的所有可能赋值对查询模式实例化，显示得到的结果</li>
<li>如果查询模式里无变量，就简化为对该查询是否出现在数据库里的检验。相应的赋值是空赋值</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8b8caea" class="outline-4">
<h4 id="org8b8caea">复合查询</h4>
<div class="outline-text-4" id="text-org8b8caea">
<p>
简单查询是基本操作，可以在其基础上构造 <b>复合查询</b> 。查询语言的组合手段是连接词 <span class="underline">and</span> ,  <span class="underline">or</span> 和 <span class="underline">not</span> 
</p>
<pre class="example">
    注意：这些组合手段不是 Scheme 内部操作
</pre>
<p>
对复合查询，系统也是 <b>设法找出所有能满足它的赋值</b> ，并显示用这些赋值实例化查询模式得到的结果
</p>
</div>

<div id="outline-container-orged92fa8" class="outline-5">
<h5 id="orged92fa8">and 查询</h5>
<div class="outline-text-5" id="text-orged92fa8">
<p>
and 复合的一般形式：
</p>

<pre class="example">
(and &lt;query1&gt;&lt;query2&gt; ... &lt;queryn&gt;)
</pre>

<p>
要求找到的变量赋值满足 <span class="underline">(and &lt;query1&gt;&lt;query2&gt; &#x2026; &lt;queryn&gt;)</span> 中的 <b>每个</b> 查询。比如找出所有程序员的住址：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>job ?person <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))</span>
     <span style="color: #696969;">(</span>address ?person ?where<span style="color: #696969;">))</span>
</pre>
</div>

<p>
返回的响应是：
</p>
<pre class="example">
(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
</pre>
</div>
</div>

<div id="outline-container-org34a849f" class="outline-5">
<h5 id="org34a849f">or 查询</h5>
<div class="outline-text-5" id="text-org34a849f">
<p>
or 复合的一般形式：
</p>
<pre class="example">
(or &lt;query1&gt;&lt;query2&gt; ... &lt;queryn&gt;)
</pre>

<p>
要求找出所有能满足 <span class="underline">(or &lt;query1&gt;&lt;query2&gt; &#x2026; &lt;queryn&gt;)</span>  <b>之一</b> 的赋值，给出用这些赋值实例化的结果。比如：得到由Ben Bitdiddle 或 Alyssa P. Hacker 管理的雇员名单：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">or</span> <span style="color: #696969;">(</span>supervisor ?x <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">))</span>
    <span style="color: #696969;">(</span>supervisor ?x <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
查询结果：
</p>
<pre class="example">
(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
</pre>
</div>
</div>

<div id="outline-container-org6d85160" class="outline-5">
<h5 id="org6d85160">not 查询</h5>
<div class="outline-text-5" id="text-org6d85160">
<p>
not 查询的一般形式为：
</p>
<pre class="example">
(not &lt;query&gt;)
</pre>

<p>
要求得到所有使 <span class="underline">&lt;query&gt;</span>   <b>不成立</b> 的赋值。比如，要求找出 Ben 管的所有人中的非程序员：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?x <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">))</span>
     <span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge2d4b18" class="outline-5">
<h5 id="orge2d4b18">lisp-value</h5>
<div class="outline-text-5" id="text-orge2d4b18">
<p>
<span class="underline">lisp-value</span> 的一般形式：
</p>
<pre class="example">
(lisp-value &lt;predicate&gt;&lt;arg1&gt; ... &lt;argn&gt;)
</pre>

<p>
第一参数 <span class="underline">&lt;predicate&gt;</span> 是一个Lisp 谓词。要求将 <b>谓词作用于后面的参数</b> （ <span class="underline">赋值后得到的值</span> ）， 选出使 <b>谓词为真</b> 的所有赋值。比如：选出所有工资高于 30000 的人
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>salary ?person ?amount<span style="color: #696969;">)</span>
     <span style="color: #696969;">(</span>lisp-value &gt; ?amount 30000<span style="color: #696969;">))</span>
</pre>
</div>

<p>
利用 <span class="underline">lisp-value</span>  可以很灵活地描述各种查询
</p>
</div>
</div>
</div>

<div id="outline-container-org2c0d554" class="outline-4">
<h4 id="org2c0d554">规则</h4>
<div class="outline-text-4" id="text-org2c0d554">
<p>
查询语言的 <b>抽象手段</b> 是 <span class="underline">建立规则</span> ，比如， <span class="underline">两个不同的人住得很近</span> 的规则就是：  <span class="underline">他们住在同一个town</span> 
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>lives-near ?person-1 ?person-2<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>address ?person-1 <span style="color: #696969;">(</span>?town . ?rest-1<span style="color: #696969;">))</span>
           <span style="color: #696969;">(</span>address ?person-2 <span style="color: #696969;">(</span>?town . ?rest-2<span style="color: #696969;">))</span>
           <span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>same ?person-1 ?person-2<span style="color: #696969;">))))</span>
</pre>
</div>

<p>
<span class="underline">同一个</span> 表达成规则：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>same ?x ?x<span style="color: #696969;">))</span>
</pre>
</div>

<p>
组织里的大人物：如果被其管理的人还管别人 
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>wheel ?person<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?middle-manager ?person<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>supervisor ?x ?middle-manager<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
规则的一般形式是：
</p>
<pre class="example">
(rule &lt;conclusion&gt; &lt;body&gt;)
</pre>

<p>
其中 <span class="underline">&lt;conclusion&gt;</span> 是 <b>模式</b> ， <span class="underline">&lt;body&gt;</span> 是任何形式的 <b>查询</b> 。可以认为一条规则表示了很大（甚至无穷大）的一个断言集，其元素是 <b>由 &lt;conclusion&gt;求出的所有满足&lt;body&gt; 的赋值</b> 
</p>

<p>
简单查询：
</p>
<ul class="org-ul">
<li>如果其中变量的某个赋值 <b>满足某查询模式</b> ，那么用这个赋值实例化模式得到的断言一定在数据库里</li>
<li>但满足规则的断言不一定实际存在在数据库里，有可能是推导出的事实</li>
</ul>

<p>
比如，找出所有住在 Bitdiddle Ben 附近的雇员：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>lives-near ?x <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">))</span>
</pre>
</div>

<p>
返回结果：
</p>
<pre class="example">
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
</pre>

<p>
找出所有住在 Bitdiddle Ben 附近的程序员：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))</span>
     <span style="color: #696969;">(</span>lives-near ?x <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
与复合过程类似， <b>已定义的规则可以用于定义新规则</b> 。例如：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>outranked-by ?staff-person ?boss<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">or</span> <span style="color: #696969;">(</span>supervisor ?staff-person ?boss<span style="color: #696969;">)</span>
          <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?staff-person ?middle-manager<span style="color: #696969;">)</span>
               <span style="color: #696969;">(</span>outranked-by ?middle-manager ?boss<span style="color: #696969;">))))</span>
</pre>
</div>

<p>
这是一条递归定义的规则： 
</p>
<ul class="org-ul">
<li><span class="underline">一个职员是某老板的下级</span></li>
<li><span class="underline">如果该老板是其主管，或者（递归的）其主管是该老板的下级</span></li>
</ul>
</div>
</div>

<div id="outline-container-org15196b6" class="outline-4">
<h4 id="org15196b6">逻辑程序</h4>
<div class="outline-text-4" id="text-org15196b6">
<p>
规则可看作 <span class="underline">逻辑蕴涵式</span> ： 若对 <span class="underline">所有模式变量的赋值能满足一条规则的身体</span> ，那么它就满足其结论。查询语言就是 <b>基于规则做逻辑推理</b> 
</p>

<p>
考虑 append 的例子，描述它的规则说：
</p>
<ul class="org-ul">
<li>对任何表 y，空表与它 append 得到的就是 y 本身</li>
<li>对任何表 u, v, y, z，(cons u v) 与 y 的 append 是 (cons u z) 的条件：v 与 y 的 append 是 z</li>
</ul>

<p>
用查询语言描述，需要 <b>描述关系</b>  (append-to-form x y z) ，直观解释是 “x 和 y 的拼接得到 z”。用规则定义是：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">()</span> ?y ?y<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>?u . ?v<span style="color: #696969;">)</span> ?y <span style="color: #696969;">(</span>?u . ?z<span style="color: #696969;">))</span>
      <span style="color: #696969;">(</span>append-to-form ?v ?y ?z<span style="color: #696969;">))</span>
</pre>
</div>

<ol class="org-ol">
<li>第一条规则 <span class="underline">没有体</span> ，说明它 <b>对任何 y 成立</b></li>
<li>第二条规是 <b>递归定义</b> 的
<ul class="org-ul">
<li>注意：这里用了表的 <span class="underline">点号</span> 形式</li>
</ul></li>
</ol>

<p>
有了上面有关 <span class="underline">append-to-form</span>   的规则，可以做许多查询：
</p>

<p>
'(a b) 和 '(c d) 做 append 的结果
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">Query input:</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>c d<span style="color: #696969;">)</span> ?z<span style="color: #696969;">)</span>
<span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">Query results:</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>c d<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
</pre>
</div>

<p>
什么和 '(a b) 做 append 会返回 '(a b c d)
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">Query input:</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b<span style="color: #696969;">)</span> ?y <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
<span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">Query results:</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>c d<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
</pre>
</div>

<p>
x 和 y 做 append 会返回 '(a b c d)， x, y 的值是什么：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">Query input:</span>
<span style="color: #696969;">(</span>append-to-form ?x ?y <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
<span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">Query results:</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">()</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>b c d<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>c d<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b c<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>d<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span>append-to-form <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">)</span> <span style="color: #696969;">()</span> <span style="color: #696969;">(</span>a b c d<span style="color: #696969;">))</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org26e3d80" class="outline-2">
<h2 id="org26e3d80">设计</h2>
<div class="outline-text-2" id="text-org26e3d80">
<p>
显然查询求值器要搜索，设法将查询与数据库里的事实和规则匹配
</p>
<ul class="org-ul">
<li>可参考 <span class="underline">amb</span> ，将系统实现为一个非确定性程序</li>
<li>可以借用 <span class="underline">流</span> 的概念控制搜索。这里采用基于流的技术</li>
</ul>

<p>
查询系统的组织围绕两个核心操作：
</p>
<ol class="org-ol">
<li><b>模式匹配</b> ：系统实现 <span class="underline">简单查询</span> 和 <span class="underline">复合查询</span> ，要考虑它与 <span class="underline">基于流的信息</span> 的 <b>集成</b></li>
<li><b>合一</b> :  <span class="underline">模式匹配的推广</span> ，用于 <b>实现规则</b></li>
</ol>

<p>
最后讨论如何通过 <span class="underline">表达式的分情况处理</span> ， 构造整个的 <b>查询解释器</b> 
</p>
</div>

<div id="outline-container-orgcaf1900" class="outline-3">
<h3 id="orgcaf1900">模式匹配</h3>
<div class="outline-text-3" id="text-orgcaf1900">
<p>
查询系统的基本构件包括一个匹配器， <span class="underline">模式匹配</span> 是其基本操作。模式匹配器 <b>检查一个数据项是否与某个给定模式匹配</b> ，比如： 数据表 <span class="underline">((a b) c (a b))</span> ：
</p>
<ul class="org-ul">
<li>与模式 <span class="underline">(?x c ?x)</span> 匹配，其中模式变量 <span class="underline">?x</span>  约束于 <span class="underline">(a b)</span></li>
<li>与模式 <span class="underline">(?x ?y ?z)</span>  匹配，其中 <span class="underline">?x</span>  和 <span class="underline">?z</span>  都约束到 <span class="underline">(a b)</span> ， <span class="underline">?y</span>  约束到 <span class="underline">c</span></li>
<li>与模式 <span class="underline">((?x ?y) c (?x ?y))</span>  匹配，其中的 <span class="underline">?x</span>  约束到 <span class="underline">a</span> ， <span class="underline">?y</span>  约束到 <span class="underline">b</span></li>
<li>与模式 <span class="underline">(?x a ?y)</span>  不匹配，因这个模式要求表中第二个元素必须是 <span class="underline">a</span></li>
</ul>

<pre class="example">
     由此可见，一个框架记录了一组模式变量与其当时确定的约束 
</pre>

<p>
模式匹配器以一个 <span class="underline">模式</span> 、一个 <span class="underline">数据</span> 和一个 <span class="underline">框架</span> 为输入。它 <b>检查 <span class="underline">数据</span> 是否以某种 <span class="underline">方式</span> 与 <span class="underline">模式</span> 匹配</b> ，而且该 <span class="underline">匹配</span> 与 <span class="underline">框架</span> 里已有的 <span class="underline">约束</span> 相容（不矛盾）
</p>
<ul class="org-ul">
<li>匹配 <span class="underline">成功</span> 时返回 <b>原框架的扩充</b> ，加入 <span class="underline">新确定的所有约束</span></li>
<li>匹配 <span class="underline">失败</span> 时返回一个 <b>失败信息</b></li>
</ul>

<pre class="example">
     基于 空框架 用模式 (?x ?y ?x)  匹配 _(a b a) ，匹配器返回的框架里 ?x  约束到 a ， ?y  约束到 b
     如果用同一模式、同一数据和包含 ?y  约束到的 a  框架去匹配，这个匹配将 失败
     如果用同一模式、同一数据和包含 ?y  约束到的 b  框架去匹配，匹配器返回的框架  扩充 了 ?x  到 a  的约束
</pre>

<p>
模式匹配器处理 <b>所有不涉及 <span class="underline">规则</span> 的查询</b> 。如，输入查询 <span class="underline">(job ?x (computer programmer))</span> 
</p>
<ul class="org-ul">
<li>匹配器将从一个 <span class="underline">空框架</span> 出发 <span class="underline">扫描数据库里的断言</span> ，选出其中与这个模式匹配的断言，得到相应的匹配框架（流）</li>
<li>对于每个成功的匹配，语言的求值器都用匹配器返回的各个框架里 <b>?x 的值实例化上述模式</b> ，得到最终结果</li>
</ul>
</div>

<div id="outline-container-org4464a31" class="outline-4">
<h4 id="org4464a31">简单查询</h4>
<div class="outline-text-4" id="text-org4464a31">
<p>
匹配器采用 <span class="underline">流</span> 的方式，基于给定 <span class="underline">框架</span> 做模式匹配：
</p>
<ul class="org-ul">
<li>基于给定框架 <b>扫描</b> 数据库断言。对每个 <span class="underline">断言</span> 
<ul class="org-ul">
<li>产生表示匹配 <span class="underline">失败的特殊符号</span></li>
<li>给出原框架的一个 <span class="underline">扩充</span> ， 匹配 <b>结果形成一个流</b></li>
</ul></li>
<li>用一个 <span class="underline">过滤器</span> <b>删除匹配失败信息</b> ，结果流里包含的框架都是 <b>原框架由于断言匹配而得到的扩充</b></li>
</ul>

<p>
一个查询以一个 <span class="underline">框架流</span> 作为输入，基于流中每个框架做上述匹配， <b>合并</b> 产生的 <span class="underline">所有框架流</span> ，得到作为 <span class="underline">查询结果的输出流</span>  
</p>


<div class="figure">
<p><img src="pic/stream-of-frames.gif" alt="stream-of-frames.gif" width="60%" /> 
</p>
</div>

<p>
回答简单查询时，初始输入流里只有一个 <span class="underline">空框架</span> ，得到的流包含这一空框架的 <span class="underline">所有扩充</span> 。用这个流 <span class="underline">实例化查询模式</span> ，就能得到所有输出：
</p>
</div>
</div>

<div id="outline-container-org8b1df31" class="outline-4">
<h4 id="org8b1df31">and 查询</h4>
<div class="outline-text-4" id="text-org8b1df31">
<p>
处理复合查询时，利用匹配器 <b>带着框架</b> 去检查匹配的功能。例如： 
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>can-do-job ?x <span style="color: #696969;">(</span>computer programmer trainee<span style="color: #696969;">))</span>
     <span style="color: #696969;">(</span>job ?person ?x<span style="color: #696969;">))</span>
</pre>
</div>

<p>
先找出与模式 <span class="underline">(can-do-job ?x (computer programmer trainee))</span>  匹配的 <b>框架流</b> ，其中每个框架都包含对 <span class="underline">?x</span>  的 <span class="underline">约束项</span> 。再找所有与模式 <span class="underline">(job ?person ?x)</span> 匹配的项，其匹配与给定的 <span class="underline">?x</span>  匹配一致。作为结果的流中各框架都包含了 <span class="underline">?person</span> 和 <span class="underline">?x</span>  的 <b>约束</b> 。下图显示了 and 查询的处理过程：
</p>


<div class="figure">
<p><img src="pic/and-query.gif" alt="and-query.gif" width="60%" /> 
</p>
</div>

<p>
框架流顺序地通过两个查询，最终得到结果流
</p>

<pre class="example">
      处理复合查询的效率问题：

      一步查询中，对输入流里的每个框架都可能产生多个框架，一系列 and 查询里的每个查询都是从前一个查询得到框架流

      这使 and 查询中可能的匹配次数是查询个数的指数函数
</pre>
</div>
</div>

<div id="outline-container-orgfcf76b3" class="outline-4">
<h4 id="orgfcf76b3">or 查询</h4>
<div class="outline-text-4" id="text-orgfcf76b3">
<p>
两个查询的 <span class="underline">or</span>  是 两个查询分别得到的 <b>框架流的归并</b> ，归并可以采用 <span class="underline">交错</span> 方式：
</p>


<div class="figure">
<p><img src="pic/or-query.gif" alt="or-query.gif" width="60%" /> 
</p>
</div>
</div>
</div>

<div id="outline-container-org9d7e3b6" class="outline-4">
<h4 id="org9d7e3b6">not 查询</h4>
<div class="outline-text-4" id="text-org9d7e3b6">
<p>
断言 <span class="underline">q</span>  的  <span class="underline">not</span>  是一个 <b>框架过滤器</b> ，删除流中所有满足 <span class="underline">q</span>  的框架。例如：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">)))</span>
</pre>
</div>
<p>
对空框架生成满足 <span class="underline">(job ?x (computer programmer)</span> 的扩充。如果一个框架能扩充就丢掉它。不能产生扩充的留在输出流里
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?x ?y<span style="color: #696969;">)</span>
<span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))))</span>
</pre>
</div>

<ol class="org-ol">
<li><span class="underline">and</span> 的第一个子句生成一批带有 <span class="underline">?x</span>  和 <span class="underline">?y</span>  的约束的框架</li>
<li>后面的 <span class="underline">not</span>  子句 <b>删除</b> 所有使 <span class="underline">?x</span>  的工作是程序员的框架</li>
</ol>
</div>
</div>

<div id="outline-container-org2006086" class="outline-4">
<h4 id="org2006086">lisp-value 查询</h4>
<div class="outline-text-4" id="text-org2006086">
<p>
实现为框架流的 <b>过滤器</b> ：
</p>
<ol class="org-ol">
<li>用流中框架 <b>实例化模式的变量</b></li>
<li>对 <span class="underline">实例化结果应用给定谓词</span> ， <b>删去</b> 不满足谓词的框架</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org4d741dc" class="outline-3">
<h3 id="org4d741dc">合一</h3>
<div class="outline-text-3" id="text-org4d741dc">
<p>
在处理 <span class="underline">规则</span> 时，要 <b>找出其结论与被处理查询模式匹配的所有规则</b> 。<sub>结论</sub>_ 的形式很像 <span class="underline">断言</span> ，但是它可以 <b>包含变量</b> ：
</p>
<ul class="org-ul">
<li>匹配的两边（ <span class="underline">查询模式</span> 和 <span class="underline">规则的结论</span> ）都可以 <b>有变量</b></li>
<li><span class="underline">模式匹配</span> 只允许一方有变量</li>
</ul>

<p>
<b>合一</b> 是 <span class="underline">模式匹配的扩充</span> ，它 <b>判断 <span class="underline">两个模式</span> 之间能否匹配</b> 。工作方式：
</p>
<ul class="org-ul">
<li>设法确定是否 <b>存在一组变量赋值</b> ，使得这 <b>两个模式经过赋值的实例化</b> 后得到的 <b>表达式相同</b>
<ul class="org-ul">
<li>成功时返回得到的赋值（框架）</li>
<li>返回失败信息</li>
</ul></li>
</ul>

<pre class="example">
     对 (?x a ?y) 和 (?y ?z a) 的合一操作将产生一个框架，在框架里 ?x, ?y 和 ?z 都约束到 a

     对 (?x ?y a) 和 (?x b ?y) 的合一将会失败，因为对 ?y 的任何赋值都不能使两个模式相同
	 根据模式的第二个元素 ?y 应约束到 b
	 然而根据它们的第三个元素 ?y 又应约束到 a
</pre>

<p>
合一算法是整个查询系统实现的难点。完成两个复杂模式的合一，看起来好像需要做 <b>推理</b> ：
</p>

<pre class="example">
合一 (?x ?x)  和 ((a ?y c) (a b ?z)) ，可以得到一个联立方程：

?x  =  (a ?y c)
?x  =  (a b ?z)

它等价于 (a ?y c)  =  (a b ?z)

它蕴涵着 a= a,?y= b,c= ?z

继续做下去，可得 ?x  =  (a b c)
</pre>

<ul class="org-ul">
<li>模式匹配成功将给所有变量赋值，前面例子都是赋值为常量的情况</li>
<li>成功的合一可能产生 <span class="underline">变量值不能完全确定</span> 的情况：
<ul class="org-ul">
<li>可能出现 <span class="underline">未约束的变量</span></li>
<li>变量 <span class="underline">约束的值里也可能还包含变量</span></li>
</ul></li>
</ul>

<pre class="example">
     考虑 (?x a) 和 ((b ?y) ?z) 合一得到 ?x = (b ?y) ，?z = a

     但 ?x 和 ?y 的值不能确定。这时也认为成功，因为已经可以确定 ?x 和 ?y  的赋值了

     这里 ?y 取值没限制，但 ?x 必须是 (b ?y)。应把 ?x 到 (b ?y) 的约束放入框架

     如果后来?y 值确定，?x 就引用相应的值
</pre>

<p>
最一般的合一确实需要解方程。但这里情况比较简单，可直接处理
</p>
</div>
</div>

<div id="outline-container-org7aadbfb" class="outline-3">
<h3 id="org7aadbfb">规则应用</h3>
<div class="outline-text-3" id="text-org7aadbfb">
<p>
假设要处理下面的规则：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>lives-near ?x <span style="color: #696969;">(</span>Hacker Alyssa P<span style="color: #696969;">))</span>
</pre>
</div>

<ul class="org-ul">
<li>先用 <span class="underline">模式匹配</span> 到数据库里找匹配断言：找不到</li>
<li>再做与 <span class="underline">规则结论的合一</span> ，发现它与下面规则合一成功：</li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>lives-near ?person-1 ?person-2<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>address ?person-1 <span style="color: #696969;">(</span>?town . ?rest-1<span style="color: #696969;">))</span>
           <span style="color: #696969;">(</span>address ?person-2 <span style="color: #696969;">(</span>?town . ?rest-2<span style="color: #696969;">))</span>
           <span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>same ?person-1 ?person-2<span style="color: #696969;">))))</span>
</pre>
</div>

<ul class="org-ul">
<li>得到 <span class="underline">?person-2</span>  约束到 <span class="underline">(Hacker Alyssa P)</span> ， <span class="underline">?x</span> 约束到 <span class="underline">?person-1</span></li>
<li>然后 <b>基于此框架</b> 对 <span class="underline">规则体的复合查询</span> 求值。匹配成功时 <span class="underline">?person-1</span> 将建立约束，从而也给 <span class="underline">?x</span> 建立了约束</li>
</ul>

<p>
当求值器在基于一个框架完成对某个查询模式的匹配时，尝试 <span class="underline">应用一条规则</span> 的过程是：
</p>
<ol class="org-ol">
<li>将 <b>查询模式与规则的结论合一</b> ，成功时 <b>形成原框架的一个扩充</b></li>
<li><b>基于这样扩充的框架</b> 再去 <b>求值该规则的体</b> ，这实际上又是一个 <span class="underline">查询</span></li>
</ol>

<pre class="example">
这一做法很像 Lisp 的 eval/apply 求值器中的过程应用：

1. 将过程的形式参数约束于实际参数值，用得到的框架扩充原环境
2. 基于扩充后的环境去求值过程体

这种相似也很自然：

过程定义是 Lisp 里的抽象手段
规则定义是查询语言里的抽象手段
无论是应用过程还是应用规则，都需要打开相关的抽象，就是建立相应约束，而后基于它们去求值过程或者规则的体
</pre>
</div>
</div>

<div id="outline-container-orgff56dc0" class="outline-3">
<h3 id="orgff56dc0">简单查询</h3>
<div class="outline-text-3" id="text-orgff56dc0">
<p>
使用 <span class="underline">规则</span> 和 <span class="underline">断言</span> 求值 <span class="underline">简单查询</span> 的完整过程：
</p>
<ul class="org-ul">
<li>给定一个 <span class="underline">查询模式</span> 和一个 <span class="underline">框架流</span> ，对流中每个框架产生 <span class="underline">两个流</span> ：
<ul class="org-ul">
<li><b>模式匹配器</b> ：用 <span class="underline">给定模式</span> 与 <span class="underline">数据库断言</span> <b>匹配</b> ，得到 <span class="underline">扩充框架的流</span></li>
<li><b>合一器</b> ： <b>应用</b> 所有 <span class="underline">可用的规则</span> ，得到另一个 <span class="underline">扩充框架的流</span></li>
<li><b>归并</b> 为与 <span class="underline">原框架相容</span> 的 <b>满足</b>  <span class="underline">给定模式</span> 的 <span class="underline">所有扩充框架</span> 的流</li>
</ul></li>
<li>把处理给定框架流里各个框架得到的流组合为一个流，其中包含由输入流中各框架扩充而得到的与给定模式匹配的所有结果</li>
</ul>

<pre class="example">
     这样的系统很像一般语言的求值器，只是其中的匹配操作比较复杂
</pre>
</div>
</div>

<div id="outline-container-org5cf0cba" class="outline-3">
<h3 id="org5cf0cba">查询求值器</h3>
<div class="outline-text-3" id="text-org5cf0cba">
<p>
过程 <b>qeval</b>  协调各种匹配操作，起着类似 <span class="underline">eval</span> 的作用：
</p>
<ul class="org-ul">
<li>参数是一个 <span class="underline">查询</span> 和一个 <span class="underline">框架流</span></li>
<li>结果是一个 <span class="underline">框架流</span> ，其中包含所有 <span class="underline">成功匹配得到的扩充框架</span></li>
<li>qeval 根据查询的类型分情况处理，将请求分派到对应的过程
<ul class="org-ul">
<li>简单查询</li>
<li>and</li>
<li>or</li>
<li>not</li>
<li>lisp-value</li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org39b9c65" class="outline-3">
<h3 id="org39b9c65">驱动循环</h3>
<div class="outline-text-3" id="text-org39b9c65">
<p>
<span class="underline">驱动循环</span> 由 <span class="underline">终端</span> 取得输入：
</p>
<ol class="org-ol">
<li>用得到的查询和一个 <span class="underline">空框架</span> 的流 <span class="underline">调用 qeval</span></li>
<li>用 qeval 返回的流中的每个框架去实例化原查询</li>
<li>最后打印出实例化的结果</li>
</ol>

<p>
驱动循环还支持特殊命令 <b>assert!</b> 
</p>
<ul class="org-ul">
<li>该命令说明输入不是 <span class="underline">查询</span> 而是一条 <b>断言或规则</b></li>
<li>这种情况下，把相应 <b>的断言或规则加入数据库</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>assert! <span style="color: #696969;">(</span>job <span style="color: #696969;">(</span>Bitdiddle Ben<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>computer wizard<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span>assert! <span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>wheel ?person<span style="color: #696969;">)</span>
               <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?middle-manager ?person<span style="color: #696969;">)</span>
                    <span style="color: #696969;">(</span>supervisor ?x ?middle-manager<span style="color: #696969;">))))</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge59d02b" class="outline-2">
<h2 id="orge59d02b">数理逻辑</h2>
<div class="outline-text-2" id="text-orge59d02b">
<p>
查询语言的组合符对应于各逻辑连接词，查询的做法看起来也具有逻辑可靠性（and 查询要经过两个子成分处理，等等），但这种对应关系并 <b>不严格</b> ，因为查询语言的基础是求值器，其中隐含着 <span class="underline">控制结构</span> 和 <span class="underline">控制流程</span> ，是用 <b>过程的方式解释逻辑语句</b> 
</p>

<p>
当然这种控制结构也可以利用例如要找程序员的上司，下面写法都行：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))</span>
     <span style="color: #696969;">(</span>supervisor ?x ?y<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?x ?y<span style="color: #696969;">)</span>
     <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">)))</span>
</pre>
</div>

<pre class="example">
    如果公司里的上司比程序员多，第一种写法的查询效率更高
</pre>

<p>
逻辑程序设计的目标是开发一种技术，把计算问题分为两个相互独立的子问题：需要计算 <span class="underline">什么</span> 和<sub>怎样</sub>_ 计算。途径是：
</p>
<ul class="org-ul">
<li>找出逻辑语言的一个子集
<ul class="org-ul">
<li>其功能 <b>足够强</b> ，足以 <span class="underline">描述人们想考虑的某类计算</span></li>
<li>足够弱，有可能为 <span class="underline">它定义一种过程式的解释</span></li>
</ul></li>
<li>实现一个 <b>求值器</b> （解释器），执行对用这种逻辑子集写出的 <b>规则和断言的解释</b> （实现其语义）</li>
</ul>

<pre class="example">
    前面描述的查询语言是上面想法的一个具体实施：
	查询语言 是数理逻辑的一个可以 过程式解释的子集 
	一个 断言 描述了一个简单 事实
	一条 规则 表示一个 蕴涵 ，所有使规则体成立的情况都使结论成立
	规则有自然的过程式解释：要得到其结论，只需确定其体成立 
</pre>

<p>
上述两方面性质保证逻辑程序设计语言程序的有效性：
</p>
<ul class="org-ul">
<li>用这种语言写出的一组规则实际上描述了一个计算过程</li>
<li>写出的断言可以交给计算机执行（说明式的描述）</li>
<li>具体的控制流程交给语言背后的求值器处理（过程式的执行）</li>
</ul>

<pre class="example">
    由于规则是逻辑语句，有逻辑解释。因此可以做些逻辑工作：

    检查逻辑推理是否总能得到同样的结果
    如果确实如此，就确认了求值器的可靠性 
</pre>

<p>
执行具有过程式的特征：
</p>
<ul class="org-ul">
<li>程序员可以通过安排子句的顺序和各子句中子目标的顺序控制计算过程。如果安排得好，有可能得到更高效的计算</li>
<li>由于用逻辑式程序的过程性解释，因此可能写出很低效的程序</li>
</ul>

<pre class="example">
    极端情况是有关程序使相应的解释陷入无穷循环
</pre>
</div>

<div id="outline-container-org61b8635" class="outline-3">
<h3 id="org61b8635">无穷循环</h3>
<div class="outline-text-3" id="text-org61b8635">
<p>
假定要做一个有关著名婚姻的数据库，加入断言：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>assert! <span style="color: #696969;">(</span>married Minnie Mickey<span style="color: #696969;">))</span>
</pre>
</div>

<p>
查询 <span class="underline">(married Mickey ?who)</span> 得不到结果。因为系统不知道婚姻是 <b>相互的</b> （对称的） 
</p>

<p>
如果加入规则：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>assert! <span style="color: #696969;">(</span>rule <span style="color: #696969;">(</span>married ?x ?y<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>married ?y ?x<span style="color: #696969;">)))</span> 
</pre>
</div>

<pre class="example">
     再查询时系统将陷入无穷循环：

     该规则产生的框架里 ?x 约束到 Mickey，?y 约束到 ?who

     规则体要求基于得到的框架匹配 (married ?who Mickey)。但这一查询不但与事实匹配，而且还与上面的规则匹配

     不幸的是由规则体得到的查询还是(married Mickey ?who)，使系统进入无穷循环
</pre>

<ul class="org-ul">
<li>能不能在进入无穷循环前找到匹配的断言 <b>依赖于查询的实现细节</b></li>
<li>一组相关规则也可能导致无穷循环</li>
</ul>
</div>
</div>
<div id="outline-container-orgd6b0f72" class="outline-3">
<h3 id="orgd6b0f72">not 问题</h3>
<div class="outline-text-3" id="text-orgd6b0f72">
<p>
对前面数据库做下面两个查询：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>supervisor ?x ?y<span style="color: #696969;">)</span>
     <span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">))))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>not <span style="color: #696969;">(</span>job ?x <span style="color: #696969;">(</span>computer programmer<span style="color: #696969;">)))</span>
     <span style="color: #696969;">(</span>supervisor ?x ?y<span style="color: #696969;">))</span>
</pre>
</div>

<p>
与逻辑里的情况不同，这两个查询会得到不同结果
</p>
<ul class="org-ul">
<li>第一个查询找出所有与 <span class="underline">(supervisor ?x ?y)</span> 匹配的条目，从得到的框架中删去 <span class="underline">?x</span>  满足 <span class="underline">(job ?x (computer programmer))</span> 的框架</li>
<li>第二个查询从初始框架流（只含一个空框架）开始检查能否扩展出与 <span class="underline">(job ?x (computer programmer))</span> 匹配的框架。显然空框架可扩展， <span class="underline">not</span>  <b>删除流中的空框架</b> 得到 <span class="underline">空流</span> ，查询最后返回 <span class="underline">空流</span></li>
</ul>

<pre class="example">
出问题的原因是对 not 的解释：

这里把 not 模式看作一种过滤器，如果 not 作用时模式里有未约束变量，就会产生不希望的结果

lisp-value 也有类似问题。如果使用lisp-value 的谓词时有些参数没有约束，系统显然无法正常工作
</pre>

<p>
此外， <span class="underline">查询语言</span> 里的 not 与 <span class="underline">逻辑</span> 里的 not 还有一个本质差异：
</p>
<ul class="org-ul">
<li>逻辑里 not P 的意思是 P  <b>不真</b></li>
<li>查询系统里 not P 则是说 P <b>不能由数据库里的知识推导出来</b> 。例如，从前面的人事数据库可以推导出许多 not 断言：
<ul class="org-ul">
<li>Ben Bitdiddle 不喜欢打篮球</li>
<li>外面没有下雨</li>
<li>2 + 2 不等于 4</li>
<li>&#x2026;&#x2026;.</li>
</ul></li>
</ul>

<pre class="example">
     逻辑程序语言里的 not 反映的是一种“封闭世界假说”，认为所有知识都包含在数据库里，凡是没有的东西其 not 都成立

     显然这并不符合形式化的数理逻辑，也不符合人们的直观推理
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd612082" class="outline-2">
<h2 id="orgd612082">实现</h2>
<div class="outline-text-2" id="text-orgd612082">
</div>
<div id="outline-container-org7d6755b" class="outline-3">
<h3 id="org7d6755b">驱动循环和实例化</h3>
<div class="outline-text-3" id="text-org7d6755b">
<ol class="org-ol">
<li>查询系统的驱动循环反复读输入表达式：
<ul class="org-ul">
<li>如果是 <span class="underline">断言</span> 或 <span class="underline">规则</span> ，就把相关信息 <b>加入数据库</b></li>
<li>否则认为是 <span class="underline">查询</span> ，送给 <span class="underline">qeval</span> ，并送去一个 <b>流</b> ，其中只包含一个 <span class="underline">空框架</span></li>
</ul></li>
<li><span class="underline">求值查询</span> 得到一个 <b>框架流</b> ：
<ul class="org-ul">
<li>各框架里的项说明 <span class="underline">模式中变量</span> 的 <span class="underline">约束值</span></li>
<li>用框架流中的框架对 <b>模式做实例化</b> ，得到 <span class="underline">实例化结果的流</span></li>
</ul></li>
<li>输出流中的各项，这是一些 <b>简单或复合的断言</b></li>
</ol>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">query-driver-loop</span><span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>prompt-for-input input-prompt<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>q <span style="color: #696969;">(</span>query-syntax-process <span style="color: #696969;">(</span>read<span style="color: #696969;">))))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>assertion-to-be-added? q<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>add-rule-or-assertion! <span style="color: #696969;">(</span>add-assertion-body q<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21152;&#20837;&#26029;&#35328;&#25110;&#35268;&#21017;</span>
           <span style="color: #696969;">(</span>newline<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>display <span style="color: #deb887;">"Assertion added to data base."</span><span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>query-driver-loop<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#37325;&#21551;&#20027;&#24490;&#29615;</span>
          <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span>
           <span style="color: #696969;">(</span>newline<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>display output-prompt<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>display-stream
            <span style="color: #696969;">(</span>stream-map 
             <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>frame<span style="color: #696969;">)</span>
               <span style="color: #696969;">(</span>instantiate q <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#29992;&#32467;&#26524;&#27969;&#20013;&#30340;&#26694;&#26550; frame &#20570;&#26597;&#35810;&#27169;&#24335;q &#30340;&#23454;&#20363;&#21270;</span>
                            frame
                            <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>v f<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">f &#30340;&#23454;&#21442;&#26159; frame </span>
                              <span style="color: #696969;">(</span>contract-question-mark v<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">;</span><span style="color: #5f9ea0; font-style: italic;">&#22788;&#29702;&#26410;&#32422;&#26463;&#21464;&#37327;&#65292;&#20135;&#29983;&#36866;&#24403;&#30340;&#36755;&#20986;&#24418;&#24335;</span>
             <span style="color: #696969;">(</span>qeval q <span style="color: #696969;">(</span>singleton-stream '<span style="color: #696969;">()))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20174;&#21253;&#21547;&#19968;&#20010;&#31354;&#26694;&#26550;&#30340;&#27969;&#26597;&#35810;&#20986;&#21305;&#37197;&#30340;&#26694;&#26550;&#27969;</span>
           <span style="color: #696969;">(</span>query-driver-loop<span style="color: #696969;">)))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#37325;&#21551;&#20027;&#24490;&#29615;</span>
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">query-syntax-process</span> : 处理输入表达式前将其变换为一种易处理形式， <b>修改其中变量的表示</b></li>
<li><span class="underline">contract-question-mark</span> : 查询后打印前把 <b>未约束变量变回原形式</b></li>
<li><span class="underline">实例化</span> 表达式时需要 <b>复制</b> ，用给定 <span class="underline">框架</span> 里的 <span class="underline">约束</span>  <b>代换</b> 其中的 <span class="underline">变量</span></li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">instantiate</span> exp frame unbound-var-handler<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">copy</span> exp<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992; frame &#37324;&#30340;&#32422;&#26463;&#26500;&#36896; exp &#30340;&#23454;&#20363;&#21270;&#21103;&#26412;</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>var? exp<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>binding <span style="color: #696969;">(</span>binding-in-frame exp frame<span style="color: #696969;">)))</span>
             <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> binding
                 <span style="color: #696969;">(</span>copy <span style="color: #696969;">(</span>binding-value binding<span style="color: #696969;">))</span>
                 <span style="color: #696969;">(</span>unbound-var-handler exp frame<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#29992;&#20256;&#20837;&#30340; &#36807;&#31243;&#21442;&#25968; &#26469; &#22788;&#29702;&#26410;&#32422;&#26463;&#21464;&#37327;</span>
          <span style="color: #696969;">((</span>pair? exp<span style="color: #696969;">)</span>
           <span style="color: #696969;">(</span>cons <span style="color: #696969;">(</span>copy <span style="color: #696969;">(</span>car exp<span style="color: #696969;">))</span> <span style="color: #696969;">(</span>copy <span style="color: #696969;">(</span>cdr exp<span style="color: #696969;">))))</span>
          <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> exp<span style="color: #696969;">)))</span>
  <span style="color: #696969;">(</span>copy exp<span style="color: #696969;">))</span>
</pre>
</div>
<pre class="example">
     无约束变量用 instantiate 的参数 unbound-var-handler 处理

     例如，变量 ? x 和 exp 合一操作后得到其值为 ? y，而 ? y 被约束为 5

     对于这个未约束变量 ? x 将使用传递进 instantiate 的参数过程来处理
</pre>
</div>
</div>
<div id="outline-container-orgd3927f3" class="outline-3">
<h3 id="orgd3927f3">求值器</h3>
<div class="outline-text-3" id="text-orgd3927f3">
<p>
<span class="underline">qeval-driver-loop</span> 调用基本求值过程 <span class="underline">qeval</span> ，qeval 是查询求值器的 <b>核心</b> ：
</p>
<ul class="org-ul">
<li>参数是一个 <span class="underline">查询模式</span> 和一个 <span class="underline">框架流</span></li>
<li>返回 <span class="underline">扩充后的框架流</span></li>
</ul>

<p>
qeval 用 <span class="underline">type</span>  识别各种 <b>特殊形式</b> ，基于 <span class="underline">get</span>  和 <span class="underline">put</span>  <b>组织操作</b> ，根据类型完成 <span class="underline">数据导向</span> 的分派：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">qeval</span> query frame-stream<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>qproc <span style="color: #696969;">(</span>get <span style="color: #696969;">(</span>type query<span style="color: #696969;">)</span> 'qeval<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> qproc 
        <span style="color: #696969;">(</span>qproc <span style="color: #696969;">(</span>contents query<span style="color: #696969;">)</span> frame-stream<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#26159;&#29305;&#27530;&#22788;&#29702;&#36807;&#31243;&#65292;&#23601;&#29992;&#35813;&#36807;&#31243;&#22788;&#29702;</span>
        <span style="color: #696969;">(</span>simple-query query frame-stream<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#38750;&#29305;&#27530;&#24418;&#24335;&#30340;&#34920;&#36798;&#24335;&#37117;&#24403;&#20316;&#31616;&#21333;&#26597;&#35810;</span>
</pre>
</div>

<p>
<span class="underline">type</span> 和 <span class="underline">contents</span> 是 <b>语法过程</b> ，后面会定义
</p>
</div>
<div id="outline-container-org04a6a2d" class="outline-4">
<h4 id="org04a6a2d">简单查询</h4>
<div class="outline-text-4" id="text-org04a6a2d">
<p>
<span class="underline">simple-query</span> ：处理简单查询
</p>
<ul class="org-ul">
<li>参数是一个 <span class="underline">模式</span> 和一个 <span class="underline">框架流</span></li>
<li>它逐个处理流中各框架：
<ul class="org-ul">
<li><span class="underline">find-assertions</span> : 找数据库里的 <b>匹配断言</b> ，生成 <b>扩充框架的流</b></li>
<li><span class="underline">apply-rules</span> :  <b>应用可应用的规则</b> ，生成 <b>扩充框架的流</b></li>
<li><span class="underline">stream-append-delayed</span> :   <b>组合</b> 上面两个流</li>
<li><span class="underline">stream-flatmap</span> : 把处理各框架得到的流 <b>合并为一个流</b> （ <span class="underline">平坦化</span> ）</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">simple-query</span> query-pattern frame-stream<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>stream-flatmap <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#25226;&#22788;&#29702;&#21508;&#26694;&#26550;&#24471;&#21040;&#30340;&#27969;&#21512;&#24182;&#20026;&#19968;&#20010;&#27969; </span>
   <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>frame<span style="color: #696969;">)</span> 
     <span style="color: #696969;">(</span>stream-append-delayed <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#32452;&#21512;&#20004;&#20010;&#27969;</span>
      <span style="color: #696969;">(</span>find-assertions query-pattern frame<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#25214;&#25968;&#25454;&#24211;&#37324;&#30340;&#21305;&#37197;&#26029;&#35328;&#65292;&#29983;&#25104;&#25193;&#20805;&#26694;&#26550;&#30340;&#27969; </span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">delay</span> <span style="color: #696969;">(</span>apply-rules query-pattern frame<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#24212;&#29992;&#21487;&#24212;&#29992;&#30340;&#35268;&#21017;&#65292;&#29983;&#25104;&#25193;&#20805;&#26694;&#26550;&#30340;&#27969; </span>
   frame-stream<span style="color: #696969;">))</span>
</pre>
</div>

<p>
这里用到了 <span class="underline">流的延时</span> 处理
</p>
</div>
</div>

<div id="outline-container-org88b3044" class="outline-4">
<h4 id="org88b3044">复合查询</h4>
<div class="outline-text-4" id="text-org88b3044">
</div>
<div id="outline-container-org133ea16" class="outline-5">
<h5 id="org133ea16">and 查询</h5>
<div class="outline-text-5" id="text-org133ea16">
<p>
过程 <span class="underline">conjoin</span> 处理 <span class="underline">and</span> 查询：
</p>
<ul class="org-ul">
<li>参数是 <span class="underline">合取项的表</span> 和一个 <span class="underline">框架流</span> 。允许 <b>任意多个</b> 合取项</li>
<li>conjoin <b>递归地使用各个合取项</b> 基于处理 <span class="underline">第一个合取项得到的框架流</span> 去处理其他合取项：</li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">conjoin</span> conjuncts frame-stream<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>empty-conjunction? conjuncts<span style="color: #696969;">)</span>
      frame-stream
      <span style="color: #696969;">(</span>conjoin <span style="color: #696969;">(</span>rest-conjuncts conjuncts<span style="color: #696969;">)</span>
               <span style="color: #696969;">(</span>qeval <span style="color: #696969;">(</span>first-conjunct conjuncts<span style="color: #696969;">)</span>
                      frame-stream<span style="color: #696969;">))))</span>
</pre>
</div>

<p>
为使 <span class="underline">qeval</span> 能使用 <span class="underline">conjoin</span> ，需要将它设置好：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span>put 'and 'qeval conjoin<span style="color: #696969;">)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org8417739" class="outline-5">
<h5 id="org8417739">or查询</h5>
<div class="outline-text-5" id="text-org8417739">
<p>
过程 <span class="underline">disjoin</span> 处理 <span class="underline">or</span>  查询：
</p>
<ul class="org-ul">
<li>参数是一些 <span class="underline">析取项</span> 和一个 <span class="underline">框架流</span></li>
<li>用各个析取项去扩充框架流里的框架，最后 <b>归并得到的流</b> 需要用 <span class="underline">交错</span> 的方式做（用 <span class="underline">interleave-delayed</span> ）</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">disjoin</span> disjuncts frame-stream<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>empty-disjunction? disjuncts<span style="color: #696969;">)</span>
      the-empty-stream
      <span style="color: #696969;">(</span>interleave-delayed
       <span style="color: #696969;">(</span>qeval <span style="color: #696969;">(</span>first-disjunct disjuncts<span style="color: #696969;">)</span> frame-stream<span style="color: #696969;">)</span>
       <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">delay</span> <span style="color: #696969;">(</span>disjoin <span style="color: #696969;">(</span>rest-disjuncts disjuncts<span style="color: #696969;">)</span>
                       frame-stream<span style="color: #696969;">)))))</span>

<span style="color: #696969;">(</span>put 'or 'qeval disjoin<span style="color: #696969;">)</span>
</pre>
</div>
<p>
两个分支分别处理 <span class="underline">第一个析取项</span> 和 <span class="underline">其余的析取项</span> 
</p>
</div>
</div>
</div>

<div id="outline-container-org7cebb4b" class="outline-4">
<h4 id="org7cebb4b">过滤器</h4>
<div class="outline-text-4" id="text-org7cebb4b">
</div>
<div id="outline-container-org1a086f6" class="outline-5">
<h5 id="org1a086f6">not 过滤器</h5>
<div class="outline-text-5" id="text-org1a086f6">
<p>
设法扩充输入流中每个框架，看它能否满足作被not 否定的模式：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">negate</span> operands frame-stream<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>stream-flatmap
   <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>frame<span style="color: #696969;">)</span>
     <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>stream-null? <span style="color: #696969;">(</span>qeval <span style="color: #696969;">(</span>negated-query operands<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#36870;&#26465;&#20214;&#26597;&#35810;</span>
                              <span style="color: #696969;">(</span>singleton-stream frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#26694;&#26550;&#27969;&#20013;&#30340;&#26576;&#20010;&#26694;&#26550;&#26159;&#21542;&#28385;&#36275; &#36870;&#26597;&#35810;</span>
         <span style="color: #696969;">(</span>singleton-stream frame<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#28385;&#36275;&#30340;&#35805;&#65292;&#21152;&#20837;&#32467;&#26524;&#27969;</span>
         the-empty-stream<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#28385;&#36275;&#30340;&#35805;&#65292;&#36807;&#28388;&#25481;</span>
   frame-stream<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>put 'not 'qeval negate<span style="color: #696969;">)</span> 
</pre>
</div>
</div>
</div>


<div id="outline-container-org9b0f0bf" class="outline-5">
<h5 id="org9b0f0bf">lisp-value 过滤器</h5>
<div class="outline-text-5" id="text-org9b0f0bf">
<p>
<span class="underline">lisp-value</span> 的工作方式与 <span class="underline">not</span> 类似：
</p>
<ol class="org-ol">
<li>流中各 <b>框架去实例化模式里的变量</b></li>
<li>将 <b>谓词应用于这些变量</b></li>
<li><b>丢掉</b> 使 <b>谓词返回假</b> 的 <span class="underline">框架</span></li>
<li>遇到 <span class="underline">未约束的变量</span> 就是 <b>错误</b></li>
</ol>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">lisp-value</span> call frame-stream<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">call &#34987;&#24212;&#29992;&#30340;&#35859;&#35789;</span>
  <span style="color: #696969;">(</span>stream-flatmap
   <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>frame<span style="color: #696969;">)</span>
     <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>execute <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#22788;&#29702;&#23454;&#20363;&#21270;&#21518;&#30340;&#35859;&#35789;&#65292;&#31867;&#20284;&#20110; eval&#65292;&#20294;&#19981;&#27714;&#20540;&#35859;&#35789;&#30340;&#21442;&#25968;&#65288;&#22240;&#23427;&#20204;&#24050;&#32463;&#26159;&#20540;&#65289;</span>
          <span style="color: #696969;">(</span>instantiate <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">instantiate &#29992; frame &#23454;&#20363;&#21270; call &#37324;&#30340;&#21464;&#37327;&#65292;&#24471;&#21040;&#25152;&#38656;&#30340;&#35859;&#35789;&#34920;&#36798;&#24335;</span>
           call
           frame
           <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>v f<span style="color: #696969;">)</span>
             <span style="color: #696969;">(</span>error <span style="color: #deb887;">"Unknown pat var -- LISP-VALUE"</span> v<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#36935;&#21040;&#26410;&#32422;&#26463;&#30340;&#21464;&#37327;&#65292;&#23601;&#26159;&#38169;&#35823; </span>
         <span style="color: #696969;">(</span>singleton-stream frame<span style="color: #696969;">)</span>
         the-empty-stream<span style="color: #696969;">))</span>
   frame-stream<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span>put 'lisp-value 'qeval lisp-value<span style="color: #696969;">)</span>
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">instantiate</span> 用 <span class="underline">frame</span> <b>实例化</b> <span class="underline">call</span> 里的变量，得到所需的 <b>谓词表达式</b></li>
<li><span class="underline">execute</span>  将 <b>谓词应用于实际参数</b> 
<ul class="org-ul">
<li>通过基础的 <span class="underline">eval</span> 和 <span class="underline">apply</span> 实现，将 <span class="underline">exp</span> 里的 <b>谓词作用于参数</b></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">execute</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>apply <span style="color: #696969;">(</span>eval <span style="color: #696969;">(</span>predicate exp<span style="color: #696969;">)</span> user-initial-environment<span style="color: #696969;">)</span>
         <span style="color: #696969;">(</span>args exp<span style="color: #696969;">)))</span>
</pre>
</div>

<pre class="example">
       与eval 不同，谓词作用的对象已是值，不需要再次求值
</pre>
</div>
</div>


<div id="outline-container-orga3b5f94" class="outline-5">
<h5 id="orga3b5f94">always-true</h5>
<div class="outline-text-5" id="text-orga3b5f94">
<p>
特殊形式 <span class="underline">always-true</span>  描述 <b>总能满足的查询</b> ，忽略查询内容， <span class="underline">直接返回作为参数的框架流</span> ：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">always-true</span> ignore frame-stream<span style="color: #696969;">)</span>
  frame-stream<span style="color: #696969;">)</span>

<span style="color: #696969;">(</span>put 'always-true 'qeval always-true<span style="color: #696969;">)</span>
</pre>
</div>

<p>
与 not 和 lisp-value 有关的语法过程（ <span class="underline">选择函数</span> ）在后面定义
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga7418b8" class="outline-3">
<h3 id="orga7418b8">模式匹配</h3>
<div class="outline-text-3" id="text-orga7418b8">
<p>
简单查询调用 <span class="underline">find-assertion</span> ，返回将参数 <span class="underline">frame</span>  与 <span class="underline">数据</span> 匹配得到的 <b>框架形成的流</b> 。其中：
</p>
<ol class="org-ol">
<li><span class="underline">fetch-assertions</span> 返回数据库中断言的流</li>
<li>用 <span class="underline">pattern</span> 和 <span class="underline">frame</span> 做  <span class="underline">简单检查</span> ， <b>丢掉明显不可能匹配的断言</b></li>
</ol>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">find-assertions</span> pattern frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>stream-flatmap <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>datum<span style="color: #696969;">)</span>
                    <span style="color: #696969;">(</span>check-an-assertion datum pattern frame<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20002;&#25481;&#19981;&#21487;&#33021;&#21305;&#37197;&#30340;&#26029;&#35328;</span>
                  <span style="color: #696969;">(</span>fetch-assertions pattern frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20174;&#25968;&#25454;&#24211;&#33719;&#21462;&#26029;&#35328;&#30340;&#27969;</span>
</pre>
</div>

<p>
<span class="underline">check-an-assertion</span> : 对一个 <span class="underline">断言</span> 调用 <b>匹配过程</b>
</p>
<ul class="org-ul">
<li>成功时：返回包含 <span class="underline">一个扩充框架的流</span></li>
<li>不成功：返回 <span class="underline">空流</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">check-an-assertion</span> assertion query-pat query-frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>match-result
         <span style="color: #696969;">(</span>pattern-match query-pat assertion query-frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#35843;&#29992;&#21305;&#37197;&#22120;</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>eq? match-result 'failed<span style="color: #696969;">)</span> 
        the-empty-stream <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#22833;&#36133;&#36820;&#22238;&#31354;&#27969;</span>
        <span style="color: #696969;">(</span>singleton-stream match-result<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#25104;&#21151;&#21253;&#21547; &#19968;&#20010;&#25193;&#20805;&#26694;&#26550;&#30340;&#27969;</span>
</pre>
</div>
</div>
<div id="outline-container-org44923b1" class="outline-4">
<h4 id="org44923b1">基本匹配器</h4>
<div class="outline-text-4" id="text-org44923b1">
<p>
<span class="underline">pattern-match</span> 是 <b>基本匹配器</b> ：
</p>
<ul class="org-ul">
<li>匹配失败：返回符号 <span class="underline">failed</span></li>
<li>成功返回： <b>扩充的框架</b></li>
</ul>

<p>
这里按 <b>结构递归地匹配</b> ：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">pattern-match</span> pat dat frame<span style="color: #696969;">)</span> 
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>eq? frame 'failed<span style="color: #696969;">)</span> 'failed<span style="color: #696969;">)</span>
        <span style="color: #696969;">((</span>equal? pat dat<span style="color: #696969;">)</span> frame<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#30456;&#21516;&#26102;&#65292;&#21305;&#37197;&#25104;&#21151;&#65292;&#30452;&#25509;&#36820;&#22238;&#21407;&#26694;&#26550;</span>
        <span style="color: #696969;">((</span>var? pat<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>extend-if-consistent pat dat frame<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#24335;&#26159;&#20010;&#21464;&#37327;&#65292;&#22522;&#20110; frame &#21644;&#26032;&#32422;&#26463;&#20570;&#25193;&#20805;&#65292;&#26816;&#26597;&#26159;&#21542;&#21327;&#35843;</span>
        <span style="color: #696969;">((</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>pair? pat<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>pair? dat<span style="color: #696969;">))</span> 
         <span style="color: #696969;">(</span>pattern-match <span style="color: #696969;">(</span>cdr pat<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#36882;&#24402;&#21305;&#37197;&#27169;&#24335;&#21644;&#25968;&#25454;&#30340;cdr &#37096;&#20998;</span>
                        <span style="color: #696969;">(</span>cdr dat<span style="color: #696969;">)</span>
                        <span style="color: #696969;">(</span>pattern-match <span style="color: #696969;">(</span>car pat<span style="color: #696969;">)</span>
                                       <span style="color: #696969;">(</span>car dat<span style="color: #696969;">)</span>
                                       frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#21305;&#37197; car &#37096;&#20998;&#24471;&#21040;&#30340;&#21487;&#33021;&#65292;&#25193;&#20805;&#30340;&#26694;&#26550;&#20316;&#20026;&#26694;&#26550;</span>
        <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> 'failed<span style="color: #696969;">)))</span>
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">extend-if-consistent</span></li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">extend-if-consistent</span> var dat frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>binding <span style="color: #696969;">(</span>binding-in-frame var frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#25214;&#20986; var &#22312; frame &#37324;&#30340;&#32422;&#26463;</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> binding
        <span style="color: #696969;">(</span>pattern-match <span style="color: #696969;">(</span>binding-value binding<span style="color: #696969;">)</span> dat frame<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#26816;&#26597;&#26159;&#21542;&#21305;&#37197; </span>
        <span style="color: #696969;">(</span>extend var dat frame<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">var &#26080;&#32422;&#26463;&#65292;&#25226;&#26032;&#32422;&#26463;&#21152;&#20837;frame</span>
</pre>
</div>

<ul class="org-ul">
<li>在 <span class="underline">var</span>  和 <span class="underline">dat</span> 的 <span class="underline">约束</span> 与 <span class="underline">frame</span> 里的 <span class="underline">约束</span> <b>兼容</b> 时产生扩充的框架</li>
<li>如果 <span class="underline">var</span> 在 <span class="underline">frame</span> 里已有约束，只有 <b>这一 <span class="underline">约束</span> 和现数据 <span class="underline">dat</span> 匹配</b> 时，整个匹配才成功
<ul class="org-ul">
<li><span class="underline">(binding-value binding)</span> ： <b>取出的已有匹配里还可能有变量</b> （由 <span class="underline">合一得到的约束</span> ）</li>
</ul></li>
</ul>

<pre class="example">
      目前框架里 ?x 约束到 (f ?y) 而 ?y 无约束，现在想加入 ?x 与 (f b) 的约束来扩大框架

      这一过程在框架里查找 ?x ，并发现它已约束到 (f ?y)

      这导致要在同一框架里做(f ?y) 与新值 (f b) 的匹配，最终将 ?y 到 b 的约束加入框架

      变量 ?x 仍约束到 (f ?y)
</pre>

<p>
匹配中已有的约束绝不改变，也不会出现一个变量有多个约束的情况
</p>
</div>
</div>

<div id="outline-container-org1314b03" class="outline-4">
<h4 id="org1314b03">点号模式</h4>
<div class="outline-text-4" id="text-org1314b03">
<p>
如果模式中有 <b>圆点</b> ，圆点后面应是一个模式变量，该变量将与数据表的 <b>剩下部分</b> 匹配（而不是与 <span class="underline">下一元素</span> 匹配）
</p>
<pre class="example">
      虽然在模式匹配器没专门处理圆点，但却能正确工作

      因为模式和数据都用 Scheme 的表表示，圆点自然有合适意义
</pre>

<p>
read 读查询时遇到圆点就把下一个项作为所构造表达式的 cdr。例如：
</p>
<ul class="org-ul">
<li>读入模式 <span class="underline">(computer ?type)</span> ，read产生的表结构相当于对表达式 <span class="underline">(cons 'computer (cons '?type '()))</span> 求值产生的结构</li>
<li>读入模式 <span class="underline">(computer . ?type)</span> 时，产生的结构相当于对表达式 <span class="underline">(cons 'computer '?type)</span> 求值产生出的结构</li>
</ul>

<pre class="example">
      如果匹配器用模式 (computer . ?type) 去匹配，它将用 ?type 与数据的 cdr 部分匹配

      例如与 (computer programmer trainee) 匹配时，?type 将约束到 (programmer trainee)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7384cab" class="outline-3">
<h3 id="org7384cab">规则合一</h3>
<div class="outline-text-3" id="text-org7384cab">
</div>
<div id="outline-container-org3e8f12b" class="outline-4">
<h4 id="org3e8f12b">应用规则</h4>
<div class="outline-text-4" id="text-org3e8f12b">
<p>
<span class="underline">apply-rules</span> ：应用规则，以一个 <span class="underline">模式</span> 和一个 <span class="underline">框架</span> 为输入，生成一个 <span class="underline">框架流</span> 。它被 <span class="underline">simple-query</span> 调用
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">apply-rules</span> pattern frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>stream-flatmap <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">lambda</span> <span style="color: #696969;">(</span>rule<span style="color: #696969;">)</span>
                    <span style="color: #696969;">(</span>apply-a-rule rule pattern frame<span style="color: #696969;">))</span>
                  <span style="color: #696969;">(</span>fetch-rules pattern frame<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
<span class="underline">apply-a-rule</span> : 应用一条规则
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">apply-a-rule</span> rule query-pattern query-frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>clean-rule <span style="color: #696969;">(</span>rename-variables-in rule<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#35268;&#21017;&#37324;&#30340;&#21464;&#37327;&#32479;&#19968;&#25913;&#21517;&#65292;&#20351;&#20043;&#19981;&#20250;&#19982;&#20854;&#20182;&#35268;&#21017;&#20914;&#31361;</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>unify-result
           <span style="color: #696969;">(</span>unify-match query-pattern
                        <span style="color: #696969;">(</span>conclusion clean-rule<span style="color: #696969;">)</span>
                        query-frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20570;&#26597;&#35810;&#27169;&#24335;&#21644;&#35268;&#21017;&#32467;&#35770;&#20570;&#21512;&#19968;&#21305;&#37197;</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>eq? unify-result 'failed<span style="color: #696969;">)</span>
          the-empty-stream
          <span style="color: #696969;">(</span>qeval <span style="color: #696969;">(</span>rule-body clean-rule<span style="color: #696969;">)</span>
                 <span style="color: #696969;">(</span>singleton-stream unify-result<span style="color: #696969;">))))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#22522;&#20110;&#24471;&#21040;&#30340; &#26032;&#26694;&#26550;&#27969; &#20570; &#35268;&#21017;&#20307; &#30340;&#21305;&#37197;</span>
</pre>
</div>

<p>
<span class="underline">rename-variables-in rule</span> : 构造新的“干净”规则
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">rename-variables-in</span> rule<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>rule-application-id <span style="color: #696969;">(</span>new-rule-application-id<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">tree-walk</span> exp<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>var? exp<span style="color: #696969;">)</span>
             <span style="color: #696969;">(</span>make-new-variable exp rule-application-id<span style="color: #696969;">))</span>
            <span style="color: #696969;">((</span>pair? exp<span style="color: #696969;">)</span>
             <span style="color: #696969;">(</span>cons <span style="color: #696969;">(</span>tree-walk <span style="color: #696969;">(</span>car exp<span style="color: #696969;">))</span>
                   <span style="color: #696969;">(</span>tree-walk <span style="color: #696969;">(</span>cdr exp<span style="color: #696969;">))))</span>
            <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> exp<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span>tree-walk rule<span style="color: #696969;">)))</span>
</pre>
</div>
<p>
递归遍历该规则，重命名所有变量（加唯一编号后缀） 
</p>

<pre class="example">
      每次应用规则前重新构造一个“干净”规则，比较耗时
</pre>
</div>
</div>


<div id="outline-container-org3b2e2fb" class="outline-4">
<h4 id="org3b2e2fb">合一操作</h4>
<div class="outline-text-4" id="text-org3b2e2fb">
<p>
合一的不同点就在于 <b>匹配的两边都可能有变量</b> ，因此都可能建立约束。与简单匹配的仅有差异在对变量的处理：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">unify-match</span> p1 p2 frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>eq? frame 'failed<span style="color: #696969;">)</span> 'failed<span style="color: #696969;">)</span>
        <span style="color: #696969;">((</span>equal? p1 p2<span style="color: #696969;">)</span> frame<span style="color: #696969;">)</span>
        <span style="color: #696969;">((</span>var? p1<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>extend-if-possible p1 p2 frame<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#20004;&#36793;&#37117;&#21487;&#33021;&#26159;&#21464;&#37327;</span>
        <span style="color: #696969;">((</span>var? p2<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>extend-if-possible p2 p1 frame<span style="color: #696969;">))</span>  
        <span style="color: #696969;">((</span><span style="color: #00bfff; font-weight: bold;">and</span> <span style="color: #696969;">(</span>pair? p1<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>pair? p2<span style="color: #696969;">))</span>
         <span style="color: #696969;">(</span>unify-match <span style="color: #696969;">(</span>cdr p1<span style="color: #696969;">)</span>
                      <span style="color: #696969;">(</span>cdr p2<span style="color: #696969;">)</span>
                      <span style="color: #696969;">(</span>unify-match <span style="color: #696969;">(</span>car p1<span style="color: #696969;">)</span>
                                   <span style="color: #696969;">(</span>car p2<span style="color: #696969;">)</span>
                                   frame<span style="color: #696969;">)))</span>
        <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> 'failed<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
遇变量时要考虑两种情况，由 <span class="underline">extend-if-possible</span> 完成
</p>
<ul class="org-ul">
<li>如果 <span class="underline">另一方也是变量</span> ，则需考虑它 <b>是否已有约束</b> 
<ul class="org-ul">
<li>如果有，就让 <b>被处理变量取相同约束</b></li>
<li>否则就直接将其 <b>约束于另一方变量</b></li>
</ul></li>
<li>如果要将 <span class="underline">变量约束于一个模式</span> ，而 <span class="underline">模式里有这个变量</span> 。那么 <b>任何赋值都不可能实现这一匹配</b> ，应作为匹配失败</li>
</ul>

<pre class="example">
      两模式里都有重复变量，可能出现第二种情况

      匹配 (?x ?x) 和 (?y (a ?y))。先得到了 ?x 约束于 ?y 

      下面要用 ?x 匹配 (a ?y)

      由于 ?x 约束于 ?y，因此要匹配 ?y 和 (a ?y)

      显然这一匹配不可能成功
</pre>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">extend-if-possible</span> var val frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>binding <span style="color: #696969;">(</span>binding-in-frame var frame<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">(</span>binding 
           <span style="color: #696969;">(</span>unify-match
            <span style="color: #696969;">(</span>binding-value binding<span style="color: #696969;">)</span> val frame<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#33509;var &#24050;&#26377;&#32422;&#26463;&#65292;&#35201;&#27714;&#20854;&#32422;&#26463;&#20540;&#21487;&#19982; val &#21512;&#19968;    </span>
          <span style="color: #696969;">((</span>var? val<span style="color: #696969;">)</span>   <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21305;&#37197;&#30340;&#21478;&#19968;&#26041;&#20063;&#26159;&#21464;&#37327;&#12290;&#22914;&#26524;&#35813;&#21464;&#37327;&#26377;&#32422;&#26463;&#65292;&#21017;&#35201;&#27714; var &#21487;&#19982;&#35813;&#21464;&#37327;&#30340;&#32422;&#26463;&#20540;&#21512;&#19968;</span>
           <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>binding <span style="color: #696969;">(</span>binding-in-frame val frame<span style="color: #696969;">)))</span>
             <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> binding
                 <span style="color: #696969;">(</span>unify-match
                  var <span style="color: #696969;">(</span>binding-value binding<span style="color: #696969;">)</span> frame<span style="color: #696969;">)</span>
                 <span style="color: #696969;">(</span>extend var val frame<span style="color: #696969;">))))</span>
          <span style="color: #696969;">((</span>depends-on? val var frame<span style="color: #696969;">)</span>     <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">val &#20381;&#36182;&#20110; var &#26102;&#21305;&#37197;&#22833;&#36133;</span>
           'failed<span style="color: #696969;">)</span>
          <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #696969;">(</span>extend var val frame<span style="color: #696969;">)))))</span>
</pre>
</div>

<p>
<span class="underline">depends-on?</span> 检查一个 <span class="underline">表达式</span>  <b>是否依赖</b> 于一个变量 <span class="underline">?x</span> 。这一检查也需要相对于一个 <span class="underline">frame</span> 进行，因为可能在模式里出现另一变量 <span class="underline">?y</span> ，而 <span class="underline">?y</span>  在 <span class="underline">frame</span> 里的 <span class="underline">约束</span> <b>依赖</b> 于 <span class="underline">?x</span> （还可能继续传递）
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">depends-on?</span> exp var frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">tree-walk</span> e<span style="color: #696969;">)</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>var? e<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#26159;&#21464;&#37327;</span>
           <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>equal? var e<span style="color: #696969;">)</span>  <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21644; var &#30456;&#21516;</span>
               true
               <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>b <span style="color: #696969;">(</span>binding-in-frame e frame<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">b &#26159; e &#22312; frame &#37324;&#30340;&#32422;&#26463; </span>
                 <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> b
                     <span style="color: #696969;">(</span>tree-walk <span style="color: #696969;">(</span>binding-value b<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#26816;&#26597;&#32422;&#26463;&#20540; &#26159;&#21542;&#26377;&#20381;&#36182;</span>
                     false<span style="color: #696969;">))))</span>
          <span style="color: #696969;">((</span>pair? e<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#36882;&#24402;&#26816;&#26597;&#27599;&#20010;&#24207;&#23545;&#30340; car &#21644; cdr </span>
           <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">or</span> <span style="color: #696969;">(</span>tree-walk <span style="color: #696969;">(</span>car e<span style="color: #696969;">))</span>
               <span style="color: #696969;">(</span>tree-walk <span style="color: #696969;">(</span>cdr e<span style="color: #696969;">))))</span>
          <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> false<span style="color: #696969;">)))</span>
  <span style="color: #696969;">(</span>tree-walk exp<span style="color: #696969;">))</span>
</pre>
</div>
<p>
这一检查基本是按结构递归
</p>
</div>
</div>
</div>
<div id="outline-container-org66025b9" class="outline-3">
<h3 id="org66025b9">数据库操作</h3>
<div class="outline-text-3" id="text-org66025b9">
</div>
<div id="outline-container-org0854998" class="outline-4">
<h4 id="org0854998">断言表示</h4>
<div class="outline-text-4" id="text-org0854998">
<p>
数据库维护的关键是尽可能 <b>减少检索时需考察的断言</b> ：
</p>
<ol class="org-ol">
<li>先把 <span class="underline">所有断言</span> 存入一个大流</li>
<li>把 <span class="underline">car 部分是相同常量的断言</span> 存入同一个流，以 <span class="underline">该 car 为索引</span> 把流存入一个表格（另一关键码用 <span class="underline">assertion-stream</span> ）</li>
</ol>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #daa520; font-weight: bold;">THE-ASSERTIONS</span> the-empty-stream<span style="color: #696969;">)</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">fetch-assertions</span> pattern frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>use-index? pattern<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">pattern &#30340; car &#26159;&#24120;&#37327;</span>
      <span style="color: #696969;">(</span>get-indexed-assertions pattern<span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21040;&#29305;&#23450;&#30340;&#27969;&#37324;&#21435;&#26816;&#32034;</span>
      <span style="color: #696969;">(</span>get-all-assertions<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">get-all-assertions</span><span style="color: #696969;">)</span> THE-ASSERTIONS<span style="color: #696969;">)</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">get-indexed-assertions</span> pattern<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>get-stream <span style="color: #696969;">(</span>index-key-of pattern<span style="color: #696969;">)</span> 'assertion-stream<span style="color: #696969;">))</span> 
</pre>
</div>
<p>
<span class="underline">get-stream</span> : 按 <span class="underline">key1</span>  和 <span class="underline">key2</span>  到表格里找相应流，找不到时返回空流
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">get-stream</span> key1 key2<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>s <span style="color: #696969;">(</span>get key1 key2<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> s s the-empty-stream<span style="color: #696969;">)))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ffc0e2" class="outline-4">
<h4 id="org0ffc0e2">规则表示</h4>
<div class="outline-text-4" id="text-org0ffc0e2">
<p>
规则管理的方式类似，以规则中 <span class="underline">结论部分的car 为索引</span> ，将结论的 car 相同的规则的流存入表格（另一关键码是 <span class="underline">rule-stream</span> ） 
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #daa520; font-weight: bold;">THE-RULES</span> the-empty-stream<span style="color: #696969;">)</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">fetch-rules</span> pattern frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>use-index? pattern<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>get-indexed-rules pattern<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>get-all-rules<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">get-all-rules</span><span style="color: #696969;">)</span> THE-RULES<span style="color: #696969;">)</span>
</pre>
</div>

<p>
<span class="underline">car 是常量的模式</span> 可与 <span class="underline">结论的 car 相同的规则</span> 匹配，也与 <span class="underline">结论的 car 是变量的规则</span> 匹配。为方便处理， <b>所有结论的 car 是变量的规则存入 <span class="underline">?索引</span> 的流</b> 。与 car 部分是常量的模式匹配的流可能由两个流组成：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">get-indexed-rules</span> pattern<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>stream-append
   <span style="color: #696969;">(</span>get-stream <span style="color: #696969;">(</span>index-key-of pattern<span style="color: #696969;">)</span> 'rule-stream<span style="color: #696969;">)</span>
   <span style="color: #696969;">(</span>get-stream '? 'rule-stream<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#25152;&#26377;&#32467;&#35770;&#30340; car &#26159;&#21464;&#37327;&#30340;&#35268;&#21017;&#23384;&#20837; ?&#32034;&#24341; &#30340;&#27969;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org196c26e" class="outline-4">
<h4 id="org196c26e">添加操作</h4>
<div class="outline-text-4" id="text-org196c26e">
<p>
加入断言或规则的请求分情况处理：
</p>
<ul class="org-ul">
<li>不但将它加入 <b>包含所有断言或规则的主流</b></li>
<li>还根据其（或结论）的 car 加入 <b>表格里的支流</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">add-rule-or-assertion!</span> assertion<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>rule? assertion<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>add-rule! assertion<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>add-assertion! assertion<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">add-assertion!</span> assertion<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>store-assertion-in-index assertion<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>old-assertions THE-ASSERTIONS<span style="color: #696969;">))</span>
    <span style="color: #696969;">(</span>set! THE-ASSERTIONS
          <span style="color: #696969;">(</span>cons-stream assertion old-assertions<span style="color: #696969;">))</span>
    'ok<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">add-rule!</span> rule<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>store-rule-in-index rule<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>old-rules THE-RULES<span style="color: #696969;">))</span>
    <span style="color: #696969;">(</span>set! THE-RULES <span style="color: #696969;">(</span>cons-stream rule old-rules<span style="color: #696969;">))</span>
    'ok<span style="color: #696969;">))</span>
</pre>
</div>

<p>
加入支流的工作由两个专门过程完成：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">store-assertion-in-index</span> assertion<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>indexable? assertion<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>key <span style="color: #696969;">(</span>index-key-of assertion<span style="color: #696969;">)))</span>
        <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>current-assertion-stream
               <span style="color: #696969;">(</span>get-stream key 'assertion-stream<span style="color: #696969;">)))</span>
          <span style="color: #696969;">(</span>put key
               'assertion-stream
               <span style="color: #696969;">(</span>cons-stream assertion
                            current-assertion-stream<span style="color: #696969;">))))))</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">store-rule-in-index</span> rule<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>pattern <span style="color: #696969;">(</span>conclusion rule<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>indexable? pattern<span style="color: #696969;">)</span>
        <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>key <span style="color: #696969;">(</span>index-key-of pattern<span style="color: #696969;">)))</span>
          <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>current-rule-stream
                 <span style="color: #696969;">(</span>get-stream key 'rule-stream<span style="color: #696969;">)))</span>
            <span style="color: #696969;">(</span>put key
                 'rule-stream
                 <span style="color: #696969;">(</span>cons-stream rule
                              current-rule-stream<span style="color: #696969;">)))))))</span>
</pre>
</div>

<p>
可以加入某个支流的 <span class="underline">条件</span> ：
</p>
<ul class="org-ul">
<li><b>模式的 car 是常量符号</b></li>
<li>对于 <span class="underline">规则</span> ，还有其 <b>结论（模式）的 car 是模式变量</b> 的情况：</li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">indexable?</span> pat<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">or</span> <span style="color: #696969;">(</span>constant-symbol? <span style="color: #696969;">(</span>car pat<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#24335;&#30340; car &#26159;&#24120;&#37327;&#31526;&#21495;</span>
      <span style="color: #696969;">(</span>var? <span style="color: #696969;">(</span>car pat<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#24335;&#65288;&#32467;&#35770;&#65289;&#30340; car &#26159;&#27169;&#24335;&#21464;&#37327;</span>
</pre>
</div>

<ul class="org-ul">
<li>模式存入表格用的 <span class="underline">关键码</span> 就是 <b>其 car</b></li>
<li>对于规则的结论模式，如果 <span class="underline">其 car 是模式变量</span> ，关键码用 <b>?</b> ：</li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">index-key-of</span> pat<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>key <span style="color: #696969;">(</span>car pat<span style="color: #696969;">)))</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>var? key<span style="color: #696969;">)</span> '? key<span style="color: #696969;">)))</span> 
</pre>
</div>

<p>
如 <span class="underline">模式的 car 是常量符号</span> ，就用 <b>它作为索引</b> 去提取相应的流用于检索：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">use-index?</span> pat<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>constant-symbol? <span style="color: #696969;">(</span>car pat<span style="color: #696969;">)))</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgaec05da" class="outline-3">
<h3 id="orgaec05da">流操作</h3>
<div class="outline-text-3" id="text-orgaec05da">
<p>
查询系统用了几个前面没定义的流操作：
</p>
<ul class="org-ul">
<li>append</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">stream-append-delayed</span> s1 delayed-s2<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>stream-null? s1<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">force</span> delayed-s2<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>cons-stream
       <span style="color: #696969;">(</span>stream-car s1<span style="color: #696969;">)</span>
       <span style="color: #696969;">(</span>stream-append-delayed <span style="color: #696969;">(</span>stream-cdr s1<span style="color: #696969;">)</span> delayed-s2<span style="color: #696969;">))))</span>
</pre>
</div>

<ul class="org-ul">
<li>交错归并：</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">interleave-delayed</span> s1 delayed-s2<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>stream-null? s1<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">force</span> delayed-s2<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>cons-stream
       <span style="color: #696969;">(</span>stream-car s1<span style="color: #696969;">)</span>
       <span style="color: #696969;">(</span>interleave-delayed <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">force</span> delayed-s2<span style="color: #696969;">)</span>
                           <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">delay</span> <span style="color: #696969;">(</span>stream-cdr s1<span style="color: #696969;">))))))</span> 

</pre>
</div>

<ul class="org-ul">
<li>把过程 proc 用于 s 的每个元素后将得到的流 <b>平坦化</b> ：</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">stream-flatmap</span> proc s<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>flatten-stream <span style="color: #696969;">(</span>stream-map proc s<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">flatten-stream</span> stream<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>stream-null? stream<span style="color: #696969;">)</span>
      the-empty-stream
      <span style="color: #696969;">(</span>interleave-delayed
       <span style="color: #696969;">(</span>stream-car stream<span style="color: #696969;">)</span>
       <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">delay</span> <span style="color: #696969;">(</span>flatten-stream <span style="color: #696969;">(</span>stream-cdr stream<span style="color: #696969;">))))))</span>
</pre>
</div>
<ul class="org-ul">
<li>构造只包含一个元素的流：</li>
</ul>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">singleton-stream</span> x<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>cons-stream x the-empty-stream<span style="color: #696969;">))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc9b7193" class="outline-3">
<h3 id="orgc9b7193">语法过程</h3>
<div class="outline-text-3" id="text-orgc9b7193">
</div>
<div id="outline-container-orgafbf657" class="outline-4">
<h4 id="orgafbf657">类型表达式</h4>
<div class="outline-text-4" id="text-orgafbf657">
<p>
应该是 <span class="underline">表</span> ，其 <b>类型</b> 就是其 <span class="underline">第一个元素</span> ，其 <b>内容</b> 就是 <span class="underline">去掉第一个元素之后的那个表</span> ：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">type</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>pair? exp<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>car exp<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>error <span style="color: #deb887;">"Unknown expression TYPE"</span> exp<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">contents</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>pair? exp<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>cdr exp<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>error <span style="color: #deb887;">"Unknown expression CONTENTS"</span> exp<span style="color: #696969;">)))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org56676c1" class="outline-4">
<h4 id="org56676c1">断言</h4>
<div class="outline-text-4" id="text-org56676c1">
<p>
断言的类型是 <span class="underline">assert</span> ，其 <b>内容</b> 就是 <span class="underline">表的第二个元素</span> ：
</p>

<pre class="example">
      在基本驱动循环里用  (assert! &lt;rule-or-assertion&gt;) 
</pre>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">assertion-to-be-added?</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>eq? <span style="color: #696969;">(</span>type exp<span style="color: #696969;">)</span> 'assert!<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">add-assertion-body</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>car <span style="color: #696969;">(</span>contents exp<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
<b>组合断言</b> 的语法过程：
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">and </span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">empty-conjunction?</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>null? exps<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">first-conjunct</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>car exps<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">rest-conjuncts</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>cdr exps<span style="color: #696969;">))</span>
<span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">or </span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">empty-disjunction?</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>null? exps<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">first-disjunct</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>car exps<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">rest-disjuncts</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>cdr exps<span style="color: #696969;">))</span>
<span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">not </span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">negated-query</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>car exps<span style="color: #696969;">))</span>
<span style="color: #5f9ea0; font-style: italic;">;;; </span><span style="color: #5f9ea0; font-style: italic;">lisp-value</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">predicate</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>car exps<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">args</span> exps<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>cdr exps<span style="color: #696969;">))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2478f8" class="outline-4">
<h4 id="orgd2478f8">规则</h4>
<div class="outline-text-4" id="text-orgd2478f8">
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">rule?</span> statement<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>tagged-list? statement 'rule<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">conclusion</span> rule<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>cadr rule<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#32467;&#35770;</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">rule-body</span> rule<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>null? <span style="color: #696969;">(</span>cddr rule<span style="color: #696969;">))</span>
      '<span style="color: #696969;">(</span>always-true<span style="color: #696969;">)</span>
      <span style="color: #696969;">(</span>caddr rule<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#35268;&#21017;&#30340;&#20307;</span>
</pre>
</div>

<p>
把模式中的 <b>模式变量变形</b> ，例如 <span class="underline">?x</span> 变成 <span class="underline">(? x)</span> ，使处理更方便：
</p>

<pre class="example">
      假设模式是： (job ?x ?y) 实际上在系统里被表示为 (job (? x) (? y))

      现在检查一个表达式是否是模式变量，只需要去校验 car 是否是 '?，而不需要从解析变量名字

      因此这可以大大提高查询处理的效率
</pre>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">query-syntax-process</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>map-over-symbols expand-question-mark exp<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">map-over-symbols</span> proc exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">cond</span> <span style="color: #696969;">((</span>pair? exp<span style="color: #696969;">)</span>
         <span style="color: #696969;">(</span>cons <span style="color: #696969;">(</span>map-over-symbols proc <span style="color: #696969;">(</span>car exp<span style="color: #696969;">))</span>
               <span style="color: #696969;">(</span>map-over-symbols proc <span style="color: #696969;">(</span>cdr exp<span style="color: #696969;">))))</span>
        <span style="color: #696969;">((</span>symbol? exp<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>proc exp<span style="color: #696969;">))</span>
        <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">else</span> exp<span style="color: #696969;">)))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">expand-question-mark</span> symbol<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #696969;">((</span>chars <span style="color: #696969;">(</span>symbol-&gt;string symbol<span style="color: #696969;">)))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#24471; symbol &#30340;&#21517;&#23383;&#23383;&#31526;&#20018;</span>
    <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>string=? <span style="color: #696969;">(</span>substring chars 0 1<span style="color: #696969;">)</span> <span style="color: #deb887;">"?"</span><span style="color: #696969;">)</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21517;&#23383;&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#26159;&#21542; '?</span>
        <span style="color: #696969;">(</span>list '?
              <span style="color: #696969;">(</span>string-&gt;symbol
               <span style="color: #696969;">(</span>substring chars 1 <span style="color: #696969;">(</span>string-length chars<span style="color: #696969;">))))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#24471; symbol &#30340;&#21517;&#23383;&#38500;&#21435; '? &#21518;&#30340;&#23383;&#31526;&#20018;</span>
        symbol<span style="color: #696969;">)))</span>
</pre>
</div>

<p>
经过前面变换：
</p>
<ul class="org-ul">
<li>模式变量就是以 <b>? 为类型</b> <span class="underline">（car ）的表</span></li>
<li>常量符号就是 Scheme 里的 <span class="underline">一般符号</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">var?</span> exp<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>tagged-list? exp '?<span style="color: #696969;">))</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">constant-symbol?</span> exp<span style="color: #696969;">)</span> <span style="color: #696969;">(</span>symbol? exp<span style="color: #696969;">))</span>
</pre>
</div>

<p>
为完成规则中的 <b>模式变量换名</b> ，需要下面几个过程：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #daa520; font-weight: bold;">rule-counter</span> 0<span style="color: #696969;">)</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">new-rule-application-id</span><span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>set! rule-counter <span style="color: #696969;">(</span>+ 1 rule-counter<span style="color: #696969;">))</span>
  rule-counter<span style="color: #696969;">)</span>

<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">make-new-variable</span> var rule-application-id<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>cons '? <span style="color: #696969;">(</span>cons rule-application-id <span style="color: #696969;">(</span>cdr var<span style="color: #696969;">))))</span>
</pre>
</div>

<pre class="example">
      换名后各模式变量用的形式是 (? 3 x) ， (? 8 y)
</pre>

<p>
驱动循环打印结果前要把 <b>结果中未约束的变量变换回原来形式</b> ，由于可能 <b>出现规则换名中生成的模式变量</b> ，因此需要分别处理：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">contract-question-mark</span> variable<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>string-&gt;symbol
   <span style="color: #696969;">(</span>string-append <span style="color: #deb887;">"?"</span> 
     <span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #696969;">(</span>number? <span style="color: #696969;">(</span>cadr variable<span style="color: #696969;">))</span> <span style="color: #5f9ea0; font-style: italic;">; </span><span style="color: #5f9ea0; font-style: italic;">&#25442;&#21517;&#21464;&#37327;&#30340;&#29305;&#28857;&#26159;&#34920;&#37324;&#30340;&#31532;&#20108;&#20010;&#20803;&#32032;&#26159;&#25968;</span>
         <span style="color: #696969;">(</span>string-append <span style="color: #696969;">(</span>symbol-&gt;string <span style="color: #696969;">(</span>caddr variable<span style="color: #696969;">))</span>
                        <span style="color: #deb887;">"-"</span>
                        <span style="color: #696969;">(</span>number-&gt;string <span style="color: #696969;">(</span>cadr variable<span style="color: #696969;">)))</span>
         <span style="color: #696969;">(</span>symbol-&gt;string <span style="color: #696969;">(</span>cadr variable<span style="color: #696969;">))))))</span>
</pre>
</div>
<p>
换名后的变量生成的变量名加了后缀
</p>
</div>
</div>
</div>
<div id="outline-container-org3fc2280" class="outline-3">
<h3 id="org3fc2280">框架和约束</h3>
<div class="outline-text-3" id="text-org3fc2280">
<p>
框架就是以一组 <b>约束为元素的表</b> ， <span class="underline">约束</span> 用 <b>cons 序对</b> 表示：
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">make-binding</span> variable value<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>cons variable value<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">binding-variable</span> binding<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>car binding<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">binding-value</span> binding<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>cdr binding<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">binding-in-frame</span> variable frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>assoc variable frame<span style="color: #696969;">))</span>
<span style="color: #696969;">(</span><span style="color: #00bfff; font-weight: bold;">define</span> <span style="color: #696969;">(</span><span style="color: #daa520; font-weight: bold;">extend</span> variable value frame<span style="color: #696969;">)</span>
  <span style="color: #696969;">(</span>cons <span style="color: #696969;">(</span>make-binding variable value<span style="color: #696969;">)</span> frame<span style="color: #696969;">))</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga557968" class="outline-2">
<h2 id="orga557968">总结</h2>
<div class="outline-text-2" id="text-orga557968">
<p>
逻辑程序设计语言的基本想法：
</p>
<ul class="org-ul">
<li>在逻辑的层次上描述要求计算什么</li>
<li>由语言解释器实现一个计算过程，把需要的东西算出来</li>
</ul>

<pre class="example">
  一个“做什么”的描述可能蕴涵着许多“怎样做”的过程

  它可能描述了多种不同方向的计算，也可能得到许多结果（非确定性）
</pre>

<p>
这里研究的逻辑编程语言是一种 <b>查询语言</b> ，用于 <span class="underline">建立</span> 和 <span class="underline">查询</span> 断言数据库：
</p>
<ul class="org-ul">
<li><span class="underline">断言</span> 描述 <b>基本事实</b></li>
<li><span class="underline">规则</span> 描述 <b>事实之间的抽象关系</b></li>
<li>提供了一些 <b>组织查询的机制</b> （ <span class="underline">and</span> ,  <span class="underline">or</span> ,  <span class="underline">not</span> 等）</li>
</ul>

<pre class="example">
  逻辑程序设计的作为数学的逻辑之间的关系：

  两者有相似之处，但并不等价
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
