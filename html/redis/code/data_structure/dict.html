<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>字典</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./adlist.html"> UP </a>
 |
 <a accesskey="H" href="./data_structure.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">字典</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org37342e7">应用</a>
<ul>
<li><a href="#org882d841">实现数据库键空间</a></li>
<li><a href="#orgcce9538">Hash 类型键的底层实现之一</a></li>
</ul>
</li>
<li><a href="#org7cf22b1">实现</a>
<ul>
<li><a href="#orgd77c48e">哈希表实现</a></li>
<li><a href="#org52be89c">哈希算法</a></li>
</ul>
</li>
<li><a href="#org566067b">创建新字典</a></li>
<li><a href="#org060693f">添加键值对到字典</a>
<ul>
<li><a href="#orgc7e2b93">添加新元素到空白字典</a></li>
<li><a href="#org861e07e">添加新键值对时发生碰撞处理</a></li>
<li><a href="#org504a49e">添加新键值对时触发了 rehash 操作</a></li>
</ul>
</li>
<li><a href="#org19b06b6">Rehash 操作</a>
<ul>
<li><a href="#orgf591253">Rehash 过程</a>
<ul>
<li><a href="#orgdc53ffe">开始 rehash</a></li>
<li><a href="#org4532185">Rehash 进行中</a></li>
<li><a href="#orgacbb007">节点迁移完毕</a></li>
<li><a href="#org8971d6f">Rehash 完毕</a></li>
</ul>
</li>
<li><a href="#org48d154a">渐进式Rehash</a>
<ul>
<li><a href="#org5ff4e70">_dictRehashStep</a></li>
<li><a href="#orga31b8b2">dictRehashMilliseconds</a></li>
<li><a href="#orgac1ceba">其他措施</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb3376e9">字典的收缩</a></li>
<li><a href="#orga8afc2a">其他操作</a></li>
<li><a href="#org3e10825">迭代</a></li>
<li><a href="#orgb13c425">总结</a></li>
</ul>
</div>
</div>
<p>
<b>字典</b> <span class="underline">dictionary</span> ， 又名 <b>映射</b> <span class="underline">map</span> 或 <b>关联数组</b>  <span class="underline">associative array</span> ， 是一种抽象数据结构， 由一组 <b>键值对</b> <span class="underline">key-value pairs</span> 组成， 各个键值对的键各不相同， 程序可以 <span class="underline">添加</span> 新的键值对到字典中， 或者基于键进行 <span class="underline">查找</span> 、 <span class="underline">更新</span> 或 <span class="underline">删除</span> 等操作 
</p>

<pre class="example" id="orge7a917d">
接下来先对字典在 Redis 中的应用进行介绍

接着讲解字典的具体实现方式， 以及这个字典实现要解决的问题

最后， 以对字典迭代器的介绍作为结束
</pre>
<div id="outline-container-org37342e7" class="outline-2">
<h2 id="org37342e7">应用</h2>
<div class="outline-text-2" id="text-org37342e7">
<p>
字典在 Redis 中的应用广泛， 使用频率可以说和 SDS 以及双端链表不相上下， 基本上各个功能模块都有用到字典的地方。其中， 字典的主要用途有以下两个：
</p>
<ul class="org-ul">
<li>实现 <b>数据库键空间</b> <span class="underline">key space</span></li>
<li>用作 <b>Hash 类型键</b> 的底层实现之一</li>
</ul>
</div>

<div id="outline-container-org882d841" class="outline-3">
<h3 id="org882d841">实现数据库键空间</h3>
<div class="outline-text-3" id="text-org882d841">
<p>
Redis 是一个键值对数据库， 数据库中的 <span class="underline">键值对</span> 由 <b>字典</b> 保存： 每个数据库都有一个对应的字典， 这个字典被称之为 <b>键空间</b> <span class="underline">key space</span>
</p>
<ul class="org-ul">
<li>当用户添加一个键值对到数据库时（不论键值对是什么类型）， 程序就将该键值对添加到键空间</li>
<li>当用户从数据库中删除键值对时， 程序就会将这个键值对从键空间中删除</li>
</ul>

<p>
举个例子，执行 <span class="underline">FLUSHDB</span> 可以清空键空间里的所有键值对数据：
</p>

<div class="org-src-container">
<pre class="src src-sh">redis&gt; FLUSHDB
OK
</pre>
</div>

<p>
执行 <span class="underline">DBSIZE</span> 则返回键空间里现有的键值对：
</p>

<div class="org-src-container">
<pre class="src src-sh">redis&gt; DBSIZE
(integer) 0
</pre>
</div>

<pre class="example" id="org0fe99e4">
后面章节会对键空间以及数据库的实现作详细的介绍

大部分针对数据库的命令， 比如 DBSIZE 、 FLUSHDB 、 RANDOMKEY ， 等等， 都是构建于对字典的操作之上的

而那些创建、更新、删除和查找键值对的命令， 也无一例外地需要在键空间上进行操作
</pre>
</div>
</div>
<div id="outline-container-orgcce9538" class="outline-3">
<h3 id="orgcce9538">Hash 类型键的底层实现之一</h3>
<div class="outline-text-3" id="text-orgcce9538">
<p>
Redis 的 Hash 类型键使用以下两种数据结构作为底层实现:
</p>
<ul class="org-ul">
<li>字典</li>
<li><p>
压缩列表
</p>

<pre class="example" id="org8d053af">
因为压缩列表比字典更节省内存， 所以程序在创建新 Hash 键时， 默认使用压缩列表作为底层实现

当有需要时， 程序才会将底层实现从压缩列表转换到字典
</pre></li>
</ul>

<p>
当用户操作一个 Hash 键时， 键值在底层就可能是一个哈希表：
</p>

<div class="org-src-container">
<pre class="src src-sh">redis&gt; HSET book name <span style="color: #ffa07a;">"The design and implementation of Redis"</span>
(integer) 1

redis&gt; HSET book type <span style="color: #ffa07a;">"source code analysis"</span>
(integer) 1

redis&gt; HSET book release-date <span style="color: #ffa07a;">"2013.3.8"</span>
(integer) 1

redis&gt; HGETALL book
1) <span style="color: #ffa07a;">"name"</span>
2) <span style="color: #ffa07a;">"The design and implementation of Redis"</span>
3) <span style="color: #ffa07a;">"type"</span>
4) <span style="color: #ffa07a;">"source code analysis"</span>
5) <span style="color: #ffa07a;">"release-date"</span>
6) <span style="color: #ffa07a;">"2013.3.8"</span>
</pre>
</div>

<pre class="example" id="org59a976d">
以后《哈希表》章节给出了关于哈希类型键的更多信息， 并介绍了压缩列表和字典之间的转换条件
</pre>
</div>
</div>
</div>
<div id="outline-container-org7cf22b1" class="outline-2">
<h2 id="org7cf22b1">实现</h2>
<div class="outline-text-2" id="text-org7cf22b1">
<p>
实现字典的方法有很多种：
</p>
<ul class="org-ul">
<li>最简单的就是使用 <span class="underline">链表</span> 或 <span class="underline">数组</span> ，但是这种方式只适用于 <b>元素个数不多</b> 的情况下：</li>
<li>要 <b>兼顾高效和简单性</b> ，可以使用 <span class="underline">哈希表</span></li>
<li>如果追求更为稳定的性能特征，并希望 <b>高效地实现排序</b> 操作的话，则可使用更为复杂的 <span class="underline">平衡树</span></li>
</ul>

<pre class="example" id="org05f1889">
在众多可能的实现中， Redis 选择了高效、实现简单的哈希表，作为字典的底层实现
</pre>

<p>
<span class="underline">dict.h/dict</span> 给出了这个字典的定义：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;"> * &#23383;&#20856;</span>
<span style="color: #ff4500;"> *</span>
<span style="color: #ff4500;"> * &#27599;&#20010;&#23383;&#20856;&#20351;&#29992;&#20004;&#20010;&#21704;&#24076;&#34920;&#65292;&#29992;&#20110;&#23454;&#29616;&#28176;&#36827;&#24335; rehash</span>
<span style="color: #ff4500;"> */</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dict</span> {
    <span style="color: #98fb98;">dictType</span> *<span style="color: #eedd82;">type</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#29305;&#23450;&#20110;&#31867;&#22411;&#30340;&#22788;&#29702;&#20989;&#25968;</span>
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">privdata</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#31867;&#22411;&#22788;&#29702;&#20989;&#25968;&#30340;&#31169;&#26377;&#25968;&#25454;</span>
    <span style="color: #98fb98;">dictht</span> <span style="color: #eedd82;">ht</span>[2]; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21704;&#24076;&#34920;&#65288;2 &#20010;&#65289;</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rehashidx</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35760;&#24405; rehash &#36827;&#24230;&#30340;&#26631;&#24535;&#65292;&#20540;&#20026; -1 &#34920;&#31034; rehash &#26410;&#36827;&#34892;</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">iterators</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24403;&#21069;&#27491;&#22312;&#36816;&#20316;&#30340;&#23433;&#20840;&#36845;&#20195;&#22120;&#25968;&#37327;</span>
} <span style="color: #98fb98;">dict</span>;
</pre>
</div>

<p>
以下是用于处理 dict 类型的 API ， 它们的作用及相应的算法复杂度：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> dict API</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">操作</td>
<td class="org-left">函数</td>
<td class="org-left">算法复杂度</td>
</tr>

<tr>
<td class="org-left">创建一个新字典</td>
<td class="org-left">dictCreate</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">添加新键值对到字典</td>
<td class="org-left">dictAdd</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">添加或更新给定键的值</td>
<td class="org-left">dictReplace</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">在字典中查找给定键所在的节点</td>
<td class="org-left">dictFind</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">在字典中查找给定键的值</td>
<td class="org-left">dictFetchValue</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">从字典中随机返回一个节点</td>
<td class="org-left">dictGetRandomKey</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">根据给定键，删除字典中的键值对</td>
<td class="org-left">dictDelete</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">清空并释放字典</td>
<td class="org-left">dictRelease</td>
<td class="org-left">\(O\)(N)</td>
</tr>

<tr>
<td class="org-left">清空并重置（但不释放）字典</td>
<td class="org-left">dictEmpty</td>
<td class="org-left">\(O\)(N)</td>
</tr>

<tr>
<td class="org-left">缩小字典</td>
<td class="org-left">dictResize</td>
<td class="org-left">\(O\)(N)</td>
</tr>

<tr>
<td class="org-left">扩大字典</td>
<td class="org-left">dictExpand</td>
<td class="org-left">\(O\)(N)</td>
</tr>

<tr>
<td class="org-left">对字典进行给定步数的 rehash</td>
<td class="org-left">dictRehash</td>
<td class="org-left">\(O\)(N)</td>
</tr>

<tr>
<td class="org-left">在给定毫秒内，对字典进行rehash</td>
<td class="org-left">dictRehashMilliseconds</td>
<td class="org-left">\(O\)(N)</td>
</tr>
</tbody>
</table>

<p>
注意 dict 类型使用了两个指针，分别指向两个 <span class="underline">哈希表</span> 。其中：
</p>
<ul class="org-ul">
<li>0 号哈希表 <span class="underline">ht[0]</span> 是字典主要使用的哈希表</li>
<li>1 号哈希表 <span class="underline">ht[1]</span> 则只有在程序对 0 号哈希表进行 <span class="underline">rehash</span> 时才使用。</li>
</ul>

<pre class="example" id="orge95260e">
接下来两个小节将对哈希表的实现，以及哈希表所使用的哈希算法进行介绍
</pre>
</div>
<div id="outline-container-orgd77c48e" class="outline-3">
<h3 id="orgd77c48e">哈希表实现</h3>
<div class="outline-text-3" id="text-orgd77c48e">
<p>
字典所使用的哈希表实现由 <span class="underline">dict.h/dictht</span> 类型定义：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;"> * &#21704;&#24076;&#34920;</span>
<span style="color: #ff4500;"> */</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dictht</span> {
    <span style="color: #98fb98;">dictEntry</span> **<span style="color: #eedd82;">table</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21704;&#24076;&#34920;&#33410;&#28857;&#25351;&#38024;&#25968;&#32452;&#65288;&#20439;&#31216;&#26742;&#65292;bucket&#65289;</span>
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">size</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25351;&#38024;&#25968;&#32452;&#30340;&#22823;&#23567;</span>
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">sizemask</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25351;&#38024;&#25968;&#32452;&#30340;&#38271;&#24230;&#25513;&#30721;&#65292;&#29992;&#20110;&#35745;&#31639;&#32034;&#24341;&#20540;</span>
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">used</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21704;&#24076;&#34920;&#29616;&#26377;&#30340;&#33410;&#28857;&#25968;&#37327;</span>
} <span style="color: #98fb98;">dictht</span>;
</pre>
</div>

<p>
<span class="underline">table</span> 属性是个数组， 数组的每个元素都是个指向 <span class="underline">dictEntry 结构</span> 的 <b>指针</b> 。每个 dictEntry 都保存着一个 <span class="underline">键值对</span> ， 以及一个指向 <span class="underline">另一个 dictEntry 结构</span> 的 <b>指针</b> ：
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;"> * &#21704;&#24076;&#34920;&#33410;&#28857;</span>
<span style="color: #ff4500;"> */</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dictEntry</span> {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">key</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38190;</span>

    <span style="color: #00ffff;">union</span> {
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">val</span>;
        <span style="color: #98fb98;">uint64_t</span> <span style="color: #eedd82;">u64</span>;
        <span style="color: #98fb98;">int64_t</span> <span style="color: #eedd82;">s64</span>;
    } <span style="color: #eedd82;">v</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20540;</span>

    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dictEntry</span> *<span style="color: #eedd82;">next</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38142;&#24448;&#21518;&#32487;&#33410;&#28857;</span>
} <span style="color: #98fb98;">dictEntry</span>;
</pre>
</div>

<p>
next 属性指向另一个 dictEntry 结构， 多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， dictht 使用 <span class="underline">链地址法</span> 来处理键碰撞： 当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。下图展示了一个由 dictht 和数个 dictEntry 组成的哈希表例子：
</p>


<div id="org3e7eb58" class="figure">
<p><img src="../pic/graphviz-c720caba6b4d02c54fe310c148f0d56316ee80a2.svg" alt="graphviz-c720caba6b4d02c54fe310c148f0d56316ee80a2.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
如果再加上之前列出的 dict 类型，那么整个字典结构可以表示如下：
</p>


<div id="org37363a5" class="figure">
<p><img src="../pic/graphviz-6989792733a041b23cdc0b8f126434590c50a4e4.svg" alt="graphviz-6989792733a041b23cdc0b8f126434590c50a4e4.svg" class="org-svg" width="90%" />
</p>
</div>

<pre class="example" id="org400b14e">
在上图的字典示例中， 字典虽然创建了两个哈希表， 但正在使用的只有 0 号哈希表， 这说明字典未进行 rehash 状态
</pre>
</div>
</div>
<div id="outline-container-org52be89c" class="outline-3">
<h3 id="org52be89c">哈希算法</h3>
<div class="outline-text-3" id="text-org52be89c">
<p>
Redis 目前使用两种不同的哈希算法：
</p>
<ul class="org-ul">
<li><p>
<span class="underline">MurmurHash2</span> 32 bit 算法：这种算法的分布率和速度都非常好
</p>
<pre class="example" id="org08ff35e">
具体信息请参考 MurmurHash 的主页： http://code.google.com/p/smhasher/ 
</pre></li>
<li><p>
基于 <span class="underline">djb 算法</span> 实现的一个大小写无关散列算法
</p>
<pre class="example" id="org2982544">
具体信息请参考 http://www.cse.yorku.ca/~oz/hash.html 
</pre></li>
</ul>

<p>
使用哪种算法取决于具体应用所处理的数据：
</p>
<ul class="org-ul">
<li>命令表以及 Lua 脚本缓存都用到了算法 2</li>
<li>算法 1 的应用则更加广泛：数据库、集群、哈希键、阻塞操作等功能都用到了这个算法</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org566067b" class="outline-2">
<h2 id="org566067b">创建新字典</h2>
<div class="outline-text-2" id="text-org566067b">
<p>
<span class="underline">dictCreate</span> 函数创建并返回一个新字典：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">d</span> = dictCreate(&amp;hash_type, <span style="color: #7fffd4;">NULL</span>);
</pre>
</div>

<p>
d 的值可以用图片表示如下：
</p>


<div id="org9117555" class="figure">
<p><img src="../pic/graphviz-ce90f2a0f396c0ab66b48c0eb83f18fa8f4754f0.svg" alt="graphviz-ce90f2a0f396c0ab66b48c0eb83f18fa8f4754f0.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
新创建的两个哈希表都没有为 <span class="underline">table 属性</span> 分配任何空间：
</p>
<ul class="org-ul">
<li><span class="underline">ht[0]-&gt;table</span> 的空间分配将在 <b>第一次</b> 往字典 <b>添加键值对</b> 时进行</li>
<li><span class="underline">ht[1]-&gt;table</span> 的空间分配将在 <b>rehash</b> 开始时进行</li>
</ul>
</div>
</div>
<div id="outline-container-org060693f" class="outline-2">
<h2 id="org060693f">添加键值对到字典</h2>
<div class="outline-text-2" id="text-org060693f">
<p>
根据字典所处的状态， 将给定的键值对添加到字典可能会引起一系列复杂的操作：
</p>
<ul class="org-ul">
<li>如果字典为未初始化（即字典的 0 号哈希表的 table 属性为空），则程序需要对 0 号哈希表进行 <b>初始化</b></li>
<li>如果在插入时发生了键碰撞，则程序需要处理 <b>碰撞</b></li>
<li>如果插入新元素，使得字典满足了 rehash 条件，则需要启动相应的  <b>rehash</b> 程序</li>
</ul>

<p>
当程序处理完以上三种情况之后，新的键值对才会被真正地添加到字典上。整个添加流程可以用下图表示：
</p>


<div id="org21c5e41" class="figure">
<p><img src="../pic/graphviz-68f4129c529e0c49d38cfe664cad48af4412770a.svg" alt="graphviz-68f4129c529e0c49d38cfe664cad48af4412770a.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
接下来将分别看到，添加操作如何在以下三种情况中执行：
</p>
<ol class="org-ol">
<li>字典为空</li>
<li>添加新键值对时发生碰撞处理</li>
<li>添加新键值对时触发了 rehash 操作</li>
</ol>
</div>
<div id="outline-container-orgc7e2b93" class="outline-3">
<h3 id="orgc7e2b93">添加新元素到空白字典</h3>
<div class="outline-text-3" id="text-orgc7e2b93">
<p>
当第一次往空字典里添加键值对时， 程序会根据 <span class="underline">dict.h/DICT_HT_INITIAL_SIZE</span> 里指定的大小为 <span class="underline">d-&gt;ht[0]-&gt;table</span>  <b>分配空间</b>
</p>

<pre class="example" id="org47fc386">
在目前的版本中， DICT_HT_INITIAL_SIZE 的值为 4 
</pre>

<p>
以下是字典空白时的样子：
</p>


<div id="orgb22721e" class="figure">
<p><img src="../pic/graphviz-ce90f2a0f396c0ab66b48c0eb83f18fa8f4754f0.svg" alt="graphviz-ce90f2a0f396c0ab66b48c0eb83f18fa8f4754f0.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
以下是往空白字典添加了第一个键值对之后的样子：
</p>


<div id="orgd54bb1d" class="figure">
<p><img src="../pic/graphviz-5db645431193228424095abdcf1a3270c9da385e.svg" alt="graphviz-5db645431193228424095abdcf1a3270c9da385e.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>
<div id="outline-container-org861e07e" class="outline-3">
<h3 id="org861e07e">添加新键值对时发生碰撞处理</h3>
<div class="outline-text-3" id="text-org861e07e">
<p>
在哈希表实现中， 当两个不同的键拥有相同的哈希值时， 称这两个键发生 <b>碰撞</b> <span class="underline">collision</span>
</p>

<pre class="example" id="org17d11ec">
哈希表实现必须想办法对碰撞进行处理
</pre>

<p>
字典哈希表所使用的碰撞解决方法被称之为 <span class="underline">链地址法</span> ： 这种方法使用 <b>链表</b> 将多个哈希值相同的节点串连在一起， 从而解决冲突问题。假设现在有一个带有三个节点的哈希表，如下图：
</p>


<div id="org1f43075" class="figure">
<p><img src="../pic/graphviz-551247f8f670dc6b0eb2dbd6406aee607068249c.svg" alt="graphviz-551247f8f670dc6b0eb2dbd6406aee607068249c.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
对于一个新的键值对 <span class="underline">key4</span> 和 <span class="underline">value4</span> ， 如果 key4 的哈希值和 key1 的哈希值相同， 那么它们将在哈希表的 <span class="underline">0</span> 号索引上发生碰撞。通过将 <span class="underline">key4-value4</span> 和 <span class="underline">key1-value1</span> 两个键值对用链表连接起来， 就可以解决碰撞的问题：
</p>

<div id="org13299ab" class="figure">
<p><img src="../pic/graphviz-f351812afbaf4b7c29731b38d17dc4a24f902069.svg" alt="graphviz-f351812afbaf4b7c29731b38d17dc4a24f902069.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org504a49e" class="outline-3">
<h3 id="org504a49e">添加新键值对时触发了 rehash 操作</h3>
<div class="outline-text-3" id="text-org504a49e">
<p>
对于使用链地址法来解决碰撞问题的哈希表 dictht 来说， 哈希表的性能取决于 <b>大小</b>  <span class="underline">size属性</span> 与 <b>保存节点数量</b> <span class="underline">used属性</span> 之间的 <b>比率</b> ：
</p>
<ul class="org-ul">
<li>哈希表的大小与节点数量，比率在 <span class="underline">1:1</span> 时，哈希表的 <b>性能最好</b></li>
<li>如果 <b>节点数量比哈希表的大小要大很多</b> 的话，那么哈希表就会退化成 <span class="underline">多个链表</span> ，哈希表本身的性能优势便不复存在；</li>
</ul>

<p>
举个例子， 下面这个哈希表， 平均每次失败查找只需要访问 1 个节点（非空节点访问 2 次，空节点访问 1 次）：
</p>


<div id="org1875ab1" class="figure">
<p><img src="../pic/graphviz-ff857f0c77749cd0213041b561bac0a6348f78e5.svg" alt="graphviz-ff857f0c77749cd0213041b561bac0a6348f78e5.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
而下面这个哈希表， 平均每次失败查找需要访问 5 个节点：
</p>

<div id="orgd872366" class="figure">
<p><img src="../pic/graphviz-cbec5e98bba611d3021b57f5417b93538328af42.svg" alt="graphviz-cbec5e98bba611d3021b57f5417b93538328af42.svg" class="org-svg" width="90%" />
</p>
</div>

<pre class="example" id="orgec708ac">
为了在字典的键值对不断增多的情况下保持良好的性能， 字典需要对所使用的哈希表（ht[0]）进行 rehash 操作

在不修改任何键值对的情况下，对哈希表进行扩容， 尽量将比率维持在 1:1 左右
</pre>

<p>
dictAdd 在每次向字典添加新键值对之前， 都会对哈希表 ht[0] 进行检查， 对于 ht[0] 的 size 和 used 属性， 如果它们之间的比率 \(ratio = used / size\) 满足以下任何一个条件的话， <span class="underline">rehash</span> 过程就会被 <b>激活</b> ：
</p>
<ol class="org-ol">
<li>自然 rehash ：  \(ratio >= 1 ，且变量 \text{dict_can_resize} 为真\)</li>
<li><p>
强制 rehash ：  \(ratio 大于变量 \text{dict_force_resize_ratio}\)
</p>
<pre class="example" id="org57f0650">
目前版本中， dict_force_resize_ratio 的值为 5 
</pre></li>
</ol>

<pre class="example" id="orgb3452b9">
什么时候 dict_can_resize 会为假?

当 Redis 使用子进程对数据库执行后台持久化任务时（比如执行 BGSAVE 或 BGREWRITEAOF 时）

为了最大化地利用系统的 copy on write 机制， 程序会暂时将 dict_can_resize 设为假

避免执行自然 rehash ， 从而减少程序对内存的触碰。当持久化任务完成之后， dict_can_resize 会重新被设为真

另一方面， 当字典满足了强制 rehash 的条件时， 即使 dict_can_resize 不为真（有 BGSAVE 或 BGREWRITEAOF 正在执行）， 这个字典一样会被 rehash 
</pre>
</div>
</div>
</div>
<div id="outline-container-org19b06b6" class="outline-2">
<h2 id="org19b06b6">Rehash 操作</h2>
<div class="outline-text-2" id="text-org19b06b6">
<p>
字典的 rehash 操作实际上就是执行以下任务：
</p>
<ol class="org-ol">
<li><b>创建</b> 一个比 <span class="underline">ht[0]-&gt;table</span> 更大的 <span class="underline">ht[1]-&gt;table</span></li>
<li>将 <span class="underline">ht[0]-&gt;table</span> 中的所有键值对 <b>迁移</b> 到 <span class="underline">ht[1]-&gt;table</span></li>
<li>将原有 <span class="underline">ht[0]</span> 的数据 <b>清空</b> ， 并将 <span class="underline">ht[1]</span> <b>替换</b> 为新的 ht[0] ；</li>
</ol>

<p>
经过以上步骤之后， 程序就在不改变原有键值对数据的基础上， 增大了哈希表的大小
</p>
</div>

<div id="outline-container-orgf591253" class="outline-3">
<h3 id="orgf591253">Rehash 过程</h3>
<div class="outline-text-3" id="text-orgf591253">
<p>
作为例子， 以下四个小节展示了一次对哈希表进行 rehash 的完整过程 
</p>
</div>

<div id="outline-container-orgdc53ffe" class="outline-4">
<h4 id="orgdc53ffe">开始 rehash</h4>
<div class="outline-text-4" id="text-orgdc53ffe">
<p>
这个阶段有两个事情要做：
</p>
<ol class="org-ol">
<li>设置字典的 <span class="underline">rehashidx</span> 为 0 ， <b>标识着 rehash 的开始</b></li>
<li>为 <span class="underline">ht[1]-&gt;table</span>  <b>分配空间</b> ，大小至少为 <span class="underline">ht[0]-&gt;used 的两倍</span></li>
</ol>


<div id="org21200d8" class="figure">
<p><img src="../pic/graphviz-8af45a72833893e88a305ccd461561b9b00a8816.svg" alt="graphviz-8af45a72833893e88a305ccd461561b9b00a8816.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4532185" class="outline-4">
<h4 id="org4532185">Rehash 进行中</h4>
<div class="outline-text-4" id="text-org4532185">
<p>
在这个阶段， ht[0]-&gt;table 的节点会被 <b>逐渐迁移</b> 到 ht[1]-&gt;table ， 因为 rehash 是分多次进行的， 字典的 <span class="underline">rehashidx</span> 变量会 <b>记录</b> rehash 进行到 <span class="underline">ht[0] 的哪个索引位置</span> 上。以下是 rehashidx 值为 2 时，字典的样子：
</p>


<div id="org988749f" class="figure">
<p><img src="../pic/graphviz-8c861670330ef855a2e053e280506d6744e1e5d4.svg" alt="graphviz-8c861670330ef855a2e053e280506d6744e1e5d4.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
注意：除了节点的移动外， 字典的 <span class="underline">rehashidx</span>  、 <span class="underline">ht[0]-&gt;used</span> 和 <span class="underline">ht[1]-&gt;used</span> 三个属性也产生了变化
</p>
</div>
</div>

<div id="outline-container-orgacbb007" class="outline-4">
<h4 id="orgacbb007">节点迁移完毕</h4>
<div class="outline-text-4" id="text-orgacbb007">
<p>
到了这个阶段，所有的节点都已经从 ht[0] 迁移到 ht[1] 了：
</p>


<div id="orgd0fb14f" class="figure">
<p><img src="../pic/graphviz-15aedc410b921c8a0fd3183c5141b7d1f1ed6eed.svg" alt="graphviz-15aedc410b921c8a0fd3183c5141b7d1f1ed6eed.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org8971d6f" class="outline-4">
<h4 id="org8971d6f">Rehash 完毕</h4>
<div class="outline-text-4" id="text-org8971d6f">
<p>
在 rehash 的最后阶段，程序会执行以下工作：
</p>
<ol class="org-ol">
<li><b>释放</b>  <span class="underline">ht[0]</span> 的空间</li>
<li>用 <span class="underline">ht[1]</span> 来 <b>代替</b> ht[0] ，使原来的 ht[1] 成为新的 ht[0]</li>
<li><b>创建</b> 一个新的空哈希表，并将它 <b>设置</b> 为 <span class="underline">ht[1]</span></li>
<li>将字典的 <span class="underline">rehashidx</span> 属性 <b>设置</b> 为  <span class="underline">-1</span> ，标识 <b>rehash 已停止</b></li>
</ol>

<p>
以下是字典 rehash 完毕之后的样子： 
</p>

<div id="org03511fb" class="figure">
<p><img src="../pic/graphviz-6d5b0f4115d30fac37af21f3834b5554d8824923.svg" alt="graphviz-6d5b0f4115d30fac37af21f3834b5554d8824923.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
对比字典 rehash 前后， 新的 ht[0] 空间更大， 并且字典原有的键值对也没有被修改或者删除
</p>
</div>
</div>
</div>

<div id="outline-container-org48d154a" class="outline-3">
<h3 id="org48d154a">渐进式Rehash</h3>
<div class="outline-text-3" id="text-org48d154a">
<pre class="example" id="orgefb60ab">
rehash 程序并不是在激活之后，就马上执行直到完成的， 而是分多次、渐进式地完成的

假设这样一个场景：在一个有很多键值对的字典里， 某个用户在添加新键值对时触发了 rehash 过程，

如果这个 rehash 过程必须将所有键值对迁移完毕之后才将结果返回给用户， 这样的处理方式将是非常不友好的

另一方面， 要求服务器必须阻塞直到 rehash 完成， 这对于 Redis 服务器本身也是不能接受的
</pre>

<p>
为了解决这个问题， Redis 使用了 <b>渐进式</b> <span class="underline">incremental</span> 的 rehash 方式： 通过将 rehash 分散到多个步骤中进行， 从而避免了集中式的计算。渐进式 rehash 主要由 <span class="underline">_dictRehashStep</span> 和 <span class="underline">dictRehashMilliseconds</span> 两个函数进行：
</p>
<ul class="org-ul">
<li>__dictRehashStep_ 用于对 <span class="underline">数据库字典</span> 、以及 <span class="underline">哈希键的字典</span> 进行 <b>被动 rehash</b></li>
<li><span class="underline">dictRehashMilliseconds</span> 则由  <b>Redis 服务器常规任务程序</b> <span class="underline">server cron job</span> 执行，用于对 <span class="underline">数据库字典</span> 进行 <b>主动 rehash</b></li>
</ul>
</div>

<div id="outline-container-org5ff4e70" class="outline-4">
<h4 id="org5ff4e70">_dictRehashStep</h4>
<div class="outline-text-4" id="text-org5ff4e70">
<p>
每次执行  <span class="underline">_dictRehashStep</span> ，  <span class="underline">_ht[0]-&gt;table</span> 哈希表 <span class="underline">第一个不为空的索引</span> 上的 <span class="underline">所有节点</span> 就会 <b>全部迁移</b> 到 <span class="underline">ht[1]-&gt;table</span> 。在 rehash 开始进行之后 <span class="underline">rehashidx 不为 -1</span> ， 每次执行一次 <span class="underline">添加</span> 、 <span class="underline">查找</span> 、 <span class="underline">删除</span> 操作，  <b>_dictRehashStep 都会被执行一次</b> ：
</p>


<div id="orga9465ea" class="figure">
<p><img src="../pic/graphviz-121adbc9859ad43720ccb8d4d91bf28062af3256.svg" alt="graphviz-121adbc9859ad43720ccb8d4d91bf28062af3256.svg" class="org-svg" width="90%" />
</p>
</div>

<pre class="example" id="org6decec8">
因为字典会保持哈希表大小和节点数的比率在一个很小的范围内， 所以每个索引上的节点数量不会很多

从目前版本的 rehash 条件来看，平均只有一个，最多通常也不会超过五个

所以在执行操作的同时，对单个索引上的节点进行迁移， 几乎不会对响应时间造成影响
</pre>
</div>
</div>

<div id="outline-container-orga31b8b2" class="outline-4">
<h4 id="orga31b8b2">dictRehashMilliseconds</h4>
<div class="outline-text-4" id="text-orga31b8b2">
<p>
dictRehashMilliseconds 可以在指定的毫秒数内， 对字典进行 rehash
</p>
<pre class="example" id="org5c17a4a">
当 Redis 的服务器常规任务执行时， dictRehashMilliseconds 会被执行

在规定的时间内， 尽可能地对数据库字典中那些需要 rehash 的字典进行 rehash ， 从而加速数据库字典的 rehash 进程（progress）
</pre>
</div>
</div>

<div id="outline-container-orgac1ceba" class="outline-4">
<h4 id="orgac1ceba">其他措施</h4>
<div class="outline-text-4" id="text-orgac1ceba">
<p>
在哈希表进行 rehash 时， 字典还会采取一些特别的措施， 确保 rehash 顺利、正确地进行：
</p>
<ul class="org-ul">
<li>因为在 rehash 时，字典会同时使用两个哈希表，所以在这期间的所有 <span class="underline">查找</span> 、 <span class="underline">删除</span> 等操作，除了在 ht[0] 上进行，还需要在 <span class="underline">ht[1]</span> 上进行</li>
<li>在执行添加操作时，新的节点会 <b>直接添加</b> 到 <span class="underline">ht[1]</span> 而不是 ht[0] ，这样保证 ht[0] 的节点数量在整个 rehash 过程中都只减不增</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb3376e9" class="outline-2">
<h2 id="orgb3376e9">字典的收缩</h2>
<div class="outline-text-2" id="text-orgb3376e9">
<pre class="example" id="org7772cda">
上面描述了通过 rehash 对字典进行扩展（expand）的情况，

如果哈希表的可用节点数比已用节点数大很多的话， 那么也可以通过对哈希表进行 rehash 来收缩（shrink）字典
</pre>

<p>
收缩 rehash 和上面展示的扩展 rehash 的操作几乎一样，执行以下步骤：
</p>
<ol class="org-ol">
<li>创建一个比 ht[0]-&gt;table 小的 ht[1]-&gt;table</li>
<li>将 ht[0]-&gt;table 中的所有键值对迁移到 ht[1]-&gt;table</li>
<li>将原有 ht[0] 的数据清空，并将 ht[1] 替换为新的 ht[0]</li>
</ol>

<p>
扩展 rehash 和收缩 rehash 执行完全相同的过程， 一个 rehash 是扩展还是收缩字典， 关键在于新分配的 <span class="underline">ht[1]-&gt;table 的大小</span> ：
</p>
<ul class="org-ul">
<li>如果 rehash 是 <span class="underline">扩展</span> 操作，那么 ht[1]-&gt;table 比 ht[0]-&gt;table 要 <span class="underline">大</span></li>
<li>如果 rehash 是 <span class="underline">收缩</span> 操作，那么 ht[1]-&gt;table 比 ht[0]-&gt;table 要 <span class="underline">小</span></li>
</ul>

<p>
字典的收缩规则由 <span class="underline">redis.c/htNeedsResize</span> 函数定义：
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;"> * &#26816;&#26597;&#23383;&#20856;&#30340;&#20351;&#29992;&#29575;&#26159;&#21542;&#20302;&#20110;&#31995;&#32479;&#20801;&#35768;&#30340;&#26368;&#23567;&#27604;&#29575;</span>
<span style="color: #ff4500;"> *</span>
<span style="color: #ff4500;"> * &#26159;&#30340;&#35805;&#36820;&#22238; 1 &#65292;&#21542;&#21017;&#36820;&#22238; 0 &#12290;</span>
<span style="color: #ff4500;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">htNeedsResize</span>(<span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">dict</span>) {
    <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">size</span>, <span style="color: #eedd82;">used</span>;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21704;&#24076;&#34920;&#22823;&#23567;</span>
    size = dictSlots(dict);

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21704;&#24076;&#34920;&#24050;&#29992;&#33410;&#28857;&#25968;&#37327;</span>
    used = dictSize(dict);

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24403;&#21704;&#24076;&#34920;&#30340;&#22823;&#23567;&#22823;&#20110; DICT_HT_INITIAL_SIZE</span>
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24182;&#19988;&#23383;&#20856;&#30340;&#22635;&#20805;&#29575;&#20302;&#20110; REDIS_HT_MINFILL &#26102;</span>
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#36820;&#22238; 1</span>
    <span style="color: #00ffff;">return</span> (size &amp;&amp; used &amp;&amp; size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;
        (used*100/size &lt; REDIS_HT_MINFILL));
}
</pre>
</div>
<p>
在默认情况下， <span class="underline">REDIS_HT_MINFILL</span> 的值为 10 ， 也即是说， 当字典的 <b>填充率低于 10%</b> 时， 程序就可以对这个字典进行 <span class="underline">收缩</span> 操作了
</p>

<p>
字典收缩和字典扩展的一个区别是：
</p>
<ul class="org-ul">
<li>字典的扩展操作是 <span class="underline">自动</span> 触发的（不管是自动扩展还是强制扩展）</li>
<li>而字典的收缩操作则是由程序 <span class="underline">手动</span> 执行</li>
</ul>

<p>
因此， 使用字典的程序可以决定何时对字典进行收缩：
</p>
<ul class="org-ul">
<li>当字典用于实现哈希键的时候， 每次从字典中 <b>删除</b> 一个键值对， 程序就会执行一次 htNeedsResize 函数， 如果字典达到了收缩的标准， 程序将立即对字典进行收缩</li>
<li>当字典用于实现数据库键空间 <span class="underline">key space</span> 的时候， 收缩的时机由 <span class="underline">redis.c/tryResizeHashTables</span> 函数决定</li>
</ul>
</div>
</div>

<div id="outline-container-orga8afc2a" class="outline-2">
<h2 id="orga8afc2a">其他操作</h2>
<div class="outline-text-2" id="text-orga8afc2a">
<p>
除了 <span class="underline">添加</span> 操作和 <span class="underline">伸展/收缩</span> 操作之外， 字典还定义了一些其他操作， 比如常见的查找、删除和更新。
</p>

<pre class="example" id="orgef4e4e9">
因为链地址法哈希表实现的相关信息可以从任何一本数据结构或算法书上找到， 这里不再对字典的其他操作进行介绍

不过前面对创建字典、添加键值对、收缩和扩展 rehash 的讨论已经涵盖了字典模块的核心内容
</pre>
</div>
</div>

<div id="outline-container-org3e10825" class="outline-2">
<h2 id="org3e10825">迭代</h2>
<div class="outline-text-2" id="text-org3e10825">
<p>
字典带有自己的 <span class="underline">迭代器</span> 实现。对字典进行迭代实际上就是对字典所使用的哈希表进行迭代：
</p>
<ul class="org-ul">
<li>迭代器首先迭代字典的第一个哈希表，然后，如果 rehash 正在进行的话，就继续对第二个哈希表进行迭代
<ul class="org-ul">
<li>当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点</li>
<li>当这个索引迭代完了，继续查找下一个不为空的索引，如此反覆，直到整个哈希表都迭代完为止</li>
</ul></li>
</ul>

<p>
整个迭代过程可以用伪代码表示如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">iter_dict</span>(<span style="color: #b0c4de;">dict</span>):
    iter_table(ht[0]-&gt;table) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36845;&#20195; 0 &#21495;&#21704;&#24076;&#34920;</span>
    <span style="color: #00ffff;">if</span> <span style="color: #b0c4de;">dict</span>.is_rehashing(): iter_table(ht[1]-&gt;table) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#22914;&#26524;&#27491;&#22312;&#25191;&#34892; rehash &#65292;&#37027;&#20040;&#20063;&#36845;&#20195; 1 &#21495;&#21704;&#24076;&#34920;</span>


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">iter_table</span>(table):
    <span style="color: #00ffff;">for</span> index <span style="color: #00ffff;">in</span> table: <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36941;&#21382;&#21704;&#24076;&#34920;&#19978;&#30340;&#25152;&#26377;&#32034;&#24341;</span>
        <span style="color: #00ffff;">if</span> table[index].empty(): <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36339;&#36807;&#31354;&#32034;&#24341;</span>
            <span style="color: #00ffff;">continue</span>
        <span style="color: #00ffff;">for</span> node <span style="color: #00ffff;">in</span> table[index]: <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36941;&#21382;&#32034;&#24341;&#19978;&#30340;&#25152;&#26377;&#33410;&#28857;</span>
            do_something_with(node) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#22788;&#29702;&#33410;&#28857;</span>
</pre>
</div>

<p>
字典的迭代器有两种：
</p>
<ol class="org-ol">
<li>安全迭代器：在迭代进行过程中，可以对字典进行修改</li>
<li>不安全迭代器：在迭代进行过程中，不对字典进行修改</li>
</ol>

<p>
以下是迭代器的数据结构定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;"> * &#23383;&#20856;&#36845;&#20195;&#22120;</span>
<span style="color: #ff4500;"> */</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dictIterator</span> {
    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">d</span>;                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27491;&#22312;&#36845;&#20195;&#30340;&#23383;&#20856;</span>

    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">table</span>,              <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27491;&#22312;&#36845;&#20195;&#30340;&#21704;&#24076;&#34920;&#30340;&#21495;&#30721;&#65288;0 &#25110;&#32773; 1&#65289;</span>
        <span style="color: #eedd82;">index</span>,              <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27491;&#22312;&#36845;&#20195;&#30340;&#21704;&#24076;&#34920;&#25968;&#32452;&#30340;&#32034;&#24341;</span>
        <span style="color: #eedd82;">safe</span>;               <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#26159;&#21542;&#23433;&#20840;&#65311;</span>

    <span style="color: #98fb98;">dictEntry</span> *<span style="color: #eedd82;">entry</span>,       <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24403;&#21069;&#21704;&#24076;&#33410;&#28857;</span>
        *<span style="color: #eedd82;">nextEntry</span>;   <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24403;&#21069;&#21704;&#24076;&#33410;&#28857;&#30340;&#21518;&#32487;&#33410;&#28857;</span>

} <span style="color: #98fb98;">dictIterator</span>;
</pre>
</div>

<p>
以下函数是这个迭代器的 API ，API 的作用及相关算法复杂度：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> dict iterator</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">操作</td>
<td class="org-left">函数</td>
<td class="org-left">算法复杂度</td>
</tr>

<tr>
<td class="org-left">创建一个不安全迭代器</td>
<td class="org-left">dictGetIterator</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">创建一个安全迭代器</td>
<td class="org-left">dictGetSafeIterator</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">返回迭代器指向的当前节点，如果迭代完毕，返回 NULL</td>
<td class="org-left">dictNext</td>
<td class="org-left">\(O\)(1)</td>
</tr>

<tr>
<td class="org-left">释放迭代器</td>
<td class="org-left">dictReleaseIterator</td>
<td class="org-left">\(O\)(1)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb13c425" class="outline-2">
<h2 id="orgb13c425">总结</h2>
<div class="outline-text-2" id="text-orgb13c425">
<ul class="org-ul">
<li>字典是由键值对构成的抽象数据结构</li>
<li>Redis 中的数据库和哈希键都基于字典来实现</li>
<li>Redis 字典的底层实现为哈希表，每个字典使用两个哈希表，一般情况下只使用 0 号哈希表，只有在 rehash 进行时，才会同时使用 0 号和 1 号哈希表</li>
<li>哈希表使用链地址法来解决键冲突的问题</li>
<li>Rehash 可以用于扩展或收缩哈希表</li>
<li><p>
对哈希表的 rehash 是分多次、渐进式地进行的
</p></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="skiplist.html">Next：跳跃表</a></td>
<td class="org-left"><a href="adlist.html">Previous：双端列表</a></td>
<td class="org-left"><a href="data_structure.html">Home: 内部数据结构</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
