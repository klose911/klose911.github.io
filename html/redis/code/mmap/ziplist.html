<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>压缩列表</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./intset.html"> UP </a>
 |
 <a accesskey="H" href="./mmap.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">压缩列表</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga4accca">构成</a>
<ul>
<li><a href="#org7f0bfbe">节点</a>
<ul>
<li><a href="#org5098c6f">pre_entry_length</a></li>
<li><a href="#orgd1a977f">encoding 和 length</a></li>
<li><a href="#orga7d5a1d">content</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org298b254">创建</a></li>
<li><a href="#org168981c">添加</a>
<ul>
<li><a href="#org3b8da6c">将节点添加到末端</a></li>
<li><a href="#org973a638">将节点添加到某个/某些节点的前面</a></li>
</ul>
</li>
<li><a href="#org9da0d10">删除</a></li>
<li><a href="#orgf1777a9">遍历</a></li>
<li><a href="#org6d90329">查找</a></li>
<li><a href="#org7309a75">总结</a></li>
</ul>
</div>
</div>
<p>
<span class="underline">ziplist</span> 是由一系列特殊编码的内存块构成的列表， 一个 ziplist 可以包含多个 <b>节点</b> <span class="underline">entry</span> ， 每个节点可以保存一个 <span class="underline">长度受限的字符数组</span> （ <b>不以 \0 结尾</b> 的 char 数组）或者 <span class="underline">整数</span> ， 包括：
</p>
<ul class="org-ul">
<li>字符数组
<ul class="org-ul">
<li>长度小于等于 63  \((2^{6} - 1)\) 字节的字符数组</li>
<li>长度小于等于 16383 \((2^{14} - 1)\) 字节的字符数组</li>
<li>长度小于等于 4294967295 \((2^{32} - 1)\) 字节的字符数组</li>
</ul></li>
<li>整数
<ul class="org-ul">
<li>4 位长，介于 0 至 12 之间的无符号整数</li>
<li>1 字节长，有符号整数</li>
<li>3 字节长，有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul></li>
</ul>

<p>
因为 ziplist <b>节约内存</b> 的性质， 哈希键、列表键和有序集合键初始化的底层实现皆采用 ziplist
</p>

<pre class="example" id="org4407a23">
更多信息请参考《哈希表》、《列表》和《有序集》

接下来先介绍 ziplist 的组成结构， 以及 ziplist 节点的编码方式

再介绍 ziplist 的添加操作和删除操作的执行过程， 以及这两种操作可能引起的连锁更新现象

最后介绍 ziplist 的遍历方法和节点查找方式
</pre>
<div id="outline-container-orga4accca" class="outline-2">
<h2 id="orga4accca">构成</h2>
<div class="outline-text-2" id="text-orga4accca">
<p>
下图展示了一个 ziplist 的典型分布结构：
</p>

<pre class="example" id="org6f193b0">
area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
	    +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
	    +---------+--------+-------+--------+--------+--------+--------+-------+
				       ^                          ^        ^
address                                |                          |        |
				ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
								  |
							 ZIPLIST_ENTRY_TAIL
</pre>

<p>
各个域的作用如下：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> fields of ziplist</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">域</td>
<td class="org-left">长度/类型</td>
<td class="org-left">域的值</td>
</tr>

<tr>
<td class="org-left">zlbytes</td>
<td class="org-left">uint32_t</td>
<td class="org-left">整个 ziplist 占用的内存字节数，对 ziplist 进行内存重分配，或者计算末端时使用</td>
</tr>

<tr>
<td class="org-left">zltail</td>
<td class="org-left">uint32_t</td>
<td class="org-left">到达 ziplist 表尾节点的偏移量。 通过这个偏移量，可以在不遍历整个 ziplist 的前提下，弹出表尾节点</td>
</tr>

<tr>
<td class="org-left">zllen</td>
<td class="org-left">uint16_t</td>
<td class="org-left">ziplist 中节点的数量。 当这个值小于 UINT16_MAX （65535）时，这个值就是 ziplist 中节点的数量； 当这个值等于 UINT16_MAX 时，节点的数量需要遍历整个 ziplist 才能计算得出。</td>
</tr>

<tr>
<td class="org-left">entryX</td>
<td class="org-left">?     ziplist</td>
<td class="org-left">所保存的节点，各个节点的长度根据内容而定</td>
</tr>

<tr>
<td class="org-left">zlend</td>
<td class="org-left">uint8_t</td>
<td class="org-left">255 的二进制值 1111 1111 （UINT8_MAX） ，用于标记 ziplist 的末端</td>
</tr>
</tbody>
</table>

<p>
为了方便地取出 ziplist 的各个域以及一些指针地址， ziplist 模块定义了以下宏：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> macro of ziplist</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">宏</td>
<td class="org-left">作用</td>
<td class="org-left">算法复杂度</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_BYTES(ziplist)</td>
<td class="org-left">取出 zlbytes 的值</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_TAIL_OFFSET(ziplist)</td>
<td class="org-left">取出 zltail 的值</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_LENGTH(ziplist)</td>
<td class="org-left">取出 zllen 的值</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_HEADER_SIZE</td>
<td class="org-left">返回 ziplist header 部分的长度，总是固定的 10 字节</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_ENTRY_HEAD(ziplist)</td>
<td class="org-left">返回到达 ziplist 第一个节点（表头）的地址</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_ENTRY_TAIL(ziplist)</td>
<td class="org-left">返回到达 ziplist 最后一个节点（表尾）的地址</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ZIPLIST_ENTRY_END(ziplist)</td>
<td class="org-left">返回 ziplist 的末端，也即是 zlend 之前的地址</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>ziplist header 部分的长度总是固定的（4 字节 + 4 字节 + 2 字节）， 因此将指针移动到表头节点的复杂度为常数时间</li>
<li>表尾节点的地址可以通过 zltail 计算得出， 因此将指针移动到表尾节点的复杂度也为常数时间</li>
</ul>

<p>
以下是用于操作 ziplist 的函数：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> function of ziplist</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数名</td>
<td class="org-left">作用</td>
<td class="org-left">算法复杂度</td>
</tr>

<tr>
<td class="org-left">ziplistNew</td>
<td class="org-left">创建一个新的 ziplist</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ziplistResize</td>
<td class="org-left">重新调整 ziplist 的内存大小</td>
<td class="org-left">\(\theta(N)\)</td>
</tr>

<tr>
<td class="org-left">ziplistPush</td>
<td class="org-left">将一个包含给定值的新节点推入 ziplist 的表头或者表尾</td>
<td class="org-left">\(\theta(N^{2})\)</td>
</tr>

<tr>
<td class="org-left">zipEntry</td>
<td class="org-left">取出给定地址上的节点，并将它的属性保存到 zlentry 结构然后返回</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>

<tr>
<td class="org-left">ziplistInsert</td>
<td class="org-left">将一个包含给定值的新节点插入到给定地址</td>
<td class="org-left">\(\theta(N^{2})\)</td>
</tr>

<tr>
<td class="org-left">ziplistDelete</td>
<td class="org-left">删除给定地址上的节点</td>
<td class="org-left">\(\theta(N^{2})\)</td>
</tr>

<tr>
<td class="org-left">ziplistDeleteRange</td>
<td class="org-left">在给定索引上，连续进行多次删除</td>
<td class="org-left">\(\theta(N^{2})\)</td>
</tr>

<tr>
<td class="org-left">ziplistFind</td>
<td class="org-left">在 ziplist 中查找并返回包含给定值的节点</td>
<td class="org-left">\(\theta(N)\)</td>
</tr>

<tr>
<td class="org-left">ziplistLen</td>
<td class="org-left">返回 ziplist 保存的节点数量</td>
<td class="org-left">\(\theta(N)\)</td>
</tr>

<tr>
<td class="org-left">ziplistBlobLen</td>
<td class="org-left">以字节为单位，返回 ziplist 占用的内存大小</td>
<td class="org-left">\(\theta(1)\)</td>
</tr>
</tbody>
</table>

<p>
因为 ziplist 由连续的内存块构成， 在最坏情况下， 当 <span class="underline">ziplistPush</span> 、  <span class="underline">ziplistDelete</span> 这类对节点进行增加或删除的函数之后， 程序需要执行一种称为 <b>连锁更新</b> 的动作来维持 ziplist 结构本身的性质， 所以这些函数的最坏复杂度都为 \(\theta(N^{2})\)
</p>

<pre class="example" id="org3cb0404">
因为这种最坏情况出现的概率并不高， 所以大可以放心使用 ziplist ， 而不必太担心出现最坏情况
</pre>
</div>
<div id="outline-container-org7f0bfbe" class="outline-3">
<h3 id="org7f0bfbe">节点</h3>
<div class="outline-text-3" id="text-org7f0bfbe">
<p>
一个 ziplist 可以包含多个节点，每个节点可以划分为以下几个部分：
</p>

<pre class="example" id="orgade4558">
area        |&lt;------------------- entry --------------------&gt;|

	    +------------------+----------+--------+---------+
component   | pre_entry_length | encoding | length | content |
	    +------------------+----------+--------+---------+
</pre>

<p>
以下几个小节将分别对这个四个部分进行介绍
</p>
</div>
<div id="outline-container-org5098c6f" class="outline-4">
<h4 id="org5098c6f">pre_entry_length</h4>
<div class="outline-text-4" id="text-org5098c6f">
<p>
<span class="underline">pre_entry_length</span> 记录了 <b>前一个节点的长度</b> ，通过这个值，可以进行指针计算，从而跳转到上一个节点。
</p>

<pre class="example" id="orgeb6dcb6">
area        |&lt;---- previous entry ---&gt;|&lt;--------------- current entry ----------------&gt;|

size          5 bytes                   1 byte             ?          ?        ?
	    +-------------------------+-----------------------------+--------+---------+
component   | ...                     | pre_entry_length | encoding | length | content |
	    |                         |                  |          |        |         |
value       |                         | 0000 0101        |    ?     |   ?    |    ?    |
	    +-------------------------+-----------------------------+--------+---------+
	    ^                         ^
address     |                         |
	    p = e - 5                 e

上图展示了如何通过一个节点向前跳转到另一个节点

用指向当前节点的指针 e ， 减去 pre_entry_length 的值（0000 0101 的十进制值， 5）

得出的结果就是指向前一个节点的地址 p 
</pre>

<p>
根据编码方式的不同， pre_entry_length 域可能占用  <span class="underline">1 字节</span> 或者 <span class="underline">5 字节</span> ：
</p>
<ul class="org-ul">
<li>1 字节：如果前一节点的长度小于 254 字节，便使用一个字节保存它的值</li>
<li>5 字节：如果前一节点的长度大于等于 254 字节，那么将第 1 个字节的值设为 <span class="underline">254</span> ，然后用接下来的 4 个字节保存实际长度</li>
</ul>

<p>
作为例子， 以下是个长度为 1 字节的 pre_entry_length 域， 域的值为 128 （二进制为 1000 0000 ）
</p>

<pre class="example" id="org2f0ddb9">
area        |&lt;------------------- entry --------------------&gt;|

size          1 byte             ?          ?        ?
	    +------------------+----------+--------+---------+
component   | pre_entry_length | encoding | length | content |
	    |                  |          |        |         |
value       | 1000 0000        |          |        |         |
	    +------------------+----------+--------+---------+
</pre>

<p>
而以下则是个长度为 5 字节的 pre_entry_length 域， 域的第一个字节被设为 254 的二进制 <span class="underline">1111 1110</span> ， 而之后的四个字节则被设置为 10086 的二进制 <span class="underline">10 0111 0110 0110</span> （多余的高位用 0 补完）：
</p>

<pre class="example" id="org3629c91">
area        |&lt;------------------------------ entry ----------------------------------&gt;|

size          5 bytes                                     ?          ?        ?
	    +-------------------------------------------+----------+--------+---------+
component   | pre_entry_length                          | encoding | length | content |
	    |                                           |          |        |         |
	    | 11111110 00000000000000000010011101100110 | ?        | ?      | ?       |
	    +-------------------------------------------+----------+--------+---------+
	    |&lt;-------&gt;|&lt;-------------------------------&gt;|
	      1 byte       4 bytes
</pre>
</div>
</div>
<div id="outline-container-orgd1a977f" class="outline-4">
<h4 id="orgd1a977f">encoding 和 length</h4>
<div class="outline-text-4" id="text-orgd1a977f">
<p>
encoding 和 length 两部分一起决定了 content 部分所保存的数据的类型（以及长度）。其中，  <span class="underline">encoding</span> 域的长度为两个 bit ， 它的值可以是 00 、 01 、 10 和 11 ：
</p>
<ul class="org-ul">
<li>00, 01 和 10 表示 content 部分保存着 <b>字符</b> 数组</li>
<li>11 表示 content 部分保存着 <b>整数</b></li>
</ul>

<p>
以 00 、 01 和 10 开头的字符数组的编码方式如下：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> encoding and length field for node of char array</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">编码</td>
<td class="org-left">编码长度</td>
<td class="org-left">content 部分保存的值</td>
</tr>

<tr>
<td class="org-left">00bbbbbb</td>
<td class="org-left">1 byte</td>
<td class="org-left">长度小于等于 63 字节的字符数组</td>
</tr>

<tr>
<td class="org-left">01bbbbbb xxxxxxxx</td>
<td class="org-left">2 byte</td>
<td class="org-left">长度小于等于 16383 字节的字符数组</td>
</tr>

<tr>
<td class="org-left">10____ aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td class="org-left">5 byte</td>
<td class="org-left">长度小于等于 4294967295 的字符数组</td>
</tr>
</tbody>
</table>

<pre class="example" id="orgfa04490">
表格中的下划线 _ 表示留空，变量 b 、 x 等则代表实际的二进制数据

为了方便阅读，多个字节之间用空格隔开
</pre>

<p>
11 开头的整数编码如下：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> encoding and length field for node of integer</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">编码</td>
<td class="org-left">编码长度</td>
<td class="org-left">content 部分保存的值</td>
</tr>

<tr>
<td class="org-right">11000000</td>
<td class="org-left">1 byte</td>
<td class="org-left">int16_t 类型的整数</td>
</tr>

<tr>
<td class="org-right">11010000</td>
<td class="org-left">1 byte</td>
<td class="org-left">int32_t 类型的整数</td>
</tr>

<tr>
<td class="org-right">11100000</td>
<td class="org-left">1 byte</td>
<td class="org-left">int64_t 类型的整数</td>
</tr>

<tr>
<td class="org-right">11110000</td>
<td class="org-left">1 byte</td>
<td class="org-left">24 bit 有符号整数</td>
</tr>

<tr>
<td class="org-right">11111110</td>
<td class="org-left">1 byte</td>
<td class="org-left">8 bit 有符号整数</td>
</tr>

<tr>
<td class="org-right">1111xxxx</td>
<td class="org-left">1 byte</td>
<td class="org-left">4 bit 无符号整数，介于 0 至 12 之间</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orga7d5a1d" class="outline-4">
<h4 id="orga7d5a1d">content</h4>
<div class="outline-text-4" id="text-orga7d5a1d">
<p>
content 部分保存着节点的内容，类型和长度由 encoding 和 length 决定。以下是一个保存着字符数组 hello world 的节点的例子：
</p>

<pre class="example" id="org587c715">
area      |&lt;---------------------- entry -----------------------&gt;|

size        ?                  2 bit      6 bit    11 byte
	  +------------------+----------+--------+---------------+
component | pre_entry_length | encoding | length | content       |
	  |                  |          |        |               |
value     | ?                |    00    | 001011 | hello world   |
	  +------------------+----------+--------+---------------+
</pre>

<ul class="org-ul">
<li>encoding 域的值 00 表示节点保存着一个长度小于等于 63 字节的字符数组</li>
<li>length 域给出了这个字符数组的准确长度 11 字节（的二进制 001011）</li>
<li>content 则保存着字符数组值 hello world 本身（为了方便表示， content 部分使用字符而不是二进制表示）</li>
</ul>

<p>
以下是另一个节点，它保存着整数 10086 ：
</p>
<pre class="example" id="org5ebe479">
area      |&lt;---------------------- entry -----------------------&gt;|

size        ?                  2 bit      6 bit    2 bytes
	  +------------------+----------+--------+---------------+
component | pre_entry_length | encoding | length | content       |
	  |                  |          |        |               |
value     | ?                |    11    | 000000 | 10086         |
	  +------------------+----------+--------+---------------+
</pre>
<ul class="org-ul">
<li>encoding 域的值 11 表示节点保存的是一个整数</li>
<li>而 length 域的值 000000 表示这个节点的值的类型为 int16_t</li>
<li>最后， content 保存着整数值 10086 本身（为了方便表示， content 部分用十进制而不是二进制表示）</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org298b254" class="outline-2">
<h2 id="org298b254">创建</h2>
<div class="outline-text-2" id="text-org298b254">
<p>
函数 <span class="underline">ziplistNew</span> 用于创建一个新的空白 ziplist ，这个 ziplist 可以表示为下图：
</p>

<pre class="example" id="org791a187">
area        |&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|

size          4 bytes   4 bytes 2 bytes  1 byte
	    +---------+--------+-------+-----------+
component   | zlbytes | zltail | zllen | zlend     |
	    |         |        |       |           |
value       |  1011   |  1010  |   0   | 1111 1111 |
	    +---------+--------+-------+-----------+
				       ^
				       |
			       ZIPLIST_ENTRY_HEAD
				       &amp;
address                        ZIPLIST_ENTRY_TAIL
				       &amp;
			       ZIPLIST_ENTRY_END
</pre>

<p>
空白 ziplist 的表头、表尾和末端处于同一地址。创建了 ziplist 之后， 就可以往里面添加新节点了， 根据新节点添加位置的不同， 这个工作可以分为两类来进行：
</p>
<ul class="org-ul">
<li>将节点添加到 ziplist 末端：在这种情况下，新节点的后面没有任何节点</li>
<li>将节点添加到某个/某些节点的前面：在这种情况下，新节点的后面有至少一个节点</li>
</ul>

<p>
以下分别讨论这两种情况
</p>
</div>
</div>
<div id="outline-container-org168981c" class="outline-2">
<h2 id="org168981c">添加</h2>
<div class="outline-text-2" id="text-org168981c">
</div>
<div id="outline-container-org3b8da6c" class="outline-3">
<h3 id="org3b8da6c">将节点添加到末端</h3>
<div class="outline-text-3" id="text-org3b8da6c">
<p>
将新节点添加到 ziplist 的末端需要执行以下步骤：
</p>
<ol class="org-ol">
<li>记录到达 ziplist 末端所需的偏移量（因为之后的内存重分配可能会改变 ziplist 的地址，因此记录偏移量而不是保存指针）</li>
<li>根据新节点要保存的值，计算出编码这个值所需的空间大小，以及编码它前一个节点的长度所需的空间大小，然后对 ziplist 进行内存重分配</li>
<li>设置新节点的各项属性： pre_entry_length 、 encoding 、 length 和 content</li>
<li>更新 ziplist 的各项属性，比如记录空间占用的 zlbytes ，到达表尾节点的偏移量 zltail ，以及记录节点数量的 zllen 。</li>
</ol>

<p>
举个例子，假设现在要将一个新节点添加到只含有一个节点的 ziplist 上，程序首先要执行步骤 1 ，定位 ziplist 的末端：
</p>

<pre class="example" id="org1bdcddb">
area        |&lt;---- ziplist header ----&gt;|&lt;--- entries --&gt;|&lt;-- end --&gt;|

size          4 bytes  4 bytes  2 bytes  5 bytes          1 bytes
	    +---------+--------+-------+----------------+-----------+
component   | zlbytes | zltail | zllen | entry 1        | zlend     |
	    |         |        |       |                |           |
value       |  10000  |  1010  |   1   | ?              | 1111 1111 |
	    +---------+--------+-------+----------------+-----------+
				       ^                ^
				       |                |
address                         ZIPLIST_ENTRY_HEAD   ZIPLIST_ENTRY_END
				       &amp;
				ZIPLIST_ENTRY_TAIL
</pre>


<p>
然后执行步骤 2 ，程序需要计算新节点所需的空间。假设要添加到节点里的值为字符数组 hello world
</p>
<ul class="org-ul">
<li>那么保存这个值共需要 12 字节的空间：
<ul class="org-ul">
<li>11 字节用于保存字符数组本身；</li>
<li>另外 1 字节中的 2 bit 用于保存类型编码 00  (encoding)， 而其余 6 bit 则保存字符数组长度 11 的二进制 001011 (length)</li>
</ul></li>
<li>还需要 1 字节， 用于保存前一个节点的长度 5 （二进制 101）</li>
</ul>

<p>
合算起来，为了添加新节点， ziplist 总共需要多分配  <span class="underline">13 字节</span> 空间。 以下是分配完成之后， ziplist 的样子：
</p>

<pre class="example" id="org9ceb6c0">
area        |&lt;---- ziplist header ----&gt;|&lt;------------ entries ------------&gt;|&lt;-- end --&gt;|

size          4 bytes  4 bytes  2 bytes  5 bytes          13 bytes           1 bytes
	    +---------+--------+-------+----------------+------------------+-----------+
component   | zlbytes | zltail | zllen | entry 1        | entry 2          | zlend     |
	    |         |        |       |                |                  |           |
value       |  10000  |  1010  |   1   | ?              | pre_entry_length | 1111 1111 |
	    |         |        |       |                | ?                |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | encoding         |           |
	    |         |        |       |                | ?                |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | length           |           |
	    |         |        |       |                | ?                |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | content          |           |
	    |         |        |       |                | ?                |           |
	    |         |        |       |                |                  |           |
	    +---------+--------+-------+----------------+------------------+-----------+
				       ^                ^
				       |                |
address                       ZIPLIST_ENTRY_HEAD   ZIPLIST_ENTRY_END
				       &amp;
			      ZIPLIST_ENTRY_TAIL
</pre>
<p>
步骤三，更新新节点的各项属性（为了方便表示， content 的内容使用字符而不是二进制来表示）：
</p>

<pre class="example" id="orgcdaeabc">
area        |&lt;---- ziplist header ----&gt;|&lt;------------ entries ------------&gt;|&lt;-- end --&gt;|

size          4 bytes  4 bytes  2 bytes  5 bytes          13 bytes           1 bytes
	    +---------+--------+-------+----------------+------------------+-----------+
component   | zlbytes | zltail | zllen | entry 1        | entry 2          | zlend     |
	    |         |        |       |                |                  |           |
value       |  10000  |  1010  |   1   | ?              | pre_entry_length | 1111 1111 |
	    |         |        |       |                | 101              |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | encoding         |           |
	    |         |        |       |                | 00               |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | length           |           |
	    |         |        |       |                | 001011           |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | content          |           |
	    |         |        |       |                | hello world      |           |
	    |         |        |       |                |                  |           |
	    +---------+--------+-------+----------------+------------------+-----------+
				       ^                ^
				       |                |
address                       ZIPLIST_ENTRY_HEAD   ZIPLIST_ENTRY_END
				       &amp;
			      ZIPLIST_ENTRY_TAIL
</pre>
<p>
最后一步，更新 ziplist 的 zlbytes 、 zltail 和 zllen 属性：
</p>

<pre class="example" id="orgc702895">
area        |&lt;---- ziplist header ----&gt;|&lt;------------ entries ------------&gt;|&lt;-- end --&gt;|

size          4 bytes  4 bytes  2 bytes  5 bytes          13 bytes           1 bytes
	    +---------+--------+-------+----------------+------------------+-----------+
component   | zlbytes | zltail | zllen | entry 1        | entry 2          | zlend     |
	    |         |        |       |                |                  |           |
value       |  11101  |  1111  |  10   | ?              | pre_entry_length | 1111 1111 |
	    |         |        |       |                | 101              |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | encoding         |           |
	    |         |        |       |                | 00               |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | length           |           |
	    |         |        |       |                | 001011           |           |
	    |         |        |       |                |                  |           |
	    |         |        |       |                | content          |           |
	    |         |        |       |                | hello world      |           |
	    |         |        |       |                |                  |           |
	    +---------+--------+-------+----------------+------------------+-----------+
				       ^                ^                  ^
				       |                |                  |
address                                |          ZIPLIST_ENTRY_TAIL   ZIPLIST_ENTRY_END
				       |
			       ZIPLIST_ENTRY_HEAD
</pre>
<p>
到这一步，添加新节点到表尾的工作正式完成
</p>

<pre class="example" id="orgadbad91">
这里没有演示往空 ziplist 添加第一个节点的过程， 因为这个过程和上面演示的添加第二个节点的过程类似

而且因为第一个节点的存在， 添加第二个节点的过程可以更好地展示“将节点添加到表尾”这一操作的一般性
</pre>
</div>
</div>

<div id="outline-container-org973a638" class="outline-3">
<h3 id="org973a638">将节点添加到某个/某些节点的前面</h3>
<div class="outline-text-3" id="text-org973a638">
<p>
比起将新节点添加到 ziplist 的末端， 将一个新节点添加到某个/某些节点的前面要复杂得多， 因为这种操作除了将新节点添加到 ziplist 以外， 还可能引起后续一系列节点的改变。举个例子，假设要将一个新节点 new 添加到节点 prev 和 next 之间：
</p>

<pre class="example" id="orgbe4c140">
   add new entry here
	   |
	   V
+----------+----------+----------+----------+----------+
|          |          |          |          |          |
|   prev   |   next   | next + 1 | next + 2 |   ...    |
|          |          |          |          |          |
</pre>

<p>
程序首先为新节点扩大 ziplist 的空间：
</p>

<pre class="example" id="org1204839">
+----------+----------+----------+----------+----------+----------+
|          |          |          |          |          |          |
|   prev   |   ???    |   next   | next + 1 | next + 2 |   ...    |
|          |          |          |          |          |          |
+----------+----------+----------+----------+----------+----------+

	   |&lt;--------&gt;|
	      expand
	      space
</pre>
<p>
然后设置 new 节点的各项值（到目前为止，一切都和前面介绍的添加操作一样）
</p>

<pre class="example" id="orgec04e3f">
	     set value,
	     property,
	     length,
	     etc.
		|
		v
+----------+----------+----------+----------+----------+----------+
|          |          |          |          |          |          |
|   prev   |   new    |   next   | next + 1 | next + 2 |   ...    |
|          |          |          |          |          |          |
+----------+----------+----------+----------+----------+----------+
</pre>
<p>
现在，新的 new 节点取代原来的 prev 节点， 成为了 next 节点的新前驱节点， 不过， 因为这时 next 节点的 <span class="underline">pre_entry_length 域</span> 编码的仍然是 prev 节点的长度， 所以程序需要将 new 节点的长度编码进 next 节点的 pre_entry_length 域里， 这里会出现三种可能：
</p>
<ul class="org-ul">
<li>next 的 pre_entry_length 域的长度正好能够编码 new 的长度（都是 1 字节或者都是 5 字节）： 程序直接更新 next 的 pre_entry_length 域</li>
<li><p>
next 的 pre_entry_length 只有 1 字节长，但编码 new 的长度需要 5 字节：
</p>
<pre class="example" id="orgc66257f">
如果是第二种情况， 那么程序必须对 ziplist 进行内存重分配， 从而扩展 next 的空间

然而，因为 next 的空间长度改变了， 所以程序又必须检查 next 的后继节点 next+1

看它的 pre_entry_length 能否编码 next 的新长度， 如果不能的话，程序又需要继续对 next+1 进行扩容。。。
</pre></li>
<li>next 的 pre_entry_length 有 5 字节长，但编码 new 的长度只需要 1 字节： 程序直接更新 next 的 pre_entry_length 域</li>
</ul>

<p>
在某个/某些节点的前面添加新节点之后， 程序必须沿着路径挨个检查后续的节点，是否满足新长度的编码要求， 直到遇到一个能满足要求的节点（如果有一个能满足，则这个节点之后的其他节点也满足）， 或者到达 ziplist 的末端 zlend 为止， 这种检查操作的复杂度为 \(\theta(N^{2})\)
</p>

<pre class="example" id="orgbf13dad">
不过，因为只有在新添加节点的后面有连续多个长度接近 254 的节点时， 这种连锁更新才会发生

所以可以普遍地认为， 这种连锁更新发生的概率非常小， 在一般情况下， 将添加操作看成是 O(N) 复杂度也是可以的
</pre>

<p>
执行完这三种情况的其中一种后， 程序更新 ziplist 的各项属性， 至此，添加操作完成
</p>

<pre class="example" id="org37d2a49">
在第三种情况中，程序实际上是可以执行类似于情况二的动作的： 它可以挨个地检查新节点之后的节点， 尝试收缩它们的空间长度

不过 Redis 决定不这么做， 因为在一些情况下，比如前面提到的，有连续多个长度接近 254 的节点时

可能会出现重复的扩展，收缩再扩展，再收缩的抖动效果， 这会让操作的性能变得非常差
</pre>
</div>
</div>
</div>
<div id="outline-container-org9da0d10" class="outline-2">
<h2 id="org9da0d10">删除</h2>
<div class="outline-text-2" id="text-org9da0d10">
<p>
删除节点和添加操作的步骤类似：
</p>
<ol class="org-ol">
<li><p>
定位目标节点，并计算节点的空间长度 target - size：
</p>
<pre class="example" id="orgeab333b">
   target start here
	   |
	   V
+----------+----------+----------+----------+----------+----------+
|          |          |          |          |          |          |
|   prev   |  target  |   next   | next + 1 | next + 2 |   ...    |
|          |          |          |          |          |          |
+----------+----------+----------+----------+----------+----------+

	   |&lt;--------&gt;|
	    target-size
</pre></li>
<li><p>
进行内存移位，覆盖 target 原本的数据，然后通过内存重分配，收缩多余空间：
</p>
<pre class="example" id="org058c477">
   target start here
	   |
	   V
+----------+----------+----------+----------+----------+
|          |          |          |          |          |
|   prev   |   next   | next + 1 | next + 2 |   ...    |
|          |          |          |          |          |
+----------+----------+----------+----------+----------+

	   | &lt;------------------------------------------ memmove
</pre></li>
<li><p>
检查 next 、 next+1 等后续节点能否满足新前驱节点的编码
</p>
<pre class="example" id="org9250fb2">
和添加操作一样，删除操作也可能会引起连锁更新
</pre></li>
</ol>
</div>
</div>
<div id="outline-container-orgf1777a9" class="outline-2">
<h2 id="orgf1777a9">遍历</h2>
<div class="outline-text-2" id="text-orgf1777a9">
<pre class="example" id="org8ccae25">
可以对 ziplist 进行从前向后的遍历，或者从后先前的遍历
</pre>
<p>
当进行从前向后的遍历时， 程序从指向节点 e1 的指针 p 开始， 计算节点 e1 的长度 <span class="underline">e1 - size</span> ， 然后将 p 加上 <span class="underline">e1 - size</span> ， 就将指针后移到了下一个节点 e2 。。。 如此反覆，直到 p 遇到 <span class="underline">ZIPLIST_ENTRY_END</span> 为止， 这样整个 ziplist 就遍历完了：
</p>
<pre class="example" id="orgc5303c5">
			       p + e1-size + e2-size
		 p + e1-size     |
	   p          |          |
	   |          |          |
	   V          V          V
+----------+----------+----------+----------+----------+----------+----------+
| ZIPLIST  |          |          |          |          |          | ZIPLIST  |
| ENTRY    |    e1    |    e2    |    e3    |    e4    |   ...    | ENTRY    |
| HEAD     |          |          |          |          |          | END      |
+----------+----------+----------+----------+----------+----------+----------+

	   |&lt;--------&gt;|&lt;--------&gt;|
	     e1-size    e2-size
</pre>
<p>
当进行从后往前遍历的时候， 程序从指向节点 eN 的指针 p 出发， 取出 eN 的 pre_entry_length 值， 然后用 <span class="underline">p - pre_entry_length</span> ， 这就将指针移动到了前一个节点 eN-1 。。。 如此反覆，直到 p 遇到 <span class="underline">ZIPLIST_ENTRY_HEAD</span> 为止， 这样整个 ziplist 就遍历完了：
</p>

<pre class="example" id="orge98cac4">
					 p - eN.pre_entry_length
					    |
					    |          p
					    |          |
					    V          V
+----------+----------+----------+----------+----------+----------+----------+
| ZIPLIST  |          |          |          |          |          | ZIPLIST  |
| ENTRY    |    e1    |    e2    |   ...    |   eN-1   |    eN    | ENTRY    |
| HEAD     |          |          |          |          |          | END      |
</pre>
</div>
</div>

<div id="outline-container-org6d90329" class="outline-2">
<h2 id="org6d90329">查找</h2>
<div class="outline-text-2" id="text-org6d90329">
<p>
查找元素、根据值定位节点，这两个操作和遍历的原理基本相同，不再赘述
</p>
</div>
</div>

<div id="outline-container-org7309a75" class="outline-2">
<h2 id="org7309a75">总结</h2>
<div class="outline-text-2" id="text-org7309a75">
<ul class="org-ul">
<li>ziplist 是由一系列特殊编码的内存块构成的列表，可以保存字符数组或整数值，同时是哈希键、列表键和有序集合键的底层实现之一</li>
<li><p>
ziplist 典型分布结构如下：
</p>
<pre class="example" id="org296edda">
area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
	    +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
	    +---------+--------+-------+--------+--------+--------+--------+-------+
				       ^                          ^        ^
address                                |                          |        |
				ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
								  |
							 ZIPLIST_ENTRY_TAIL
</pre></li>
<li><p>
ziplist 节点的分布结构如下：
</p>
<pre class="example" id="orgb0b5348">
area        |&lt;------------------- entry --------------------&gt;|

	    +------------------+----------+--------+---------+
component   | pre_entry_length | encoding | length | content |
	    +------------------+----------+--------+---------+
</pre></li>
<li><p>
添加和删除 ziplist 节点有可能会引起连锁更新，因此，添加和删除操作的最坏复杂度为 \(\theta(N^2)\)
</p>
<pre class="example" id="orgdc7d297">
不过，因为连锁更新的出现概率并不高，所以一般可以将添加和删除操作的复杂度视为 O(N) 
</pre></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
