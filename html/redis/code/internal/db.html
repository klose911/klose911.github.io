<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数据库</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./server.html"> UP </a>
 |
 <a accesskey="H" href="./internal.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">数据库</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org97fa926">数据库结构</a></li>
<li><a href="#org697d1fb">数据库的切换</a></li>
<li><a href="#orgece149c">数据库键空间</a>
<ul>
<li><a href="#org85950e9">键空间的操作</a>
<ul>
<li><a href="#org082648e">添加</a></li>
<li><a href="#org1589d52">删除</a></li>
<li><a href="#org0ecee64">更新</a></li>
<li><a href="#org6061df1">查询</a></li>
<li><a href="#org891efcc">其他</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6ae5b09">键过期</a>
<ul>
<li><a href="#orgc0830c7">过期时间的保存</a></li>
<li><a href="#org720423c">设置生存时间</a></li>
<li><a href="#org450c320">过期键的判定</a></li>
<li><a href="#orga1da1bc">过期键的清除</a>
<ul>
<li><a href="#orgd09f824">定时删除</a></li>
<li><a href="#org4b1551b">惰性删除</a></li>
<li><a href="#org8accf5e">定期删除</a></li>
<li><a href="#org1559097">Redis 使用的策略</a>
<ul>
<li><a href="#org4aff19f">过期键的惰性删除策略</a></li>
<li><a href="#org8f3fdf9">过期键的定期删除策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org09364c4">过期键对 AOF 、RDB 和复制的影响</a>
<ul>
<li><a href="#orge41d7c5">更新后的 RDB 文件</a></li>
<li><a href="#org153cba0">AOF 文件</a></li>
<li><a href="#orgefd34a5">AOF 重写</a></li>
<li><a href="#org934b6ac">复制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdae972e">数据库空间的收缩和扩展</a></li>
</ul>
</div>
</div>
<p>
接下来对 Redis 数据库的构造和实现进行讨论
</p>

<pre class="example" id="orgbdd1c0d">
除了说明数据库是如何储存数据对象之外，还会讨论键的过期信息是如何保存，而 Redis 又是如何删除过期键的
</pre>
<div id="outline-container-org97fa926" class="outline-2">
<h2 id="org97fa926">数据库结构</h2>
<div class="outline-text-2" id="text-org97fa926">
<p>
Redis 中的每个数据库，都由一个 <span class="underline">redis.h/redisDb</span> 结构表示：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">redisDb</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20445;&#23384;&#30528;&#25968;&#25454;&#24211;&#20197;&#25972;&#25968;&#34920;&#31034;&#30340;&#21495;&#30721;</span>

    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">dict</span>;     <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20445;&#23384;&#30528;&#25968;&#25454;&#24211;&#20013;&#30340;&#25152;&#26377;&#38190;&#20540;&#23545;&#25968;&#25454;&#65292;&#36825;&#20010;&#23646;&#24615;&#20063;&#34987;&#31216;&#20026;&#38190;&#31354;&#38388;&#65288;key space&#65289;</span>

    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">expires</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20445;&#23384;&#30528;&#38190;&#30340;&#36807;&#26399;&#20449;&#24687;</span>

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23454;&#29616;&#21015;&#34920;&#38459;&#22622;&#21407;&#35821;&#65292;&#22914; BLPOP&#65292;&#22312;&#21015;&#34920;&#31867;&#22411;&#19968;&#31456;&#26377;&#35814;&#32454;&#30340;&#35752;&#35770;</span>
    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">blocking_keys</span>;
    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">ready_keys</span>;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#29992;&#20110;&#23454;&#29616; WATCH &#21629;&#20196;&#65292;&#22312;&#20107;&#21153;&#31456;&#33410;&#26377;&#35814;&#32454;&#30340;&#35752;&#35770;</span>
    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">watched_keys</span>;
} <span style="color: #98fb98;">redisDb</span>;
</pre>
</div>

<p>
下面将详细讨论 <span class="underline">id</span> , <span class="underline">dict</span> 和 <span class="underline">expires</span> 三个属性， 以及针对这三个属性所执行的数据库操作
</p>
</div>
</div>
<div id="outline-container-org697d1fb" class="outline-2">
<h2 id="org697d1fb">数据库的切换</h2>
<div class="outline-text-2" id="text-org697d1fb">
<p>
redisDb 结构的 <span class="underline">id</span> 域保存着 <span class="underline">数据库的号码</span>
</p>
<pre class="example" id="orgc5f1712">
这个号码很容易让人将它和切换数据库的 SELECT 命令联系在一起

但是， 实际上， id 属性并不是用来实现 SELECT 命令， 而是给 Redis 内部程序使用的
</pre>
<p>
当 Redis 服务器初始化时， 它会创建出 <span class="underline">redis.h/REDIS_DEFAULT_DBNUM</span> 个 <b>数据库</b> ， 并将所有数据库 <b>保存</b> 到 <span class="underline">redis.h/redisServer.db 数组</span> 中， 每个数据库的 id 为从 \(0\) 到 <span class="underline">REDIS_DEFAULT_DBNUM - 1</span> 的值
</p>
<ul class="org-ul">
<li>当执行 <span class="underline">SELECT number</span> 命令时，程序直接使用 <span class="underline">redisServer.db[number]</span> 来切换数据库</li>
</ul>

<pre class="example" id="org927158d">
但是， 一些内部程序， 比如 AOF 程序、复制程序和 RDB 程序， 需要知道当前数据库的号码

如果没有 id 域的话， 程序就只能在当前使用的数据库的指针， 和 redisServer.db 数组中所有数据库的指针进行对比

以此来弄清楚自己正在使用的是那个数据库
</pre>

<p>
以下伪代码描述了这个对比过程：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">PSEUDO_GET_CURRENT_DB_NUMBER</span>(current_db_pointer):
    <span style="color: #eedd82;">i</span> = 0
    <span style="color: #00ffff;">for</span> db_pointer <span style="color: #00ffff;">in</span> redisServer.db:
        <span style="color: #00ffff;">if</span> db_pointer == current_db_pointer:
            <span style="color: #00ffff;">break</span>
        i += 1
    <span style="color: #00ffff;">return</span> i
</pre>
</div>

<p>
有了 id 域的话， 程序就可以通过读取 id 域来了解自己正在使用的是哪个数据库， 这样就不用对比指针那么麻烦了
</p>
</div>
</div>
<div id="outline-container-orgece149c" class="outline-2">
<h2 id="orgece149c">数据库键空间</h2>
<div class="outline-text-2" id="text-orgece149c">
<p>
因为 Redis 是一个 <b>键值对数据库</b> <span class="underline">key-value pairs database</span> ， 所以它的数据库本身也是一个 <b>字典</b> （俗称 <span class="underline">key space</span> ）：
</p>
<ul class="org-ul">
<li>字典的 <span class="underline">键</span> 是一个 <b>字符串</b> 对象</li>
<li>字典的 <b>值</b> 则可以是包括 <span class="underline">字符串</span> ， <span class="underline">列表</span> ， <span class="underline">哈希表</span> ， <span class="underline">集合</span> 或 <span class="underline">有序集</span> 在内的任意一种 <b>Redis 类型对象</b></li>
</ul>

<p>
在 redisDb 结构的 <span class="underline">dict 属性</span> 中，保存着数据库的所有 <span class="underline">键值对数据</span> 。下图展示了一个包含 number 、 book 、 message 三个键的数据库：
</p>

<div id="orgeb208da" class="figure">
<p><img src="../pic/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" class="org-svg" width="90%" />
</p>
</div>

<pre class="example" id="orge28b976">
number 键是一个列表，列表中包含三个整数值

book 键是一个哈希表，表中包含三个键值对

而 message 键则指向另一个字符串
</pre>
</div>
<div id="outline-container-org85950e9" class="outline-3">
<h3 id="org85950e9">键空间的操作</h3>
<div class="outline-text-3" id="text-org85950e9">
<p>
因为数据库本身是一个字典， 所以对数据库的操作基本上都是对字典的操作， 加上以下一些 <b>维护</b> 操作：
</p>
<ul class="org-ul">
<li><b>更新</b> 键的 <span class="underline">命中率</span> 和 <span class="underline">不命中率</span> ，这个值可以用 <span class="underline">INFO</span> 命令查看</li>
<li><b>更新</b> 键的 <span class="underline">LRU 时间</span> ，这个值可以用 <span class="underline">OBJECT</span> 命令来查看</li>
<li><b>删除</b> <span class="underline">过期键</span> （稍后会详细说明）</li>
<li>如果键被 <b>修改</b> 了的话，那么将键设为 <span class="underline">脏</span> （用于事务监视），并将服务器设为 <span class="underline">脏</span> （等待 RDB 保存）</li>
<li>将对键的修改发送到 <span class="underline">AOF 文件</span> 和 <span class="underline">附属节点</span> ，保持 <b>数据库状态的一致</b></li>
</ul>

<p>
作为例子，以下会展示键的 <span class="underline">添加</span> 、 <span class="underline">删除</span> 、 <span class="underline">更新</span> 、 <span class="underline">取值</span> 等几个主要操作
</p>
</div>

<div id="outline-container-org082648e" class="outline-4">
<h4 id="org082648e">添加</h4>
<div class="outline-text-4" id="text-org082648e">
<p>
添加一个新键对到数据库， 实际上就是将一个 <span class="underline">新的键值对</span> <b>添加</b> 到 <span class="underline">键空间字典</span> 中
</p>
<ul class="org-ul">
<li>其中键为字符串对象</li>
<li>而值则是任意一种 Redis 类型值对象</li>
</ul>

<p>
举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：
</p>

<div id="org393378a" class="figure">
<p><img src="../pic/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
那么在客户端执行 <span class="underline">SET date 2013.2.1</span> 命令之后，数据库更新为下图状态：
</p>

<div id="org6df7558" class="figure">
<p><img src="../pic/graphviz-574f2a7d4969f29d50d0b3a5fba6f152ec118676.svg" alt="graphviz-574f2a7d4969f29d50d0b3a5fba6f152ec118676.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org1589d52" class="outline-4">
<h4 id="org1589d52">删除</h4>
<div class="outline-text-4" id="text-org1589d52">
<p>
删除数据库中的一个键， 实际上就是 <b>删除</b> <span class="underline">字典空间</span> 中对应的 <span class="underline">键对象</span> 和 <span class="underline">值对象</span> 。举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：
</p>

<div id="org8c76b42" class="figure">
<p><img src="../pic/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
那么在客户端执行 <span class="underline">DEL message</span> 命令之后，数据库更新为下图状态：
</p>


<div id="org3af631b" class="figure">
<p><img src="../pic/graphviz-e5ee0986e5626ab032382bce64e2b41a60008e25.svg" alt="graphviz-e5ee0986e5626ab032382bce64e2b41a60008e25.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org0ecee64" class="outline-4">
<h4 id="org0ecee64">更新</h4>
<div class="outline-text-4" id="text-org0ecee64">
<p>
当对一个已存在于数据库的键执行更新操作时， 数据库 <b>释放</b> 键 <span class="underline">原来的值对象</span> ， 然后将指针 <b>指向</b> <span class="underline">新的值对象</span> 。举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：
</p>

<div id="orge24a5c4" class="figure">
<p><img src="../pic/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
那么在客户端执行 <span class="underline">SET message "blah blah"</span> 命令之后，数据库更新为下图状态：
</p>

<div id="org0a09279" class="figure">
<p><img src="../pic/graphviz-baa230ed027a28ac6bb0de0767a91876c1993195.svg" alt="graphviz-baa230ed027a28ac6bb0de0767a91876c1993195.svg" class="org-svg" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org6061df1" class="outline-4">
<h4 id="org6061df1">查询</h4>
<div class="outline-text-4" id="text-org6061df1">
<p>
在数据库中取值实际上就是在 <span class="underline">字典空间</span> 中 <b>取值</b> ， 再加上一些 <b>额外的</b> <span class="underline">类型检查</span> ：
</p>
<ul class="org-ul">
<li>键 *不存在*，返回 <span class="underline">空回复</span></li>
<li>键 <b>存在</b> ，且 <b>类型正确</b> ，按照通讯协议返回 <span class="underline">值对象</span></li>
<li>键 <b>存在</b> ，但 <b>类型不正确</b> ，返回 <span class="underline">类型错误</span></li>
</ul>

<p>
举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）
</p>

<div id="orga284d17" class="figure">
<p><img src="../pic/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" class="org-svg" width="90%" />
</p>
</div>

<pre class="example" id="org769574b">
当客户端执行 GET message 时，服务器返回 "hello moto" 

当客户端执行 GET not-exists-key 时，服务器返回空回复

当服务器执行 GET book 时，服务器返回类型错误
</pre>
</div>
</div>

<div id="outline-container-org891efcc" class="outline-4">
<h4 id="org891efcc">其他</h4>
<div class="outline-text-4" id="text-org891efcc">
<p>
除了上面展示的键值操作之外，还有很多针对数据库本身的命令，也是通过对键空间进行处理来完成的：
</p>
<ul class="org-ul">
<li><span class="underline">FLUSHDB</span> 命令：删除键空间中的所有键值对</li>
<li><span class="underline">RANDOMKEY</span> 命令：从键空间中随机返回一个键</li>
<li><span class="underline">DBSIZE</span> 命令：返回键空间中键值对的数量</li>
<li><span class="underline">EXISTS</span> 命令：检查给定键是否存在于键空间中</li>
<li><span class="underline">RENAME</span> 命令：在键空间中，对给定键进行改名</li>
<li>。。。。。。</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org6ae5b09" class="outline-2">
<h2 id="org6ae5b09">键过期</h2>
<div class="outline-text-2" id="text-org6ae5b09">
<pre class="example" id="org58896ab">
在前面的内容中， 讨论了很多涉及数据库本身、以及对数据库中的键值对进行处理的操作

但是， 关于数据库如何保存键的过期时间， 以及如何处理过期键这一问题， 还没有讨论到
</pre>

<p>
通过 <span class="underline">EXPIRE</span> ,  <span class="underline">PEXPIRE</span> ,  <span class="underline">EXPIREAT</span> 和 <span class="underline">PEXPIREAT</span> 四个命令， 客户端可以给某个 <b>存在的</b> <span class="underline">键</span> 设置 <span class="underline">过期时间</span> ， 当键的过期时间到达时， 键就不再可用：
</p>

<pre class="example" id="orgd7439d8">
redis&gt; SETEX key 5 value
OK

redis&gt; GET key
"value"

redis&gt; GET key   // 5 秒过后
(nil)
</pre>

<p>
命令 <span class="underline">TTL</span> 和 <span class="underline">PTTL</span> 则用于返回给定键距离过期还有 <span class="underline">多长时间</span> ：
</p>

<pre class="example" id="orgc785fe2">
redis&gt; SETEX key 10086 value
OK

redis&gt; TTL key
(integer) 10082

redis&gt; PTTL key
(integer) 10068998
</pre>
</div>

<div id="outline-container-orgc0830c7" class="outline-3">
<h3 id="orgc0830c7">过期时间的保存</h3>
<div class="outline-text-3" id="text-orgc0830c7">
<p>
在数据库中， 所有键的过期时间都被保存在 <span class="underline">redisDb</span> 结构的 <span class="underline">expires</span> 字典里：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">redisDb</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
    <span style="color: #98fb98;">dict</span> *<span style="color: #eedd82;">expires</span>;
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...</span>
} <span style="color: #98fb98;">redisDb</span>;
</pre>
</div>

<p>
<span class="underline">expires 字典</span> ：的
</p>
<ul class="org-ul">
<li>键：一个指向 <span class="underline">dict 字典</span> （键空间）里 <span class="underline">某个键的指针</span></li>
<li>值：键所指向的数据库键的 <span class="underline">到期时间</span> ， 这个值以 <span class="underline">long long</span> 类型表示</li>
</ul>

<p>
下图展示了一个含有三个键的数据库，其中 number 和 book 两个键带有过期时间：
</p>


<div id="org923f0b8" class="figure">
<p><img src="../pic/graphviz-db4eb6451979faf62da12bc0943cd00a9e0097e4.svg" alt="graphviz-db4eb6451979faf62da12bc0943cd00a9e0097e4.svg" class="org-svg" width="90%" />
</p>
</div>

<pre class="example" id="orgb77180d">
为了展示的方便， 图中重复出现了两次 number 键和 book 键

在实际中， 键空间字典的键和过期时间字典的键都指向同一个字符串对象， 所以不会浪费任何空间
</pre>
</div>
</div>

<div id="outline-container-org720423c" class="outline-3">
<h3 id="org720423c">设置生存时间</h3>
<div class="outline-text-3" id="text-org720423c">
<p>
Redis 有四个命令可以设置键的生存时间（可以存活多久）和过期时间（什么时候到期）：
</p>
<ul class="org-ul">
<li>EXPIRE: 以 <span class="underline">秒</span> 为单位设置键的 <span class="underline">生存时间</span></li>
<li>PEXPIRE 以 <span class="underline">毫秒</span> 为单位设置键的 <span class="underline">生存时间</span></li>
<li>EXPIREAT 以 <span class="underline">秒</span> 为单位，设置键的 <span class="underline">过期 UNIX 时间戳</span></li>
<li>PEXPIREAT 以 <span class="underline">毫秒</span> 为单位，设置键的 <span class="underline">过期 UNIX 时间戳</span></li>
</ul>

<p>
虽然有那么多种不同单位和不同形式的设置方式， 但是 expires 字典的值只保存 <b>以毫秒为单位的过期 UNIX 时间戳</b>
</p>
<pre class="example" id="orgfba5943">
这就是说， 通过进行转换， 所有命令的效果最后都和 PEXPIREAT 命令的效果一样
</pre>

<p>
举个例子，从 EXPIRE 命令到 PEXPIREAT 命令的转换可以用伪代码表示如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">EXPIRE</span>(key, sec):
    <span style="color: #eedd82;">ms</span> = sec_to_ms(sec) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#23558; TTL &#20174;&#31186;&#36716;&#25442;&#20026;&#27627;&#31186;</span>

    <span style="color: #eedd82;">ts_in_ms</span> = get_current_unix_timestamp_in_ms() <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#33719;&#21462;&#20197;&#27627;&#31186;&#35745;&#31639;&#30340;&#24403;&#21069; UNIX &#26102;&#38388;&#25139;</span>

    PEXPIREAT(ms + ts_in_ms, key) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#27627;&#31186; TTL &#21152;&#19978;&#27627;&#31186;&#26102;&#38388;&#25139;&#65292;&#23601;&#26159; key &#21040;&#26399;&#30340;&#26102;&#38388;&#25139;</span>
</pre>
</div>

<pre class="example" id="org148a09b">
其他函数的转换方式也是类似的
</pre>

<p>
作为例子， 下图展示了一个 expires 字典示例， 字典中 <span class="underline">number</span> 键的过期时间是 <span class="underline">2013 年 2 月 10 日</span> （农历新年）， 而 <span class="underline">book</span> 键的过期时间则是 <span class="underline">2013 年 2 月 14 日</span> （情人节）：
</p>

<div id="org6888ce4" class="figure">
<p><img src="../pic/graphviz-3bd6730e0529a24b3a3d6e11a751b395e2039717.svg" alt="graphviz-3bd6730e0529a24b3a3d6e11a751b395e2039717.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
这两个键的过期时间可能是用以上四个命令的任意一个设置的， 但它们都以统一的格式被保存在 expires 字典中
</p>
</div>
</div>

<div id="outline-container-org450c320" class="outline-3">
<h3 id="org450c320">过期键的判定</h3>
<div class="outline-text-3" id="text-org450c320">
<p>
通过 expires 字典， 可以用以下步骤检查某个键是否过期：
</p>
<ol class="org-ol">
<li>检查键是否 <b>存在</b> 于 <span class="underline">expires</span> 字典：如果存在，那么 <b>取出</b> 键的 <span class="underline">过期时间</span></li>
<li>检查 <span class="underline">当前 UNIX 时间戳</span> 是否 <b>大于</b> <span class="underline">键的过期时间</span> ：
<ul class="org-ul">
<li>如果是的话，那么键 <b>已经过期</b></li>
<li>否则，键未过期</li>
</ul></li>
</ol>

<p>
可以用伪代码来描述这一过程：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">is_expired</span>(key):
    <span style="color: #eedd82;">key_expire_time</span> = expires.get(key) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21462;&#20986;&#38190;&#30340;&#36807;&#26399;&#26102;&#38388;</span>

    <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#22914;&#26524;&#36807;&#26399;&#26102;&#38388;&#19981;&#20026;&#31354;&#65292;&#24182;&#19988;&#24403;&#21069;&#26102;&#38388;&#25139;&#22823;&#20110;&#36807;&#26399;&#26102;&#38388;&#65292;&#37027;&#20040;&#38190;&#24050;&#32463;&#36807;&#26399;</span>
    <span style="color: #00ffff;">if</span> expire_time <span style="color: #00ffff;">is</span> <span style="color: #00ffff;">not</span> <span style="color: #7fffd4;">None</span> <span style="color: #00ffff;">and</span> current_timestamp() &gt; key_expire_time:
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">True</span>

    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">False</span> <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21542;&#21017;&#65292;&#38190;&#26410;&#36807;&#26399;&#25110;&#27809;&#26377;&#35774;&#32622;&#36807;&#26399;&#26102;&#38388;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1da1bc" class="outline-3">
<h3 id="orga1da1bc">过期键的清除</h3>
<div class="outline-text-3" id="text-orga1da1bc">
<pre class="example" id="org696ade0">
已经知道了过期时间保存在 expires 字典里， 又知道了该如何判定一个键是否过期

现在剩下的问题是， 如果一个键是过期的， 那它什么时候会被删除？
</pre>
<p>
这个问题有三种可能的答案：
</p>
<ol class="org-ol">
<li><span class="underline">定时</span> 删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作</li>
<li><span class="underline">惰性</span> 删除：放任键过期不管，但是在每次从 dict 字典中取出键值时，要检查键是否过期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值</li>
<li><span class="underline">定期</span> 删除：每隔一段时间，对 expires 字典进行检查，删除里面的过期键</li>
</ol>
</div>

<div id="outline-container-orgd09f824" class="outline-4">
<h4 id="orgd09f824">定时删除</h4>
<div class="outline-text-4" id="text-orgd09f824">
<ul class="org-ul">
<li>定时删除策略对 <b>内存</b> 是最友好的： 因为它保证过期键会在第一时间被删除， 过期键所消耗的内存会立即被释放</li>
<li>这种策略的缺点是：
<ul class="org-ul">
<li><p>
它对 <b>CPU</b> 时间是最不友好的： 因为删除操作可能会占用大量的 CPU 时间
</p>
<pre class="example" id="org8f91f6b">
在内存不紧张、但是 CPU 时间非常紧张的时候 （比如说，进行交集计算或排序的时候）

将 CPU 时间花在删除那些和当前任务无关的过期键上， 这种做法毫无疑问会是低效的
</pre></li>
<li><p>
目前 Redis 事件处理器对时间事件的实现方式 <span class="underline">无序链表</span> ， 查找一个时间复杂度为 \(O(N)\)
</p>
<pre class="example" id="org1783b70">
所以 redis 并不适合用来处理大量时间事件
</pre></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org4b1551b" class="outline-4">
<h4 id="org4b1551b">惰性删除</h4>
<div class="outline-text-4" id="text-org4b1551b">
<ul class="org-ul">
<li><p>
惰性删除对 <b>CPU 时间来说是最友好的</b> ： 它只会在取出键时进行检查， 这可以保证删除操作只会在非做不可的情况下进行
</p>
<pre class="example" id="org75bf640">
并且删除的目标仅限于当前处理的键， 这个策略不会在删除其他无关的过期键上花费任何 CPU 时间
</pre></li>
<li>惰性删除的缺点是， 它对 <b>内存是最不友好</b> 的： 如果一个键已经过期， 而这个键又仍然保留在数据库中， 那么 dict 字典和 expires 字典都需要继续保存这个键的信息， 只要这个过期键不被删除， 它占用的内存就不会被释放</li>
</ul>

<pre class="example" id="org7ee79f3">
举个例子， 对于一些按时间点来更新的数据， 比如日志（log）， 在某个时间点之后， 对它们的访问就会大大减少

如果大量的这些过期数据积压在数据库里面， 用户以为它们已经过期了（已经被删除了）

但实际上这些键却没有真正的被删除（内存也没有被释放）， 那结果肯定是非常糟糕
</pre>

<p>
在使用惰性删除策略时， 如果数据库中有非常多的过期键， 但这些过期键又正好没有被访问的话， 那么它们就永远也不会被删除（除非用户手动执行）， 这对于性能非常依赖于内存大小的 Redis 来说， 肯定不是一个好消息
</p>
</div>
</div>

<div id="outline-container-org8accf5e" class="outline-4">
<h4 id="org8accf5e">定期删除</h4>
<div class="outline-text-4" id="text-org8accf5e">
<p>
从上面对定时删除和惰性删除的讨论来看， 这两种删除方式在单一使用时都有明显的缺陷： 定时删除占用太多 CPU 时间， 惰性删除浪费太多内存。
</p>

<p>
定期删除是这两种策略的一种折中：
</p>
<ul class="org-ul">
<li>它每隔一段时间执行一次删除操作，并通过 <b>限制</b> 删除操作执行的时长和频率，籍此来减少删除操作对 CPU 时间的影响</li>
<li>另一方面，通过定期删除过期键，它有效地减少了因惰性删除而带来的内存浪费</li>
</ul>
</div>
</div>

<div id="outline-container-org1559097" class="outline-4">
<h4 id="org1559097">Redis 使用的策略</h4>
<div class="outline-text-4" id="text-org1559097">
<p>
Redis 使用的过期键删除策略是 <span class="underline">惰性删除</span> 加上 <span class="underline">定期删除</span> ， 这两个策略相互配合，可以很好地在合理利用 CPU 时间和节约内存空间之间取得平衡
</p>
</div>

<div id="outline-container-org4aff19f" class="outline-5">
<h5 id="org4aff19f">过期键的惰性删除策略</h5>
<div class="outline-text-5" id="text-org4aff19f">
<p>
实现过期键惰性删除策略的核心是 <span class="underline">db.c/expireIfNeeded</span> 函数，所有命令在 <b>读取</b> 或 <b>写入</b> 数据库之前，程序都会调用 <span class="underline">expireIfNeeded</span> 对 <span class="underline">输入键</span> 进行 <b>检查</b> ， 并将 <span class="underline">过期键</span> <b>删除</b> ：
</p>

<div id="org6aa5bac" class="figure">
<p><img src="../pic/graphviz-efb7f7ae1a793feea33285531dfe0023f3017b90.svg" alt="graphviz-efb7f7ae1a793feea33285531dfe0023f3017b90.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
比如说， GET 命令的执行流程可以用下图来表示：
</p>

<div id="org48c48c7" class="figure">
<p><img src="../pic/graphviz-acca43b0dd583eb92a1ce7193dc6b9bb14e9c0f9.svg" alt="graphviz-acca43b0dd583eb92a1ce7193dc6b9bb14e9c0f9.svg" class="org-svg" width="90%" />
</p>
</div>

<p>
<span class="underline">expireIfNeeded</span> 的作用是， 如果输入键已经 <span class="underline">过期</span> 的话， 那么将 <span class="underline">键</span> 、_键的值_ 、 <span class="underline">键保存在 expires 字典中的过期时间</span> 都 <b>删除</b> 掉。用伪代码描述的 expireIfNeeded 定义如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">expireIfNeeded</span>(key):
    <span style="color: #00ffff;">if</span> key.is_expired(): <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#23545;&#36807;&#26399;&#38190;&#25191;&#34892;&#20197;&#19979;&#25805;&#20316; &#12290;&#12290;&#12290;</span>
        db.<span style="color: #b0c4de;">dict</span>.remove(key) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#20174;&#38190;&#31354;&#38388;&#20013;&#21024;&#38500;&#38190;&#20540;&#23545;</span>
        db.expires.remove(key) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21024;&#38500;&#38190;&#30340;&#36807;&#26399;&#26102;&#38388;</span>
        propagateDelKeyToAofAndReplication(key) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#23558;&#21024;&#38500;&#21629;&#20196;&#20256;&#25773;&#21040; AOF &#25991;&#20214;&#21644;&#38468;&#23646;&#33410;&#28857;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f3fdf9" class="outline-5">
<h5 id="org8f3fdf9">过期键的定期删除策略</h5>
<div class="outline-text-5" id="text-org8f3fdf9">
<p>
对过期键的定期删除由 <span class="underline">redis.c/activeExpireCycle</span> 函执行： 这个函数在 <span class="underline">规定的时间限制</span> 内， 尽可能地 <b>遍历</b> <span class="underline">各个数据库</span> 的 <span class="underline">expires 字典</span> ，  <b>随机</b> 地检查 <span class="underline">一部分键</span> 的 <span class="underline">过期时间</span> ， 并 <b>删除</b> 其中的 <span class="underline">过期键</span> 。整个过程可以用伪代码描述如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">activeExpireCycle</span>():
    <span style="color: #00ffff;">for</span> db <span style="color: #00ffff;">in</span> server.<span style="color: #eedd82;">db</span>: <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36941;&#21382;&#25968;&#25454;&#24211;&#65288;&#19981;&#19968;&#23450;&#33021;&#20840;&#37096;&#37117;&#36941;&#21382;&#23436;&#65292;&#30475;&#26102;&#38388;&#26159;&#21542;&#36275;&#22815;&#65289;</span>
        i = 0 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">MAX_KEY_PER_DB &#26159;&#19968;&#20010; DB &#26368;&#22823;&#33021;&#22788;&#29702;&#30340; key &#20010;&#25968;&#65292;&#23427;&#20445;&#35777;&#26102;&#38388;&#19981;&#20250;&#20840;&#37096;&#29992;&#22312;&#20010;&#21035;&#30340; DB &#19978;&#65288;&#36991;&#20813;&#39269;&#39295;&#65289;</span>

        <span style="color: #00ffff;">while</span> (i &lt; MAX_KEY_PER_DB):
            <span style="color: #00ffff;">if</span> db.is_empty(): <span style="color: #00ffff;">break</span> <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25968;&#25454;&#24211;&#20026;&#31354;&#65292;&#36339;&#20986; while &#65292;&#22788;&#29702;&#19979;&#20010; DB</span>

            <span style="color: #eedd82;">key_with_ttl</span> = db.expires.get_random_key() <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#38543;&#26426;&#21462;&#20986;&#19968;&#20010;&#24102; TTL &#30340;&#38190;</span>

            <span style="color: #00ffff;">if</span> is_expired(key_with_ttl):
                db.deleteExpiredKey(key_with_ttl) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#26816;&#26597;&#38190;&#26159;&#21542;&#36807;&#26399;&#65292;&#22914;&#26524;&#26159;&#30340;&#35805;&#65292;&#23558;&#23427;&#21024;&#38500;</span>

            <span style="color: #00ffff;">if</span> reach_time_limit(): <span style="color: #00ffff;">return</span> <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#24403;&#25191;&#34892;&#26102;&#38388;&#21040;&#36798;&#19978;&#38480;&#65292;&#20989;&#25968;&#23601;&#36820;&#22238;&#65292;&#19981;&#20877;&#32487;&#32493;&#65292;&#36825;&#30830;&#20445;&#21024;&#38500;&#25805;&#20316;&#19981;&#20250;&#21344;&#29992;&#22826;&#22810;&#30340; CPU &#26102;&#38388;</span>

            <span style="color: #eedd82;">i</span> += 1
</pre>
</div>

<pre class="example" id="orgb502465">
每当 Redis 的例行处理程序 serverCron 执行时， activeExpireCycle 都会被调用 
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org09364c4" class="outline-3">
<h3 id="org09364c4">过期键对 AOF 、RDB 和复制的影响</h3>
<div class="outline-text-3" id="text-org09364c4">
<pre class="example" id="org6059c01">
前面的内容讨论了过期键对 CPU 时间和内存的影响

现在，是时候说说过期键在 RDB 文件、 AOF 文件、 AOF 重写以及复制中的影响了
</pre>
<p>
过期键会被保存在更新后的 RDB 文件、 AOF 文件或者重写后的 AOF 文件里面吗？
</p>

<p>
附属节点会会如何处理过期键？处理的方式和主节点一样吗？
</p>
</div>

<div id="outline-container-orge41d7c5" class="outline-4">
<h4 id="orge41d7c5">更新后的 RDB 文件</h4>
<div class="outline-text-4" id="text-orge41d7c5">
<p>
在创建新的 RDB 文件时，程序会对键进行检查， <span class="underline">过期的键</span> <b>不会被</b> 写入到更新后的 RDB 文件中。
</p>

<pre class="example" id="orgb5f24a8">
因此，过期键对更新后的 RDB 文件没有影响
</pre>
</div>
</div>

<div id="outline-container-org153cba0" class="outline-4">
<h4 id="org153cba0">AOF 文件</h4>
<div class="outline-text-4" id="text-org153cba0">
<ul class="org-ul">
<li>在键已经过期，但是还 <b>没有</b> 被 <span class="underline">惰性删除</span> 或者 <span class="underline">定期删除</span> 之前，这个键不会产生任何影响，AOF 文件也不会因为这个键而被修改</li>
<li><p>
当过期键被惰性删除、或者定期删除之后，程序会向 AOF 文件追加一条 <span class="underline">DEL</span> 命令，来 <b>显式</b> 地记录该键已被删除
</p>

<pre class="example" id="org817309a">
举个例子， 如果客户端使用 GET message 试图访问 message 键的值， 但 message 已经过期了， 那么服务器执行以下三个动作：
    1. 从数据库中删除 message
    2. 追加一条 DEL message 命令到 AOF 文件
    3. 向客户端返回 NIL 
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orgefd34a5" class="outline-4">
<h4 id="orgefd34a5">AOF 重写</h4>
<div class="outline-text-4" id="text-orgefd34a5">
<p>
和 RDB 文件类似， 当进行 AOF 重写时， 程序会对键进行检查， 过期的键 <b>不会</b> 被保存到重写后的 AOF 文件。
</p>

<pre class="example" id="orga2e619a">
因此，过期键对重写后的 AOF 文件没有影响
</pre>
</div>
</div>

<div id="outline-container-org934b6ac" class="outline-4">
<h4 id="org934b6ac">复制</h4>
<div class="outline-text-4" id="text-org934b6ac">
<p>
当服务器带有 <span class="underline">附属节点</span> 时，  <span class="underline">过期键的删除</span> 由 <b>主节点</b> <span class="underline">统一控制</span> ：
</p>
<ul class="org-ul">
<li>如果服务器是 <span class="underline">主节点</span> ，那么它在删除一个过期键之后，会 <b>显式</b> 地向 <span class="underline">所有附属节点</span> 发送一个 <span class="underline">DEL</span> 命令</li>
<li><p>
如果服务器是 <span class="underline">附属节点</span> ，那么当它碰到一个过期键的时候，它会向程序 <b>返回</b> <span class="underline">键已过期</span> 的回复，但并不真正的删除过期键
</p>
<pre class="example" id="orgf192ca3">
因为程序只根据键是否已经过期、而不是键是否已经被删除来决定执行流程，所以这种处理并不影响命令的正确执行结果

当接到从主节点发来的 DEL 命令之后，附属节点才会真正的将过期键删除掉
</pre></li>
</ul>

<p>
附属节点不自主对键进行删除是为了和主节点的数据保持 <b>绝对一致</b> ， 因此， 当一个过期键还存在于主节点时，这个键在所有附属节点的副本也不会被删除
</p>

<pre class="example" id="orgc285ed8">
这种处理机制对那些使用大量附属节点，并且带有大量过期键的应用来说，可能会造成一部分内存不能立即被释放

但是，因为过期键通常很快会被主节点发现并删除，所以这实际上也算不上什么大问题
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdae972e" class="outline-2">
<h2 id="orgdae972e">数据库空间的收缩和扩展</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
