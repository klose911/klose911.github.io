<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Codec 编码</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="channel.html"> UP </a>
 |
 <a accesskey="H" href="netty.html"> HOME </a>
</div><div id="content">
<h1 class="title">Codec 编码</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgeebb589">Codec</a>
<ul>
<li><a href="#orgb34c507">Decoder</a>
<ul>
<li><a href="#org9f54716">ByteToMessageDecoder</a></li>
<li><a href="#org4f83639">ReplayingDecoder</a>
<ul>
<li><a href="#org86f6969">ByteToMessageDecoder VS ReplayingDecoder</a></li>
<li><a href="#orgc619189">更多 Decoder</a></li>
</ul>
</li>
<li><a href="#orgedb9cca">MessageToMessageDecoder</a>
<ul>
<li><a href="#org4dfc426">HttpObjectAggregator</a></li>
</ul>
</li>
<li><a href="#org0b98e75">在解码时处理太大的帧</a></li>
</ul>
</li>
<li><a href="#org65695df">Encoder</a>
<ul>
<li><a href="#org113654d">MessageToByteEncoder</a></li>
<li><a href="#orga443237">MessageToMessageEncoder</a></li>
</ul>
</li>
<li><a href="#org64b7593">抽象 Codec 类</a>
<ul>
<li><a href="#orgb84e772">ByteToMessageCodec</a></li>
<li><a href="#orgfbb37fc">MessageToMessageCodec</a></li>
<li><a href="#orgcb4270b">CombinedChannelDuplexHandler</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章介绍：
</p>
<ul class="org-ul">
<li>Decoder(解码器)</li>
<li>Encoder(编码器)</li>
<li>Codec(编解码器)</li>
</ul>

<p>
在前面的章节中，我们讨论了连接到拦截操作或数据处理链的不同方式，展示了如何使用 ChannelHandler 及其相关的类来实现几乎任何一种应用程序所需的逻辑。但正如标准架构模式通常有专门的框架，通用处理模式很适合使用目标实现，可以节省我们大量的开发时间和精力
</p>

<p>
在这一章，我们将研究编码和解码： <b>数据从一种特定协议格式到另一种格式的转换</b> 。这种处理模式是由通常被称为 <b>codecs</b> 的组件来处理的。Netty提供了一些组件，利用它们可以很容易地为各种不同协议编写编解码器。例如，如果您正在构建一个基于 Netty 的邮件服务器，你可以使用POP3, IMAP 和 SMTP的现成的实现
</p>

<div id="outline-container-orgeebb589" class="outline-2">
<h2 id="orgeebb589">Codec</h2>
<div class="outline-text-2" id="text-orgeebb589">
<p>
编写一个网络应用程序需要实现某种 codec (编解码器)，codec的作用就是 <b>将原始字节数据与目标程序数据格式进行互转</b> 。网络中都是以字节码的数据形式来传输数据的，codec 由两部分组成：
</p>
<ul class="org-ul">
<li>decoder: 解码器</li>
<li>encoder: 编码器</li>
</ul>

<p>
编码器和解码器一个字节序列转换为另一个业务对象。一个 <b>消息</b> 是一个结构化的字节序列，语义为一个特定的应用程序的 <b>数据</b> 。encoder 是组件，转换消息格式适合传输(就像字节流)，而相应的 decoder 转换传输数据回到程序的消息格式。逻辑上,  <b>从</b> 消息转换来是当作操作  <b>outbound（出站）</b> 数据,而转换， <b>到</b> 消息是处理  <b>inbound（入站）</b> 数据
</p>
</div>

<div id="outline-container-orgb34c507" class="outline-3">
<h3 id="orgb34c507">Decoder</h3>
<div class="outline-text-3" id="text-orgb34c507">
<p>
Netty 提供了丰富的解码器抽象基类，可以很容易的实现这些基类来自定义解码器。主要分两类：
</p>
<ul class="org-ul">
<li>解码字节到消息
<ul class="org-ul">
<li>ByteToMessageDecoder</li>
<li>ReplayingDecoder</li>
</ul></li>
<li>解码消息到消息
+MessageToMessageDecoder</li>
</ul>

<p>
decoder 负责将 <b>入站</b> 数据从一种格式转换到另一种格式，Netty的解码器是一种 ChannelInboundHandler 的抽象实现。实践中使用解码器很简单，就是将入站数据转换格式后传递到 ChannelPipeline 中的下一个ChannelInboundHandler 进行处理
</p>

<p>
这样的处理是很灵活的，可以将解码器放在 ChannelPipeline 中，重用逻辑
</p>
</div>

<div id="outline-container-org9f54716" class="outline-4">
<h4 id="org9f54716">ByteToMessageDecoder</h4>
<div class="outline-text-4" id="text-org9f54716">
<p>
ByteToMessageDecoder 是用于将字节转为消息（或其他字节序列）
</p>

<p>
不能确定远端是否会一次发送完一个完整的信息，因此这个类会缓存入站的数据，直到准备好了用于处理。表7.1说明了它的两个最重要的方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> ByteToMessageDecoder 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">decode</td>
<td class="org-left">This is the only abstract method you need to implement. It is called with a ByteBuf having the incoming bytes and a List into which decoded messages are added. decode() is called repeatedly until the List is empty on return. The contents of the List are then passed to the next handler in the pipeline</td>
</tr>

<tr>
<td class="org-left">decodeLast</td>
<td class="org-left">The default implementation provided simply calls decode().This method is called once, when the Channel goes inactive. Override to provide special handling</td>
</tr>
</tbody>
</table>

<p>
假设我们接收一个包含简单整数的字节流，每个都单独处理。在本例中，将从入站 ByteBuf 读取每个整数并将其传递给 pipeline 中的下一个ChannelInboundHandler。扩展ByteToMessageDecoder来实现解码字节流成整数，如图7.1所示：
</p>

<div class="figure">
<p><img src="pic/to-integer-decoder.jpg" alt="to-integer-decoder.jpg" width="70%" />
</p>
</div>

<p>
每次从入站的 ByteBuf 读取四个字节，解码成整形，并添加到一个 List ，当不能再添加数据到 List 时，它所包含的内容就会被发送到下个 ChannelInboundHandler：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ToIntegerDecoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ByteToMessageDecoder</span> {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#23454;&#29616;&#32487;&#25215;&#20102; ByteToMessageDecode &#29992;&#20110;&#23558;&#23383;&#33410;&#35299;&#30721;&#20026;&#28040;&#24687;</span>
    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">in</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        <span style="color: #00bfff; font-weight: bold;">if</span> (in.readableBytes() &gt;= 4) {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#26816;&#26597;&#21487;&#35835;&#30340;&#23383;&#33410;&#26159;&#21542;&#33267;&#23569;&#26377;4&#20010; ( int &#26159;4&#20010;&#23383;&#33410;&#38271;&#24230;)</span>
            out.add(in.readInt());  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#20174;&#20837;&#31449; ByteBuf &#35835;&#21462; int &#65292; &#28155;&#21152;&#21040;&#35299;&#30721;&#28040;&#24687;&#30340; List &#20013;</span>
        }
    }
}
</pre>
</div>

<p>
尽管 ByteToMessageDecoder 简化了这个模式，你会发现它还是有点烦人。在实际的读操作(readInt)之前，必须要验证输入的 ByteBuf 要有足够的数据。在下一节中将看看 ReplayingDecoder，一个特殊的解码器
</p>

<p>
引用计数对于编码器和解码器来说，这个过程非常简单。一旦一个消息被编码或解码它自动被调用ReferenceCountUtil.release(message) 。如果你稍后还需要用到这个引用而不是马上释放，你可以调用 <b>ReferenceCountUtil.retain(message)</b> 。这将 <b>增加引用计数防止消息被释放</b>
</p>
</div>
</div>

<div id="outline-container-org4f83639" class="outline-4">
<h4 id="org4f83639">ReplayingDecoder</h4>
<div class="outline-text-4" id="text-org4f83639">
<p>
ReplayingDecoder 是 byte-to-message 解码的一种特殊的抽象基类，读取缓冲区的数据之前需要检查缓冲区是否有足够的字节，使用ReplayingDecoder就无需自己检查：
</p>
<ul class="org-ul">
<li>若ByteBuf中有足够的字节，则会正常读取</li>
<li>若没有足够的字节则会停止解码</li>
</ul>
</div>

<div id="outline-container-org86f6969" class="outline-5">
<h5 id="org86f6969">ByteToMessageDecoder VS ReplayingDecoder</h5>
<div class="outline-text-5" id="text-org86f6969">
<p>
ReplayingDecoder 继承自 ByteToMessageDecoder ，所以两者 API 是相同的。也正因为这样的包装使得 ReplayingDecoder 带有一定的局限性：
</p>
<ul class="org-ul">
<li>不是所有的标准 ByteBuf 操作都被支持，如果调用一个不支持的操作会抛出 UnreplayableOperationException</li>
<li>ReplayingDecoder 略慢于 ByteToMessageDecoder</li>
</ul>

<p>
如果这些限制是可以接受你可能更喜欢使用 ReplayingDecoder。下面是一个简单的准则：
</p>
<pre class="example">
如果不引入过多的复杂性 使用 ByteToMessageDecoder ，否则使用ReplayingDecoder
</pre>

<p>
使用 ReplayingDecoder 更简单：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ToIntegerDecoder2</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ReplayingDecoder</span>&lt;<span style="color: #98f5ff;">Void</span>&gt; {   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#23454;&#29616;&#32487;&#25215;&#33258; ReplayingDecoder &#29992;&#20110;&#23558;&#23383;&#33410;&#35299;&#30721;&#20026;&#28040;&#24687;</span>

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">in</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        out.add(in.readInt());  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20174;&#20837;&#31449; ByteBuf &#35835;&#21462;&#25972;&#22411;&#65292;&#24182;&#28155;&#21152;&#21040;&#35299;&#30721;&#28040;&#24687;&#30340; List &#20013;</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc619189" class="outline-5">
<h5 id="orgc619189">更多 Decoder</h5>
<div class="outline-text-5" id="text-orgc619189">
<ul class="org-ul">
<li>io.netty.handler.codec.LineBasedFrameDecoder: 通过结束控制符( <b>\n</b> 或 <b>\r\n</b> )解析入站数据</li>
<li>io.netty.handler.codec.http.HttpObjectDecoder: 用于 HTTP 数据解码</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgedb9cca" class="outline-4">
<h4 id="orgedb9cca">MessageToMessageDecoder</h4>
<div class="outline-text-4" id="text-orgedb9cca">
<p>
用于从一种消息解码为另外一种消息（例如 POJO 到 POJO），下表展示了方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> ByteToMessageDecoder 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">decode</td>
<td class="org-left">decode is the only abstract method you need to implement. It is called for each inbound message to be decoded to another format . The decoded messages are then passed to the next ChannelInboundHandler in the pipeline</td>
</tr>

<tr>
<td class="org-left">decodeLast</td>
<td class="org-left">The default implementation provided simply calls decode().This method is called once, when the Channel goes inactive. Override to provide special handling</td>
</tr>
</tbody>
</table>

<p>
将 Integer 转为 String，提供了 IntegerToStringDecoder，继承自 MessageToMessageDecoder。因为这是一个参数化的类，所以实现的签名是：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">IntegerToStringDecoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">MessageToMessageDecoder</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt;
</pre>
</div>

<p>
decode() 方法的签名是：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>( <span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>,
               <span style="color: #98f5ff;">Integer</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span> ) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span>
</pre>
</div>

<p>
也就是说，入站消息是按照在 <b>类定义中声明的参数类型</b> (Integer) 而不是 ByteBuf来解析的。 <b>解码消息</b> (String)将被添加到List，并传递到下个 ChannelInboundHandler。 这是如图7.2所示：
</p>


<div class="figure">
<p><img src="pic/integer-to-string-decoder.jpg" alt="integer-to-string-decoder.jpg" width="70%" />
</p>
</div>

<p>
实现如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">IntegerToStringDecoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span>
                    <span style="color: #98f5ff;">MessageToMessageDecoder</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt; { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#23454;&#29616;&#32487;&#25215;&#33258; MessageToMessageDecoder </span>

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">Integer</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        out.add(String.valueOf(msg)); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#36890;&#36807; String.valueOf() &#36716;&#25442; Integer &#28040;&#24687;&#23383;&#31526;&#20018;</span>
    }
}
</pre>
</div>

<p>
正如上面指出的：decode()方法的消息参数的类型是由给这个类指定的泛型的类型(Integer)确定的
</p>
</div>

<div id="outline-container-org4dfc426" class="outline-5">
<h5 id="org4dfc426">HttpObjectAggregator</h5>
<div class="outline-text-5" id="text-org4dfc426">
<p>
更多复杂的示例，请查看类 io.netty.handler.codec.http.HttpObjectAggregator，继承自MessageToMessageDecoder
</p>
</div>
</div>
</div>

<div id="outline-container-org0b98e75" class="outline-4">
<h4 id="org0b98e75">在解码时处理太大的帧</h4>
<div class="outline-text-4" id="text-org0b98e75">
<p>
Netty 是异步框架需要缓冲区字节在内存中，直到能够解码它们。因此，不能让你的解码器缓存太多的数据以免耗尽可用内存。为了解决这个共同关心的问题， Netty 提供了一个 TooLongFrameException ，通常由解码器在帧太长时抛出
</p>

<p>
为了避免这个问题，可以在你的解码器里设置一个最大字节数阈值。如果超出，将导致 TooLongFrameException 抛出(并由 ChannelHandler.exceptionCaught() 捕获)。然后由译码器的用户决定如何处理它。虽然一些协议,比如 HTTP、允许这种情况下有一个特殊的响应,有些可能没有，事件唯一的选择可能就是关闭连接
</p>

<p>
如下所示 ByteToMessageDecoder 可以利用 TooLongFrameException 通知其他 ChannelPipeline 中的 ChannelHandler：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">SafeByteToMessageDecoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ByteToMessageDecoder</span> {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#23454;&#29616;&#32487;&#25215; ByteToMessageDecoder &#26469;&#23558;&#23383;&#33410;&#35299;&#30721;&#20026;&#28040;&#24687;</span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">MAX_FRAME_SIZE</span> = 1024;

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">in</span>,
               <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">readable</span> = in.readableBytes();
        <span style="color: #00bfff; font-weight: bold;">if</span> (readable &gt; MAX_FRAME_SIZE) { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#26816;&#27979;&#32531;&#20914;&#21306;&#25968;&#25454;&#26159;&#21542;&#22823;&#20110; MAX_FRAME_SIZE</span>
            in.skipBytes(readable);        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#24573;&#30053;&#25152;&#26377;&#21487;&#35835;&#30340;&#23383;&#33410;&#65292;&#24182;&#25243;&#20986; TooLongFrameException &#26469;&#36890;&#30693; ChannelPipeline &#20013;&#30340; ChannelHandler</span>
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">TooLongFrameException</span>(<span style="color: #deb887;">"Frame too big!"</span>);
        }
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">do something</span>
    }
}
</pre>
</div>

<p>
这种保护是很重要的，尤其是当你解码一个有可变帧大小的协议的时候 
</p>
</div>
</div>
</div>

<div id="outline-container-org65695df" class="outline-3">
<h3 id="org65695df">Encoder</h3>
<div class="outline-text-3" id="text-org65695df">
<p>
encoder 是用来把出站数据从一种格式转换到另外一种格式，因此它实现了 ChanneOutboundHandler 。正如所期望的一样，类似于 decoder，Netty 也提供了一组类来帮助你写 encoder，当然这些类提供的是与 decoder 相反的方法，如下所示：
</p>
<ul class="org-ul">
<li>编码从消息到字节</li>
<li>编码从消息到消息</li>
</ul>
</div>

<div id="outline-container-org113654d" class="outline-4">
<h4 id="org113654d">MessageToByteEncoder</h4>
<div class="outline-text-4" id="text-org113654d">
<p>
使用 MessageToByteEncoder 实现从消息到字节
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> MessageToByteEncoder 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">encode</td>
<td class="org-left">The encode method is the only abstract method you need to implement. It is called with the outbound message, which this class will encodes to a ByteBuf. The ByteBuf is then forwarded to the next ChannelOutboundHandler in the ChannelPipeline</td>
</tr>
</tbody>
</table>

<p>
这个类只有一个方法，而 decoder 却是有两个，原因就是 decoder 经常需要在 Channel 关闭时产生一个 <b>最后的消息</b> 。出于这个原因，提供了decodeLast()，而 encoder 没有这个需求
</p>

<p>
下面示例，想产生 Short 值，并想将他们编码成 ByteBuf 来发送到 线上，因此提供了 ShortToByteEncoder 来实现该目的
</p>


<div class="figure">
<p><img src="pic/short-encode-byte.jpg" alt="short-encode-byte.jpg" width="70%" />
</p>
</div>

<p>
上图展示了，encoder 收到了 Short 消息，编码他们，并把他们写入 ByteBuf。 ByteBuf 接着前进到下一个 pipeline 的ChannelOutboundHandler。每个 Short 将占用 ByteBuf 的两个字节：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ShortToByteEncoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span>
                <span style="color: #98f5ff;">MessageToByteEncoder</span>&lt;<span style="color: #98f5ff;">Short</span>&gt; {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#23454;&#29616;&#32487;&#25215;&#33258; MessageToByteEncoder</span>
    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">encode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">Short</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        out.writeShort(msg);  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20889; Short &#21040; ByteBuf</span>
    }
}
</pre>
</div>

<p>
Netty 提供很多 MessageToByteEncoder 类来帮助你的实现自己的 encoder 。其中 WebSocket08FrameEncoder 就是个不错的范例。可以在 io.netty.handler.codec.http.websocketx 包找到
</p>
</div>
</div>

<div id="outline-container-orga443237" class="outline-4">
<h4 id="orga443237">MessageToMessageEncoder</h4>
<div class="outline-text-4" id="text-orga443237">
<p>
MessageToMessageEncoder 提供一种方法来将出站数据从一种消息编码成另一种消息，同样的只有一个方法,因为不需要产生 <b>最后的消息</b> 
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> MessageToMessageEncoder 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">encode</td>
<td class="org-left">The encode method is the only abstract method you need to implement. It is called for each message written with write(&#x2026;) to encode the message to one or multiple new outbound messages. The encoded messages are then forwarded</td>
</tr>
</tbody>
</table>

<p>
下面例子，将要解码 Integer 消息到 String 消息。可简单使用 MessageToMessageEncoder
</p>

<div class="figure">
<p><img src="pic/integer-encode-string.jpg" alt="integer-encode-string.jpg" width="70%" />
</p>
</div>

<p>
encoder 从出站字节流提取 Integer，以 String 形式传递给ChannelPipeline 中的下一个 ChannelOutboundHandler ：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">IntegerToStringEncoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span>
                    <span style="color: #98f5ff;">MessageToMessageEncoder</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt; { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#23454;&#29616;&#32487;&#25215;&#33258; MessageToMessageEncoder</span>

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">encode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">Integer</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        out.add(String.valueOf(msg));  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#36716; Integer &#20026; String&#65292;&#24182;&#28155;&#21152;&#21040; MessageBuf</span>
    }
}
</pre>
</div>

<p>
更复杂 的 MessageToMessageEncoder 应用案例，可以查看 io.netty.handler.codec.protobuf 包下的 ProtobufEncoder
</p>
</div>
</div>
</div>

<div id="outline-container-org64b7593" class="outline-3">
<h3 id="org64b7593">抽象 Codec 类</h3>
<div class="outline-text-3" id="text-org64b7593">
<p>
虽然我们一直把解码器和编码器作为不同的实体来讨论，但有时可能会发现把入站和出站的数据和信息转换都放在同一个类中更实用。Netty的抽象编解码器类就是用于这个目的,他们把一些成对的解码器和编码器组合在一起，以此来提供对于字节和消息都相同的操作。(这些类实现了 ChannelInboundHandler 和 ChannelOutboundHandler )
</p>

<p>
是否有时候使用单独的解码器和编码器会比使用这些组合类要好？最简单的答案是： <b>紧密耦合的两个函数减少了他们的可重用性，但是把他们分开实现就会更容易扩展</b> 
</p>
</div>

<div id="outline-container-orgb84e772" class="outline-4">
<h4 id="orgb84e772">ByteToMessageCodec</h4>
<div class="outline-text-4" id="text-orgb84e772">
<p>
需要解码字节到消息，也许是一个 POJO，然后转回来。ByteToMessageCodec 将处理这个问题，因为它结合了ByteToMessageDecoder 和 MessageToByteEncoder。表7.5中列出的重要方法：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> ByteToMessageCodec 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">decode</td>
<td class="org-left">This method is called as long as bytes are available to be consumed. It converts the inbound ByteBuf to the specified message format and forwards them to the next ChannelInboundHandler in the pipeline</td>
</tr>

<tr>
<td class="org-left">decodeLast</td>
<td class="org-left">The default implementation of this method delegates to decode(). It is called only be called once, when the Channel goes inactive. For special handling it can be oerridden</td>
</tr>

<tr>
<td class="org-left">encode</td>
<td class="org-left">This method is called for each message to be written through the ChannelPipeline. The encoded messages are contained in a ByteBuf which</td>
</tr>
</tbody>
</table>

<p>
例如 SMTP：编解码器将读取入站字节并解码到一个自定义的消息类型 SmtpRequest。当接收到一个 SmtpResponse 会产生用于编码为字节进行传输
</p>
</div>
</div>

<div id="outline-container-orgfbb37fc" class="outline-4">
<h4 id="orgfbb37fc">MessageToMessageCodec</h4>
<div class="outline-text-4" id="text-orgfbb37fc">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 6:</span> MessageToMessageCodec 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">decode</td>
<td class="org-left">This method is called with the inbound messages of the codec and decodes them to messages. Those messages are forwarded to the next ChannelInboundHandler in the ChannelPipeline</td>
</tr>

<tr>
<td class="org-left">decodeLast</td>
<td class="org-left">Default implementation delegates to decode().decodeLast will only be called one time, which is when the Channel goes inactive. If you need special handling here you may override decodeLast() to implement it</td>
</tr>

<tr>
<td class="org-left">encode</td>
<td class="org-left">The encode method is called for each outbound message to be moved through the ChannelPipeline. The encoded messages are forwarded to the next ChannelOutboundHandler in the pipeline</td>
</tr>
</tbody>
</table>

<p>
MessageToMessageCodec 是一个参数化的类，定义如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MessageToMessageCodec</span>&lt;<span style="color: #98f5ff;">INBOUND</span>,<span style="color: #98f5ff;">OUTBOUND</span>&gt;
</pre>
</div>

<p>
上面所示的完整签名的方法都是这样的：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">encode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>,
                   <span style="color: #98f5ff;">OUTBOUND</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>);

<span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>,
                   <span style="color: #98f5ff;">INBOUND</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>);
</pre>
</div>

<p>
encode() 处理出站消息类型 OUTBOUND 到 INBOUND，而 decode() 则相反
</p>

<p>
在现实中存在一个相当常见的用例，往往涉及两个来回转换的数据消息传递API 。我们不得不与遗留或专有的消息格式进行互操作。在下面的例子中，WebSocketConvertHandler 是一个静态嵌套类，继承了参数为 WebSocketFrame（类型为 INBOUND）和 WebSocketFrame（类型为 OUTBOUND）：
</p>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">WebSocketConvertHandler</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">MessageToMessageCodec</span>&lt;<span style="color: #98f5ff;">WebSocketFrame</span>, <span style="color: #ffd700;">WebSocketConvertHandler</span>.<span style="color: #98f5ff;">WebSocketFrame</span>&gt; {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#32534;&#30721; WebSocketFrame &#28040;&#24687;&#36716;&#20026; WebSocketFrame &#28040;&#24687;</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">WebSocketConvertHandler</span> <span style="color: #4eee94;">INSTANCE</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketConvertHandler</span>();

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">encode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">WebSocketFrame</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {   
        <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">payload</span> = msg.getData().duplicate().retain();
        <span style="color: #00bfff; font-weight: bold;">switch</span> (msg.getType()) {   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#26816;&#27979; WebSocketFrame &#30340; FrameType &#31867;&#22411;&#65292;&#24182;&#19988;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#21709;&#24212;&#30340; FrameType &#31867;&#22411;&#30340; WebSocketFrame</span>
        <span style="color: #00bfff; font-weight: bold;">case</span> BINARY:
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">BinaryWebSocketFrame</span>(payload));
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">case</span> TEXT:
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">TextWebSocketFrame</span>(payload));
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">case</span> CLOSE:
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">CloseWebSocketFrame</span>(<span style="color: #ffd700;">true</span>, 0, payload));
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">case</span> CONTINUATION:
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ContinuationWebSocketFrame</span>(payload));
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">case</span> PONG:
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">PongWebSocketFrame</span>(payload));
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">case</span> PING:
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">PingWebSocketFrame</span>(payload));
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">default</span>:
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">IllegalStateException</span>(<span style="color: #deb887;">"Unsupported websocket msg "</span> + msg);
        }
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #ffd700;">io</span>.<span style="color: #ffd700;">netty</span>.<span style="color: #ffd700;">handler</span>.<span style="color: #ffd700;">codec</span>.<span style="color: #ffd700;">http</span>.<span style="color: #ffd700;">websocketx</span>.<span style="color: #98f5ff;">WebSocketFrame</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        <span style="color: #00bfff; font-weight: bold;">if</span> (msg <span style="color: #00bfff; font-weight: bold;">instanceof</span> BinaryWebSocketFrame) {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#36890;&#36807; instanceof &#26469;&#26816;&#27979;&#27491;&#30830;&#30340; FrameType</span>
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketFrame</span>(<span style="color: #ffd700;">WebSocketFrame</span>.<span style="color: #ffd700;">FrameType</span>.BINARY, msg.content().copy()));
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (msg <span style="color: #00bfff; font-weight: bold;">instanceof</span> CloseWebSocketFrame) {
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketFrame</span>(<span style="color: #ffd700;">WebSocketFrame</span>.<span style="color: #ffd700;">FrameType</span>.CLOSE, msg.content().copy()));
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (msg <span style="color: #00bfff; font-weight: bold;">instanceof</span> PingWebSocketFrame) {
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketFrame</span>(<span style="color: #ffd700;">WebSocketFrame</span>.<span style="color: #ffd700;">FrameType</span>.PING, msg.content().copy()));
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (msg <span style="color: #00bfff; font-weight: bold;">instanceof</span> PongWebSocketFrame) {
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketFrame</span>(<span style="color: #ffd700;">WebSocketFrame</span>.<span style="color: #ffd700;">FrameType</span>.PONG, msg.content().copy()));
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (msg <span style="color: #00bfff; font-weight: bold;">instanceof</span> TextWebSocketFrame) {
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketFrame</span>(<span style="color: #ffd700;">WebSocketFrame</span>.<span style="color: #ffd700;">FrameType</span>.TEXT, msg.content().copy()));
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (msg <span style="color: #00bfff; font-weight: bold;">instanceof</span> ContinuationWebSocketFrame) {
            out.add(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WebSocketFrame</span>(<span style="color: #ffd700;">WebSocketFrame</span>.<span style="color: #ffd700;">FrameType</span>.CONTINUATION, msg.content().copy()));
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">IllegalStateException</span>(<span style="color: #deb887;">"Unsupported websocket msg "</span> + msg);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">WebSocketFrame</span> {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#33258;&#23450;&#20041;&#28040;&#24687;&#31867;&#22411; WebSocketFrame</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">enum</span> <span style="color: #98f5ff;">FrameType</span> {        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#26522;&#20030;&#31867;&#26126;&#30830;&#20102; WebSocketFrame &#30340;&#31867;&#22411;</span>
            <span style="color: #4eee94;">BINARY</span>,
            <span style="color: #4eee94;">CLOSE</span>,
            <span style="color: #4eee94;">PING</span>,
            <span style="color: #4eee94;">PONG</span>,
            <span style="color: #4eee94;">TEXT</span>,
            <span style="color: #4eee94;">CONTINUATION</span>
        }

        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">FrameType</span> <span style="color: #4eee94;">type</span>;
        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">data</span>;
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">WebSocketFrame</span>(<span style="color: #98f5ff;">FrameType</span> <span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">data</span>) {
            <span style="color: #00bfff; font-weight: bold;">this</span>.type = type;
            <span style="color: #00bfff; font-weight: bold;">this</span>.data = data;
        }

        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">FrameType</span> <span style="color: #daa520; font-weight: bold;">getType</span>() {
            <span style="color: #00bfff; font-weight: bold;">return</span> type;
        }

        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #daa520; font-weight: bold;">getData</span>() {
            <span style="color: #00bfff; font-weight: bold;">return</span> data;
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb4270b" class="outline-4">
<h4 id="orgcb4270b">CombinedChannelDuplexHandler</h4>
<div class="outline-text-4" id="text-orgcb4270b">
<p>
结合解码器和编码器在一起可能会牺牲可重用性。为了避免这种方式，并且部署一个解码器和编码器到 ChannelPipeline 作为逻辑单元而不失便利性
</p>

<p>
关键是下面的类：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">CombinedChannelDuplexHandler</span>&lt;<span style="color: #98f5ff;">I</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ChannelInboundHandler</span>,
                        <span style="color: #98f5ff;">O</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ChannelOutboundHandler</span>&gt;
</pre>
</div>

<p>
这个类是扩展 ChannelInboundHandler 和 ChannelOutboundHandler 参数化的类型。这提供了一个容器，单独的解码器和编码器类合作而无需直接扩展抽象的编解码器类。将在下面的例子说明这一点。首先查看 ByteToCharDecoder ：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ByteToCharDecoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span>
                   <span style="color: #98f5ff;">ByteToMessageDecoder</span> { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#32487;&#25215; ByteToMessageDecoder</span>

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">decode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">in</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        <span style="color: #00bfff; font-weight: bold;">if</span> (in.readableBytes() &gt;= 2) {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20889; char &#21040; MessageBuf</span>
            out.add(in.readChar());
        }
    }
}
</pre>
</div>

<p>
decode() 方法从输入数据中提取两个字节，并将它们作为一个 char 写入 List 。(注意：扩展 ByteToMessageDecoder 因为它从 ByteBuf 读取字符)
</p>

<p>
下面是把字符转换为字节的编码器：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">CharToByteEncoder</span> <span style="color: #00bfff; font-weight: bold;">extends</span>
                   <span style="color: #98f5ff;">MessageToByteEncoder</span>&lt;<span style="color: #98f5ff;">Character</span>&gt; { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#32487;&#25215; MessageToByteEncoder</span>

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">encode</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">Character</span> <span style="color: #4eee94;">msg</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">out</span>)
        <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        out.writeChar(msg);   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20889; char &#21040; ByteBuf</span>
    }
}
</pre>
</div>

<p>
这个实现继承自 MessageToByteEncoder ，因为需要编码 char 消息 到 ByteBuf。这将直接将字符串写为 ByteBuf
</p>

<p>
现在有了编码器和解码器，将他们组成一个编解码器：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">CombinedByteCharCodec</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">CombinedChannelDuplexHandler</span>&lt;<span style="color: #98f5ff;">ByteToCharDecoder</span>,
                                        <span style="color: #98f5ff;">CharToByteEncoder</span>&gt; { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21442;&#25968;&#26159;&#35299;&#30721;&#22120;&#21644;&#32534;&#30721;&#22120;&#30340;&#23454;&#29616;&#29992;&#20110;&#22788;&#29702;&#36827;&#31449;&#23383;&#33410;&#21644;&#20986;&#31449;&#28040;&#24687;</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">CombinedByteCharCodec</span>() {
        <span style="color: #00bfff; font-weight: bold;">super</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ByteToCharDecoder</span>(), <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">CharToByteEncoder</span>()); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20256;&#36882; ByteToCharDecoder &#21644; CharToByteEncoder &#23454;&#20363;&#21040; super &#26500;&#36896;&#20989;&#25968;&#26469;&#22996;&#25176;&#35843;&#29992;&#20351;&#20182;&#20204;&#32467;&#21512;&#36215;&#26469;</span>
    }
}
</pre>
</div>

<p>
上述方式来使程序更简单、更灵活，而不是使用一个以上的编解码器类。它也可以归结到你个人喜好或风格
</p>

<p>
<a href="embedded.html">Next：内置的 ChannelHandler 和 Codecs</a>
</p>

<p>
<a href="channel.html">Previous：ChannelHandler</a>
</p>

<p>
<a href="netty.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
