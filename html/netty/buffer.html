<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>缓冲</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="transport.html"> UP </a>
 |
 <a accesskey="H" href="netty.html"> HOME </a>
</div><div id="content">
<h1 class="title">缓冲</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd741050">Buffer API</a></li>
<li><a href="#orgd327a1a">ByteBuf</a>
<ul>
<li><a href="#org4b411f2">原理</a></li>
<li><a href="#orgaefa0c6">使用</a>
<ul>
<li><a href="#org23e9143">Heap Buffer(堆缓冲区)</a></li>
<li><a href="#org8d753c8">Direct buffer (直接缓冲区)</a></li>
<li><a href="#org3909b88">Composite Buffer (复合缓冲区)</a></li>
</ul>
</li>
<li><a href="#orgd14307e">字节级别的操作</a>
<ul>
<li><a href="#org8514b60">随机访问索引</a></li>
<li><a href="#orgafedd31">顺序访问索引</a>
<ul>
<li><a href="#org653ddc6">可丢弃字节的字节</a></li>
<li><a href="#orge0bf6e3">可读字节</a></li>
</ul>
</li>
<li><a href="#org2601475">索引管理</a></li>
<li><a href="#org0f5e1a9">查询操作</a></li>
<li><a href="#org0b86bb9">衍生的缓冲区</a>
<ul>
<li><a href="#org73e5c0a">ByteBuf 拷贝</a></li>
</ul>
</li>
<li><a href="#org1350b19">读/写操作</a></li>
</ul>
</li>
<li><a href="#org6bb69f7">更多操作</a></li>
</ul>
</li>
<li><a href="#orgfeaae17">ByteBufHolder</a>
<ul>
<li><a href="#orgd84c6ff">ByteBuf 分配</a>
<ul>
<li><a href="#org2e2e7d2">ByteBufAllocator</a>
<ul>
<li><a href="#orgc22d1e9">Unpooled 缓存</a></li>
</ul>
</li>
<li><a href="#org7ed41c1">ByteBufUtil</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org657df26">引用计数器</a></li>
</ul>
</div>
</div>
<p>
网络数据的基本单位永远是 byte(字节)。Java NIO 提供 ByteBuffer 作为字节的容器，但这个类是过于复杂，有点难以使用
</p>

<p>
Netty 中 ByteBuffer 替代是 ByteBuf，一个强大的实现，解决 JDK 的 API 的限制，以及为网络应用程序开发者一个更好的工具。 但 ByteBuf 并不仅仅暴露操作一个字节序列的方法，这也是专门的Netty 的 ChannelPipeline 的语义设计
</p>

<p>
在本章中，我们会说明相比于 JDK 的 API，ByteBuf 所提供的卓越的功能和灵活性。这也将使我们能够更好地理解了 Netty 的数据处理
</p>

<div id="outline-container-orgd741050" class="outline-2">
<h2 id="orgd741050">Buffer API</h2>
<div class="outline-text-2" id="text-orgd741050">
<p>
主要包括：
</p>
<ul class="org-ul">
<li>ByteBuf</li>
<li>ByteBufHolder</li>
</ul>

<p>
Netty 使用 reference-counting 来判断何时可以释放 ByteBuf 或 ByteBufHolder 和其他相关资源，从而可以利用池和其他技巧来提高性能和降低内存的消耗。这一点上不需要开发人员做任何事情，但是在开发 Netty 应用程序时，尤其是使用 ByteBuf 和 ByteBufHolder 时，你应该尽可能早地释放池资源。 Netty 缓冲 API 提供了几个优势：
</p>
<ul class="org-ul">
<li>可以自定义缓冲类型</li>
<li>通过一个内置的复合缓冲类型实现零拷贝</li>
<li>扩展性好，比如 StringBuilder</li>
<li>不需要调用 flip() 来切换读/写模式</li>
<li>读取和写入索引分开</li>
<li>方法链</li>
<li>引用计数</li>
<li>Pooling(池)</li>
</ul>
</div>
</div>

<div id="outline-container-orgd327a1a" class="outline-2">
<h2 id="orgd327a1a">ByteBuf</h2>
<div class="outline-text-2" id="text-orgd327a1a">
<p>
因为所有的网络通信最终都是基于底层的字节流传输，因此一个高效、方便、易用的数据接口是必要的，而 Netty 的 ByteBuf 满足这些需求
</p>

<p>
ByteBuf 是一个很好的经过优化的数据容器，可以将字节数据有效的添加到 ByteBuf 中或从 ByteBuf 中获取数据。ByteBuf 有2部分：
</p>
<ul class="org-ul">
<li>一个用于读</li>
<li>一个用于写</li>
</ul>

<p>
可以按顺序的读取数据，也可以通过调整读取数据的索引或者直接将读取位置索引作为参数传递给get方法来重复读取数据 
</p>
</div>

<div id="outline-container-org4b411f2" class="outline-3">
<h3 id="org4b411f2">原理</h3>
<div class="outline-text-3" id="text-org4b411f2">
<p>
写入数据到 ByteBuf 后，writerIndex（写入索引）增加。开始读字节后，readerIndex（读取索引）增加。你可以读取字节，直到写入索引和读取索引处在相同的位置，ByteBuf 变为不可读。当访问数据超过数组的最后位，则会抛出 IndexOutOfBoundsException
</p>

<p>
调用 ByteBuf 的 <b>read 或 *write</b> 开头的任何方法都会提升相应的索引。另一方面， <b>set</b>  、 <b>get</b> 操作字节将不会移动索引位置，他们只会操作相关的通过参数传入方法的相对索引
</p>

<p>
可以给ByteBuf指定一个最大容量值，这个值限制着ByteBuf的容量。任何尝试将写入索引超过这个值的行为都将导致抛出异常。ByteBuf 的默认最大容量限制是 Integer.MAX_VALUE
</p>

<p>
ByteBuf 类似于一个字节数组，最大的区别是读和写的索引可以用来控制对缓冲区数据的访问。下图显示了一个容量为16的空的 ByteBuf 的布局和状态，writerIndex 和 readerIndex 都在索引位置 0 ：
</p>


<div class="figure">
<p><img src="pic/ByteBuf.jpg" alt="ByteBuf.jpg" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgaefa0c6" class="outline-3">
<h3 id="orgaefa0c6">使用</h3>
<div class="outline-text-3" id="text-orgaefa0c6">
</div>
<div id="outline-container-org23e9143" class="outline-4">
<h4 id="org23e9143">Heap Buffer(堆缓冲区)</h4>
<div class="outline-text-4" id="text-org23e9143">
<p>
最常用的模式是 ByteBuf 将数据存储在 JVM 的堆空间，这是通过将数据存储在数组的实现。堆缓冲区可以快速分配，当不使用时也可以快速释放。它还提供了直接访问数组的方法，通过 ByteBuf.array() 来获取 byte[]数据。 这种方法，正如清单5.1中所示的那样，是非常适合用来处理遗留数据的
</p>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">heapBuf</span> = ...;
<span style="color: #00bfff; font-weight: bold;">if</span> (heapBuf.hasArray()) {                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#26816;&#26597; ByteBuf &#26159;&#21542;&#26377;&#25903;&#25345;&#25968;&#32452;</span>
    <span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">array</span> = heapBuf.array();        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#22914;&#26524;&#26377;&#30340;&#35805;&#65292;&#24471;&#21040;&#24341;&#29992;&#25968;&#32452;</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">offset</span> = heapBuf.arrayOffset() + heapBuf.readerIndex();                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#35745;&#31639;&#31532;&#19968;&#23383;&#33410;&#30340;&#20559;&#31227;&#37327;</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">length</span> = heapBuf.readableBytes(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#33719;&#21462;&#21487;&#35835;&#30340;&#23383;&#33410;&#25968;</span>
    handleArray(array, offset, length); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#20351;&#29992;&#25968;&#32452;&#65292;&#20559;&#31227;&#37327;&#21644;&#38271;&#24230;&#20316;&#20026;&#35843;&#29992;&#26041;&#27861;&#30340;&#21442;&#25968;</span>
}
</pre>
</div>

<p>
注意：
</p>
<ul class="org-ul">
<li>访问非堆缓冲区 ByteBuf 的数组会导致UnsupportedOperationException， 可以使用 ByteBuf.hasArray()来检查是否支持访问数组</li>
<li>这个用法与 JDK 的 ByteBuffer 类似</li>
</ul>
</div>
</div>

<div id="outline-container-org8d753c8" class="outline-4">
<h4 id="org8d753c8">Direct buffer (直接缓冲区)</h4>
<div class="outline-text-4" id="text-org8d753c8">
<p>
<b>直接缓冲区</b> 是另一个 ByteBuf 模式。对象的所有内存分配发生在堆？好吧，并非总是如此。在 JDK1.4 中被引入 NIO 的ByteBuffer 类允许 JVM 通过本地方法调用分配内存，其目的是：
</p>
<ul class="org-ul">
<li>通过免去中间交换的内存拷贝，提升IO处理速度，直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外</li>
<li>DirectBuffer 在 -XX:MaxDirectMemorySize=xxM大小限制下, 使用 Heap 之外的内存, GC对此无能为力，也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响</li>
</ul>

<p>
这就解释了为什么 <b>直接缓冲区</b> 对于那些通过 socket 实现数据传输的应用来说，是一种非常理想的方式。如果你的数据是存放在堆中分配的缓冲区，那么实际上，在通过 socket 发送数据之前，JVM 需要将先数据复制到直接缓冲区
</p>

<p>
但是直接缓冲区的缺点是在内存空间的分配和释放上比堆缓冲区更复杂，另外一个缺点是如果要将数据传递给遗留代码处理，因为数据不是在堆上，你可能不得不作出一个副本，如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">directBuf</span> = ...
    <span style="color: #00bfff; font-weight: bold;">if</span> (!directBuf.hasArray()) {            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#26816;&#26597; ByteBuf &#26159;&#19981;&#26159;&#30001;&#25968;&#32452;&#25903;&#25345;&#12290;&#22914;&#26524;&#19981;&#26159;&#65292;&#36825;&#26159;&#19968;&#20010;&#30452;&#25509;&#32531;&#20914;&#21306;</span>
        <span style="color: #98f5ff;">int</span> length = directBuf.readableBytes(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#33719;&#21462;&#21487;&#35835;&#30340;&#23383;&#33410;&#25968;</span>
        <span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">array</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">byte</span>[length];    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#20998;&#37197;&#19968;&#20010;&#26032;&#30340;&#25968;&#32452;&#26469;&#20445;&#23384;&#23383;&#33410;</span>
        directBuf.getBytes(directBuf.readerIndex(), array);        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#23383;&#33410;&#22797;&#21046;&#21040;&#25968;&#32452;</span>
        handleArray(array, 0, length);  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#23558;&#25968;&#32452;&#65292;&#20559;&#31227;&#37327;&#21644;&#38271;&#24230;&#20316;&#20026;&#21442;&#25968;&#35843;&#29992;&#26576;&#20123;&#22788;&#29702;&#26041;&#27861;</span>
    }
</pre>
</div>

<p>
显然，这比使用数组要多做一些工作。因此，如果事前就知道容器里的数据将作为一个数组被访问，可能更愿意使用堆内存
</p>
</div>
</div>

<div id="outline-container-org3909b88" class="outline-4">
<h4 id="org3909b88">Composite Buffer (复合缓冲区)</h4>
<div class="outline-text-4" id="text-org3909b88">
<p>
最后一种模式是复合缓冲区，可以创建多个不同的 ByteBuf，然后提供一个这些 ByteBuf 组合的视图。复合缓冲区就像一个列表，可以动态的添加和删除其中的 ByteBuf，JDK 的 ByteBuffer 没有这样的功能
</p>

<p>
Netty 提供了 ByteBuf 的子类 CompositeByteBuf 类来处理复合缓冲区，CompositeByteBuf 只是一个视图
</p>

<pre class="example">
CompositeByteBuf.hasArray() 总是返回 false，因为它可能既包含堆缓冲区，也包含直接缓冲区
</pre>

<p>
例如，一条消息由 header 和 body 两部分组成，将 header 和 body 组装成一条消息发送出去，可能 body 相同，只是 header 不同，使用CompositeByteBuf 就不用每次都重新分配一个新的缓冲区。下图显示CompositeByteBuf 组成 header 和 body：
</p>


<div class="figure">
<p><img src="pic/composite-buffer.jpg" alt="composite-buffer.jpg" width="70%" />
</p>
</div>

<p>
下面代码显示了使用 JDK 的 ByteBuffer 的一个实现。两个 ByteBuffer 的数组创建保存消息的组件，第三个创建用于保存所有数据的副本：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#25968;&#32452;&#20445;&#23384;&#28040;&#24687;&#30340;&#21508;&#20010;&#37096;&#20998;</span>
<span style="color: #98f5ff;">ByteBuffer</span>[] <span style="color: #4eee94;">message</span> = { header, body };

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#21103;&#26412;&#26469;&#21512;&#24182;&#36825;&#20004;&#20010;&#37096;&#20998;</span>
<span style="color: #98f5ff;">ByteBuffer</span> <span style="color: #4eee94;">message2</span> = ByteBuffer.allocate(
    header.remaining() + body.remaining());
message2.put(header);
message2.put(body);
message2.flip();
</pre>
</div>

<p>
这种做法显然是低效的：分配和复制操作不是最优的方法，操纵数组使代码显得很笨拙
</p>

<p>
下面看使用 CompositeByteBuf 的改进版本：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">CompositeByteBuf</span> <span style="color: #4eee94;">messageBuf</span> = ...;
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">headerBuf</span> = ...; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21487;&#20197;&#25903;&#25345;&#25110;&#30452;&#25509;</span>
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">bodyBuf</span> = ...; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21487;&#20197;&#25903;&#25345;&#25110;&#30452;&#25509;</span>
messageBuf.addComponents(headerBuf, bodyBuf); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#36861;&#21152; ByteBuf &#23454;&#20363;&#30340; CompositeByteBuf </span>
messageBuf.removeComponent(0);   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#21024;&#38500;&#32034;&#24341;1&#30340; ByteBuf</span>

<span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; messageBuf.<span style="color: #98f5ff;">numComponents</span>(); i++) {                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#36941;&#21382;&#25152;&#26377; ByteBuf &#23454;&#20363;</span>
    System.out.println(messageBuf.component(i).toString());
}
</pre>
</div>

<p>
简单地把 CompositeByteBuf 当作一个可迭代遍历的容器。 CompositeByteBuf 不允许访问其内部可能存在的支持数组，也不允许直接访问数据，这一点类似于直接缓冲区模式。想要读取数据，需要如下面代码所示：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">CompositeByteBuf</span> <span style="color: #4eee94;">compBuf</span> = ...;
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">length</span> = compBuf.readableBytes();    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#24471;&#21040;&#30340;&#21487;&#35835;&#30340;&#23383;&#33410;&#25968;</span>
<span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">array</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">byte</span>[length];        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20998;&#37197;&#19968;&#20010;&#26032;&#30340;&#25968;&#32452;,&#25968;&#32452;&#38271;&#24230;&#20026;&#21487;&#35835;&#23383;&#33410;&#38271;&#24230;</span>
compBuf.getBytes(compBuf.readerIndex(), array);    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#35835;&#21462;&#23383;&#33410;&#21040;&#25968;&#32452;</span>
handleArray(array, 0, length);    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#20351;&#29992;&#25968;&#32452;&#65292;&#25226;&#20559;&#31227;&#37327;&#21644;&#38271;&#24230;&#20316;&#20026;&#21442;&#25968;</span>
</pre>
</div>

<p>
Netty 尝试使用 CompositeByteBuf 优化 socket I/O 操作，消除原生 JDK 中可能存在的的性能低和内存消耗问题。虽然这是在 Netty 的核心代码中进行的优化，并且是不对外暴露的，但是作为开发者还是应该意识到其影响
</p>
</div>
</div>
</div>

<div id="outline-container-orgd14307e" class="outline-3">
<h3 id="orgd14307e">字节级别的操作</h3>
<div class="outline-text-3" id="text-orgd14307e">
<p>
除了基本的读写操作， ByteBuf 还提供了它所包含的数据的修改方法
</p>
</div>

<div id="outline-container-org8514b60" class="outline-4">
<h4 id="org8514b60">随机访问索引</h4>
<div class="outline-text-4" id="text-org8514b60">
<p>
ByteBuf 使用从0开始的索引，第一个字节的索引是 0，最后一个字节的索引是 ByteBuf 的 capacity - 1，下面代码是遍历 ByteBuf 的所有字节：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buffer</span> = ...;

<span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; buffer.<span style="color: #98f5ff;">capacity</span>(); i++) {
    <span style="color: #98f5ff;">byte</span> <span style="color: #4eee94;">b</span> = buffer.getByte(i);
    System.out.println((<span style="color: #98f5ff;">char</span>) b);
}
</pre>
</div>

<p>
注意：通过索引访问时不会推进 readerIndex 和 writerIndex，我们可以通过 ByteBuf 的 readerIndex(index) 或 writerIndex(index) 来分别推进读索引或写索引
</p>
</div>
</div>

<div id="outline-container-orgafedd31" class="outline-4">
<h4 id="orgafedd31">顺序访问索引</h4>
<div class="outline-text-4" id="text-orgafedd31">
<p>
ByteBuf 提供两个指针变量支付读和写操作，读操作是使用 readerIndex()，写操作时使用 writerIndex()。这和JDK的ByteBuffer不同，ByteBuffer只有一个方法来设置索引，所以需要使用 flip() 方法来切换读和写模式
</p>

<pre class="example">
ByteBuf 一定符合：0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity
</pre>


<div class="figure">
<p><img src="pic/bytebug-internal-segmentation.jpg" alt="bytebug-internal-segmentation.jpg" width="70%" />
</p>
</div>

<ol class="org-ol">
<li>字节，可以被丢弃，因为它们已经被读</li>
<li>还没有被读的字节是： readable bytes（可读字节）</li>
<li>空间可加入多个字节的是： writeable bytes（写字节）</li>
</ol>
</div>

<div id="outline-container-org653ddc6" class="outline-5">
<h5 id="org653ddc6">可丢弃字节的字节</h5>
<div class="outline-text-5" id="text-org653ddc6">
<p>
标有 <b>可丢弃字节</b> 的段包含已经被读取的字节。他们可以被丢弃，通过调用discardReadBytes() 来回收空间。这个段的初始大小存储在readerIndex，为 0，当 <b>read</b> 操作被执行时递增（ <b>get</b> 操作不会移动 readerIndex）
</p>

<p>
图5.4示出了在 图5.3 中的缓冲区中调用 discardReadBytes() 所示的结果。可以看到，在丢弃字节段的空间已变得可用写。需要注意的是不能保证对可写的段之后的内容在 discardReadBytes() 方法之后已经被调用：
</p>


<div class="figure">
<p><img src="pic/discard-read-bytes.jpg" alt="discard-read-bytes.jpg" width="70%" />
</p>
</div>

<ol class="org-ol">
<li>字节尚未被读出（readerIndex 现在 0）</li>
<li>可用的空间，由于空间被回收而增大</li>
</ol>

<p>
ByteBuf.discardReadBytes() 可以用来清空 ByteBuf 中已读取的数据，从而使 ByteBuf 有多余的空间容纳新的数据，但是discardReadBytes() 可能会涉及内存复制，因为它需要移动 ByteBuf 中可读的字节到开始位置，这样的操作会影响性能，一般在需要马上释放内存的时候使用收益会比较大
</p>
</div>
</div>

<div id="outline-container-orge0bf6e3" class="outline-5">
<h5 id="orge0bf6e3">可读字节</h5>
<div class="outline-text-5" id="text-orge0bf6e3">
<p>
ByteBuf 的 <b>可读字节</b> 分段存储的是实际数据。新分配，包装，或复制的缓冲区的 readerIndex 的默认值为 0 。任何操作，其名称以 <b>read</b> 或 <b>skip</b> 开头的都将检索或跳过该数据在当前 readerIndex ，并且通过读取的字节数来递增
</p>

<p>
如果所谓的读操作是一个指定 ByteBuf 参数作为写入的对象，并且没有一个目标索引参数，目标缓冲区的 writerIndex 也会增加了。例如：
</p>

<div class="org-src-container">
<pre class="src src-java">readBytes(<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">dest</span>);
</pre>
</div>

<p>
如果试图从缓冲器读取已经用尽的可读的字节，则抛出IndexOutOfBoundsException。下面显示了如何读取所有可读字节：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36941;&#21382;&#32531;&#20914;&#21306;&#30340;&#21487;&#35835;&#23383;&#33410;</span>
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buffer</span>= ...;
<span style="color: #00bfff; font-weight: bold;">while</span> (buffer.isReadable()) {
    System.out.println(buffer.readByte());
}
</pre>
</div>

<p>
一个新分配的缓冲区的 writerIndex 的默认值是 0 。任何操作，其名称 <b>write</b> 开头的操作在当前的 writerIndex 写入数据时，递增字节写入的数量。如果写操作的目标也是 ByteBuf ，且未指定源索引，则源缓冲区的 readerIndex 将增加相同的量。例如：
</p>
<div class="org-src-container">
<pre class="src src-java">writeBytes(<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">dest</span>);
</pre>
</div>

<p>
如果试图写入超出目标的容量，则抛出 IndexOutOfBoundException
</p>

<p>
下面的例子展示了填充随机整数到缓冲区中，直到耗尽空间。该方法writableBytes() 被用在这里确定是否存在足够的缓冲空间：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22635;&#20805;&#38543;&#26426;&#25972;&#25968;&#21040;&#32531;&#20914;&#21306;&#20013;</span>
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buffer</span> = ...;
<span style="color: #00bfff; font-weight: bold;">while</span> (buffer.writableBytes() &gt;= 4) {
    buffer.writeInt(random.nextInt());
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2601475" class="outline-4">
<h4 id="org2601475">索引管理</h4>
<div class="outline-text-4" id="text-org2601475">
<p>
在 JDK 的 InputStream 定义了 mark(int readlimit) 和 reset()方法。这些是分别用来标记流中的当前位置和复位流到该位置
</p>

<p>
同样，可以设置和重新定位ByteBuf readerIndex 和 writerIndex 通过调用 markReaderIndex(), markWriterIndex(), resetReaderIndex() 和 resetWriterIndex()。这些类似于InputStream 的调用，所不同的是，没有 readlimit 参数来指定当标志变为无效
</p>

<p>
可以通过调用 readerIndex(int) 或 writerIndex(int) 将指标移动到指定的位置。在尝试任何无效位置上设置一个索引将导致 IndexOutOfBoundsException 异常
</p>

<p>
调用 clear() 可以同时设置 readerIndex 和 writerIndex 为 0。注意，这不会清除内存中的内容。调用之前，包含3个段，下面显示了调用之后：
</p>


<div class="figure">
<p><img src="pic/bytebuf-clear.jpg" alt="bytebuf-clear.jpg" width="70%" />
</p>
</div>

<p>
现在整个 ByteBuf 空间都是可写的了。clear() 比 discardReadBytes() 更低成本，因为他只是重置了索引，而没有内存拷贝
</p>
</div>
</div>

<div id="outline-container-org0f5e1a9" class="outline-4">
<h4 id="org0f5e1a9">查询操作</h4>
<div class="outline-text-4" id="text-org0f5e1a9">
<p>
有几种方法，以确定在所述缓冲器中的指定值的索引。最简单的是使用 indexOf() 方法。更复杂的搜索执行以 ByteBufProcessor 为参数的方法。这个接口定义了一个方法，boolean process(byte value)，它用来报告输入值是否是一个正在寻求的值
</p>

<p>
ByteBufProcessor 定义了很多方便实现共同目标值。例如，假设您的应用程序需要集成所谓的“Flash sockets”，将使用 NULL 结尾的内容：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">index</span>=buffer.forEachByte&#65288;<span style="color: #ffd700;">ByteBufProcessor</span>.FIND_NUL&#65289;;
</pre>
</div>

<p>
通过减少的，因为少量的 <b>边界检查</b> 的处理过程中执行了，从而使 消耗 Flash 数据变得 编码工作量更少、效率更高
</p>

<p>
下面例子展示了寻找一个回车符 \r的一个例子：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buffer</span> = ...;
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">index</span> = buffer.forEachByte(<span style="color: #ffd700;">ByteBufProcessor</span>.FIND_CR);
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b86bb9" class="outline-4">
<h4 id="org0b86bb9">衍生的缓冲区</h4>
<div class="outline-text-4" id="text-org0b86bb9">
<p>
<b>衍生的缓冲区</b> 是代表一个专门的展示 ByteBuf 内容的 <b>视图</b> 。这种视图是由 duplicate(), slice(), slice(int, int), readOnly() 和 order(ByteOrder) 方法创建的。所有这些都返回一个新的 ByteBuf 实例包括它自己的 reader, writer 和标记索引。然而，内部数据存储共享就像在一个 NIO 的 ByteBuffer。这使得衍生的缓冲区创建、修改其 内容，以及修改其 <b>源</b> 实例更廉价
</p>
</div>

<div id="outline-container-org73e5c0a" class="outline-5">
<h5 id="org73e5c0a">ByteBuf 拷贝</h5>
<div class="outline-text-5" id="text-org73e5c0a">
<p>
如果需要已有的缓冲区的全新副本，使用 <b>copy()</b> 或者 <b>copy(int, int)</b> 。不同于派生缓冲区，这个调用返回的 ByteBuf 有数据的独立副本
</p>

<p>
若需要操作某段数据，使用 <b>slice(int, int)</b> ，下面展示了用法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Charset</span> <span style="color: #4eee94;">utf8</span> = Charset.forName(<span style="color: #deb887;">"UTF-8"</span>);
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buf</span> = Unpooled.copiedBuffer(<span style="color: #deb887;">"Netty in Action rocks!"</span>, utf8); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010; ByteBuf &#20445;&#23384;&#29305;&#23450;&#23383;&#33410;&#20018;</span>

<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">sliced</span> = buf.slice(0, 14);          <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#21019;&#24314;&#20174;&#32034;&#24341; 0 &#24320;&#22987;&#65292;&#24182;&#22312; 14 &#32467;&#26463;&#30340; ByteBuf &#30340;&#26032; slice</span>
System.out.println(sliced.toString(utf8));  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#25171;&#21360; Netty in Action</span>

buf.setByte(0, (<span style="color: #98f5ff;">byte</span>) <span style="color: #deb887;">'J'</span>);                 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#26356;&#26032;&#32034;&#24341; 0 &#30340;&#23383;&#33410;</span>
<span style="color: #98f5ff;">assert</span> buf.<span style="color: #daa520; font-weight: bold;">getByte</span>(0) == sliced.getByte(0); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">5 &#26029;&#35328;&#25104;&#21151;&#65292;&#22240;&#20026;&#25968;&#25454;&#26159;&#20849;&#20139;&#30340;&#65292;&#24182;&#20197;&#19968;&#20010;&#22320;&#26041;&#25152;&#20570;&#30340;&#20462;&#25913;&#23558;&#22312;&#20854;&#20182;&#22320;&#26041;&#21487;&#35265;</span>
</pre>
</div>

<p>
下面看下如何将一个 ByteBuf 段的副本不同于 slice：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Charset</span> <span style="color: #4eee94;">utf8</span> = Charset.forName(<span style="color: #deb887;">"UTF-8"</span>);
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buf</span> = Unpooled.copiedBuffer(<span style="color: #deb887;">"Netty in Action rocks!"</span>, utf8);     <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010; ByteBuf &#20445;&#23384;&#29305;&#23450;&#23383;&#33410;&#20018;</span>

<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">copy</span> = buf.copy(0, 14);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#21019;&#24314;&#20174;&#32034;&#24341;0&#24320;&#22987;&#21644; 14 &#32467;&#26463; &#30340; ByteBuf &#30340;&#27573;&#30340;&#25335;&#36125;</span>
System.out.println(copy.toString(utf8));      <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 .&#25171;&#21360; Netty in Action</span>

buf.setByte(0, (<span style="color: #98f5ff;">byte</span>) <span style="color: #deb887;">'J'</span>);                   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#26356;&#26032;&#32034;&#24341; 0 &#30340;&#23383;&#33410;</span>
<span style="color: #98f5ff;">assert</span> buf.<span style="color: #daa520; font-weight: bold;">getByte</span>(0) != copy.getByte(0); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#26029;&#35328;&#25104;&#21151;&#65292;&#22240;&#20026;&#25968;&#25454;&#19981;&#26159;&#20849;&#20139;&#30340;&#65292;&#24182;&#20197;&#19968;&#20010;&#22320;&#26041;&#25152;&#20570;&#30340;&#20462;&#25913;&#23558;&#19981;&#24433;&#21709;&#20854;&#20182; </span>
</pre>
</div>

<p>
代码几乎是相同的，但所 衍生的 ByteBuf 效果是不同的。因此，使用一个 slice 可以尽可能避免复制内存
</p>
</div>
</div>
</div>

<div id="outline-container-org1350b19" class="outline-4">
<h4 id="org1350b19">读/写操作</h4>
<div class="outline-text-4" id="text-org1350b19">
<p>
读/写操作主要由2类：
</p>
<ul class="org-ul">
<li>get()/set() ：操作从给定的索引开始，保持不变</li>
<li>read()/write()： 操作从给定的索引开始，与字节访问的数量来适用，递增当前的写索引或读索引</li>
</ul>

<p>
下表是常见的 get() 操作：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> get操作</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">getBoolean(int)</td>
<td class="org-left">返回当前索引的 Boolean 值</td>
</tr>

<tr>
<td class="org-left">getByte(int) getUnsignedByte(int)</td>
<td class="org-left">返回当前索引的(无符号)字节</td>
</tr>

<tr>
<td class="org-left">getMedium(int) getUnsignedMedium(int)</td>
<td class="org-left">返回当前索引的 (无符号) 24-bit 中间值</td>
</tr>

<tr>
<td class="org-left">getInt(int) getUnsignedInt(int)</td>
<td class="org-left">返回当前索引的(无符号) 整型</td>
</tr>

<tr>
<td class="org-left">getLong(int) getUnsignedLong(int)</td>
<td class="org-left">返回当前索引的 (无符号) Long 型</td>
</tr>

<tr>
<td class="org-left">getShort(int) getUnsignedShort(int)</td>
<td class="org-left">返回当前索引的 (无符号) Short 型</td>
</tr>

<tr>
<td class="org-left">getBytes(int, &#x2026;)</td>
<td class="org-left">字节</td>
</tr>
</tbody>
</table>

<p>
常见 set() 操作如下：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> set操作</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">setBoolean(int, boolean)</td>
<td class="org-left">在指定的索引位置设置 Boolean 值</td>
</tr>

<tr>
<td class="org-left">setByte(int, int)</td>
<td class="org-left">在指定的索引位置设置 byte 值</td>
</tr>

<tr>
<td class="org-left">setMedium(int, int)</td>
<td class="org-left">在指定的索引位置设置 24-bit 中间 值</td>
</tr>

<tr>
<td class="org-left">setInt(int, int)</td>
<td class="org-left">在指定的索引位置设置 int 值</td>
</tr>

<tr>
<td class="org-left">setLong(int, long)</td>
<td class="org-left">在指定的索引位置设置 long 值</td>
</tr>

<tr>
<td class="org-left">setShort(int, int)</td>
<td class="org-left">在指定的索引位置设置 short 值</td>
</tr>
</tbody>
</table>

<p>
下面是 get 和 set 的实例：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Charset</span> <span style="color: #4eee94;">utf8</span> = Charset.forName(<span style="color: #deb887;">"UTF-8"</span>);
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buf</span> = Unpooled.copiedBuffer(<span style="color: #deb887;">"Netty in Action rocks!"</span>, utf8);    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; ByteBuf &#32473;&#25351;&#23450; String &#20445;&#23384;&#23383;&#33410;</span>
System.out.println((<span style="color: #98f5ff;">char</span>)buf.getByte(0));                    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#25171;&#21360;&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#65292;N</span>

<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">readerIndex</span> = buf.readerIndex();                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#23384;&#20648;&#24403;&#21069; readerIndex &#21644; writerIndex</span>
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">writerIndex</span> = buf.writerIndex();

buf.setByte(0, (<span style="color: #98f5ff;">byte</span>)<span style="color: #deb887;">'B'</span>);                            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#26356;&#26032;&#32034;&#24341; 0 &#30340;&#23383;&#31526;B</span>

System.out.println((<span style="color: #98f5ff;">char</span>)buf.getByte(0));                    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#25171;&#21360;&#20986;&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#65292;&#29616;&#22312;B</span>
<span style="color: #98f5ff;">assert</span> <span style="color: #4eee94;">readerIndex</span> == buf.readerIndex();                    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">6 &#36825;&#20123;&#26029;&#35328;&#25104;&#21151;&#65292;&#22240;&#20026;&#36825;&#20123;&#25805;&#20316;&#27704;&#36828;&#19981;&#20250;&#25913;&#21464;&#32034;&#24341;</span>
<span style="color: #98f5ff;">assert</span> <span style="color: #4eee94;">writerIndex</span> ==  buf.writerIndex();
</pre>
</div>

<p>
下面展示了常见的 read() 方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> read操作</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">readBoolean()　   　</td>
<td class="org-left">Reads the Boolean value at the current readerIndex and increases the readerIndex by 1</td>
</tr>

<tr>
<td class="org-left">readByte()　readUnsignedByte()　</td>
<td class="org-left">Reads the (unsigned) byte value at the current readerIndex and increases the readerIndex by 1</td>
</tr>

<tr>
<td class="org-left">readMedium()　readUnsignedMedium()　</td>
<td class="org-left">Reads the (unsigned) 24-bit medium value at the current readerIndex and increases the readerIndex by 3</td>
</tr>

<tr>
<td class="org-left">readInt()　readUnsignedInt()</td>
<td class="org-left">Reads the (unsigned) int value at the current readerIndex and increases the readerIndex by 4</td>
</tr>

<tr>
<td class="org-left">readLong()　readUnsignedLong()　</td>
<td class="org-left">Reads the (unsigned) int value at the current readerIndex and increases the readerIndex by 8</td>
</tr>

<tr>
<td class="org-left">readShort()　readUnsignedShort()　</td>
<td class="org-left">Reads the (unsigned) int value at the current readerIndex and increases the readerIndex by 2</td>
</tr>

<tr>
<td class="org-left">readBytes(int,int, &#x2026;)</td>
<td class="org-left">Reads the value on the current readerIndex for the given length into the given object. Also increases the readerIndex by the length.</td>
</tr>
</tbody>
</table>

<p>
每个 read() 方法都对应一个 write()：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> write操作</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">writeBoolean(boolean)</td>
<td class="org-left">Writes the Boolean value on the current writerIndex and increases the　writerIndex by 1</td>
</tr>

<tr>
<td class="org-left">writeByte(int)</td>
<td class="org-left">Writes the byte value on the current writerIndex and increases the　writerIndex by 1</td>
</tr>

<tr>
<td class="org-left">writeMedium(int)</td>
<td class="org-left">Writes the medium value on the current writerIndex and increases the　writerIndex by 3</td>
</tr>

<tr>
<td class="org-left">writeInt(int)</td>
<td class="org-left">Writes the int value on the current writerIndex and increases the　writerIndex by 4</td>
</tr>

<tr>
<td class="org-left">writeLong(long)</td>
<td class="org-left">Writes the long value on the current writerIndex and increases the　writerIndex by 8</td>
</tr>

<tr>
<td class="org-left">writeShort(int)</td>
<td class="org-left">Writes the short value on the current writerIndex and increases thewriterIndex by 2</td>
</tr>

<tr>
<td class="org-left">writeBytes(int，&#x2026;）     　</td>
<td class="org-left">Transfers the bytes on the current writerIndex from given resources</td>
</tr>
</tbody>
</table>

<p>
下面是 read 和 write 的实例：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Charset</span> <span style="color: #4eee94;">utf8</span> = Charset.forName(<span style="color: #deb887;">"UTF-8"</span>);
<span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buf</span> = Unpooled.copiedBuffer(<span style="color: #deb887;">"Netty in Action rocks!"</span>, utf8);    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; ByteBuf &#20445;&#23384;&#32473;&#23450; String &#30340;&#23383;&#33410;</span>
System.out.println((<span style="color: #98f5ff;">char</span>)buf.readByte());                    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#25171;&#21360;&#30340;&#31532;&#19968;&#20010;&#23383;&#31526; N</span>

<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">readerIndex</span> = buf.readerIndex();                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#23384;&#20648;&#24403;&#21069;&#30340; readerIndex</span>
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">writerIndex</span> = buf.writerIndex();                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#20445;&#23384;&#24403;&#21069;&#30340; writerIndex</span>

buf.writeByte((<span style="color: #98f5ff;">byte</span>)<span style="color: #deb887;">'B'</span>);                            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#26356;&#26032;&#32034;&#24341;0&#30340;&#23383;&#31526; B</span>

<span style="color: #98f5ff;">assert</span> <span style="color: #4eee94;">readerIndex</span> == buf.readerIndex(); 
<span style="color: #98f5ff;">assert</span> <span style="color: #4eee94;">writerIndex</span> != buf.writerIndex(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">6 &#27492;&#26029;&#35328;&#25104;&#21151;&#65292;&#22240;&#20026; writeByte() &#22312; 5 &#31227;&#21160;&#20102; writerIndex</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6bb69f7" class="outline-3">
<h3 id="org6bb69f7">更多操作</h3>
<div class="outline-text-3" id="text-org6bb69f7">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> 更多操作</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">isReadable()</td>
<td class="org-left">Returns true if at least one byte can be read</td>
</tr>

<tr>
<td class="org-left">isWritable()</td>
<td class="org-left">Returns true if at least one byte can be written</td>
</tr>

<tr>
<td class="org-left">readableBytes()</td>
<td class="org-left">Returns the number of bytes that can be read</td>
</tr>

<tr>
<td class="org-left">writablesBytes()</td>
<td class="org-left">Returns the number of bytes that can be written</td>
</tr>

<tr>
<td class="org-left">capacity()</td>
<td class="org-left">Returns the number of bytes that the ByteBuf can hold. After this it will try to expand again until maxCapacity() is reached</td>
</tr>

<tr>
<td class="org-left">maxCapacity()</td>
<td class="org-left">Returns the maximum number of bytes the ByteBuf can hold</td>
</tr>

<tr>
<td class="org-left">hasArray()</td>
<td class="org-left">Returns true if the ByteBuf is backed by a byte array</td>
</tr>

<tr>
<td class="org-left">array()</td>
<td class="org-left">Returns the byte array if the ByteBuf is backed by a byte array, otherwise throws an UnsupportedOperationException</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgfeaae17" class="outline-2">
<h2 id="orgfeaae17">ByteBufHolder</h2>
<div class="outline-text-2" id="text-orgfeaae17">
<p>
我们经常遇到需要另外存储除有效的实际数据各种属性值。 HTTP 响应是一个很好的例子；与内容一起的字节的还有状态码, cookies等
</p>

<p>
Netty 提供 ByteBufHolder 处理这种常见的情况。 ByteBufHolder 还提供对于 Netty 的高级功能，如缓冲池，其中保存实际数据的 ByteBuf 可以从池中借用，如果需要还可以自动释放
</p>

<p>
ByteBufHolder 有那么几个方法。到底层的这些支持接入数据和引用计数。表5.7所示的方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 6:</span> ByteBufHolder operations</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">data()</td>
<td class="org-left">返回 ByteBuf 保存的数据</td>
</tr>

<tr>
<td class="org-left">copy()</td>
<td class="org-left">制作一个 ByteBufHolder 的拷贝，但不共享其数据(所以数据也是拷贝)</td>
</tr>
</tbody>
</table>

<p>
如果你想实现一个 <b>消息对象</b> 有效负载存储在 ByteBuf，使用ByteBufHolder 是一个好主意
</p>
</div>

<div id="outline-container-orgd84c6ff" class="outline-3">
<h3 id="orgd84c6ff">ByteBuf 分配</h3>
<div class="outline-text-3" id="text-orgd84c6ff">
<p>
本节介绍 ByteBuf 实例管理的几种方式：
</p>
</div>

<div id="outline-container-org2e2e7d2" class="outline-4">
<h4 id="org2e2e7d2">ByteBufAllocator</h4>
<div class="outline-text-4" id="text-org2e2e7d2">
<p>
为了减少分配和释放内存的开销，Netty 通过支持池类 ByteBufAllocator，可用于分配的任何 ByteBuf 我们已经描述过的类型的实例。是否使用池是由应用程序决定的，表5.8列出了 ByteBufAllocator 提供的操作：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 7:</span> ByteBufAllocator方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">buffer() buffer(int) buffer(int, int)</td>
<td class="org-left">Return a ByteBuf with heap-based or direct data storage</td>
</tr>

<tr>
<td class="org-left">heapBuffer() heapBuffer(int) heapBuffer(int, int)</td>
<td class="org-left">Return a ByteBuf with heap-based storage</td>
</tr>

<tr>
<td class="org-left">directBuffer() directBuffer(int) directBuffer(int, int)</td>
<td class="org-left">Return a ByteBuf with direct storage</td>
</tr>

<tr>
<td class="org-left">compositeBuffer() compositeBuffer(int) heapCompositeBuffer() heapCompositeBuffer(int) directCompositeBuffer() directCompositeBuffer(int)</td>
<td class="org-left">Return a CompositeByteBuf that can be expanded by adding heapbased or direct buffers</td>
</tr>

<tr>
<td class="org-left">ioBuffer()</td>
<td class="org-left">Return a ByteBuf that will be used for I/O operations on a socket</td>
</tr>
</tbody>
</table>

<p>
通过一些方法接受整型参数允许用户指定 ByteBuf 的初始和最大容量值。你可能还记得，ByteBuf 存储可以扩大到其最大容量
</p>

<p>
得到一个 ByteBufAllocator 的引用很简单。你可以得到从 Channel ，或通过绑定到的 ChannelHandler 的 ChannelHandlerContext 得到它，用它实现了数据处理逻辑
</p>

<p>
下面的代码说明获得 ByteBufAllocator 的两种方式：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Channel</span> <span style="color: #4eee94;">channel</span> = ...;
<span style="color: #98f5ff;">ByteBufAllocator</span> <span style="color: #4eee94;">allocator</span> = channel.alloc(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#20174; channel &#33719;&#24471; ByteBufAllocator</span>
....
ChannelHandlerContext ctx = ...;
<span style="color: #98f5ff;">ByteBufAllocator</span> <span style="color: #4eee94;">allocator2</span> = ctx.alloc(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20174; ChannelHandlerContext &#33719;&#24471; ByteBufAllocator</span>
...
</pre>
</div>

<p>
Netty 提供了两种 ByteBufAllocator 的实现：
</p>
<ul class="org-ul">
<li>PooledByteBufAllocator，用ByteBuf 实例池改进性能以及内存使用降到最低，此实现使用一个 <b>jemalloc</b> 内存分配</li>
<li>不池化 ByteBuf 情况下，每次返回一个新的实例</li>
</ul>

<p>
Netty 默认使用 PooledByteBufAllocator，可以通过 <b>ChannelConfig</b> 或通过引导设置一个不同的实现来改变
</p>
</div>

<div id="outline-container-orgc22d1e9" class="outline-5">
<h5 id="orgc22d1e9">Unpooled 缓存</h5>
<div class="outline-text-5" id="text-orgc22d1e9">
<p>
当未引用 ByteBufAllocator 时，上面的方法无法访问到 ByteBuf。对于这个用例 Netty 提供一个实用工具类称为 Unpooled,，它提供了静态辅助方法来创建非池化的 ByteBuf 实例。表5.9列出了最重要的方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 8:</span> Unpooled 辅助类方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">buffer() buffer(int) buffer(int, int)</td>
<td class="org-left">Returns an unpooled ByteBuf with heap-based storage</td>
</tr>

<tr>
<td class="org-left">directBuffer() directBuffer(int) directBuffer(int, int)</td>
<td class="org-left">Returns an unpooled ByteBuf with direct storage</td>
</tr>

<tr>
<td class="org-left">wrappedBuffer()</td>
<td class="org-left">Returns a ByteBuf, which wraps the given data.</td>
</tr>

<tr>
<td class="org-left">copiedBuffer()</td>
<td class="org-left">Returns a ByteBuf, which copies the given data</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org7ed41c1" class="outline-4">
<h4 id="org7ed41c1">ByteBufUtil</h4>
<div class="outline-text-4" id="text-org7ed41c1">
<p>
ByteBufUtil 静态辅助方法来操作 ByteBuf，因为这个 API 是通用的，与使用池无关，这些方法已经在外面的分配类实现
</p>

<p>
最有价值的是 hexDump() 方法，这个方法返回指定 ByteBuf 中可读字节的十六进制字符串，可以用于调试程序时打印 ByteBuf 的内容。一个典型的用途是记录一个 ByteBuf 的内容进行调试。十六进制字符串相比字节而言对用户更友好。 而且十六进制版本可以很容易地转换回实际字节表示
</p>

<p>
另一个有用方法是使用 boolean equals(ByteBuf, ByteBuf),用来比较 ByteBuf 实例是否相等。在实现自己 ByteBuf 的子类时经常用到
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org657df26" class="outline-2">
<h2 id="org657df26">引用计数器</h2>
<div class="outline-text-2" id="text-org657df26">
<p>
Netty 4 引入了 引用计数器给 ByteBuf 和 ByteBufHolder
</p>

<p>
引用计数本身并不复杂，它在特定的对象上跟踪引用的数目。实现了 <b>ReferenceCounted</b> 的类的实例会通常开始于一个活动的引用计数器为 1。活动的引用计数器大于0的对象被保证不被释放。当数量引用减少到0，该实例将被释放。需要注意的是 <b>释放</b> 的语义是特定于具体的实现。最起码，一个对象，它已被释放应不再可用。
</p>

<p>
这种技术就是诸如 PooledByteBufAllocator 这种 <b>减少内存分配开销的池化</b> 的精髓部分 
</p>

<p>
获取引用计数：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Channel</span> <span style="color: #4eee94;">channel</span> = ...;
<span style="color: #98f5ff;">ByteBufAllocator</span> <span style="color: #4eee94;">allocator</span> = channel.alloc(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#20174; channel &#33719;&#21462; ByteBufAllocator</span>
....
ByteBuf buffer = allocator.directBuffer(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#20174; ByteBufAllocator &#20998;&#37197;&#19968;&#20010; ByteBuf</span>
<span style="color: #98f5ff;">assert</span> buffer.<span style="color: #daa520; font-weight: bold;">refCnt</span>() == 1; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#26816;&#26597;&#24341;&#29992;&#35745;&#25968;&#22120;&#26159;&#21542;&#26159; 1</span>
...
</pre>
</div>

<p>
释放应用计数：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">buffer</span> = ...;
<span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">released</span> = buffer.release(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 release() &#23558;&#20250;&#36882;&#20943;&#23545;&#35937;&#24341;&#29992;&#30340;&#25968;&#30446;&#12290;&#24403;&#36825;&#20010;&#24341;&#29992;&#35745;&#25968;&#36798;&#21040;0&#26102;&#65292;&#23545;&#35937;&#24050;&#34987;&#37322;&#25918;&#65292;&#24182;&#19988;&#35813;&#26041;&#27861;&#36820;&#22238; true</span>
...
</pre>
</div>

<p>
如果尝试访问已经释放的对象，将会抛出 IllegalReferenceCountException 异常。
</p>

<p>
一个特定的类可以定义自己独特的方式其 <b>释放计数的规则</b> ，例如 release() 可以将引用计数器直接计为 0 而不管当前引用的对象数目
</p>

<pre class="example">
  在一般情况下，最后访问的对象负责释放它
</pre>

<p>
<a href="channel.html">Next：ChannelHandler</a>
</p>

<p>
<a href="transport.html">Previous：传输</a>
</p>

<p>
<a href="netty.html">Home：目录</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
