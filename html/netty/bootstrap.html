<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>引导</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="embedded.html"> UP </a>
 |
 <a accesskey="H" href="netty.html"> HOME </a>
</div><div id="content">
<h1 class="title">引导</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb170886">引导</a>
<ul>
<li><a href="#orgb58b750">类型</a>
<ul>
<li><a href="#org6504232">克隆引导类</a></li>
</ul>
</li>
<li><a href="#orge6a0585">引导客户端</a>
<ul>
<li><a href="#org3353cfd">Bootstap常用方法</a></li>
<li><a href="#org031e7ad">过程</a>
<ul>
<li><a href="#org4324d76">Bootstrap 实例</a></li>
<li><a href="#org71af79e">兼容性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8325c91">引导服务器</a>
<ul>
<li><a href="#org95cbc40">ServerBootstrap 的方法</a></li>
<li><a href="#org7018cc1">过程</a></li>
</ul>
</li>
<li><a href="#org7f04029">从 Channel 引导客户端</a>
<ul>
<li><a href="#orgbf529b1">共享 EventLoop</a>
<ul>
<li><a href="#org5558f0f">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org067f07a">在一个引导中添加多个 ChannelHandler</a>
<ul>
<li><a href="#org129877f">实例</a></li>
</ul>
</li>
<li><a href="#org59be412">使用Netty 的 ChannelOption 和属性</a>
<ul>
<li><a href="#org4855446">配置和属性实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org17f0508">关闭之前已经引导的客户端或服务器</a></li>
</ul>
</div>
</div>
<p>
本章介绍：
</p>
<ul class="org-ul">
<li>引导客户端和服务器</li>
<li>从Channel引导客户端</li>
<li>添加 ChannelHandler</li>
<li>使用 ChannelOption 和属性</li>
</ul>

<p>
通过 ChannelPipeline 、ChannelHandler和编解码器提供工具，可以处理一个广泛的数据处理需求。但是可能会问,“我创建了组件后,如何将其组装形成一个应用程序?”
</p>

<p>
答案是 <b>bootstrapping</b> 。到目前为止使用这个词有点模糊,时间可以来定义它。在最简单的条件下,引导就是配置应用程序的过程。但我们看到的,不仅仅如此； <b>Netty的引导客户端和服务器的类从网络基础设施使应用程序代码在后台可以连接和启动所有的组件</b> 。简而言之，引导使 Netty 应用程序完整
</p>

<div id="outline-container-orgb170886" class="outline-2">
<h2 id="orgb170886">引导</h2>
<div class="outline-text-2" id="text-orgb170886">
</div>
<div id="outline-container-orgb58b750" class="outline-3">
<h3 id="orgb58b750">类型</h3>
<div class="outline-text-3" id="text-orgb58b750">
<p>
Netty包括两种不同类型的引导：不仅仅是 <b>服务器</b> 和 <b>客户</b> 的引导，更有用的是考虑他们的目的是支持的应用程序功能。从这个意义上讲, <b>服务器</b> 应用程序把一个 <b>父</b> 管道接受连接和创建 <b>子</b> 管道,而 <b>客户端</b> 很可能只需要一个单一的、非 <b>父</b> 对所有网络交互的管道（对于无连接的比如 UDP 协议也是一样）
</p>

<p>
如图9.1所示,两个引导实现自一个名为 <b>AbstractBootstrap</b> 的超类：
</p>


<div class="figure">
<p><img src="pic/bootstrap-hierarchy.jpg" alt="bootstrap-hierarchy.jpg" width="40%" />
</p>
</div>

<p>
前面介绍了许多共同关注的话题,同样适用于客户端和服务器。这些都是由 AbstractBootstrap 处理,从而防止重复的功能和代码。专业引导类可以完全专注于它们独特的需要关心的地方
</p>
</div>

<div id="outline-container-org6504232" class="outline-4">
<h4 id="org6504232">克隆引导类</h4>
<div class="outline-text-4" id="text-org6504232">
<p>
经常需要创建多个通道具有相似或相同的设置。支持这种模式而不需要为每个通道创建和配置一个新的引导实例, AbstractBootstrap 已经被标记为 Cloneable。调用 clone() 在一个已经配置引导将返回另一个引导实例并且是立即可用
</p>

<pre class="example">
   因为这将创建只是 EventLoopGroup 浅拷贝,后者将会共享所有的克隆管道
   
   这是可以接受的,因为往往是克隆的管道是短暂的，典型示例是管道创建用于 HTTP 请求
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6a0585" class="outline-3">
<h3 id="orge6a0585">引导客户端</h3>
<div class="outline-text-3" id="text-orge6a0585">
<p>
当需要引导客户端或一些无连接协议时，需要使用Bootstrap类。 在本节中,将回顾可用的各种方法引导客户端,引导线程,和可用的管道实现
</p>
</div>

<div id="outline-container-org3353cfd" class="outline-4">
<h4 id="org3353cfd">Bootstap常用方法</h4>
<div class="outline-text-4" id="text-org3353cfd">
<p>
下表是 <b>Bootstrap</b> 的常用方法，其中很多是继承自 AbstractBootstrap：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> Boostrap 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名称</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">group</td>
<td class="org-left">设置 EventLoopGroup 用于处理所有的 Channel 的事件</td>
</tr>

<tr>
<td class="org-left">channel channelFactory</td>
<td class="org-left">channel() 指定Channel的实现类。如果类没有提供一个默认的构造函数,你可以调用channelFactory()来指定一个工厂类被bind()调用</td>
</tr>

<tr>
<td class="org-left">localAddress</td>
<td class="org-left">指定应该绑定到本地地址Channel。如果不提供,将由操作系统创建一个随机的。或者,您可以使用bind()或connect()指定localAddress</td>
</tr>

<tr>
<td class="org-left">option</td>
<td class="org-left">设置ChannelOption应用于新创建Channel的ChannelConfig。这些选项将被bind或connect设置在通道,这取决于哪个被首先调用。这个方法在创建管道后没有影响。所支持ChannelOption取决于使用的管道类型。请参考9.6节和 ChannelConfig 的 API 文档 的 Channel 类型使用</td>
</tr>

<tr>
<td class="org-left">attr</td>
<td class="org-left">这些选项将被bind或connect设置在通道,这取决于哪个被首先调用。这个方法在创建管道后没有影响。请参考9.6节</td>
</tr>

<tr>
<td class="org-left">handler</td>
<td class="org-left">设置添加到 ChannelPipeline 中的 ChannelHandler 接收事件通知</td>
</tr>

<tr>
<td class="org-left">clone</td>
<td class="org-left">创建一个当前 Bootstrap的克隆拥有原来相同的设置</td>
</tr>

<tr>
<td class="org-left">remoteAddress</td>
<td class="org-left">设置远程地址。此外可以通过connect()指定</td>
</tr>

<tr>
<td class="org-left">connect</td>
<td class="org-left">连接到远端，返回一个ChannelFuture, 用于通知连接操作完成</td>
</tr>

<tr>
<td class="org-left">bind</td>
<td class="org-left">将通道绑定并返回一个 ChannelFuture,用于通知绑定操作完成后,必须调用 Channel.connect() 来建立连接</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org031e7ad" class="outline-4">
<h4 id="org031e7ad">过程</h4>
<div class="outline-text-4" id="text-org031e7ad">
<p>
Bootstrap 类负责创建管道给客户或应用程序，利用无连接协议和在调用 bind() 或 connect() 之后
下图展示了如何工作：
</p>

<div class="figure">
<p><img src="pic/bootstrap-process.jpg" alt="bootstrap-process.jpg" width="70%" />
</p>
</div>

<ol class="org-ol">
<li>当 bind() 调用时，Bootstrap 将创建一个新的管道, 当 connect() 调用在 Channel 来建立连接</li>
<li>Bootstrap 将创建一个新的管道, 当 connect() 调用时</li>
<li>新的 Channel</li>
</ol>
</div>

<div id="outline-container-org4324d76" class="outline-5">
<h5 id="org4324d76">Bootstrap 实例</h5>
<div class="outline-text-5" id="text-org4324d76">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">EventLoopGroup</span> <span style="color: #4eee94;">group</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>();
<span style="color: #98f5ff;">Bootstrap</span> <span style="color: #4eee94;">bootstrap</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Bootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; Bootstrap &#26469;&#21019;&#24314;&#21644;&#36830;&#25509;&#21040;&#26032;&#30340;&#23458;&#25143;&#31471;&#31649;&#36947;</span>
bootstrap.group(group) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#25351;&#23450; EventLoopGroup</span>
.channel(NioSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#25351;&#23450; Channel &#23454;&#29616;&#26469;&#20351;&#29992;</span>
.handler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SimpleChannelInboundHandler</span>&lt;<span style="color: #98f5ff;">ByteBuf</span>&gt;() { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#35774;&#32622;&#22788;&#29702;&#22120;&#32473; Channel &#30340;&#20107;&#20214;&#21644;&#25968;&#25454;</span>
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channeRead0</span>(
            <span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">channelHandlerContext</span>,
            <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">byteBuf</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            System.out.println(<span style="color: #deb887;">"Received data"</span>);
            byteBuf.clear();
        }
    });
<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">future</span> = bootstrap.connect(
    <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(<span style="color: #deb887;">"www.manning.com"</span>, 80)); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#36830;&#25509;&#21040;&#36828;&#31471;&#20027;&#26426;</span>
future.addListener(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ChannelFutureListener</span>() {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">operationComplete</span>(<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">channelFuture</span>)
            <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (channelFuture.isSuccess()) {
                System.out.println(<span style="color: #deb887;">"Connection established"</span>);
            } <span style="color: #00bfff; font-weight: bold;">else</span> {
                System.err.println(<span style="color: #deb887;">"Connection attempt failed"</span>);
                channelFuture.cause().printStackTrace();
            }
        }
    });
</pre>
</div>

<pre class="example">
Bootstrap 提供了一个fluent语法

示例中使用的方法(除了connect()) 由 Bootstrap 返回实例本身的引用链接他们
</pre>
</div>
</div>

<div id="outline-container-org71af79e" class="outline-5">
<h5 id="org71af79e">兼容性</h5>
<div class="outline-text-5" id="text-org71af79e">
<p>
Channel 的实现和 EventLoop 的处理过程在 EventLoopGroup 中必须兼容．哪些 Channel 兼容哪些 EventLoopGroup 可以查看 API 文档。经验显示，相兼容的实现一般在同一个包下面，例如使用NioEventLoop，NioEventLoopGroup 和 NioServerSocketChannel 在一起。请注意，这些都是前缀 <b>Nio</b> ，然后 <b>不会用这些代替另一个实现和另一个前缀</b> ，如“Oio”，也就是说 OioEventLoopGroup 和NioServerSocketChannel 是不相容的
</p>

<p>
<b>Channel 和 EventLoopGroup 的 EventLoop 也必须兼容</b> ，例如NioEventLoop、NioEventLoopGroup、NioServerSocketChannel是相容的，但是 OioEventLoopGroup 和 NioServerSocketChannel 是不相容的。从类名可以看出前缀是 <b>Nio</b> 的只能和 <b>Nio</b> 的一起使用
</p>

<pre class="example">
EventLoop 分配给该 Channel 负责处理 Channel 的所有操作。 当执行一个方法,该方法返回一个 ChannelFuture ，它将在分配给 Channel 的 EventLoop 执行

EventLoopGroup 包含许多 EventLoops 和分配一个 EventLoop 通道时注册 
</pre>

<p>
下面代码所示的结果,试图使用一个 Channel 类型与一个 EventLoopGroup 兼容：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">EventLoopGroup</span> <span style="color: #4eee94;">group</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>();
<span style="color: #98f5ff;">Bootstrap</span> <span style="color: #4eee94;">bootstrap</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Bootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#26032;&#30340; Bootstrap &#26469;&#21019;&#24314;&#26032;&#30340;&#23458;&#25143;&#31471;&#31649;&#36947;</span>
bootstrap.group(group) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#27880;&#20876; EventLoopGroup &#29992;&#20110;&#33719;&#21462; EventLoop</span>
.channel(OioSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#25351;&#23450;&#35201;&#20351;&#29992;&#30340; Channel &#31867;&#12290;&#36890;&#30693;&#25105;&#20204;&#20351;&#29992; NIO &#29256;&#26412;&#29992;&#20110; EventLoopGroup &#65292; OIO &#29992;&#20110; Channel</span>
.handler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SimpleChannelInboundHandler</span>&lt;<span style="color: #98f5ff;">ByteBuf</span>&gt;() { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#35774;&#32622;&#22788;&#29702;&#22120;&#29992;&#20110;&#31649;&#36947;&#30340; I/O &#20107;&#20214;&#21644;&#25968;&#25454;</span>
                <span style="color: #ffd700;">@Override</span>
                <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelRead0</span>(
                        <span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">channelHandlerContext</span>,
                        <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">byteBuf</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
                        System.out.println(<span style="color: #deb887;">"Reveived data"</span>);
                        byteBuf.clear();
                }
        });
<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">future</span> = bootstrap.connect(
        <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(<span style="color: #deb887;">"www.manning.com"</span>, 80)); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#23581;&#35797;&#36830;&#25509;&#21040;&#36828;&#31471;&#12290;&#24403; NioEventLoopGroup &#21644; OioSocketChannel &#19981;&#20860;&#23481;&#26102;&#65292;&#20250;&#25243;&#20986; IllegalStateException &#24322;&#24120;</span>
future.syncUninterruptibly();
</pre>
</div>

<pre class="example">
Exception in thread "main" java.lang.IllegalStateException: incompatible event loop
type: io.netty.channel.nio.NioEventLoop
at
io.netty.channel.AbstractChannel$AbstractUnsafe.register(AbstractChannel.java:5
71)
...
</pre>


<p>
出现 IllegalStateException 的其他情况是，在 bind() 或 connect() 调用前 调用需要设置参数的方法调用失败时，包括：
</p>
<ul class="org-ul">
<li>group()</li>
<li>channel() 或 channnelFactory()</li>
<li>handler()</li>
</ul>

<p>
handler() 方法尤为重要,因为这些 ChannelPipeline 需要适当配置。 一旦提供了这些参数,应用程序将充分利用 Netty 的能力
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org8325c91" class="outline-3">
<h3 id="org8325c91">引导服务器</h3>
<div class="outline-text-3" id="text-org8325c91">
<p>
服务器的引导共用了客户端引导的一些逻辑 
</p>
</div>

<div id="outline-container-org95cbc40" class="outline-4">
<h4 id="org95cbc40">ServerBootstrap 的方法</h4>
<div class="outline-text-4" id="text-org95cbc40">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> ServerBoostrap 方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">group</td>
<td class="org-left">设置 EventLoopGroup 用于 ServerBootstrap。这个 EventLoopGroup 提供 ServerChannel 的 I/O 并且接收 Channel</td>
</tr>

<tr>
<td class="org-left">channel channelFactory</td>
<td class="org-left">channel() 指定 Channel 的实现类。如果管道没有提供一个默认的构造函数,你可以提供一个 ChannelFactory</td>
</tr>

<tr>
<td class="org-left">localAddress</td>
<td class="org-left">指定 ServerChannel 实例化的类。如果不提供，将由操作系统创建一个随机的。或者，可以使用 bind() 或 connect()指定localAddress</td>
</tr>

<tr>
<td class="org-left">option</td>
<td class="org-left">指定一个 ChannelOption 来用于新创建的 ServerChannel 的 ChannelConfig 。这些选项将被设置在管道的 bind() 或 connect(),这取决于谁首先被调用。在此调用这些方法之后设置或更改 ChannelOption 是无效的。所支持 ChannelOption 取决于使用的管道类型。请参考9.6节和 ChannelConfig 的 API 文档 的 Channel 类型使用</td>
</tr>

<tr>
<td class="org-left">childOption</td>
<td class="org-left">当管道已被接受，指定一个 ChannelOption 应用于 Channel 的 ChannelConfig</td>
</tr>

<tr>
<td class="org-left">attr</td>
<td class="org-left">指定 ServerChannel 的属性。这些属性可以被 管道的 bind() 设置。当调用 bind() 之后，修改它们不会生效</td>
</tr>

<tr>
<td class="org-left">childAttr</td>
<td class="org-left">应用属性到接收到的管道上。后续调用没有效果</td>
</tr>

<tr>
<td class="org-left">handler</td>
<td class="org-left">设置添加到 ServerChannel 的 ChannelPipeline 中的 ChannelHandler。 具体详见 childHandler() 描述</td>
</tr>

<tr>
<td class="org-left">childHandler</td>
<td class="org-left">设置添加到接收到的 Channel 的 ChannelPipeline 中的 ChannelHandler。handler() 和 childHandler()之间的区别是前者是接收和处理ServerChannel，同时 childHandler() 添加处理器用于处理和接收 Channel。后者代表一个套接字绑定到一个远端</td>
</tr>

<tr>
<td class="org-left">clone</td>
<td class="org-left">克隆 ServerBootstrap 用于连接到不同的远端，通过设置相同的原始 ServerBoostrap</td>
</tr>

<tr>
<td class="org-left">bind</td>
<td class="org-left">绑定 ServerChannel 并且返回一个 ChannelFuture，用于通知连接操作完成了（结果可以是成功或者失败）</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org7018cc1" class="outline-4">
<h4 id="org7018cc1">过程</h4>
<div class="outline-text-4" id="text-org7018cc1">
<p>
ServerBootstrap 中的 childHandler(), childAttr() 和 childOption() 是常用的服务器应用的操作。具体来说,ServerChannel实现负责创建子 Channel，它代表接受连接。因此引导 ServerChannel 的 ServerBootstrap ,提供这些方法来简化接收的 Channel 对 ChannelConfig 应用设置的任务
</p>

<p>
图9.3显示了 ServerChannel 创建 ServerBootstrap 在 bind()，后者管理大量的子 Channel：
</p>


<div class="figure">
<p><img src="pic/server-bootstrap.jpg" alt="server-bootstrap.jpg" width="70%" />
</p>
</div>

<ol class="org-ol">
<li>当调用 bind() 后 ServerBootstrap 将创建一个新的管道，这个管道将会在绑定成功后接收子管道</li>
<li>接收新连接给每个子管道</li>
<li>接收连接的 Channel</li>
</ol>

<p>
记住： <b>child 的方法都是操作在子的 Channel，被 ServerChannel 管理</b>
</p>

<p>
下面代码展示创建一个 NioServerSocketChannel实例 bind() 。这个 NioServerChannel 负责接受新连接和创建NioSocketChannel 实例：
</p>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">NioEventLoopGroup</span> <span style="color: #4eee94;">group</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>();
<span style="color: #98f5ff;">ServerBootstrap</span> <span style="color: #4eee94;">bootstrap</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ServerBootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#35201;&#32473;&#26032;&#30340; ServerBootstrap &#26469;&#21019;&#24314;&#26032;&#30340; SocketChannel &#31649;&#36947;&#24182;&#32465;&#23450;&#20182;&#20204;</span>
bootstrap.group(group) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#25351;&#23450; EventLoopGroup &#29992;&#20110;&#20174;&#27880;&#20876;&#30340; ServerChannel &#20013;&#33719;&#21462;EventLoop &#21644;&#25509;&#25910;&#21040;&#30340;&#31649;&#36947;</span>
.channel(NioServerSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#25351;&#23450;&#35201;&#20351;&#29992;&#30340;&#31649;&#36947;&#31867;</span>
.childHandler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SimpleChannelInboundHandler</span>&lt;<span style="color: #98f5ff;">ByteBuf</span>&gt;() { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#35774;&#32622;&#23376;&#22788;&#29702;&#22120;&#29992;&#20110;&#22788;&#29702;&#25509;&#25910;&#30340;&#31649;&#36947;&#30340; I/O &#21644;&#25968;&#25454;</span>
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelRead0</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>,
                        <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">byteBuf</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            System.out.println(<span style="color: #deb887;">"Reveived data"</span>);
            byteBuf.clear();
        }
    }
    );
<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">future</span> = bootstrap.bind(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(8080)); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#36890;&#36807;&#37197;&#32622;&#24341;&#23548;&#26469;&#32465;&#23450;&#31649;&#36947;</span>
future.addListener(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ChannelFutureListener</span>() {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">operationComplete</span>(<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">channelFuture</span>)
            <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (channelFuture.isSuccess()) {
                System.out.println(<span style="color: #deb887;">"Server bound"</span>);
            } <span style="color: #00bfff; font-weight: bold;">else</span> {
                System.err.println(<span style="color: #deb887;">"Bound attempt failed"</span>);
                channelFuture.cause().printStackTrace();
            }
        }
    }
    );
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7f04029" class="outline-3">
<h3 id="org7f04029">从 Channel 引导客户端</h3>
<div class="outline-text-3" id="text-org7f04029">
<p>
有时可能需要引导客户端 Channel 从另一个 Channel。例如，正在编写一个代理或从其他系统需要检索数据，许多 Netty 的应用程序集成现有系统（web 服务或数据库）
</p>

<pre class="example">
当然可以创建一个新的 Bootstrap 但这个解决方案不一定有效：
1. 需要创建另一个 EventLoop 给新客户端 Channel 的
2. Channel 将会需要在不同的 Thread 间进行上下文切换
</pre>


<p>
幸运的是，由于 EventLoop 继承自 EventLoopGroup ，所以可以通过 <b>传递接收到的 Channel 的 EventLoop 到 Bootstrap 的 group() 方法</b> 。这允许客户端 Channel 来操作相同的EventLoop，这样就能消除了额外的线程创建和所有相关的上下文切换的开销
</p>
</div>

<div id="outline-container-orgbf529b1" class="outline-4">
<h4 id="orgbf529b1">共享 EventLoop</h4>
<div class="outline-text-4" id="text-orgbf529b1">
<p>
当分享一个 EventLoop ，保证所有 Channel 分配给 EventLoop 将使用相同的线程，消除上下文切换和相关的开销。请记住： <b>一个EventLoop分配给一个线程执行操作</b> 
</p>

<p>
共享一个 EventLoop 描述如下：
</p>

<div class="figure">
<p><img src="pic/share-event-loop.jpg" alt="share-event-loop.jpg" width="70%" />
</p>
</div>

<ol class="org-ol">
<li>当 bind() 调用时，ServerBootstrap 创建一个新的ServerChannel 。 当绑定成功后，这个管道就能接收子管道了</li>
<li>ServerChannel 接收新连接并且创建子管道来服务它们</li>
<li>Channel 用于接收到的连接</li>
<li>管道自己创建了 Bootstrap，用于当 connect() 调用时创建一个新的管道</li>
<li>新管道连接到远端</li>
<li>在 EventLoop 接收通过 connect() 创建后就在管道间共享</li>
</ol>
</div>

<div id="outline-container-org5558f0f" class="outline-5">
<h5 id="org5558f0f">实例</h5>
<div class="outline-text-5" id="text-org5558f0f">
<p>
下面代码实现 EventLoop 共享，包括设置 EventLoop 引导通过Bootstrap.eventLoop() 方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ServerBootstrap</span> <span style="color: #4eee94;">bootstrap</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ServerBootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; ServerBootstrap &#26469;&#21019;&#24314;&#26032;&#30340; SocketChannel &#31649;&#36947;&#24182;&#19988;&#32465;&#23450;&#20182;&#20204;</span>
bootstrap.group(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>(), <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#25351;&#23450; EventLoopGroups &#20174; ServerChannel &#21644;&#25509;&#25910;&#21040;&#30340;&#31649;&#36947;&#26469;&#27880;&#20876;&#24182;&#33719;&#21462; EventLoops </span>
        <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>()).channel(NioServerSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3&#25351;&#23450; Channel &#31867;&#26469;&#20351;&#29992;</span>
.childHandler(        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#35774;&#32622;&#22788;&#29702;&#22120;&#29992;&#20110;&#22788;&#29702;&#25509;&#25910;&#21040;&#30340;&#31649;&#36947;&#30340; I/O &#21644;&#25968;&#25454;</span>
    <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SimpleChannelInboundHandler</span>&lt;<span style="color: #98f5ff;">ByteBuf</span>&gt;() {
        <span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">connectFuture</span>;

        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelActive</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #98f5ff;">Bootstrap</span> <span style="color: #4eee94;">bootstrap</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Bootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; Bootstrap &#26469;&#36830;&#25509;&#21040;&#36828;&#31243;&#20027;&#26426;</span>
            bootstrap.channel(NioSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">6 &#35774;&#32622;&#31649;&#36947;&#31867;</span>
                .handler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SimpleChannelInboundHandler</span>&lt;<span style="color: #98f5ff;">ByteBuf</span>&gt;() {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">7 &#35774;&#32622;&#22788;&#29702;&#22120;&#26469;&#22788;&#29702; I/O</span>
                        <span style="color: #ffd700;">@Override</span>
                        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelRead0</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">in</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
                            System.out.println(<span style="color: #deb887;">"Reveived data"</span>);
                        }
                    });
            bootstrap.group(ctx.channel().eventLoop()); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">8 &#20351;&#29992;&#30456;&#21516;&#30340; EventLoop &#20316;&#20026;&#20998;&#37197;&#21040;&#25509;&#25910;&#30340;&#31649;&#36947;</span>
            connectFuture = bootstrap.connect(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(<span style="color: #deb887;">"www.manning.com"</span>, 80));  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">9 &#36830;&#25509;&#21040;&#36828;&#31471;</span>
        }

        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelRead0</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">channelHandlerContext</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">byteBuf</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (connectFuture.isDone()) {
                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">do something with the data  //10 &#36830;&#25509;&#23436;&#25104;&#22788;&#29702;&#19994;&#21153;&#36923;&#36753; (&#27604;&#22914;, proxy)</span>
            }
        }
    });
<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">future</span> = bootstrap.bind(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(8080));  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">11 &#36890;&#36807;&#37197;&#32622;&#20102;&#30340; Bootstrap &#26469;&#32465;&#23450;&#21040;&#31649;&#36947;</span>
future.addListener(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ChannelFutureListener</span>() {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">operationComplete</span>(<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">channelFuture</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (channelFuture.isSuccess()) {
                System.out.println(<span style="color: #deb887;">"Server bound"</span>);
            } <span style="color: #00bfff; font-weight: bold;">else</span> {
                System.err.println(<span style="color: #deb887;">"Bound attempt failed"</span>);
                channelFuture.cause().printStackTrace();
            }
        }
    });
</pre>
</div>

<pre class="example">
注意，新的 EventLoop 会创建一个新的 Thread

EventLoop 实例应该尽量重用。或者限制实例的数量来避免耗尽系统资源
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org067f07a" class="outline-3">
<h3 id="org067f07a">在一个引导中添加多个 ChannelHandler</h3>
<div class="outline-text-3" id="text-org067f07a">
<p>
在所有的例子代码中，在引导过程中通过 handler() 或childHandler() 都只添加了一个 ChannelHandler 实例，对于简单的程序可能足够，但是对于复杂的程序则无法满足需求。例如，某个程序必须支持多个协议，如 HTTP、WebSocket。若在一个 ChannelHandler中处理这些协议将导致一个庞大而复杂的 ChannelHandler。Netty 通过添加多个 ChannelHandler，从而使每个 ChannelHandler 分工明确，结构清晰
</p>

<pre class="example">
Netty 的一个优势是可以在 ChannelPipeline 中堆叠很多ChannelHandler ，并且可以最大程度的重用代码
</pre>

<p>
Netty 提供 ChannelInitializer 抽象类用来初始化 ChannelPipeline 中的 ChannelHandler。ChannelInitializer是一个特殊的 ChannelHandler， <b>通道被注册到 EventLoop 后就会调用ChannelInitializer，并允许将 ChannelHandler 添加到CHannelPipeline；完成初始化通道后，这个特殊的 ChannelHandler 初始化器会从 ChannelPipeline 中自动删除</b>
</p>
</div>

<div id="outline-container-org129877f" class="outline-4">
<h4 id="org129877f">实例</h4>
<div class="outline-text-4" id="text-org129877f">
<p>
看下面代码：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">ServerBootstrap</span> <span style="color: #4eee94;">bootstrap</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ServerBootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; ServerBootstrap &#26469;&#21019;&#24314;&#21644;&#32465;&#23450;&#26032;&#30340; Channel</span>
bootstrap.group(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>(), <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>())  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#25351;&#23450; EventLoopGroups &#20174; ServerChannel &#21644;&#25509;&#25910;&#21040;&#30340;&#31649;&#36947;&#26469;&#27880;&#20876;&#24182;&#33719;&#21462; EventLoops </span>
.channel(NioServerSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>)  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#25351;&#23450; Channel &#31867;&#26469;&#20351;&#29992; </span>
.childHandler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ChannelInitializerImpl</span>()); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#35774;&#32622;&#22788;&#29702;&#22120;&#29992;&#20110;&#22788;&#29702;&#25509;&#25910;&#21040;&#30340;&#31649;&#36947;&#30340; I/O &#21644;&#25968;&#25454;</span>
<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">future</span> = bootstrap.bind(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(8080));  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#36890;&#36807;&#37197;&#32622;&#30340;&#24341;&#23548;&#26469;&#32465;&#23450;&#31649;&#36947;</span>
future.sync();


<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ChannelInitializerImpl</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ChannelInitializer</span>&lt;<span style="color: #98f5ff;">Channel</span>&gt; {  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">6 ChannelInitializer &#36127;&#36131;&#35774;&#32622; ChannelPipeline</span>
    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">initChannel</span>(<span style="color: #98f5ff;">Channel</span> <span style="color: #4eee94;">ch</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        <span style="color: #98f5ff;">ChannelPipeline</span> <span style="color: #4eee94;">pipeline</span> = ch.pipeline(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">7 &#29616; initChannel() &#26469;&#28155;&#21152;&#38656;&#35201;&#30340;&#22788;&#29702;&#22120;&#21040; ChannelPipeline&#12290;&#19968;&#26086;&#23436;&#25104;&#20102;&#36825;&#26041;&#27861; ChannelInitializer &#23558;&#20250;&#20174; ChannelPipeline &#21024;&#38500;&#33258;&#36523;</span>
        pipeline.addLast(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">HttpClientCodec</span>());
        pipeline.addLast(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">HttpObjectAggregator</span>(<span style="color: #ffd700;">Integer</span>.MAX_VALUE));

    }
}
</pre>
</div>

<p>
通过 ChannelInitializer，Netty 允许你添加你程序所需的多个 ChannelHandler 到 ChannelPipeline
</p>
</div>
</div>
</div>

<div id="outline-container-org59be412" class="outline-3">
<h3 id="org59be412">使用Netty 的 ChannelOption 和属性</h3>
<div class="outline-text-3" id="text-org59be412">
<p>
比较麻烦的是创建通道后不得不手动配置每个通道，为了避免这种情况，Netty 提供了 ChannelOption 来帮助引导配置。这些选项会自动应用到引导创建的所有通道，可用的各种选项可以配置底层连接的详细信息，如通道 <b>keep-alive（保持活跃）</b> 或 <b>timeout（超时）</b> 的特性。
</p>

<p>
Netty 应用程序通常会与组织或公司其他的软件进行集成，在某些情况下，Netty 的组件如 Channel 在 Netty 正常生命周期外使用； Netty 的提供了 *抽象 AttributeMap 集合*，这是由 Netty的管道和引导类和 AttributeKey常见类用于插入和检索属性值。属性允许安全的关联任何数据项与客户端和服务器的 Channel
</p>
</div>

<div id="outline-container-org4855446" class="outline-4">
<h4 id="org4855446">配置和属性实例</h4>
<div class="outline-text-4" id="text-org4855446">
<p>
例如，考虑一个服务器应用程序跟踪用户和 Channel 之间的关系。这可以通过存储用户 ID 作为 Channel 的一个属性。类似的技术可以用来路由消息到基于用户 ID 或关闭基于用户活动的一个管道：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AttributeKey</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt; <span style="color: #4eee94;">id</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AttributeKey</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt;(<span style="color: #deb887;">"ID"</span>);&#12288;<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#26032;&#24314;&#19968;&#20010; AttributeKey &#29992;&#26469;&#23384;&#20648;&#23646;&#24615;&#20540;</span>

Bootstrap bootstrap = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Bootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#26032;&#24314; Bootstrap &#29992;&#26469;&#21019;&#24314;&#23458;&#25143;&#31471;&#31649;&#36947;&#24182;&#36830;&#25509;&#20182;&#20204;</span>
bootstrap.group(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>()) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#25351;&#23450; EventLoopGroups &#20174;&#21644;&#25509;&#25910;&#21040;&#30340;&#31649;&#36947;&#26469;&#27880;&#20876;&#24182;&#33719;&#21462; EventLoop</span>
.channel(NioSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">4 &#25351;&#23450; Channel &#31867;</span>
.handler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SimpleChannelInboundHandler</span>&lt;<span style="color: #98f5ff;">ByteBuf</span>&gt;() { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">5 &#35774;&#32622;&#22788;&#29702;&#22120;&#26469;&#22788;&#29702;&#31649;&#36947;&#30340; I/O &#21644;&#25968;&#25454;</span>
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelRegistered</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">ctx</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #98f5ff;">Integer</span> <span style="color: #4eee94;">idValue</span> = ctx.channel().attr(id).get();  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">6 &#26816;&#32034; AttributeKey &#30340;&#23646;&#24615;&#21450;&#20854;&#20540;</span>
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">do something  with the idValue</span>
        }

        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">channelRead0</span>(<span style="color: #98f5ff;">ChannelHandlerContext</span> <span style="color: #4eee94;">channelHandlerContext</span>, <span style="color: #98f5ff;">ByteBuf</span> <span style="color: #4eee94;">byteBuf</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            System.out.println(<span style="color: #deb887;">"Reveived data"</span>);
        }
    });
bootstrap.option(<span style="color: #ffd700;">ChannelOption</span>.SO_KEEPALIVE, <span style="color: #ffd700;">true</span>).option(<span style="color: #ffd700;">ChannelOption</span>.CONNECT_TIMEOUT_MILLIS, 5000);   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">7 &#35774;&#32622; ChannelOption &#23558;&#20250;&#35774;&#32622;&#22312;&#31649;&#36947;&#22312;&#36830;&#25509;&#25110;&#32773;&#32465;&#23450;</span>
bootstrap.attr(id, 123456); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">8 &#23384;&#20648; id &#23646;&#24615;</span>

<span style="color: #98f5ff;">ChannelFuture</span> <span style="color: #4eee94;">future</span> = bootstrap.connect(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InetSocketAddress</span>(<span style="color: #deb887;">"www.manning.com"</span>, 80));   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">9 &#36890;&#36807;&#37197;&#32622;&#30340; Bootstrap &#26469;&#36830;&#25509;&#21040;&#36828;&#31243;&#20027;&#26426;</span>
future.syncUninterruptibly();
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org17f0508" class="outline-2">
<h2 id="org17f0508">关闭之前已经引导的客户端或服务器</h2>
<div class="outline-text-2" id="text-org17f0508">
<p>
引导应用程序启动并运行，但是迟早也需要关闭它。当然你可以让 JVM处理所有退出但这不会满足 <b>优雅</b> 的定义，是指干净地释放资源。关闭一个Netty 的应用程序并不复杂，但有几件事要记住：
</p>
<ul class="org-ul">
<li>关闭 EventLoopGroup 将处理任何悬而未决的事件和任务并随后释放所有活动线程。EventLoopGroup.shutdownGracefully()这个调用将返回一个 Future 用来通知关闭完成</li>
<li>shutdownGracefully() 也是一个异步操作，所以 <b>需要阻塞直到它完成或注册一个侦听器直到返回的 Future</b> 来通知完成</li>
</ul>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">EventLoopGroup</span> <span style="color: #4eee94;">group</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">NioEventLoopGroup</span>() <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">1 &#21019;&#24314; EventLoopGroup &#29992;&#20110;&#22788;&#29702; I/O</span>
    Bootstrap bootstrap = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Bootstrap</span>(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">2 &#21019;&#24314;&#19968;&#20010;&#26032;&#30340; Bootstrap &#24182;&#19988;&#37197;&#32622;&#20182;</span>
bootstrap.group(group)
.channel(NioSocketChannel.<span style="color: #00bfff; font-weight: bold;">class</span>);
...
...
<span style="color: #98f5ff;">Future</span>&lt;?&gt; future = group.shutdownGracefully(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">3 &#26368;&#32456;&#20248;&#38597;&#30340;&#20851;&#38381; EventLoopGroup &#37322;&#25918;&#36164;&#28304;&#12290;&#36825;&#20010;&#20063;&#20250;&#20851;&#38381;&#20013;&#24403;&#21069;&#20351;&#29992;&#30340; Channel</span>
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">block until the group has shutdown</span>
future.sync();
</pre>
</div>

<pre class="example">
当然在调用EventLoopGroup.shutdownGracefully()之前可以显示调用 Channel.close() 关闭活动管道

在所有情况下，记得关闭EventLoopGroup 本身
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
