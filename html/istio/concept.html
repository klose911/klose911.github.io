<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>概念</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="istio.html"> UP </a>
 |
 <a accesskey="H" href="istio.html"> HOME </a>
</div><div id="content">
<h1 class="title">概念</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd401014">Istio 是什么？</a>
<ul>
<li><a href="#orgb3b48f0">服务网格</a></li>
<li><a href="#orga4ce8c9">为什么使用 Istio？</a></li>
<li><a href="#org8cfc695">核心特性</a>
<ul>
<li><a href="#orgb4316bd">流量管理</a></li>
<li><a href="#orgebb1858">安全</a></li>
<li><a href="#orgfa8b57c">可观察性</a></li>
<li><a href="#orgf38bef9">平台支持</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1068a7b">流量管理</a>
<ul>
<li><a href="#org4e4b5e7">介绍</a></li>
<li><a href="#orgd3f35d6">虚拟服务</a>
<ul>
<li><a href="#orgc58a229">为什么使用虚拟服务？</a></li>
<li><a href="#orge9763e3">虚拟服务示例</a>
<ul>
<li><a href="#orge47c171">hosts 字段</a></li>
<li><a href="#org831e193">路由规则</a></li>
<li><a href="#orge05ad23">路由规则优先级</a></li>
</ul>
</li>
<li><a href="#orgc9a1420">路由规则的更多内容</a></li>
</ul>
</li>
<li><a href="#orgbf5b545">目标规则</a>
<ul>
<li><a href="#org59fef47">负载均衡选项</a></li>
<li><a href="#org7defc86">目标规则示例</a></li>
</ul>
</li>
<li><a href="#org59a1ab4">网关</a>
<ul>
<li><a href="#org47dfc45">Gateway 示例</a></li>
</ul>
</li>
<li><a href="#orgf2f989c">服务入口</a>
<ul>
<li><a href="#org7a9f085">服务入口实例</a></li>
</ul>
</li>
<li><a href="#org3a479f7">Sidecar</a></li>
<li><a href="#org87dd3e4">网络弹性和测试</a>
<ul>
<li><a href="#orge84a2d1">超时</a></li>
<li><a href="#org767266c">重试</a></li>
<li><a href="#org074b96a">熔断器</a></li>
<li><a href="#orgd884249">故障注入</a></li>
<li><a href="#org6a38f68">和您的应用程序一起运行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org20f985b">扩展性</a></li>
<li><a href="#org14efe51">安全</a>
<ul>
<li><a href="#org4a47fd1">高级架构</a></li>
<li><a href="#org4636893">Istio 身份</a></li>
<li><a href="#org7ae267f">公钥基础设施 (PKI)</a></li>
<li><a href="#orge8b530b">认证</a>
<ul>
<li><a href="#org463246c">双向 TLS 认证</a>
<ul>
<li><a href="#orgb670d60">宽容模式</a></li>
<li><a href="#orgaf47915">安全命名</a></li>
</ul>
</li>
<li><a href="#orga716ce5">认证架构</a></li>
<li><a href="#org21c1657">认证策略</a>
<ul>
<li><a href="#org467cf68">策略存储</a></li>
<li><a href="#org325b1aa">Selector 字段</a></li>
<li><a href="#orgefab3f5">Peer authentication</a></li>
<li><a href="#org21b9065">Request authentication</a></li>
<li><a href="#org557895b">Principals</a></li>
</ul>
</li>
<li><a href="#org48b54a5">更新认证策略</a></li>
</ul>
</li>
<li><a href="#org4da80bd">授权</a>
<ul>
<li><a href="#orgbdbb470">授权架构</a></li>
<li><a href="#orgab05cfa">隐式启用</a></li>
<li><a href="#orga12ee4a">授权策略</a>
<ul>
<li><a href="#orgf27fd15">策略目标</a></li>
<li><a href="#orga756126">值匹配</a></li>
<li><a href="#org74eda20">排除匹配</a></li>
<li><a href="#org5061c31">全部允许和默认全部拒绝授权策略</a></li>
<li><a href="#org89acf46">自定义条件</a></li>
<li><a href="#orgc7ae05a">认证与未认证身份</a></li>
</ul>
</li>
<li><a href="#orgb9f2d8d">在普通 TCP 协议上使用 Istio 授权</a></li>
<li><a href="#orgd9f2f01">对双向 TLS 的依赖</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8142186">可观察性</a>
<ul>
<li><a href="#orgf8b6046">指标</a>
<ul>
<li><a href="#org59c6a77">代理级别指标</a></li>
<li><a href="#org0e6770d">服务级别指标</a></li>
<li><a href="#org7ec51f3">控制平面指标</a></li>
</ul>
</li>
<li><a href="#orgdc3c567">分布式追踪</a></li>
<li><a href="#org70c1539">访问日志</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd401014" class="outline-2">
<h2 id="orgd401014">Istio 是什么？</h2>
<div class="outline-text-2" id="text-orgd401014">
<pre class="example">
云平台令使用它们的公司受益匪浅，但不可否认的是，上云会给 DevOps 团队带来压力

为了可移植性，开发人员必须使用微服务来构建应用，同时运维人员也正在管理着极端庞大的混合云和多云的部署环境
</pre>
<p>
Istio 允许您 <span class="underline">连接</span> 、 <span class="underline">保护</span> 、 <span class="underline">控制</span> 和 <span class="underline">观察</span> 服务。从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力：
</p>
<ul class="org-ul">
<li>它是一个完全开源的 <span class="underline">服务网格</span> ，作为 <span class="underline">透明的一层</span> 接入到现有的分布式应用程序里</li>
<li>它也是一个 <span class="underline">平台</span> ，拥有可以集成任何 <span class="underline">日志</span> 、 <span class="underline">遥测</span>  和 <span class="underline">策略</span> 系统的 <span class="underline">API 接口</span></li>
</ul>

<p>
Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法
</p>
</div>
<div id="outline-container-orgb3b48f0" class="outline-3">
<h3 id="orgb3b48f0">服务网格</h3>
<div class="outline-text-3" id="text-orgb3b48f0">
<p>
<span class="underline">服务网格</span> 用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括 <span class="underline">服务发现</span> 、 <span class="underline">负载均衡</span> 、 <span class="underline">故障恢复</span> 、 <span class="underline">度量</span> 和 <span class="underline">监控</span> 等。服务网格通常还有更复杂的运维需求，比如 <span class="underline">A/B 测试</span> 、 <span class="underline">金丝雀发布</span> 、 <span class="underline">速率限制</span> 、 <span class="underline">访问控制</span> 和 <span class="underline">端到端认证</span> 
</p>

<pre class="example">
Istio 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案
</pre>
</div>
</div>
<div id="outline-container-orga4ce8c9" class="outline-3">
<h3 id="orga4ce8c9">为什么使用 Istio？</h3>
<div class="outline-text-3" id="text-orga4ce8c9">
<p>
通过负载均衡、服务间的身份验证、监控等方法，Istio 可以轻松地创建一个已经部署了服务的网络，而服务的代码只需很少更改甚至无需更改。通过在整个环境中部署一个特殊的 <span class="underline">sidecar 代理</span> 为服务添加 Istio 的支持，而代理会 <b>拦截</b> <span class="underline">微服务之间</span> 的所有 <span class="underline">网络通信</span> ，然后使用其 <span class="underline">控制平面</span> 的功能来 <b>配置</b> 和 <b>管理</b> Istio，这包括：
</p>
<ul class="org-ul">
<li>为 HTTP、gRPC、WebSocket 和 TCP 流量自动 <span class="underline">负载均衡</span></li>
<li>通过丰富的 <span class="underline">路由规则</span> 、 <span class="underline">重试</span> 、 <span class="underline">故障转移</span> 和 <span class="underline">故障注入</span> 对 <b>流量行为</b> 进行 <span class="underline">细粒度控制</span></li>
<li>可插拔的策略层和配置 API，支持 <span class="underline">访问控制</span> 、 <span class="underline">速率限制</span> 和 <span class="underline">配额</span></li>
<li>集群内（包括集群的入口和出口）所有流量的 <span class="underline">自动化度量</span> 、 <span class="underline">日志记录</span> 和 <span class="underline">追踪</span></li>
<li>在具有强大的基于 <span class="underline">身份验证</span> 和 <span class="underline">授权</span> 的集群中实现 <b>安全的</b> 服务间通信</li>
</ul>

<pre class="example">
Istio 为可扩展性而设计，可以满足不同的部署需求
</pre>
</div>
</div>
<div id="outline-container-org8cfc695" class="outline-3">
<h3 id="org8cfc695">核心特性</h3>
<div class="outline-text-3" id="text-org8cfc695">
<p>
Istio 以统一的方式提供了许多跨服务网络的关键功能
</p>
</div>
<div id="outline-container-orgb4316bd" class="outline-4">
<h4 id="orgb4316bd">流量管理</h4>
<div class="outline-text-4" id="text-orgb4316bd">
<p>
Istio 简单的 <span class="underline">规则配置</span> 和 <span class="underline">流量路由</span> 允许您控制服务之间的流量和 API 调用过程。Istio 简化了 <b>服务级属性</b> （如 <span class="underline">熔断器</span> 、 <span class="underline">超时</span> 和 <span class="underline">重试</span> ）的配置，并且让它轻而易举的执行重要的任务（如 <span class="underline">A/B 测试</span> 、 <span class="underline">金丝雀发布</span> 和 <span class="underline">按流量百分比</span> 划分的分阶段发布） 
</p>

<pre class="example">
有了更好的对流量的可视性和开箱即用的故障恢复特性，您就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮
</pre>
</div>
</div>
<div id="outline-container-orgebb1858" class="outline-4">
<h4 id="orgebb1858">安全</h4>
<div class="outline-text-4" id="text-orgebb1858">
<p>
Istio 的安全特性解放了开发人员，使其只需要专注于应用程序级别的安全。Istio 提供了 <b>底层的安全通信通道</b> ，并为大规模的服务通信管理 <span class="underline">认证</span> 、 <span class="underline">授权</span> 和 <span class="underline">加密</span> 
</p>
<pre class="example">
有了 Istio，服务通信在默认情况下就是受保护的，可以让您在跨不同协议和运行时的情况下实施一致的策略――而所有这些都只需要很少甚至不需要修改应用程序

Istio 是独立于平台的，可以与 Kubernetes（或基础设施）的网络策略一起使用。但它更强大，能够在网络和应用层面保护pod到 pod 或者服务到服务之间的通信
</pre>
</div>
</div>
<div id="outline-container-orgfa8b57c" class="outline-4">
<h4 id="orgfa8b57c">可观察性</h4>
<div class="outline-text-4" id="text-orgfa8b57c">
<p>
Istio 健壮的 <span class="underline">追踪</span> 、 <span class="underline">监控</span> 和 <span class="underline">日志</span> 特性让您能够深入的了解服务网格部署
</p>
<pre class="example">
通过 Istio 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的

而它的定制 Dashboard 提供了对所有服务性能的可视化能力，并让您看到它如何影响其他进程
</pre>
<p>
Istio 的 <span class="underline">Mixer 组件</span> 负责 <b>策略控制</b> 和 <b>遥测数据收集</b> 。它提供了后端抽象和中介，将一部分 Istio 与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制
</p>

<pre class="example">
所有这些特性都使您能够更有效地设置、监控和加强服务的 SLO。当然，底线是您可以快速有效地检测到并修复出现的问题
</pre>
</div>
</div>
<div id="outline-container-orgf38bef9" class="outline-4">
<h4 id="orgf38bef9">平台支持</h4>
<div class="outline-text-4" id="text-orgf38bef9">
<p>
Istio 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、Kubernetes、Mesos 等等。可以在 Kubernetes 或是装有 Consul 的 Nomad 环境上部署 Istio。Istio 目前支持：
</p>
<ul class="org-ul">
<li>Kubernetes 上的服务部署</li>
<li>基于 Consul 的服务注册</li>
<li>服务运行在独立的虚拟机上</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org1068a7b" class="outline-2">
<h2 id="org1068a7b">流量管理</h2>
<div class="outline-text-2" id="text-org1068a7b">
<pre class="example">
Istio 的 流量路由规则可以让您很容易的控制服务之间的流量和 API 调用

Istio 简化了服务级别属性的配置，比如熔断器、超时和重试，并且能轻松的设置重要的任务，如 A/B 测试、金丝雀发布、基于流量百分比切分的概率发布等

它还提供了开箱即用的故障恢复特性，有助于增强应用的健壮性，从而更好地应对被依赖的服务或网络发生故障的情况
</pre>
<p>
Istio 的流量管理模型源于和 <span class="underline">服务一起部署</span> 的 <span class="underline">Envoy 代理</span> 。 <span class="underline">网格内服务</span> <b>发送</b> 和 <b>接收</b> 的  <span class="underline">所有流量</span> （data plane流量）都经由 <span class="underline">Envoy</span> <b>代理</b> 
</p>

<pre class="example">
这让控制网格内的流量变得异常简单，而且不需要对服务做任何的更改
</pre>
</div>
<div id="outline-container-org4e4b5e7" class="outline-3">
<h3 id="org4e4b5e7">介绍</h3>
<div class="outline-text-3" id="text-org4e4b5e7">
<p>
为了在网格中导流，Istio 需要知道所有的 endpoint 在哪和属于哪个服务。为了定位到 <span class="underline">service registry</span> (服务注册中心)，Istio 会连接到一个服务发现系统
</p>
<pre class="example">
例如，如果您在 Kubernetes 集群上安装了 Istio，那么它将自动检测该集群中的服务和 endpoint
</pre>

<p>
使用此服务注册中心，Envoy 代理可以将流量定向到相关服务。大多数基于微服务的应用程序，每个服务的工作负载都有多个实例来处理流量，称为 <span class="underline">负载均衡池</span> 。默认情况下，Envoy 代理基于 <span class="underline">轮询调度</span> 模型在服务的负载均衡池内分发流量，按顺序将请求发送给池中每个成员，一旦所有服务实例均接收过一次请求后，重新回到第一个池成员 
</p>

<pre class="example">
Istio 基本的服务发现和负载均衡能力为您提供了一个可用的服务网格，但它能做到的远比这多的多

在许多情况下，您可能希望对网格的流量情况进行更细粒度的控制

作为 A/B 测试的一部分，您可能想将特定百分比的流量定向到新版本的服务，或者为特定的服务实例子集应用不同的负载均衡策略

您可能还想对进出网格的流量应用特殊的规则，或者将网格的外部依赖项添加到服务注册中心
</pre>

<p>
通过使用 Istio 的 <span class="underline">流量管理 API</span> 将流量配置添加到 Istio，就可以完成所有这些甚至更多的工作 
</p>

<pre class="example">
和其他 Istio 配置一样，这些 API 也使用 Kubernetes 的自定义资源定义（CRDs）来声明，可以像示例中看到的那样使用 YAML 进行配置
</pre>
</div>
</div>
<div id="outline-container-orgd3f35d6" class="outline-3">
<h3 id="orgd3f35d6">虚拟服务</h3>
<div class="outline-text-3" id="text-orgd3f35d6">
<p>
<span class="underline">虚拟服务</span> （Virtual Service） 和 <span class="underline">目标规则</span> （Destination Rule） 是 Istio 流量路由功能的关键拼图。虚拟服务让您配置如何在服务网格内将请求路由到服务，这基于 Istio 和平台提供的基本的连通性和服务发现能力。每个虚拟服务包含一组 <span class="underline">路由规则</span> ，Istio 按顺序评估它们，Istio 将每个给定的请求匹配到虚拟服务指定的实际目标地址
</p>

<pre class="example">
您的网格可以有多个虚拟服务，也可以没有，取决于您的使用场景
</pre>
</div>

<div id="outline-container-orgc58a229" class="outline-4">
<h4 id="orgc58a229">为什么使用虚拟服务？</h4>
<div class="outline-text-4" id="text-orgc58a229">
<p>
虚拟服务在增强 Istio 流量管理的 <span class="underline">灵活性</span> 和 <span class="underline">有效性</span> 方面，发挥着至关重要的作用，通过对 <span class="underline">客户端请求的目标地址</span> 与 <span class="underline">真实响应请求的目标工作负载</span> 进行 <b>解耦</b> 来实现。虚拟服务同时提供了丰富的方式，为发送至这些工作负载的流量指定不同的路由规则。
</p>

<pre class="example">
为什么这如此有用？就像在介绍中所说，如果没有虚拟服务，Envoy 会在所有的服务实例中使用轮询的负载均衡策略分发请求，您可以用您对工作负载的了解来改善这种行为

例如，有些可能代表不同的版本。这在 A/B 测试中可能有用，您可能希望在其中配置基于不同服务版本的流量百分比路由，或指引从内部用户到特定实例集的流量
</pre>
<p>
使用 <span class="underline">虚拟服务</span> ，可以为 <span class="underline">一个或多个主机名</span> 指定 <span class="underline">流量行为</span> 。在虚拟服务中使用 <span class="underline">路由规则</span> ，告诉 Envoy 如何 <b>发送</b> <span class="underline">虚拟服务的流量</span> 到适当的 <span class="underline">目标</span> 。 <span class="underline">路由目标地址</span> 可以是 <span class="underline">同一服务的不同版本</span> ，也可以是 <span class="underline">完全不同的服务</span> 
</p>

<pre class="example">
一个典型的用例是将流量发送到被指定为服务子集的服务的不同版本

客户端将虚拟服务视为一个单一实体，将请求发送至虚拟服务主机，然后 Envoy 根据虚拟服务规则把流量路由到不同的版本。例如，“20% 的调用转到新版本”或“将这些用户的调用转到版本 2”

这允许您创建一个金丝雀发布，逐步增加发送到新版本服务的流量百分比

流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由

相比之下，像 Kubernetes 这样的容器编排平台只支持基于实例缩放的流量分发，这会让情况变得复杂
</pre>

<p>
虚拟服务可以让您：
</p>
<ul class="org-ul">
<li>通过单个虚拟服务处理多个应用程序服务。如果您的网格使用 Kubernetes，可以配置一个虚拟服务处理特定命名空间中的所有服务</li>
</ul>
<pre class="example">
映射单一的虚拟服务到多个“真实”服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统

您的路由规则可以指定为“对这些 monolith.com 的 URI 调用转到microservice A”等等

可以在下面的一个示例看到它是如何工作的
</pre>
<ul class="org-ul">
<li>和网关整合并配置流量规则来控制出入流量</li>
</ul>

<pre class="example">
在某些情况下，您还需要配置目标规则来使用这些特性，因为这是指定服务子集的地方

在一个单独的对象中指定服务子集和其它特定目标策略，有利于在虚拟服务之间更简洁地重用这些规则
</pre>
</div>
</div>

<div id="outline-container-orge9763e3" class="outline-4">
<h4 id="orge9763e3">虚拟服务示例</h4>
<div class="outline-text-4" id="text-orge9763e3">
<p>
下面的虚拟服务根据请求是否来自特定的用户，把它们路由到服务的不同版本
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: VirtualService
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: reviews
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - reviews
  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">match</span>:
    - <span style="color: #4eee94;">headers</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   end-user</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   exact</span>: jason
    <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   host</span>: reviews
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   subset</span>: v2
  - <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   host</span>: reviews
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   subset</span>: v3
</pre>
</div>
</div>

<div id="outline-container-orge47c171" class="outline-5">
<h5 id="orge47c171">hosts 字段</h5>
<div class="outline-text-5" id="text-orge47c171">
<p>
使用 hosts 字段列举 <span class="underline">虚拟服务的主机</span> ：即 <span class="underline">用户指定的目标</span> 或是 <span class="underline">路由规则设定的目标</span> 。这是客户端向服务发送请求时使用的一个或多个地址
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">hosts</span>:
- reviews
</pre>
</div>

<p>
虚拟服务主机名可以是 <span class="underline">IP 地址</span> 、 <span class="underline">DNS 名称</span> ，或者依赖于平台的一个简称（例如 <span class="underline">Kubernetes 服务的短名称</span> ），隐式或显式地指向一个 <span class="underline">完全限定域名</span> （FQDN）。您也可以使用 <span class="underline">通配符</span> （“*”）前缀，让您创建一组匹配所有服务的路由规则
</p>

<pre class="example">
虚拟服务的 hosts 字段实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址，这让您可以为没有路由到网格内部的虚拟主机建模
</pre>
</div>
</div>

<div id="outline-container-org831e193" class="outline-5">
<h5 id="org831e193">路由规则</h5>
<div class="outline-text-5" id="text-org831e193">
<p>
在 http 字段包含了虚拟服务的 <span class="underline">路由规则</span> ，用来描述 <span class="underline">匹配条件</span> 和 <span class="underline">路由行为</span> ，它们把 HTTP/1.1、HTTP2 和 gRPC 等流量发送到 <span class="underline">hosts 字段指定的目标</span> （您也可以用 tcp 和 tls 片段为 TCP 和未终止的 TLS 流量设置路由规则）。一个路由规则包含了指定的请求要流向哪个 <span class="underline">目标地址</span> ，具有 <span class="underline">0 或多个匹配条件</span> ，取决于您的使用场景 
</p>
</div>

<ul class="org-ul">
<li><a id="orge7d4ccc"></a>匹配条件<br />
<div class="outline-text-6" id="text-orge7d4ccc">
<p>
示例中的第一个路由规则有一个条件，因此以 match 字段开始
</p>

<div class="org-src-container">
<pre class="src src-yaml">- <span style="color: #4eee94;">match</span>:
   - <span style="color: #4eee94;">headers</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> end-user</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> exact</span>: jason
</pre>
</div>

<p>
在本例中，您希望此路由应用于来自 ”jason“ 用户的所有请求，所以使用 headers、end-user 和 exact 字段选择适当的请求
</p>
</div>
</li>

<li><a id="org4da6a99"></a>Destination<br />
<div class="outline-text-6" id="text-org4da6a99">
<p>
route 部分的 destination 字段指定了符合此条件的流量的 <span class="underline">实际目标地址</span> 。与虚拟服务的 hosts 不同，destination 的 host 必须是 <b>存在于 Istio 服务注册中心</b> 的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。可以是一个 <span class="underline">有代理的服务网格</span> ，或者是一个通过 <span class="underline">服务入口</span> 被添加进来的 <span class="underline">非网格服务</span> 
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">route</span>:
- <span style="color: #4eee94;">destination</span>:
    <span style="color: #4eee94;">host</span>: reviews
    <span style="color: #4eee94;">subset</span>: v2
</pre>
</div>

<pre class="example">
本示例运行在 Kubernetes 环境中，host 名为一个 Kubernetes 服务名

请注意，在该示例和本页其它示例中，为了简单，我们使用 Kubernetes 的短名称设置 destination 的 host

在评估此规则时，Istio 会添加一个基于虚拟服务命名空间的域后缀，这个虚拟服务包含要获取主机的完全限定名的路由规则

在我们的示例中使用短名称也意味着您可以复制并在任何喜欢的命名空间中尝试它们
</pre>

<p>
destination 片段还指定了 <span class="underline">Kubernetes 服务的子集</span> ，将符合此规则条件的请求转入其中
</p>

<pre class="example">
在本例中子集名称是 v2，可以在目标规则章节中看到如何定义服务子集
</pre>
</div>
</li>
</ul>
</div>

<div id="outline-container-orge05ad23" class="outline-5">
<h5 id="orge05ad23">路由规则优先级</h5>
<div class="outline-text-5" id="text-orge05ad23">
<p>
路由规则按从上到下的顺序选择，虚拟服务中定义的第一条规则有最高优先级
</p>

<pre class="example">
本示例中，不满足第一个路由规则的流量均流向一个默认的目标

该目标在第二条规则中指定。因此，第二条规则没有 match 条件，直接将流量导向 v3 子集
</pre>

<p>
我们建议提供一个默认的“无条件”或基于权重的规则（见下文）作为每一个虚拟服务的最后一条规则，如案例所示，从而确保流经虚拟服务的流量至少能够匹配一条路由规则
</p>
</div>
</div>
</div>

<div id="outline-container-orgc9a1420" class="outline-4">
<h4 id="orgc9a1420">路由规则的更多内容</h4>
<div class="outline-text-4" id="text-orgc9a1420">
<p>
正如上面所看到的，路由规则是将特定流量子集路由到指定目标地址的强大工具。您可以在流量端口、header 字段、URI 等内容上设置匹配条件
</p>

<pre class="example">
例如，这个虚拟服务让用户发送请求到两个独立的服务：ratings 和 reviews，就好像它们是 http://bookinfo.com/ 这个更大的虚拟服务的一部分

虚拟服务规则根据请求的 URI 和指向适当服务的请求匹配流量
</pre>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: VirtualService
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: bookinfo
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
    - bookinfo.com
  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">match</span>:
    - <span style="color: #4eee94;">uri</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   prefix</span>: /reviews
    <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   host</span>: reviews
  - <span style="color: #4eee94;">match</span>:
    - <span style="color: #4eee94;">uri</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   prefix</span>: /ratings
    <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  host</span>: ratings
<span style="color: #5f9ea0; font-style: italic;">...</span>

  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">match</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">sourceLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">app</span>: reviews
    <span style="color: #4eee94;">route</span>:
<span style="color: #5f9ea0; font-style: italic;">...</span>
</pre>
</div>

<p>
有些匹配条件可以使用精确的值，如前缀或正则。可以使用 AND 向同一个 match 块添加多个匹配条件，或者使用 OR 向同一个规则添加多个 match 块。对于任何给定的虚拟服务也可以有多个路由规则
</p>

<pre class="example">
这可以在单个虚拟服务中使路由条件变得随您所愿的复杂或简单

匹配条件字段和备选值的完整列表可以在 HTTPMatchRequest 参考中找到
</pre>

<p>
另外，使用匹配条件您可以按百分比 <span class="underline">权重</span> 分发请求。这在 A/B 测试和金丝雀发布中非常有用：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - reviews
  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   host</span>: reviews
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   subset</span>: v1
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   weight</span>: 75
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   host</span>: reviews
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   subset</span>: v2
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   weight</span>: 25
</pre>
</div>

<p>
也可以使用路由规则在流量上执行一些操作，例如：
</p>
<ul class="org-ul">
<li>添加或删除 header</li>
<li>重写 URL</li>
<li>为调用这一目标地址的请求设置重试策略。</li>
</ul>

<pre class="example">
想了解如何利用这些操作，查看 HTTPRoute 参考
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf5b545" class="outline-3">
<h3 id="orgbf5b545">目标规则</h3>
<div class="outline-text-3" id="text-orgbf5b545">
<p>
与虚拟服务一样， <span class="underline">目标规则</span> 也是 Istio 流量路由功能的关键部分，可以将虚拟服务视为将流量如何路由到给定目标地址，然后使用目标规则来 <b>配置该目标的流量</b> 。在评估虚拟服务路由规则之后，目标规则将应用于流量的“真实”目标地址 
</p>
<ul class="org-ul">
<li>可以使用目标规则来 <span class="underline">指定命名的服务子集</span></li>
</ul>
<pre class="example">
例如按版本为所有给定服务的实例分组，然后可以在虚拟服务的路由规则中使用这些服务子集来控制到服务不同实例的流量
</pre>
<ul class="org-ul">
<li>还允许在调用整个目的地服务或特定服务子集时 <span class="underline">定制 Envoy 的流量策略</span></li>
</ul>
<pre class="example">
比如您喜欢的负载均衡模型、TLS 安全模式或熔断器设置 
</pre>
</div>

<div id="outline-container-org59fef47" class="outline-4">
<h4 id="org59fef47">负载均衡选项</h4>
<div class="outline-text-4" id="text-org59fef47">
<p>
默认情况下，Istio 使用 <span class="underline">轮询的负载均衡</span> 策略，实例池中的每个实例依次获取请求。Istio 同时支持如下的负载均衡模型，可以在 DestinationRule 中为流向某个特定服务或服务子集的流量指定这些模型：
</p>
<ul class="org-ul">
<li><span class="underline">随机</span> ：请求以随机的方式转到池中的实例</li>
<li><span class="underline">权重</span> ：请求根据指定的百分比转到实例</li>
<li><span class="underline">最少请求</span> ：请求被转到最少被访问的实例</li>
</ul>
</div>
</div>

<div id="outline-container-org7defc86" class="outline-4">
<h4 id="org7defc86">目标规则示例</h4>
<div class="outline-text-4" id="text-org7defc86">
<p>
在下面的示例中，目标规则为 my-svc 目标服务配置了 3 个具有不同负载均衡策略的子集：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: DestinationRule
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: my-destination-rule
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">host</span>: my-svc
  <span style="color: #4eee94;">trafficPolicy</span>:
    <span style="color: #4eee94;">loadBalancer</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">simple</span>: RANDOM
  <span style="color: #4eee94;">subsets</span>:
  - <span style="color: #4eee94;">name</span>: v1
    <span style="color: #4eee94;">labels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">version</span>: v1
  - <span style="color: #4eee94;">name</span>: v2
    <span style="color: #4eee94;">labels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">version</span>: v2
    <span style="color: #4eee94;">trafficPolicy</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">loadBalancer</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   simple</span>: ROUND_ROBIN
  - <span style="color: #4eee94;">name</span>: v3
    <span style="color: #4eee94;">labels</span>:
       <span style="color: #4eee94;">version</span>: v3
</pre>
</div>

<p>
每个子集都是基于一个或多个 <span class="underline">labels</span> 定义的
</p>

<pre class="example">
在 Kubernetes 中它是附加到像 Pod 这种对象上的键/值对

这些标签应用于 Kubernetes 服务的 Deployment 并作为 metadata 来识别不同的版本
</pre>

<p>
除了定义子集之外，目标规则对于所有子集都有默认的流量策略，而对于该子集，则有特定于子集的策略覆盖它
</p>

<pre class="example">
定义在 subsets 上的默认策略，为 v1 和 v3 子集设置了一个简单的随机负载均衡器

在 v2 策略中，轮询负载均衡器被指定在相应的子集字段上
</pre>
</div>
</div>
</div>

<div id="outline-container-org59a1ab4" class="outline-3">
<h3 id="org59a1ab4">网关</h3>
<div class="outline-text-3" id="text-org59a1ab4">
<p>
使用网关为网格来管理入站和出站流量，可以让您指定要进入或离开网格的流量：
</p>
<ul class="org-ul">
<li>网关配置被用于运行在 <span class="underline">网格边界</span> 的 <span class="underline">独立 Envoy 代理</span></li>
<li>不是服务工作负载的 sidecar 代理</li>
</ul>

<pre class="example">
与 Kubernetes Ingress API 这种控制进入系统流量的其他机制不同，Istio 网关充分利用流量路由的强大能力和灵活性

可以这么做的原因是 Istio 的网关资源可以配置 4-6 层的负载均衡属性，如对外暴露的端口、TLS 设置等

作为替代应用层流量路由（L7）到相同的 API 资源，绑定了一个常规的 Istio 虚拟服务到网关，这可以像管理网格中其他数据平面的流量一样去管理网关流量
</pre>
<p>
网关主要用于管理进入的流量，但也可以配置出口网关。出口网关让您为 <span class="underline">离开网格的流量</span> <b>配置</b> 一个 <span class="underline">专用的出口节点</span> ：
</p>
<ul class="org-ul">
<li>可以限制哪些服务可以或应该访问外部网络</li>
<li>启用出口流量安全控制为您的网格添加安全性</li>
<li>可以使用网关配置一个纯粹的内部代理</li>
</ul>

<pre class="example">
Istio 提供了一些预先配置好的网关代理部署（istio-ingressgateway 和 istio-egressgateway）供使用

如果使用演示安装它们都已经部署好了；如果使用默认或 sds 配置文件则只部署了入口网关

可以将您自己的网关配置应用到这些部署或配置您自己的网关代理
</pre>
</div>
<div id="outline-container-org47dfc45" class="outline-4">
<h4 id="org47dfc45">Gateway 示例</h4>
<div class="outline-text-4" id="text-org47dfc45">
<p>
下面的示例展示了一个外部 HTTPS 入口流量的网关配置：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: Gateway
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: ext-host-gwy
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">app</span>: my-gateway-controller
  <span style="color: #4eee94;">servers</span>:
  - <span style="color: #4eee94;">port</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">number</span>: 443
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">name</span>: https
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">protocol</span>: HTTPS
    <span style="color: #4eee94;">hosts</span>:
    - ext-host.example.com
    <span style="color: #4eee94;">tls</span>:
     <span style="color: #4eee94;">mode</span>: SIMPLE
     <span style="color: #4eee94;">serverCertificate</span>: /tmp/tls.crt
     <span style="color: #4eee94;">privateKey</span>: /tmp/tls.key
</pre>
</div>

<pre class="example">
这个网关配置让 HTTPS 流量从 ext-host.example.com 通过 443 端口流入网格，但没有为请求指定任何路由规则
</pre>
<p>
为想要工作的网关指定路由，您必须把网关绑定到虚拟服务上。正如下面的示例所示，使用虚拟服务的 gateways 字段进行设置：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: VirtualService
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: virtual-svc
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - ext-host.example.com
  <span style="color: #4eee94;">gateways</span>:
    - ext-host-gwy
</pre>
</div>

<p>
然后就可以为出口流量配置带有路由规则的虚拟服务 
</p>
</div>
</div>
</div>

<div id="outline-container-orgf2f989c" class="outline-3">
<h3 id="orgf2f989c">服务入口</h3>
<div class="outline-text-3" id="text-orgf2f989c">
<p>
使用 <span class="underline">服务入口</span> （Service Entry） 来添加一个 <span class="underline">入口</span> 到 Istio 内部维护的 <span class="underline">服务注册中心</span> 。添加了服务入口后，Envoy 代理可以向服务发送流量，就好像它是网格内部的服务一样。配置服务入口允许管理运行在 <span class="underline">网格外的服务的流量</span> ，它包括以下几种能力：
</p>
<ul class="org-ul">
<li>为外部目标 redirect 和转发请求，例如来自 web 端的 API 调用，或者流向遗留老系统的服务</li>
<li>为外部目标定义重试、超时和故障注入策略</li>
<li>添加一个运行在虚拟机的服务来扩展您的网格</li>
<li>从逻辑上添加来自不同集群的服务到网格，在 Kubernetes 上实现一个多集群 Istio 网格</li>
</ul>

<pre class="example">
不需要为网格服务要使用的每个外部服务都添加服务入口，默认情况下，Istio 配置 Envoy 代理将请求传递给未知服务

但是，您不能使用 Istio 的特性来控制没有在网格中注册的目标流量 
</pre>
</div>

<div id="outline-container-org7a9f085" class="outline-4">
<h4 id="org7a9f085">服务入口实例</h4>
<div class="outline-text-4" id="text-org7a9f085">
<p>
下面示例的 mesh-external 服务入口将 ext-resource 外部依赖项添加到 Istio 的服务注册中心：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: ServiceEntry
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: svc-entry
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - ext-svc.example.com
  <span style="color: #4eee94;">ports</span>:
  - <span style="color: #4eee94;">number</span>: 443
    <span style="color: #4eee94;">name</span>: https
    <span style="color: #4eee94;">protocol</span>: HTTPS
  <span style="color: #4eee94;">location</span>: MESH_EXTERNAL
  <span style="color: #4eee94;">resolution</span>: DNS
</pre>
</div>

<pre class="example">
您指定的外部资源使用 hosts 字段，可以使用完全限定名或通配符作为前缀域名
</pre>

<p>
可以配置虚拟服务和目标规则，以更细粒度的方式控制到服务入口的流量，这与网格中的任何其他服务配置流量的方式相同
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: DestinationRule
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: ext-res-dr
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">host</span>: ext-svc.example.com
  <span style="color: #4eee94;">trafficPolicy</span>:
    <span style="color: #4eee94;">tls</span>:
      <span style="color: #4eee94;">mode</span>: MUTUAL
      <span style="color: #4eee94;">clientCertificate</span>: /etc/certs/myclientcert.pem
      <span style="color: #4eee94;">privateKey</span>: /etc/certs/client_private_key.pem
      <span style="color: #4eee94;">caCertificates</span>: /etc/certs/rootcacerts.pem
</pre>
</div>

<pre class="example">
例如，目标规则配置流量路由以使用双向 TLS 来保护到 ext-svc.example.com 外部服务的连接，使用服务入口配置了该外部服务
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a479f7" class="outline-3">
<h3 id="org3a479f7">Sidecar</h3>
<div class="outline-text-3" id="text-org3a479f7">
<p>
默认情况下，Istio 让每个 Envoy 代理都可以访问来自和它关联的工作负载的所有端口的请求，然后转发到对应的工作负载。可以使用 sidecar 配置去做下面的事情：
</p>
<ul class="org-ul">
<li><b>微调</b> Envoy 代理 <b>接受的</b> <span class="underline">端口</span> 和 <span class="underline">协议集</span></li>
<li><b>限制</b> Envoy 代理 <b>可以访问</b> 的 <span class="underline">服务集合</span></li>
</ul>

<pre class="example">
可能希望在较庞大的应用程序中限制这样的 sidecar 可达性，配置每个代理能访问网格中的任意服务可能会因为高内存使用量而影响网格的性能
</pre>

<p>
可以指定将 sidecar 配置应用于特定命名空间中的所有工作负载，或者使用 workloadSelector 选择特定的工作负载
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: Sidecar
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: default
  <span style="color: #4eee94;">namespace</span>: bookinfo
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">egress</span>:
  - <span style="color: #4eee94;">hosts</span>:
    - <span style="color: #deb887;">"./*"</span>
    - <span style="color: #deb887;">"istio-system/*"</span>
</pre>
</div>

<pre class="example">
sidecar 配置将 bookinfo 命名空间中的所有服务配置为仅能访问运行在相同命名空间和 Istio 控制平面中的服务（目前需要使用 Istio 的策略和遥测功能）
</pre>
</div>
</div>

<div id="outline-container-org87dd3e4" class="outline-3">
<h3 id="org87dd3e4">网络弹性和测试</h3>
<div class="outline-text-3" id="text-org87dd3e4">
<p>
除了网格导流之外，Istio 还提供了可选的 <span class="underline">故障恢复</span> 和 <span class="underline">故障注入</span> 功能
</p>

<pre class="example">
可以在运行时动态配置这些功能

使用这些特性可以让应用程序运行稳定，确保服务网格能够容忍故障节点，并防止局部故障级联影响到其他节点
</pre>
</div>


<div id="outline-container-orge84a2d1" class="outline-4">
<h4 id="orge84a2d1">超时</h4>
<div class="outline-text-4" id="text-orge84a2d1">
<p>
超时是 Envoy 代理等待来自给定服务的答复的时间量，以确保服务不会因为等待答复而无限期的挂起，并在可预测的时间范围内调用成功或失败。HTTP 请求的默认超时时间是 <span class="underline">15 秒</span> ，这意味着如果服务在 15 秒内没有响应，调用将失败。对于某些应用程序和服务，Istio 的缺省超时可能不合适：
</p>
<ul class="org-ul">
<li>超时太长可能会由于等待失败服务的回复而导致过度的延迟</li>
<li>而超时过短则可能在等待涉及多个服务返回的操作时触发不必要地失败</li>
</ul>

<p>
为了找到并使用最佳超时设置，Istio 允许您使用虚拟服务按服务轻松地动态调整超时，而不必修改您的业务代码：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: VirtualService
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: ratings
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - ratings
  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  host</span>: ratings
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  subset</span>: v1
    <span style="color: #4eee94;">timeout</span>: 10s
</pre>
</div>

<pre class="example">
示例是一个虚拟服务，它对 ratings 服务的 v1 子集的调用指定 10 秒超时
</pre>
</div>
</div>

<div id="outline-container-org767266c" class="outline-4">
<h4 id="org767266c">重试</h4>
<div class="outline-text-4" id="text-org767266c">
<p>
重试设置指定如果初始调用失败，Envoy 代理尝试连接服务的最大次数。通过确保调用不会因为临时过载的服务或网络等问题而永久失败，重试可以  <b>提高</b> 服务 <span class="underline">可用性</span> 和应用程序的性能。重试之间的间隔（ <span class="underline">25ms+</span> ）是可变的，并由 Istio 自动确定，从而防止被调用服务被请求淹没。HTTP 请求的默认重试行为是在返回错误之前重试 <span class="underline">两次</span>  。与超时一样，Istio 默认的重试行为在延迟方面可能不适合您的应用程序需求（对失败的服务进行过多的重试会降低速度）或可用性。可以在虚拟服务中按服务调整重试设置，而不必修改业务代码。还可以通过添加每次重试的超时来进一步细化重试行为，并指定每次重试都试图成功连接到服务所等待的时间量
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: VirtualService
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: ratings
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - ratings
  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  host</span>: ratings
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  subset</span>: v1
    <span style="color: #4eee94;">retries</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">attempts</span>: 3
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">perTryTimeout</span>: 2s
</pre>
</div>

<pre class="example">
示例配置了在初始调用失败后最多重试 3 次来连接到服务子集，每个重试都有 2 秒的超时 
</pre>
</div>
</div>

<div id="outline-container-org074b96a" class="outline-4">
<h4 id="org074b96a">熔断器</h4>
<div class="outline-text-4" id="text-org074b96a">
<p>
熔断器是 Istio 为创建具有弹性的微服务应用提供的另一个有用的机制。在熔断器中，设置一个对服务中的单个主机调用的限制，例如 <span class="underline">并发连接的数量</span> 或对该主机 <span class="underline">调用失败的次数</span> 。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。 熔断适用于在负载均衡池中的 <b>真实</b> <span class="underline">网格目标地址</span> ，您可以在 <span class="underline">目标规则</span> 中配置熔断器阈值，让配置适用于服务中的每个主机
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: DestinationRule
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: reviews
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">host</span>: reviews
  <span style="color: #4eee94;">subsets</span>:
  - <span style="color: #4eee94;">name</span>: v1
    <span style="color: #4eee94;">labels</span>:
       <span style="color: #4eee94;">version</span>: v1
    <span style="color: #4eee94;">trafficPolicy</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">connectionPool</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">tcp</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">maxConnections</span>: 100
</pre>
</div>

<pre class="example">
示例将 v1 子集的reviews服务工作负载的并发连接数限制为 100
</pre>
</div>
</div>

<div id="outline-container-orgd884249" class="outline-4">
<h4 id="orgd884249">故障注入</h4>
<div class="outline-text-4" id="text-orgd884249">
<p>
在配置了网络，包括故障恢复策略之后，可以使用 Istio 的故障注入机制来为整个应用程序测试故障恢复能力
</p>

<pre class="example">
故障注入是一种将错误引入系统以确保系统能够承受并从错误条件中恢复的测试方法

使用故障注入特别有用，能确保故障恢复策略不至于不兼容或者太严格，这会导致关键服务不可用
</pre>

<p>
与其他错误注入机制（如延迟数据包或在网络层杀掉 Pod）不同，Istio 允许在应用层注入错误
</p>

<pre class="example">
这可以注入更多相关的故障，例如 HTTP 错误码，以获得更多相关的结果
</pre>

<p>
可以注入两种故障，它们都使用 <span class="underline">虚拟服务</span> 配置：
</p>
<ul class="org-ul">
<li><span class="underline">延迟</span> ：延迟是时间故障。它们模拟增加的网络延迟或一个超载的上游服务</li>
<li><span class="underline">终止</span> ：终止是崩溃失败。他们模仿上游服务的失败。终止通常以 HTTP 错误码或 TCP 连接失败的形式出现</li>
</ul>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: networking.istio.io/v1alpha3
<span style="color: #4eee94;">kind</span>: VirtualService
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: ratings
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">hosts</span>:
  - ratings
  <span style="color: #4eee94;">http</span>:
  - <span style="color: #4eee94;">fault</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">delay</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">percentage</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">    value</span>: 0.1
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">    fixedDelay</span>: 5s
    <span style="color: #4eee94;">route</span>:
    - <span style="color: #4eee94;">destination</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   host</span>: ratings
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   subset</span>: v1
</pre>
</div>

<pre class="example">
虚拟服务为千分之一的访问 ratings 服务的请求配置了一个 5 秒的延迟
</pre>
</div>
</div>

<div id="outline-container-org6a38f68" class="outline-4">
<h4 id="org6a38f68">和您的应用程序一起运行</h4>
<div class="outline-text-4" id="text-org6a38f68">
<p>
Istio 故障恢复功能对应用程序来说是完全透明的。在返回响应之前，应用程序不知道 Envoy sidecar 代理是否正在处理被调用服务的故障
</p>

<pre class="example">
这意味着，如果在应用程序代码中设置了故障恢复策略，那么需要记住这两个策略都是独立工作的，否则会发生冲突

例如，假设设置了两个超时，一个在虚拟服务中配置，另一个在应用程序中配置

应用程序为服务的 API 调用设置了 2 秒超时。而在虚拟服务中配置了一个 3 秒超时和重试

在这种情况下，应用程序的超时会先生效，因此 Envoy 的超时和重试尝试会失效
</pre>

<p>
虽然 Istio 故障恢复特性提高了网格中服务的可靠性和可用性，但 <span class="underline">应用程序</span> 必须 <span class="underline">处理故障</span> 或 <span class="underline">错误</span> 并采取适当的 <span class="underline">回退操作</span> 
</p>

<pre class="example">
例如，当负载均衡中的所有实例都失败时，Envoy 返回一个HTTP 503代码。应用程序必须实现回退逻辑来处理HTTP 503错误代码
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org20f985b" class="outline-2">
<h2 id="org20f985b">扩展性</h2>
<div class="outline-text-2" id="text-org20f985b">
<p>
WebAssembly 是一种沙盒技术，可以用于扩展 Istio 代理（Envoy）的能力
</p>

<pre class="example">
Proxy-Wasm 沙盒 API 取代了 Mixer 作为 Istio 主要的扩展机制，在 Istio 1.6 中将会为 Proxy-Wasm 插件提供一种统一的配置 API
</pre>

<p>
WebAssembly 沙盒的目标：
</p>
<ul class="org-ul">
<li>效率 - 这是一种低延迟，低 CPU 和内存开销的扩展机制</li>
<li>功能 - 这是一种可以执行策略，收集遥测数据和执行有效荷载变更的扩展机制</li>
<li>隔离 - 一个插件中程序的错误或是崩溃不会影响其它插件</li>
<li>配置 - 插件使用与其它 Istio API 一致的 API 进行配置。可以动态的配置扩展</li>
<li>运维 - 扩展可以以仅日志，故障打开或者故障关闭的方式进行访问和部署</li>
<li>扩展开发者 - 可以用多种编程语言编写</li>
</ul>
</div>
</div>

<div id="outline-container-org14efe51" class="outline-2">
<h2 id="org14efe51">安全</h2>
<div class="outline-text-2" id="text-org14efe51">
<p>
将单一应用程序分解为微服务可提供各种好处，包括更好的灵活性、可伸缩性以及服务复用的能力。但是，微服务也有特殊的安全需求：
</p>
<ul class="org-ul">
<li>为了抵御中间人攻击，需要流量加密</li>
<li>为了提供灵活的服务访问控制，需要双向 TLS 和细粒度的访问策略</li>
<li>要确定谁在什么时候做了什么，需要审计工具</li>
</ul>

<pre class="example">
Istio Security 尝试提供全面的安全解决方案来解决所有这些问题

接下来概述了如何使用 Istio 的安全功能来保护您的服务，无论您在何处运行它们。特别是 Istio 安全性可以缓解针对您的数据、端点、通信和平台的内部和外部威胁
</pre>


<div class="figure">
<p><object type="image/svg+xml" data="./pic/overview.svg" class="org-svg" width="40%">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
Istio 安全功能提供强大的身份，强大的策略，透明的 TLS 加密，认证，授权和审计（AAA）工具来保护你的服务和数据。Istio 安全的目标是：
</p>
<ul class="org-ul">
<li>默认安全：应用程序代码和基础设施无需更改</li>
<li>深度防御：与现有安全系统集成以提供多层防御</li>
<li>零信任网络：在不受信任的网络上构建安全解决方案</li>
</ul>
</div>

<div id="outline-container-org4a47fd1" class="outline-3">
<h3 id="org4a47fd1">高级架构</h3>
<div class="outline-text-3" id="text-org4a47fd1">
<p>
Istio 中的安全性涉及多个组件：
</p>
<ul class="org-ul">
<li>用于密钥和证书管理的证书颁发机构（CA）</li>
<li>配置 API 服务器分发给代理：
<ul class="org-ul">
<li>认证策略</li>
<li>授权策略</li>
<li>安全命名信息</li>
</ul></li>
<li><span class="underline">Sidecar</span> 和 <span class="underline">边缘代理</span> 作为 <span class="underline">Policy Enforcement Points</span> (PEPs) 以保护客户端和服务器之间的通信安全</li>
<li>一组 <span class="underline">Envoy 代理</span> 扩展，用于管理 <span class="underline">遥测</span> 和 <span class="underline">审计</span></li>
</ul>

<p>
控制面处理来自 API server 的配置，并且在数据面中配置 PEPs。PEPs 用 Envoy 实现。下图显示了架构：
</p>


<div class="figure">
<p><object type="image/svg+xml" data="./pic/arch-sec.svg" class="org-svg" width="40%">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-org4636893" class="outline-3">
<h3 id="org4636893">Istio 身份</h3>
<div class="outline-text-3" id="text-org4636893">
<pre class="example">
身份是任何安全基础架构的基本概念

在工作负载间通信开始时，双方必须交换包含身份信息的凭证以进行双向验证

在客户端，根据安全命名信息检查服务器的标识，以查看它是否是该服务的授权运行程序

在服务器端，服务器可以根据授权策略确定客户端可以访问哪些信息，审计谁在什么时间访问了什么，根据他们使用的工作负载向客户收费，并拒绝任何未能支付账单的客户访问工作负载
</pre>

<p>
Istio 身份模型使用 <span class="underline">service identity</span> （服务身份）来确定一个请求源端的身份。这种模型有极好的灵活性和粒度，可以用服务身份来标识人类用户、单个工作负载或一组工作负载。在没有服务身份的平台上，Istio 可以使用其它可以对服务实例进行分组的身份，例如 <span class="underline">服务名称</span>  。下面的列表展示了在不同平台上可以使用的服务身份：
</p>
<ul class="org-ul">
<li>Kubernetes:  <span class="underline">Kubernetes service account</span></li>
<li>GKE/GCE: GCP service account</li>
<li>GCP: GCP service account</li>
<li>AWS: AWS IAM user/role account</li>
<li>本地（非 Kubernetes）：用户帐户、自定义服务帐户、服务名称、Istio 服务帐户或 GCP 服务帐户</li>
</ul>

<pre class="example">
自定义服务帐户引用现有服务帐户，就像客户的身份目录管理的身份一样
</pre>
</div>
</div>

<div id="outline-container-org7ae267f" class="outline-3">
<h3 id="org7ae267f">公钥基础设施 (PKI)</h3>
<div class="outline-text-3" id="text-org7ae267f">
<p>
Istio PKI 使用 <span class="underline">X.509 证书</span> 为每个 <span class="underline">工作负载</span> 都提供强大的 <span class="underline">身份标识</span> 。可以大规模进行自动化密钥和证书轮换，伴随每个 <span class="underline">Envoy 代理</span> 都运行着一个 <span class="underline">istio-agent</span> 负责 <span class="underline">证书和密钥</span> 的供应。下图显示了这个机制的运行流程：
</p>


<div class="figure">
<p><object type="image/svg+xml" data="./pic/id-prov.svg" class="org-svg" width="40%">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Istio 供应身份是通过 <span class="underline">secret discovery service</span> （SDS）来实现的，具体流程如下：
</p>
<ol class="org-ol">
<li><span class="underline">CA</span> 提供 <span class="underline">gRPC 服务</span> 以接受 <span class="underline">证书签名</span> 请求（CSRs）</li>
<li>Envoy 通过 Envoy <span class="underline">秘密发现服务</span> （SDS）API 发送证书和 <span class="underline">密钥</span> <b>请求</b></li>
<li>在收到 SDS 请求后，istio-agent <b>创建</b> <span class="underline">私钥和 CSR</span> ，然后将  <span class="underline">CSR 及其凭据</span> 发送到 <span class="underline">Istio CA</span> 进行 <b>签名</b></li>
<li><span class="underline">CA</span> <b>验证</b> CSR 中携带的 <span class="underline">凭据</span> 并 <b>签署</b> CSR 以生成 <span class="underline">证书</span></li>
<li><span class="underline">Istio-agent</span> 通过 Envoy SDS API 将 <span class="underline">私钥</span> 和从 Istio CA 收到的证书发送给 <span class="underline">Envoy</span></li>
</ol>

<p>
上述 CSR 过程会周期性地重复，以处理证书和密钥轮换 
</p>
</div>
</div>

<div id="outline-container-orge8b530b" class="outline-3">
<h3 id="orge8b530b">认证</h3>
<div class="outline-text-3" id="text-orge8b530b">
<p>
Istio 提供两种类型的认证：
</p>
<ul class="org-ul">
<li>Peer authentication：用于服务到服务的认证，以验证进行连接的客户端。Istio 提供 <span class="underline">双向 TLS</span> 作为传输认证的全栈解决方案，无需更改服务代码就可以启用它。这个解决方案：
<ul class="org-ul">
<li>为每个服务提供强大的身份，表示其角色，以实现跨群集和云的互操作性</li>
<li>保护服务到服务的通信</li>
<li>提供密钥管理系统，以自动进行密钥和证书的生成，分发和轮换</li>
</ul></li>
<li>Request authentication：用于最终用户认证，以验证附加到请求的凭据。 Istio 使用 JSON Web Token（JWT）验证启用请求级认证，并使用自定义认证实现或任何 OpenID Connect 的认证实现（例如下面列举的）来简化的开发人员体验
<ul class="org-ul">
<li>ORY Hydra</li>
<li>Keycloak</li>
<li>Auth0</li>
<li>Firebase Auth</li>
<li>Google Auth</li>
</ul></li>
</ul>

<p>
在所有情况下，Istio 都通过 <span class="underline">自定义 Kubernetes API</span>  将 <span class="underline">认证策略</span> <b>存储</b> 在 <span class="underline">Istio config store</span> 。Istiod 使 <span class="underline">每个代理</span> 保持最新状态，并在适当时提供密钥
</p>

<pre class="example">
此外，Istio 的认证机制支持宽容模式（permissive mode），以帮助您了解策略更改在实施之前如何影响您的安全状况
</pre>
</div>

<div id="outline-container-org463246c" class="outline-4">
<h4 id="org463246c">双向 TLS 认证</h4>
<div class="outline-text-4" id="text-org463246c">
<p>
Istio 通过 <span class="underline">客户端</span> 和 <span class="underline">服务器端 PEPs</span> 建立服务到服务的通信通道，PEPs 被实现为Envoy 代理。当一个工作负载使用双向 TLS 认证向另一个工作负载发送请求时，该请求的处理方式如下：
</p>
<ol class="org-ol">
<li>Istio 将 <span class="underline">出站流量</span> 从客户端重新 <b>路由</b> 到 <span class="underline">客户端的本地 sidecar Envoy</span></li>
<li><span class="underline">客户端 Envoy</span> 与 <span class="underline">服务器端 Envoy</span> 开始 <b>双向 TLS 握手</b> 。在握手期间，客户端 Envoy 还做了 <span class="underline">安全命名检查</span> ，以验证 <span class="underline">服务器证书</span> 中显示的 <span class="underline">服务帐户</span> 是否被 <b>授权</b> 运行 <span class="underline">目标服务</span></li>
<li>客户端 Envoy 和服务器端 Envoy <b>建立</b> 了一个 <span class="underline">双向的 TLS 连接</span> ，Istio 将流量从 <span class="underline">客户端 Envoy</span> <b>转发</b> 到 <span class="underline">服务器端 Envoy</span></li>
<li>授权后， <span class="underline">服务器端 Envoy</span> 通过 <span class="underline">本地 TCP 连接</span> 将流量 <b>转发</b> 到 <span class="underline">服务器服务</span></li>
</ol>
</div>

<div id="outline-container-orgb670d60" class="outline-5">
<h5 id="orgb670d60">宽容模式</h5>
<div class="outline-text-5" id="text-orgb670d60">
<p>
Istio 双向 TLS 具有一个 <span class="underline">宽容模式</span> （permissive mode），允许服务同时接受 <span class="underline">纯文本</span> 流量和 <span class="underline">双向 TLS</span> 流量。这个功能极大的提升了双向 TLS 的入门体验。
</p>

<pre class="example">
在运维人员希望将服务移植到启用了双向 TLS 的 Istio 上时，许多非 Istio 客户端和非 Istio 服务端通信时会产生问题

通常情况下，运维人员无法同时为所有客户端安装 Istio sidecar，甚至没有这样做的权限

即使在服务端上安装了 Istio sidecar，运维人员也无法在不中断现有连接的情况下启用双向 TLS
</pre>
<p>
启用宽容模式后，服务可以同时接受纯文本和双向 TLS 流量。这个模式为入门提供了极大的灵活性。服务中安装的 Istio sidecar 立即接受双向 TLS 流量而不会打断现有的纯文本流量。因此，运维人员可以逐步安装和配置客户端 Istio sidecar 发送双向 TLS 流量。一旦客户端配置完成，运维人员便可以将服务端配置为仅 TLS 模式
</p>
</div>
</div>

<div id="outline-container-orgaf47915" class="outline-5">
<h5 id="orgaf47915">安全命名</h5>
<div class="outline-text-5" id="text-orgaf47915">
<p>
服务器身份（Server identities）被编码在证书里，但服务名称（service names）通过服务发现或 DNS 被检索。 <span class="underline">安全命名信息</span> 将 <span class="underline">服务器身份</span> <b>映射</b> 到 <span class="underline">服务名称</span> 。身份 A 到服务名称 B 的映射表示“授权 A 运行服务 B“。 <span class="underline">控制平面</span> 监视 apiserver，生成安全命名映射，并将其安全地分发到 PEPs 
</p>

<pre class="example">
以下示例说明了为什么安全命名对身份验证至关重要

假设运行服务 datastore 的合法服务器仅使用 infra-team 身份，恶意用户拥有 test-team 身份的证书和密钥

恶意用户打算模拟服务以检查从客户端发送的数据。恶意用户使用证书和 test-team 身份的密钥部署伪造服务器。假设恶意用户成功攻击了发现服务或 DNS，以将 datastore 服务名称映射到伪造服务器

当客户端调用 datastore 服务时，它从服务器的证书中提取 test-team 身份，并用安全命名信息检查 test-team 是否被允许运行 datastore。客户端检测到 test-team 不允许运行 datastore 服务，认证失败
</pre>

<p>
安全命名能够防止 <span class="underline">HTTPS 流量</span> 受到 <span class="underline">一般性网络劫持</span> ，除了 DNS 欺骗外，它还可以保护 <span class="underline">TCP 流量</span> 免受一般网络劫持
</p>

<pre class="example">
如果攻击者劫持了 DNS 并修改了目的地的 IP 地址，它将无法用于 TCP 通信

这是因为 TCP 流量不包含主机名信息，只能依靠 IP 地址进行路由，而且甚至在客户端 Envoy 收到流量之前，也可能发生 DNS 劫持
</pre>
</div>
</div>
</div>

<div id="outline-container-orga716ce5" class="outline-4">
<h4 id="orga716ce5">认证架构</h4>
<div class="outline-text-4" id="text-orga716ce5">
<p>
可以使用 peer 和 request 认证策略为在 Istio 网格中接收请求的工作负载指定认证要求：
</p>
<ol class="org-ol">
<li>网格运维人员使用 .yaml 文件来指定策略</li>
<li>部署后，策略将保存在 Istio 配置存储中</li>
<li>Istio 控制器监视配置存储</li>
</ol>

<p>
一有任何的策略变更，新策略都会转换为适当的配置，告知 PEP 如何执行所需的认证机制：
</p>
<ul class="org-ul">
<li>控制平面可以获取公共密钥，并将其附加到配置中以进行 JWT 验证</li>
<li>或者，Istiod 提供了 Istio 系统管理的密钥和证书的路径，并将它们安装到应用程序 pod 用于双向 TLS</li>
</ul>

<p>
Istio 异步发送配置到目标端点。代理收到配置后，新的认证要求会立即生效。发送请求的客户端服务负责遵循必要的认证机制：
</p>
<ul class="org-ul">
<li>对于 peer authentication，应用程序负责获取 JWT 凭证并将其附加到请求</li>
<li>对于双向 TLS，Istio 会自动将两个 PEPs 之间的所有流量升级为双向 TLS</li>
</ul>

<pre class="example">
如果认证策略禁用了双向 TLS 模式，则 Istio 将继续在 PEPs 之间使用纯文本

要覆盖此行为，请使用 destination rules显式禁用双向 TLS 模式
</pre>


<div class="figure">
<p><object type="image/svg+xml" data="./pic/authn.svg" class="org-svg" width="40%">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Istio 将两种类型的身份验证以及凭证中的其他声明（如果适用）输出到下一层：授权
</p>
</div>
</div>

<div id="outline-container-org21c1657" class="outline-4">
<h4 id="org21c1657">认证策略</h4>
<div class="outline-text-4" id="text-org21c1657">
<p>
正如认证架构中所说的，认证策略是对服务收到的请求生效的。要在 <span class="underline">双向 TLS</span> 中指定 客户端认证策略 ，需要在 <span class="underline">DetinationRule</span> 中设置 <span class="underline">TLSSettings</span> 
</p>
<pre class="example">
TLS 设置参考文档中有更多这方面的信息
</pre>

<p>
和其他的 Istio 配置一样，可以用 <span class="underline">.yaml 文件</span> 的形式来编写认证策略。部署策略使用 <span class="underline">kubectl</span> ：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: <span style="color: #deb887;">"security.istio.io/v1beta1"</span>
<span style="color: #4eee94;">kind</span>: <span style="color: #deb887;">"PeerAuthentication"</span>
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: <span style="color: #deb887;">"example-peer-policy"</span>
  <span style="color: #4eee94;">namespace</span>: <span style="color: #deb887;">"foo"</span>
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">matchLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">app</span>: reviews
  <span style="color: #4eee94;">mtls</span>:
    <span style="color: #4eee94;">mode</span>: STRICT
</pre>
</div>

<pre class="example">
与带有 app:reviews 标签的工作负载的传输层认证，必须使用双向 TLS
</pre>
</div>

<div id="outline-container-org467cf68" class="outline-5">
<h5 id="org467cf68">策略存储</h5>
<div class="outline-text-5" id="text-org467cf68">
<p>
Istio 将：
</p>
<ul class="org-ul">
<li><span class="underline">网格范围</span> 的策略存储在 <span class="underline">根命名空间</span> 。这些策略使用一个 <span class="underline">空的 selector</span> 适用于 <span class="underline">网格中的所有</span> 工作负载</li>
<li>具有 <span class="underline">名称空间范围</span> 的策略存储在 <span class="underline">相应的名称空间</span> 中。它们仅适用于其 <span class="underline">命名空间内</span> 的工作负载</li>
<li>如果配置了 <span class="underline">selector 字段</span> ，则认证策略仅适用于与 <span class="underline">配置的条件匹配</span> 的工作负载</li>
</ul>

<p>
Peer 和 request 认证策略用 kind 字段区分，分别是 <span class="underline">PeerAuthentication</span> 和 <span class="underline">RequestAuthentication</span> 
</p>
</div>
</div>

<div id="outline-container-org325b1aa" class="outline-5">
<h5 id="org325b1aa">Selector 字段</h5>
<div class="outline-text-5" id="text-org325b1aa">
<p>
Peer 和 request 认证策略使用 selector 字段来指定该策略适用的工作负载的标签：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">selector</span>:
  <span style="color: #4eee94;">matchLabels</span>:
    <span style="color: #4eee94;">app</span>: product-page
</pre>
</div>

<pre class="example">
适用于带有 app：product-page 标签的工作负载的策略的 selector 字段
</pre>

<p>
如果没有为 selector 字段提供值，则 Istio 会将策略与策略存储范围内的所有工作负载进行匹配。因此，selector 字段可帮助指定策略的范围：
</p>
<ul class="org-ul">
<li>网格范围策略：为根名称空间指定的策略，不带或带有空的 selector 字段</li>
<li>命名空间范围的策略：为非root命名空间指定的策略，不带有或带有空的 selector 字段</li>
<li>特定于工作负载的策略：在常规名称空间中定义的策略，带有非空 selector 字段</li>
</ul>

<p>
Peer 和 request 认证策略对 selector 字段遵循相同的层次结构原则，但是 Istio 以略有不同的方式组合和应用它们 ，只能有一个网格范围的 Peer 认证策略，每个命名空间也只能有一个命名空间范围的 Peer 认证策略
</p>
<pre class="example">
当您为同一网格或命名空间配置多个网格范围或命名空间范围的 Peer 认证策略时，Istio 会忽略较新的策略。当多个特定于工作负载的 Peer 认证策略匹配时，Istio 将选择最旧的策略
</pre>

<p>
Istio 按照以下顺序为每个工作负载应用最窄的匹配策略：
</p>
<ol class="org-ol">
<li>特定于工作负载的</li>
<li>命名空间范围</li>
<li>网格范围</li>
</ol>

<p>
Istio 可以将所有匹配的 request 认证策略组合起来，就像它们来自单个 request 认证策略一样。因此，您可以在网格或名称空间中配置多个网格范围或命名空间范围的策略
</p>

<pre class="example">
但是，避免使用多个网格范围或命名空间范围的 request 认证策略仍然是一个好的实践
</pre>
</div>
</div>

<div id="outline-container-orgefab3f5" class="outline-5">
<h5 id="orgefab3f5">Peer authentication</h5>
<div class="outline-text-5" id="text-orgefab3f5">
<p>
Peer 认证策略指定 Istio 对目标工作负载实施的双向 TLS 模式。支持以下模式：
</p>
<ul class="org-ul">
<li>PERMISSIVE：工作负载接受双向 TLS 和纯文本流量。此模式在迁移因为没有 sidecar 而无法使用双向 TLS 的工作负载的过程中非常有用。一旦工作负载完成 sidecar 注入的迁移，应将模式切换为 STRICT</li>
<li>STRICT： 工作负载仅接收双向 TLS 流量</li>
<li>DISABLE：禁用双向 TLS。 从安全角度来看，除非您提供自己的安全解决方案，否则请勿使用此模式</li>
</ul>

<pre class="example">
如果未设置模式，将继承父作用域的模式

未设置模式的网格范围的 peer 认证策略默认使用 PERMISSIVE 模式
</pre>

<p>
下面的 peer 认证策略要求命名空间 foo 中的所有工作负载都使用双向 TLS：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: <span style="color: #deb887;">"security.istio.io/v1beta1"</span>
<span style="color: #4eee94;">kind</span>: <span style="color: #deb887;">"PeerAuthentication"</span>
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: <span style="color: #deb887;">"example-policy"</span>
  <span style="color: #4eee94;">namespace</span>: <span style="color: #deb887;">"foo"</span>
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">mtls</span>:
    <span style="color: #4eee94;">mode</span>: STRICT
</pre>
</div>

<p>
对于特定于工作负载的 peer 认证策略，可以为 <span class="underline">不同的端口</span> 指定不同的双向 TLS 模式。您只能将工作负载声明过的端口用于端口范围的双向 TLS 配置。以下示例为 app:example-app 工作负载禁用了端口80上的双向TLS，并对所有其他端口使用名称空间范围的 peer 认证策略的双向 TLS 设置：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: <span style="color: #deb887;">"security.istio.io/v1beta1"</span>
<span style="color: #4eee94;">kind</span>: <span style="color: #deb887;">"PeerAuthentication"</span>
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: <span style="color: #deb887;">"example-workload-policy"</span>
  <span style="color: #4eee94;">namespace</span>: <span style="color: #deb887;">"foo"</span>
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
     <span style="color: #4eee94;">matchLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  app</span>: example-app
  <span style="color: #4eee94;">portLevelMtls</span>:
    <span style="color: #4eee94;">80</span>:
       <span style="color: #4eee94;">mode</span>: DISABLE
</pre>
</div>

<p>
上面的 peer 认证策略仅在有如下 Service 定义时工作，将流向 example-service 服务的请求绑定到 example-app 工作负载的 80 端口
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: v1
<span style="color: #4eee94;">kind</span>: Service
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: example-service
  <span style="color: #4eee94;">namespace</span>: foo
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">ports</span>:
  - <span style="color: #4eee94;">name</span>: http
    <span style="color: #4eee94;">port</span>: 8000
    <span style="color: #4eee94;">protocol</span>: TCP
    <span style="color: #4eee94;">targetPort</span>: 80
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">app</span>: example-app
</pre>
</div>
</div>
</div>

<div id="outline-container-org21b9065" class="outline-5">
<h5 id="org21b9065">Request authentication</h5>
<div class="outline-text-5" id="text-org21b9065">
<p>
Request 认证策略指定验证 JSON Web Token（JWT）所需的值。 这些值包括：
</p>
<ul class="org-ul">
<li>token 在请求中的位置</li>
<li>请求的 issuer</li>
<li>公共 JSON Web Key Set（JWKS）</li>
</ul>

<p>
Istio 会根据 request 认证策略中的规则检查提供的令牌（如果已提供），并拒绝令牌无效的请求。当请求不带有令牌时，默认情况下将接受它们。要拒绝没有令牌的请求，请提供授权规则，该规则指定对特定操作（例如，路径或操作）的限制 
</p>

<pre class="example">
如果 Request 认证策略使用唯一的位置，则它们可以指定多个JWT

当多个策略与工作负载匹配时，Istio 会将所有规则组合起来，就好像它们被指定为单个策略一样，此行为对于开发接受来自不同 JWT 提供者的工作负载时很有用

但是，不支持具有多个有效 JWT 的请求，因为此类请求的输出主体未定义
</pre>
</div>
</div>

<div id="outline-container-org557895b" class="outline-5">
<h5 id="org557895b">Principals</h5>
<div class="outline-text-5" id="text-org557895b">
<ul class="org-ul">
<li>使用 peer 认证策略和双向 TLS 时，Istio 将身份从 peer 认证提取到 <span class="underline">source.principal</span> 中</li>
<li>使用 request 认证策略时，Istio 会将 JWT 中的身份赋值给 <span class="underline">request.auth.principal</span></li>
</ul>

<p>
使用这些 principals 设置 <span class="underline">授权策略</span> 和作为 <span class="underline">遥测的输出</span>  
</p>
</div>
</div>
</div>

<div id="outline-container-org48b54a5" class="outline-4">
<h4 id="org48b54a5">更新认证策略</h4>
<div class="outline-text-4" id="text-org48b54a5">
<p>
可以随时更改认证策略，Istio 几乎实时将新策略推送到工作负载。但是，Istio 无法保证所有工作负载都同时收到新政策。以下建议有助于避免在更新认证策略时造成干扰：
</p>
<ul class="org-ul">
<li>将 peer 认证策略的模式从 DISABLE 更改为 STRICT 时，请使用 PERMISSIVE 模式来过渡，反之亦然。当所有工作负载成功切换到所需模式时，您可以将策略应用于最终模式。您可以使用 Istio 遥测技术来验证工作负载已成功切换</li>
<li>将 request 认证策略从一个 JWT 迁移到另一个 JWT 时，将新 JWT 的规则添加到该策略中，而不删除旧规则。这样，工作负载接受两种类型的 JWT，当所有流量都切换到新的 JWT 时，您可以删除旧规则。但是，每个 JWT 必须使用不同的位置</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4da80bd" class="outline-3">
<h3 id="org4da80bd">授权</h3>
<div class="outline-text-3" id="text-org4da80bd">
<p>
Istio 的授权功能为网格中的工作负载提供 <span class="underline">网格</span> 、 <span class="underline">命名空间</span> 和 <span class="underline">工作负载</span> 级别的访问控制。这种控制层级提供了以下优点：
</p>
<ul class="org-ul">
<li>工作负载间和最终用户到工作负载的授权</li>
<li>一个简单的 API：它包括一个单独的并且很容易使用和维护的 AuthorizationPolicy CRD</li>
<li>灵活的语义：运维人员可以在 Istio 属性上定义自定义条件，并使用 DENY 和 ALLOW 动作</li>
<li>高性能：Istio 授权是在 Envoy 本地强制执行的</li>
<li>高兼容性：原生支持 HTTP、HTTPS 和 HTTP2，以及任意普通 TCP 协议</li>
</ul>
</div>

<div id="outline-container-orgbdbb470" class="outline-4">
<h4 id="orgbdbb470">授权架构</h4>
<div class="outline-text-4" id="text-orgbdbb470">
<p>
每个 <span class="underline">Envoy 代理</span> 都运行一个 <b>授权引擎</b> ，该引擎在运行时授权请求。当请求到达代理时，授权引擎根据当前 <span class="underline">授权策略</span> 评估 <span class="underline">请求上下文</span> ，并返回授权结果 <span class="underline">ALLOW</span> 或 <span class="underline">DENY</span> 。 运维人员使用 <span class="underline">.yaml</span> 文件指定 Istio 授权策略 
</p>


<div class="figure">
<p><object type="image/svg+xml" data="./pic/authz.svg" class="org-svg" width="40%">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgab05cfa" class="outline-4">
<h4 id="orgab05cfa">隐式启用</h4>
<div class="outline-text-4" id="text-orgab05cfa">
<p>
无需显式启用 Istio 的授权功能。只需将 <span class="underline">授权策略</span> <b>应用</b> 于 <span class="underline">工作负载</span> 即可实施访问控制。对于未应用授权策略的工作负载，Istio 不会执行访问控制，放行所有请求。
</p>

<p>
授权策略支持 ALLOW 和 DENY 动作。 <b>拒绝策略优先于允许策略</b> ：
</p>
<ul class="org-ul">
<li>如果将 <span class="underline">任何允许策略</span> 应用于工作负载，则 <span class="underline">默认</span> 情况下将 <b>拒绝</b> 对该工作负载的访问，除非策略中的规则明确允许</li>
<li>将多个授权策略应用于相同的工作负载时，Istio 会 <span class="underline">累加</span> 地应用它们</li>
</ul>
</div>
</div>

<div id="outline-container-orga12ee4a" class="outline-4">
<h4 id="orga12ee4a">授权策略</h4>
<div class="outline-text-4" id="text-orga12ee4a">
<p>
要配置授权策略，请创建一个 <span class="underline">AuthorizationPolicy</span> 自定义资源。 一个授权策略包括 <span class="underline">选择器</span> （selector）， <span class="underline">动作</span> （action） 和一个 <span class="underline">规则</span> （rules）列表：
</p>
<ul class="org-ul">
<li>selector 字段指定策略的目标</li>
<li>action 字段指定允许还是拒绝请求</li>
<li>rules 指定何时触发动作
<ul class="org-ul">
<li>rules 下的 from 字段指定请求的来源</li>
<li>rules 下的 to 字段指定请求的操作</li>
<li>rules 下的 when 字段指定应用规则所需的条件</li>
</ul></li>
</ul>

<p>
以下示例显示了一个授权策略，该策略允许两个源（服务帐号 cluster.local/ns/default/sa/sleep 和命名空间 dev），在使用有效的 JWT 令牌发送请求时，可以访问命名空间 foo 中的带有标签 app: httpbin 和 version: v1 的工作负载：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
 <span style="color: #4eee94;">name</span>: httpbin
 <span style="color: #4eee94;">namespace</span>: foo
<span style="color: #4eee94;">spec</span>:
 <span style="color: #4eee94;">selector</span>:
   <span style="color: #4eee94;">matchLabels</span>:
     <span style="color: #4eee94;">app</span>: httpbin
     <span style="color: #4eee94;">version</span>: v1
 <span style="color: #4eee94;">action</span>: ALLOW
 <span style="color: #4eee94;">rules</span>:
 - <span style="color: #4eee94;">from</span>:
   - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> principals</span>: [<span style="color: #deb887;">"cluster.local/ns/default/sa/sleep"</span>]
   - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  namespaces</span>: [<span style="color: #deb887;">"dev"</span>]
   <span style="color: #4eee94;">to</span>:
   - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> methods</span>: [<span style="color: #deb887;">"GET"</span>]
   <span style="color: #4eee94;">when</span>:
   - <span style="color: #4eee94;">key</span>: request.auth.claims[iss]
     <span style="color: #4eee94;">values</span>: [<span style="color: #deb887;">"https://accounts.google.com"</span>]
</pre>
</div>

<p>
下例显示了一个授权策略，如果请求来源不是命名空间 foo，请求将被拒绝 
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
 <span style="color: #4eee94;">name</span>: httpbin-deny
 <span style="color: #4eee94;">namespace</span>: foo
<span style="color: #4eee94;">spec</span>:
 <span style="color: #4eee94;">selector</span>:
   <span style="color: #4eee94;">matchLabels</span>:
     <span style="color: #4eee94;">app</span>: httpbin
     <span style="color: #4eee94;">version</span>: v1
 <span style="color: #4eee94;">action</span>: DENY
 <span style="color: #4eee94;">rules</span>:
 - <span style="color: #4eee94;">from</span>:
   - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> notNamespaces</span>: [<span style="color: #deb887;">"foo"</span>]
</pre>
</div>

<pre class="example">
拒绝策略优先于允许策略

如果请求同时匹配上允许策略和拒绝策略，请求将被拒绝。Istio 首先评估拒绝策略，以确保允许策略不能绕过拒绝策略
</pre>
</div>

<div id="outline-container-orgf27fd15" class="outline-5">
<h5 id="orgf27fd15">策略目标</h5>
<div class="outline-text-5" id="text-orgf27fd15">
<p>
可以通过 <span class="underline">metadata/namespace</span> 字段和可选的 <span class="underline">selector</span> 字段来指定策略的范围或目标：
</p>
<ul class="org-ul">
<li>metadata/namespace 告诉该策略适用于哪个命名空间
<ul class="org-ul">
<li>如果将其值设置为根名称空间，则该策略将应用于网格中的所有名称空间。根命名空间的值是可配置的，默认值为 istio-system</li>
<li>如果设置为任何其他名称空间，则该策略仅适用于指定的名称空间</li>
</ul></li>
<li>使用 selector 字段来进一步限制策略以应用于特定工作负载
<ul class="org-ul">
<li>selector 使用标签选择目标工作负载。slector 包含 {key: value}对的列表，其中 key 是标签的名称</li>
<li>如果未设置，则授权策略将应用于与授权策略相同的命名空间中的所有工作负载</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: allow-read
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">matchLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> app</span>: products
  <span style="color: #4eee94;">action</span>: ALLOW
  <span style="color: #4eee94;">rules</span>:
  - <span style="color: #4eee94;">to</span>:
    - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  methods</span>: [<span style="color: #deb887;">"GET"</span>, <span style="color: #deb887;">"HEAD"</span>]
</pre>
</div>

<pre class="example">
策略 allow-read 允许对 default 命名空间中带有标签 app: products 的工作负载的 "GET" 和 "HEAD" 访问
</pre>
</div>
</div>

<div id="outline-container-orga756126" class="outline-5">
<h5 id="orga756126">值匹配</h5>
<div class="outline-text-5" id="text-orga756126">
<p>
授权策略中的大多数字段都支持以下所有匹配模式
</p>
<ul class="org-ul">
<li>完全匹配：即完整的字符串匹配</li>
<li>前缀匹配："<b>" 结尾的字符串。例如，"test.abc.</b>" 匹配 "test.abc.com"、"test.abc.com.cn"、"test.abc.org" 等等</li>
<li>后缀匹配："<b>" 开头的字符串。例如，"</b>.abc.com" 匹配 "eng.abc.com"、"test.eng.abc.com" 等等</li>
<li>存在匹配：* 用于指定非空的任意内容。您可以使用格式 fieldname: ["*"] 指定必须存在的字段。这意味着该字段可以匹配任意内容，但是 <span class="underline">不能为空</span></li>
</ul>
<pre class="example">
请注意这与不指定字段不同，后者意味着包括空的任意内容
</pre>

<p>
有一些例外。 例如，以下字段仅支持完全匹配：
</p>
<ul class="org-ul">
<li>when 部分下的 key 字段</li>
<li>source 部分下 的 ipBlocks</li>
<li>to 部分下的 ports 字段</li>
</ul>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: tester
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">matchLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">app</span>: products
  <span style="color: #4eee94;">action</span>: ALLOW
  <span style="color: #4eee94;">rules</span>:
  - <span style="color: #4eee94;">to</span>:
    - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  paths</span>: [<span style="color: #deb887;">"/test/*"</span>, <span style="color: #deb887;">"*/info"</span>]
</pre>
</div>

<pre class="example">
示例策略允许访问前缀为 /test/* 或后缀为 */info 的路径
</pre>
</div>
</div>

<div id="outline-container-org74eda20" class="outline-5">
<h5 id="org74eda20">排除匹配</h5>
<div class="outline-text-5" id="text-org74eda20">
<p>
为了匹配诸如 when 字段中的 notValues，source 字段中的 notIpBlocks，to 字段中的 notPorts 之类的否定条件，Istio 支持排除匹配。下面示例中如果请求路径不是 /healthz，则要求从请求的 JWT 认证中导出的主体是有效的
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: disable-jwt-for-healthz
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">matchLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">app</span>: products
  <span style="color: #4eee94;">action</span>: ALLOW
  <span style="color: #4eee94;">rules</span>:
  - <span style="color: #4eee94;">to</span>:
    - <span style="color: #4eee94;">operation</span>: 
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  notPaths</span>: [<span style="color: #deb887;">"/healthz"</span>]
    <span style="color: #4eee94;">from</span>:
    - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   requestPrincipals</span>: [<span style="color: #deb887;">"*"</span>]
</pre>
</div>

<pre class="example">
该策略从 JWT 身份验证中排除对 /healthz 路径的请求
</pre>

<p>
下面的示例拒绝到 /admin 路径且不带请求主体的请求：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: enable-jwt-for-admin
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">selector</span>:
    <span style="color: #4eee94;">matchLabels</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> app</span>: products
  <span style="color: #4eee94;">action</span>: DENY
  <span style="color: #4eee94;">rules</span>:
  - <span style="color: #4eee94;">to</span>:
    - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">  paths</span>: [<span style="color: #deb887;">"/admin"</span>]
    <span style="color: #4eee94;">from</span>:
    - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">   notRequestPrincipals</span>: [<span style="color: #deb887;">"*"</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-org5061c31" class="outline-5">
<h5 id="org5061c31">全部允许和默认全部拒绝授权策略</h5>
<div class="outline-text-5" id="text-org5061c31">
<p>
一个简单的 allow-all 授权策略，该策略允许完全访问 default 命名空间中的所有工作负载：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: allow-all
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">spec</span>:
  <span style="color: #4eee94;">action</span>: ALLOW
  <span style="color: #4eee94;">rules</span>:
  - {}
</pre>
</div>

<p>
不允许任何对 admin 命名空间工作负载的访问：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: deny-all
  <span style="color: #4eee94;">namespace</span>: admin
<span style="color: #4eee94;">spec</span>:
  {}
</pre>
</div>
</div>
</div>

<div id="outline-container-org89acf46" class="outline-5">
<h5 id="org89acf46">自定义条件</h5>
<div class="outline-text-5" id="text-org89acf46">
<p>
可以使用 <span class="underline">when</span> 部分指定其他条件。 例如，下面的 AuthorizationPolicy 定义包括以下条件：request.headers [version] 是 v1 或 v2。 在这种情况下，key 是 request.headers [version]，它是 Istio 属性 request.headers（是个字典）中的一项 
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
 <span style="color: #4eee94;">name</span>: httpbin
 <span style="color: #4eee94;">namespace</span>: foo
<span style="color: #4eee94;">spec</span>:
 <span style="color: #4eee94;">selector</span>:
   <span style="color: #4eee94;">matchLabels</span>:
     <span style="color: #4eee94;">app</span>: httpbin
     <span style="color: #4eee94;">version</span>: v1
 <span style="color: #4eee94;">action</span>: ALLOW
 <span style="color: #4eee94;">rules</span>:
 - <span style="color: #4eee94;">from</span>:
   - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> principals</span>: [<span style="color: #deb887;">"cluster.local/ns/default/sa/sleep"</span>]
   <span style="color: #4eee94;">to</span>:
   - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> methods</span>: [<span style="color: #deb887;">"GET"</span>]
   <span style="color: #4eee94;">when</span>:
   - <span style="color: #4eee94;">key</span>: request.headers[version]
     <span style="color: #4eee94;">values</span>: [<span style="color: #deb887;">"v1"</span>, <span style="color: #deb887;">"v2"</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc7ae05a" class="outline-5">
<h5 id="orgc7ae05a">认证与未认证身份</h5>
<div class="outline-text-5" id="text-orgc7ae05a">
<p>
如果要使工作负载可公开访问，则需要将 <span class="underline">source 部分留空</span> 。这允许来自所有（经过认证和未经认证）的用户和工作负载的源，例如：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
 <span style="color: #4eee94;">name</span>: httpbin
 <span style="color: #4eee94;">namespace</span>: foo
<span style="color: #4eee94;">spec</span>:
 <span style="color: #4eee94;">selector</span>:
   <span style="color: #4eee94;">matchLabels</span>:
     <span style="color: #4eee94;">app</span>: httpbin
     <span style="color: #4eee94;">version</span>: v1
 <span style="color: #4eee94;">action</span>: ALLOW
 <span style="color: #4eee94;">rules</span>:
 - <span style="color: #4eee94;">to</span>:
   - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> methods</span>: [<span style="color: #deb887;">"GET"</span>, <span style="color: #deb887;">"POST"</span>]
</pre>
</div>

<p>
要仅允许经过认证的用户，请将 <span class="underline">principal 设置为 "*"</span> ，例如：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: security.istio.io/v1beta1
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
 <span style="color: #4eee94;">name</span>: httpbin
 <span style="color: #4eee94;">namespace</span>: foo
<span style="color: #4eee94;">spec</span>:
 <span style="color: #4eee94;">selector</span>:
   <span style="color: #4eee94;">matchLabels</span>:
     <span style="color: #4eee94;">app</span>: httpbin
     <span style="color: #4eee94;">version</span>: v1
 <span style="color: #4eee94;">action</span>: ALLOW
 <span style="color: #4eee94;">rules</span>:
 - <span style="color: #4eee94;">from</span>:
   - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">principals</span>: [<span style="color: #deb887;">"*"</span>]
   <span style="color: #4eee94;">to</span>:
   - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;">methods</span>: [<span style="color: #deb887;">"GET"</span>, <span style="color: #deb887;">"POST"</span>]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb9f2d8d" class="outline-4">
<h4 id="orgb9f2d8d">在普通 TCP 协议上使用 Istio 授权</h4>
<div class="outline-text-4" id="text-orgb9f2d8d">
<p>
Istio 授权支持工作负载使用任意普通 TCP 协议，如 MongoDB。 在这种情况下，您可以按照与 HTTP 工作负载相同的方式配置授权策略。 不同之处在于某些字段和条件仅适用于 HTTP 工作负载。 这些字段包括：
</p>
<ul class="org-ul">
<li>授权策略对象 source 部分中的 request_principals 字段</li>
<li>授权策略对象 operation 部分中的 hosts、methods 和 paths 字段</li>
</ul>

<pre class="example">
如果在授权策略中对 TCP 工作负载使用了任何只适用于 HTTP 的字段，Istio 将会忽略它们 
</pre>

<p>
假设在端口 27017 上有一个 MongoDB 服务，下例配置了一个授权策略，只允许 Istio 网格中的 bookinfo-ratings-v2 服务访问该 MongoDB 工作负载：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: <span style="color: #deb887;">"security.istio.io/v1beta1"</span>
<span style="color: #4eee94;">kind</span>: AuthorizationPolicy
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: mongodb-policy
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">spec</span>:
 <span style="color: #4eee94;">selector</span>:
   <span style="color: #4eee94;">matchLabels</span>:
     <span style="color: #4eee94;">app</span>: mongodb
 <span style="color: #4eee94;">action</span>: ALLOW
 <span style="color: #4eee94;">rules</span>:
 - <span style="color: #4eee94;">from</span>:
   - <span style="color: #4eee94;">source</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> principals</span>: [<span style="color: #deb887;">"cluster.local/ns/default/sa/bookinfo-ratings-v2"</span>]
   <span style="color: #4eee94;">to</span>:
   - <span style="color: #4eee94;">operation</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #4eee94;"> ports</span>: [<span style="color: #deb887;">"27017"</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd9f2f01" class="outline-4">
<h4 id="orgd9f2f01">对双向 TLS 的依赖</h4>
<div class="outline-text-4" id="text-orgd9f2f01">
<p>
Istio 使用双向 TLS 将某些信息从客户端安全地传递到服务器。在使用授权策略中的以下任何字段之前，必须先启用双向 TLS：
</p>
<ul class="org-ul">
<li>source 部分下的 principals 字段</li>
<li>source 部分下的 namespaces 字段</li>
<li>source.principal 自定义条件</li>
<li>source.namespace 自定义条件</li>
<li>connection.sni 自定义条件</li>
</ul>

<pre class="example">
如果不使用授权策略中的上述任何字段，则双向 TLS 不是必须的
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8142186" class="outline-2">
<h2 id="org8142186">可观察性</h2>
<div class="outline-text-2" id="text-org8142186">
<p>
Istio 为网格内所有的服务通信生成详细的遥测数据
</p>

<pre class="example">
这种遥测技术提供了服务行为的可观察性，使运维人员能够排查故障、维护和优化应用程序，而不会给服务的开发人员带来任何额外的负担

通过 Istio，运维人员可以全面了解到受监控的服务如何与其他服务以及 Istio 组件进行交互
</pre>

<p>
Istio 生成以下类型的遥测数据，以提供对整个服务网格的可观察性：
</p>
<ul class="org-ul">
<li>指标。Istio 基于 4 个监控的黄金标识（延迟、流量、错误、饱和）生成了一系列服务指标。Istio 还为网格控制平面提供了更详细的指标。除此以外还提供了一组默认的基于这些指标的网格监控仪表板</li>
<li>分布式追踪。Istio 为每个服务生成分布式追踪 span，运维人员可以理解网格内服务的依赖和调用流程</li>
<li>访问日志。当流量流入网格中的服务时，Istio 可以生成每个请求的完整记录，包括源和目标的元数据。此信息使运维人员能够将服务行为的审查控制到单个工作负载实例的级别。</li>
</ul>
</div>

<div id="outline-container-orgf8b6046" class="outline-3">
<h3 id="orgf8b6046">指标</h3>
<div class="outline-text-3" id="text-orgf8b6046">
<p>
指标（Metric）提供了一种以聚合的方式监控和理解行为的方法
</p>
<ul class="org-ul">
<li>为了监控服务行为，Istio 为服务网格中所有 <span class="underline">出入的服务流量</span> 都生成了指标。这些指标提供了关于行为的信息，例如 <span class="underline">总流量数</span> 、 <span class="underline">错误率</span> 和 <span class="underline">请求响应时间</span></li>
<li>除了监控网格中服务的行为外，监控网格本身的行为也很重要。Istio 组件可以导出 <span class="underline">自身内部行为</span> 的指标，以提供对网格 <span class="underline">控制平面的功能</span> 和 <span class="underline">健康情况</span> 的洞察能力</li>
</ul>

<pre class="example">
Istio 指标收集由运维人员配置来驱动，运维人员决定如何以及何时收集指标，以及指标本身的详细程度

这使得它能够灵活地调整指标收集来满足个性化需求
</pre>
</div>

<div id="outline-container-org59c6a77" class="outline-4">
<h4 id="org59c6a77">代理级别指标</h4>
<div class="outline-text-4" id="text-org59c6a77">
<p>
Istio 指标收集从 sidecar 代理（Envoy）开始。每个代理为通过它的所有流量（入站和出站）生成一组丰富的指标。代理还提供关于它本身管理功能的详细统计信息，包括配置信息和健康信息
</p>

<pre class="example">
Envoy 生成的指标提供了资源（例如监听器和集群）粒度上的网格监控

因此，为了监控 Envoy 指标，需要了解网格服务和 Envoy 资源之间的连接
</pre>
<p>
Istio 允许运维人员在 <span class="underline">每个工作负载实例</span> 上选择生成和收集哪个 Envoy 指标
</p>

<pre class="example">
默认情况下，Istio 只支持 Envoy 生成的统计数据的一小部分，以避免依赖过多的后端服务，还可以减少与指标收集相关的 CPU 开销

然而，运维人员可以在需要时轻松地扩展收集到的代理指标集。这支持有针对性地调试网络行为，同时降低了跨网格监控的总体成本
</pre>

<p>
代理级别指标的例子：
</p>

<div class="org-src-container">
<pre class="src src-sh">envoy_cluster_internal_upstream_rq{<span style="color: #4eee94;">response_code_class</span>=<span style="color: #deb887;">"2xx"</span>,<span style="color: #4eee94;">cluster_name</span>=<span style="color: #deb887;">"xds-grpc"</span>} 7163

envoy_cluster_upstream_rq_completed{<span style="color: #4eee94;">cluster_name</span>=<span style="color: #deb887;">"xds-grpc"</span>} 7164

envoy_cluster_ssl_connection_error{<span style="color: #4eee94;">cluster_name</span>=<span style="color: #deb887;">"xds-grpc"</span>} 0

envoy_cluster_lb_subsets_removed{<span style="color: #4eee94;">cluster_name</span>=<span style="color: #deb887;">"xds-grpc"</span>} 0

envoy_cluster_internal_upstream_rq{<span style="color: #4eee94;">response_code</span>=<span style="color: #deb887;">"503"</span>,<span style="color: #4eee94;">cluster_name</span>=<span style="color: #deb887;">"xds-grpc"</span>} 1
</pre>
</div>
</div>
</div>

<div id="outline-container-org0e6770d" class="outline-4">
<h4 id="org0e6770d">服务级别指标</h4>
<div class="outline-text-4" id="text-org0e6770d">
<p>
除了代理级别指标之外，Istio 还提供了一组用于监控服务通信的面向服务的指标。这些指标涵盖了四个基本的服务监控需求： <span class="underline">延迟</span> 、  <span class="underline">流量</span> 、 <span class="underline">错误</span> 和 <span class="underline">饱和</span> 情况。Istio 带有一组 <span class="underline">默认的仪表板</span> ，用于监控基于这些指标的服务行为
</p>

<pre class="example">
默认的 Istio 指标由 Istio 提供的配置集定义并默认导出到 Prometheus

运维人员可以自由地修改这些指标的形态和内容，更改它们的收集机制，以满足各自的监控需求
</pre>

<p>
服务级别指标的使用完全是可选的。运维人员可以选择关闭指标的生成和收集来满足自身需要 
</p>
<div class="org-src-container">
<pre class="src src-sh">istio_requests_total{
  <span style="color: #4eee94;">connection_security_policy</span>=<span style="color: #deb887;">"mutual_tls"</span>,
  <span style="color: #4eee94;">destination_app</span>=<span style="color: #deb887;">"details"</span>,
  <span style="color: #4eee94;">destination_principal</span>=<span style="color: #deb887;">"cluster.local/ns/default/sa/default"</span>,
  <span style="color: #4eee94;">destination_service</span>=<span style="color: #deb887;">"details.default.svc.cluster.local"</span>,
  <span style="color: #4eee94;">destination_service_name</span>=<span style="color: #deb887;">"details"</span>,
  <span style="color: #4eee94;">destination_service_namespace</span>=<span style="color: #deb887;">"default"</span>,
  <span style="color: #4eee94;">destination_version</span>=<span style="color: #deb887;">"v1"</span>,
  <span style="color: #4eee94;">destination_workload</span>=<span style="color: #deb887;">"details-v1"</span>,
  <span style="color: #4eee94;">destination_workload_namespace</span>=<span style="color: #deb887;">"default"</span>,
  <span style="color: #4eee94;">reporter</span>=<span style="color: #deb887;">"destination"</span>,
  <span style="color: #4eee94;">request_protocol</span>=<span style="color: #deb887;">"http"</span>,
  <span style="color: #4eee94;">response_code</span>=<span style="color: #deb887;">"200"</span>,
  <span style="color: #4eee94;">response_flags</span>=<span style="color: #deb887;">"-"</span>,
  <span style="color: #4eee94;">source_app</span>=<span style="color: #deb887;">"productpage"</span>,
  <span style="color: #4eee94;">source_principal</span>=<span style="color: #deb887;">"cluster.local/ns/default/sa/default"</span>,
  <span style="color: #4eee94;">source_version</span>=<span style="color: #deb887;">"v1"</span>,
  <span style="color: #4eee94;">source_workload</span>=<span style="color: #deb887;">"productpage-v1"</span>,
  <span style="color: #4eee94;">source_workload_namespace</span>=<span style="color: #deb887;">"default"</span>
} 214
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ec51f3" class="outline-4">
<h4 id="org7ec51f3">控制平面指标</h4>
<div class="outline-text-4" id="text-org7ec51f3">
<p>
每一个 Istio 的组件（Pilot、Galley、Mixer）都提供了对自身监控指标的集合。这些指标容许监控 Istio 自己的行为（这与网格内的服务有所不同）。
</p>
<pre class="example">
有关这些被维护指标的更多信息，请查看每个组件的参考文档
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc3c567" class="outline-3">
<h3 id="orgdc3c567">分布式追踪</h3>
<div class="outline-text-3" id="text-orgdc3c567">
<p>
分布式追踪通过监控流经网格的单个请求，提供了一种监控和理解行为的方法。追踪使网格的运维人员能够理解服务的依赖关系以及在服务网格中的延迟源
</p>
<ul class="org-ul">
<li>Istio 支持通过 Envoy 代理进行分布式追踪。 <span class="underline">代理</span> 自动为其应用程序 <b>生成</b> <span class="underline">追踪 span</span> ，只需要应用程序转发适当的请求上下文即可</li>
<li>Istio 支持很多追踪系统，包括 <span class="underline">Zipkin</span> 、Jaeger、LightStep、Datadog
<ul class="org-ul">
<li>运维人员 <b>控制</b> 生成追踪的 <span class="underline">采样率</span> （每个请求生成跟踪数据的速率）。这允许运维人员控制网格生成追踪数据的数量和速率</li>
</ul></li>
</ul>

<p>
Istio 为一个请求生成的分布式追踪数据：
</p>


<div class="figure">
<p><img src="./pic/zipkin.png" alt="zipkin.png" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org70c1539" class="outline-3">
<h3 id="org70c1539">访问日志</h3>
<div class="outline-text-3" id="text-org70c1539">
<p>
访问日志提供了一种从单个工作负载实例的角度监控和理解行为的方法
</p>
<ul class="org-ul">
<li>Istio 可以以一组 <span class="underline">可配置的格式集</span> 生成服务流量的访问日志，为运维人员提供日志记录的方式、内容、时间和位置的完全控制</li>
<li>Istio 向访问日志机制暴露了完整的 <span class="underline">源和目标</span> <b>元数据</b> ，允许对网络通信进行详细的审查</li>
<li>访问日志可以在 <span class="underline">本地生成</span> ，或者导出到 <span class="underline">自定义的后端基础设施</span> ，包括 Fluentd。</li>
</ul>

<div class="org-src-container">
<pre class="src src-js">{<span style="color: #deb887;">"level"</span>:<span style="color: #deb887;">"info"</span>,<span style="color: #deb887;">"time"</span>:<span style="color: #deb887;">"2019-06-11T20:57:35.424310Z"</span>,<span style="color: #deb887;">"instance"</span>:<span style="color: #deb887;">"accesslog.instance.istio-control"</span>,<span style="color: #deb887;">"connection_security_policy"</span>:<span style="color: #deb887;">"mutual_tls"</span>,<span style="color: #deb887;">"destinationApp"</span>:<span style="color: #deb887;">"productpage"</span>,<span style="color: #deb887;">"destinationIp"</span>:<span style="color: #deb887;">"10.44.2.15"</span>,<span style="color: #deb887;">"destinationName"</span>:<span style="color: #deb887;">"productpage-v1-6db7564db8-pvsnd"</span>,<span style="color: #deb887;">"destinationNamespace"</span>:<span style="color: #deb887;">"default"</span>,<span style="color: #deb887;">"destinationOwner"</span>:<span style="color: #deb887;">"kubernetes://apis/apps/v1/namespaces/default/deployments/productpage-v1"</span>,<span style="color: #deb887;">"destinationPrincipal"</span>:<span style="color: #deb887;">"cluster.local/ns/default/sa/default"</span>,<span style="color: #deb887;">"destinationServiceHost"</span>:<span style="color: #deb887;">"productpage.default.svc.cluster.local"</span>,<span style="color: #deb887;">"destinationWorkload"</span>:<span style="color: #deb887;">"productpage-v1"</span>,<span style="color: #deb887;">"httpAuthority"</span>:<span style="color: #deb887;">"35.202.6.119"</span>,<span style="color: #deb887;">"latency"</span>:<span style="color: #deb887;">"35.076236ms"</span>,<span style="color: #deb887;">"method"</span>:<span style="color: #deb887;">"GET"</span>,<span style="color: #deb887;">"protocol"</span>:<span style="color: #deb887;">"http"</span>,<span style="color: #deb887;">"receivedBytes"</span>:917,<span style="color: #deb887;">"referer"</span>:<span style="color: #deb887;">""</span>,<span style="color: #deb887;">"reporter"</span>:<span style="color: #deb887;">"destination"</span>,<span style="color: #deb887;">"requestId"</span>:<span style="color: #deb887;">"e3f7cffb-5642-434d-ae75-233a05b06158"</span>,<span style="color: #deb887;">"requestSize"</span>:0,<span style="color: #deb887;">"requestedServerName"</span>:<span style="color: #deb887;">"outbound_.9080_._.productpage.default.svc.cluster.local"</span>,<span style="color: #deb887;">"responseCode"</span>:200,<span style="color: #deb887;">"responseFlags"</span>:<span style="color: #deb887;">"-"</span>,<span style="color: #deb887;">"responseSize"</span>:4183,<span style="color: #deb887;">"responseTimestamp"</span>:<span style="color: #deb887;">"2019-06-11T20:57:35.459150Z"</span>,<span style="color: #deb887;">"sentBytes"</span>:4328,<span style="color: #deb887;">"sourceApp"</span>:<span style="color: #deb887;">"istio-ingressgateway"</span>,<span style="color: #deb887;">"sourceIp"</span>:<span style="color: #deb887;">"10.44.0.8"</span>,<span style="color: #deb887;">"sourceName"</span>:<span style="color: #deb887;">"ingressgateway-7748774cbf-bvf4j"</span>,<span style="color: #deb887;">"sourceNamespace"</span>:<span style="color: #deb887;">"istio-control"</span>,<span style="color: #deb887;">"sourceOwner"</span>:<span style="color: #deb887;">"kubernetes://apis/apps/v1/namespaces/istio-control/deployments/ingressgateway"</span>,<span style="color: #deb887;">"sourcePrincipal"</span>:<span style="color: #deb887;">"cluster.local/ns/istio-control/sa/default"</span>,<span style="color: #deb887;">"sourceWorkload"</span>:<span style="color: #deb887;">"ingressgateway"</span>,<span style="color: #deb887;">"url"</span>:<span style="color: #deb887;">"/productpage"</span>,<span style="color: #deb887;">"userAgent"</span>:<span style="color: #deb887;">"curl/7.54.0"</span>,<span style="color: #deb887;">"xForwardedFor"</span>:<span style="color: #deb887;">"10.128.0.35"</span>}
</pre>
</div>

<pre class="example">
更多关于访问日志的内容在收集日志和获取 Envoy 服务日志任务中提供
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
