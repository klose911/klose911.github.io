<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>基本类型</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="./basic.html"> HOME </a>
</div><div id="content">
<h1 class="title">基本类型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga84df77">数字</a>
<ul>
<li><a href="#org15fb0c1">字面常量</a>
<ul>
<li><a href="#org91893d0">数字字面值中的下划线</a></li>
<li><a href="#org855abec">表示方式</a></li>
</ul>
</li>
<li><a href="#orgf205c2b">显式转换</a></li>
<li><a href="#orga368e72">运算</a>
<ul>
<li><a href="#org0b43d9a">整数除法</a></li>
<li><a href="#org3acfe76">位运算</a></li>
</ul>
</li>
<li><a href="#orgb43345e">浮点数比较</a></li>
</ul>
</li>
<li><a href="#orgfc5377a">字符</a></li>
<li><a href="#org9c1c460">布尔</a></li>
<li><a href="#orge64a18b">数组</a>
<ul>
<li><a href="#org7ef6932">原生类型数组</a></li>
</ul>
</li>
<li><a href="#org8610644">字符串</a>
<ul>
<li><a href="#orgef8a91e">字符串字面值</a></li>
<li><a href="#orgd18f514">字符串模板</a></li>
</ul>
</li>
<li><a href="#org8c53375">非符号整数</a></li>
</ul>
</div>
</div>
<pre class="example">
  在 Kotlin 中，所有东西都是对象，在这个意义上讲可以在任何变量上调用成员函数与属性

  一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类
</pre>

<p>
接下来会描述 Kotlin 中使用的基本类型： <span class="underline">数字</span> 、 <span class="underline">字符</span> 、 <span class="underline">布尔值</span> 、 <span class="underline">数组</span> 与 <span class="underline">字符串</span> 
</p>
<div id="outline-container-orga84df77" class="outline-2">
<h2 id="orga84df77">数字</h2>
<div class="outline-text-2" id="text-orga84df77">
<p>
Kotlin 提供了一组表示数字的内置类型。 对于整数，有四种不同大小的类型，因此值的范围也不同：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> kotlin 整数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">类型</td>
<td class="org-right">大小（比特数）</td>
<td class="org-left">最小值</td>
<td class="org-left">最大值</td>
</tr>

<tr>
<td class="org-left">Byte</td>
<td class="org-right">8</td>
<td class="org-left">-128</td>
<td class="org-left">127</td>
</tr>

<tr>
<td class="org-left">Short</td>
<td class="org-right">16</td>
<td class="org-left">-32768</td>
<td class="org-left">32767</td>
</tr>

<tr>
<td class="org-left">Int</td>
<td class="org-right">32</td>
<td class="org-left">-2,147,483,648 (-2<sup>31</sup>)</td>
<td class="org-left">2,147,483,647 (2<sup>31</sup> - 1)</td>
</tr>

<tr>
<td class="org-left">Long</td>
<td class="org-right">64</td>
<td class="org-left">-9,223,372,036,854,775,808 (-2<sup>63</sup>)</td>
<td class="org-left">9,223,372,036,854,775,807 (2<sup>63</sup> - 1)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>所有以未超出 Int 最大值的整型值初始化的变量都会推断为 Int 类型</li>
<li>如果初始值超过了其最大值，那么推断为 Long 类型</li>
<li>如需显式指定 Long 型值，请在该值后追加 L 后缀</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">one</span> = 1 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Int</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">threeBillion</span> = 3000000000 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Long</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">oneLong</span> = 1L <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Long</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">oneByte</span>: <span style="color: #98f5ff;">Byte</span> = 1
</pre>
</div>

<p>
对于浮点数，Kotlin 提供了 <span class="underline">Float</span> 与 <span class="underline">Double</span> 类型
</p>

<pre class="example">
    根据 IEEE 754 标准， 两种浮点类型的十进制位数（即可以存储多少位十进制数）不同。 Float 反映了 IEEE 754 单精度，而 Double 提供了双精度
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> kotlin 浮点数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">类型</td>
<td class="org-right">大小（比特数）</td>
<td class="org-right">有效数字比特数</td>
<td class="org-right">指数比特数</td>
<td class="org-right">十进制位数</td>
</tr>

<tr>
<td class="org-left">Float</td>
<td class="org-right">32</td>
<td class="org-right">24</td>
<td class="org-right">8</td>
<td class="org-right">6-7</td>
</tr>

<tr>
<td class="org-left">Double</td>
<td class="org-right">64</td>
<td class="org-right">53</td>
<td class="org-right">11</td>
<td class="org-right">15-16</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>对于以小数初始化的变量，编译器会推断为 Double 类型</li>
<li>如需将一个值显式指定为 Float 类型，请添加 f 或 F 后缀
<ul class="org-ul">
<li>如果这样的值包含多于 6～7 位十进制数，那么会将其舍入</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">pi</span> = 3.14 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Double</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">e</span> = 2.7182818284 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Double</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">eFloat</span> = 2.7182818284f <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Float&#65292;&#23454;&#38469;&#20540;&#20026; 2.7182817</span>
</pre>
</div>

<p>
请注意，与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换
</p>

<pre class="example">
    例如，具有 Double 参数的函数只能对 Double 值调用，而不能对 Float、 Int 或者其他数字值调用
</pre>

<div class="org-src-container">
<pre class="src src-kotlin">
<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">printDouble</span>(d: <span style="color: #98f5ff;">Double</span>) { print(d) }

    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">i</span> = 1    
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">d</span> = 1.1
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">f</span> = 1.1f 

    printDouble(d)
<span style="color: #5f9ea0; font-style: italic;">//    </span><span style="color: #5f9ea0; font-style: italic;">printDouble(i) // &#38169;&#35823;&#65306;&#31867;&#22411;&#19981;&#21305;&#37197;</span>
<span style="color: #5f9ea0; font-style: italic;">//    </span><span style="color: #5f9ea0; font-style: italic;">printDouble(f) // &#38169;&#35823;&#65306;&#31867;&#22411;&#19981;&#21305;&#37197;</span>
}
</pre>
</div>
</div>
<div id="outline-container-org15fb0c1" class="outline-3">
<h3 id="org15fb0c1">字面常量</h3>
<div class="outline-text-3" id="text-org15fb0c1">
<p>
数值常量字面值有以下几种:
</p>
<ul class="org-ul">
<li>十进制: 123</li>
<li>Long 类型用大写 L 标记: 123L</li>
<li>十六进制: 0x0F</li>
<li>二进制: 0b00001011</li>
</ul>

<pre class="example">
     注意: 不支持八进制
</pre>

<p>
Kotlin 同样支持浮点数的常规表示方法:
</p>
<ul class="org-ul">
<li>默认 double：123.5、123.5e10</li>
<li>Float 用 f 或者 F 标记: 123.5f</li>
</ul>
</div>

<div id="outline-container-org91893d0" class="outline-4">
<h4 id="org91893d0">数字字面值中的下划线</h4>
<div class="outline-text-4" id="text-org91893d0">
<p>
可以使用下划线使数字常量更易读：
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">oneMillion</span> = 1_000_000
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">creditCardNumber</span> = 1234_5678_9012_3456L
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">socialSecurityNumber</span> = 999_99_9999L
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">hexBytes</span> = 0xFF_<span style="color: #98f5ff;">EC</span>_<span style="color: #98f5ff;">DE</span>_5E
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">bytes</span> = 0b11010010_01101001_10010100_10010010
</pre>
</div>
</div>
</div>

<div id="outline-container-org855abec" class="outline-4">
<h4 id="org855abec">表示方式</h4>
<div class="outline-text-4" id="text-org855abec">
<pre class="example">
      在 Java 平台数字是物理存储为 JVM 的原生类型，除非需要一个可空的引用（如 Int?）或泛型
</pre>

<p>
后者情况下会把数字装箱。注意数字装箱 <b>不一定保留同一性</b> :
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">a</span>: <span style="color: #98f5ff;">Int</span> = 10000
    println(a === a) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20986;&#8220;true&#8221;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">boxedA</span>: <span style="color: #98f5ff;">Int?</span> = a
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">anotherBoxedA</span>: <span style="color: #98f5ff;">Int?</span> = a
    println(boxedA === anotherBoxedA) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#65281;&#65281;&#65281;&#36755;&#20986;&#8220;false&#8221;&#65281;&#65281;&#65281;</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
另一方面，它 <b>保留了相等性</b> : 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">a</span>: <span style="color: #98f5ff;">Int</span> = 10000
    println(a == a) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20986;&#8220;true&#8221;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">boxedA</span>: <span style="color: #98f5ff;">Int?</span> = a
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">anotherBoxedA</span>: <span style="color: #98f5ff;">Int?</span> = a
    println(boxedA == anotherBoxedA) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20986;&#8220;true&#8221;</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf205c2b" class="outline-3">
<h3 id="orgf205c2b">显式转换</h3>
<div class="outline-text-3" id="text-orgf205c2b">
<p>
由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#24819;&#30340;&#20195;&#30721;&#65292;&#23454;&#38469;&#19978;&#24182;&#19981;&#33021;&#32534;&#35793;&#65306;</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">a</span>: <span style="color: #98f5ff;">Int?</span> = 1 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19968;&#20010;&#35013;&#31665;&#30340; Int (java.lang.Integer)</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span>: <span style="color: #98f5ff;">Long?</span> = a <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38544;&#24335;&#36716;&#25442;&#20135;&#29983;&#19968;&#20010;&#35013;&#31665;&#30340; Long (java.lang.Long)</span>
print(b == a) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24778;&#65281;&#36825;&#23558;&#36755;&#20986;&#8220;false&#8221;&#37492;&#20110; Long &#30340; equals() &#20250;&#26816;&#27979;&#21478;&#19968;&#20010;&#26159;&#21542;&#20063;&#20026; Long</span>
</pre>
</div>

<pre class="example">
   所以相等性会在所有地方悄无声息地失去，更别说同一性了
</pre>

<p>
因此较小的类型不能隐式转换为较大的类型。这意味着在不进行显式转换的情况下不能把 Byte 型值赋给一个 Int 变量
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span>: <span style="color: #98f5ff;">Byte</span> = 1 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">OK, &#23383;&#38754;&#20540;&#26159;&#38745;&#24577;&#26816;&#27979;&#30340;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">i</span>: <span style="color: #98f5ff;">Int</span> = b <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38169;&#35823;</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
可以 <span class="underline">显式转换</span> 来拓宽数字
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span>: <span style="color: #98f5ff;">Byte</span> = 1
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">i</span>: <span style="color: #98f5ff;">Int</span> = b.toInt() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">OK&#65306;&#26174;&#24335;&#25299;&#23485;</span>
    print(i)
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
每个数字类型支持如下的转换:
</p>
<ul class="org-ul">
<li>toByte(): Byte</li>
<li>toShort(): Short</li>
<li>toInt(): Int</li>
<li>toLong(): Long</li>
<li>toFloat(): Float</li>
<li>toDouble(): Double</li>
<li>toChar(): Char</li>
</ul>

<p>
缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">l</span> = 1L + 3 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Long + Int =&gt; Long</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga368e72" class="outline-3">
<h3 id="orga368e72">运算</h3>
<div class="outline-text-3" id="text-orga368e72">
<p>
Kotlin支持数字运算的标准集（+ - * / %），运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）
</p>
</div>

<div id="outline-container-org0b43d9a" class="outline-4">
<h4 id="org0b43d9a">整数除法</h4>
<div class="outline-text-4" id="text-org0b43d9a">
<p>
请注意，整数间的除法总是返回整数。会丢弃任何小数部分。例如：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span> = 5 / 2
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'</span>
    println(x == 2)
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
对于任何两个整数类型之间的除法来说都是如此：
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span> = 5L / 2
    println(x == 2L)
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
如需返回浮点类型，请将其中的一个参数显式转换为浮点类型：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span> = 5 / 2.toDouble()
    println(x == 2.5)
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3acfe76" class="outline-4">
<h4 id="org3acfe76">位运算</h4>
<div class="outline-text-4" id="text-org3acfe76">
<p>
对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span> = (1 shl 2) and 0x000FF000
</pre>
</div>
<p>
这是完整的位运算列表（只用于 Int 与 Long）：
</p>
<ul class="org-ul">
<li>shl(bits): 有符号左移</li>
<li>shr(bits): 有符号右移</li>
<li>ushr(bits): 无符号右移</li>
<li>and(bits): 位与</li>
<li>or(bits): 位或</li>
<li>xor(bits): 位异或</li>
<li>inv(): 位非</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb43345e" class="outline-3">
<h3 id="orgb43345e">浮点数比较</h3>
<div class="outline-text-3" id="text-orgb43345e">
<p>
浮点数操作如下：
</p>
<ul class="org-ul">
<li>相等性检测： <span class="underline">a == b</span> 与 <span class="underline">a != b</span></li>
<li>比较操作符： <span class="underline">a &lt; b</span> 、  <span class="underline">a &gt; b</span> 、 <span class="underline">a &lt;= b</span> 、 <span class="underline">a &gt;= b</span></li>
<li>区间实例以及区间检测： <span class="underline">a..b</span> 、 <span class="underline">x in a..b</span> 、  <span class="underline">x !in a..b</span></li>
</ul>

<pre class="example">
     当其中的操作数 a 与 b 都是静态已知的 Float 或 Double 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准
</pre>

<p>
然而，为了支持泛型场景并提供全序支持，当这些操作数并非静态类型为浮点数（例如是 <span class="underline">Any</span> 、 <span class="underline">Comparable&lt;……&gt;</span> 、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现：
</p>
<ul class="org-ul">
<li>认为 NaN 与其自身相等</li>
<li>认为 NaN 比包括正无穷大 <span class="underline">POSITIVE<sub>INFINITY</sub></span> 在内的任何其他元素都大</li>
<li>认为 <span class="underline">-0.0</span> 小于 <span class="underline">0.0</span></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfc5377a" class="outline-2">
<h2 id="orgfc5377a">字符</h2>
<div class="outline-text-2" id="text-orgfc5377a">
<p>
字符用 <span class="underline">Char</span> 类型表示。它们不能直接当作数字
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">check</span>(c: <span style="color: #98f5ff;">Char</span>) {
    <span style="color: #00bfff; font-weight: bold;">if</span> (c == 1) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38169;&#35823;&#65306;&#31867;&#22411;&#19981;&#20860;&#23481;</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#8230;&#8230;</span>
    }
}
</pre>
</div>

<p>
字符字面值用单引号括起来: '1'
</p>
<pre class="example">
    特殊字符可以用反斜杠转义：

    支持这几个转义序列：\t、 \b、\n、\r、\'、\"、\\ 与 \$

    编码其他字符要用 Unicode 转义序列语法：'\uFF00'
</pre>

<p>
可以显式把字符转换为 Int 数字：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">decimalDigitValue</span>(c: <span style="color: #98f5ff;">Char</span>): <span style="color: #98f5ff;">Int</span> {
    <span style="color: #00bfff; font-weight: bold;">if</span> (c !<span style="color: #00bfff; font-weight: bold;">in</span> <span style="color: #deb887;">'0'</span>..<span style="color: #deb887;">'9'</span>)
        <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">IllegalArgumentException</span>(<span style="color: #deb887;">"Out of range"</span>)
    <span style="color: #00bfff; font-weight: bold;">return</span> c.toInt() - <span style="color: #deb887;">'0'</span>.toInt() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26174;&#24335;&#36716;&#25442;&#20026;&#25968;&#23383;</span>
}
</pre>
</div>
<p>
当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性
</p>
</div>
</div>

<div id="outline-container-org9c1c460" class="outline-2">
<h2 id="org9c1c460">布尔</h2>
<div class="outline-text-2" id="text-org9c1c460">
<p>
布尔用 <span class="underline">Boolean</span> 类型表示：
</p>
<ul class="org-ul">
<li>它有两个值： <span class="underline">true</span> 与 <span class="underline">false</span></li>
<li>若需要可空引用布尔会被装箱</li>
<li>内置的布尔运算有：
<ul class="org-ul">
<li>|| : 逻辑或</li>
<li>&amp;&amp; : 逻辑与</li>
<li>! : 逻辑非</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge64a18b" class="outline-2">
<h2 id="orge64a18b">数组</h2>
<div class="outline-text-2" id="text-orge64a18b">
<p>
数组在 Kotlin 中使用 <span class="underline">Array</span> 类来表示，它定义了 <span class="underline">get</span> 与 <span class="underline">set</span> 函数（按照运算符重载约定这会转变为 []）以及 <span class="underline">size</span> 属性，以及一些其他有用的成员函数：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Array&lt;T&gt;</span> <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">constructor</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">Int</span>
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">get</span>(index: <span style="color: #98f5ff;">Int</span>): <span style="color: #98f5ff;">T</span>
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">set</span>(index: <span style="color: #98f5ff;">Int</span>, value: <span style="color: #98f5ff;">T</span>): <span style="color: #98f5ff;">Unit</span>

    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">iterator</span>(): <span style="color: #98f5ff;">Iterator&lt;T&gt;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#8230;&#8230;</span>
}
</pre>
</div>

<ul class="org-ul">
<li><p>
可以使用库函数 <span class="underline">arrayOf()</span> 来创建一个数组并传递元素值给它
</p>
<pre class="example">
arrayOf(1, 2, 3) 创建了 array [1, 2, 3]
</pre></li>
<li>库函数 <span class="underline">arrayOfNulls()</span> 可以用于创建一个指定大小的、所有元素都为空的数组</li>
<li><p>
也可以用接受数组大小以及一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值：
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#19968;&#20010; Array&lt;String&gt; &#21021;&#22987;&#21270;&#20026; ["0", "1", "4", "9", "16"]</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">asc</span> = <span style="color: #98f5ff;">Array</span>(5) { i -&gt; (i * i).toString() }
    asc.forEach { println(<span style="color: #00bfff; font-weight: bold;">it</span>) }
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div></li>
</ul>

<p>
Kotlin 中数组是 <b>不变的</b> （invariant）
</p>

<pre class="example">
    这意味着 Kotlin 不能把 Array&lt;String&gt; 赋值给 Array&lt;Any&gt;，以防止可能的运行时失败

    （但是可以使用 Array&lt;out Any&gt;）
</pre>
</div>

<div id="outline-container-org7ef6932" class="outline-3">
<h3 id="org7ef6932">原生类型数组</h3>
<div class="outline-text-3" id="text-org7ef6932">
<p>
Kotlin 也有无装箱开销的专门的类来表示原生类型数组: <span class="underline">ByteArray</span> 、 <span class="underline">ShortArray</span> 、 <span class="underline">IntArray</span> 等等。它们也都有相应的工厂方法:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">IntArray</span> = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
</pre>
</div>

<pre class="example">
     注意：这些类与 Array 并没有继承关系，但是它们有同样的方法属性集
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22823;&#23567;&#20026; 5&#12289;&#20540;&#20026; [0, 0, 0, 0, 0] &#30340;&#25972;&#22411;&#25968;&#32452;</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">arr</span> = <span style="color: #98f5ff;">IntArray</span>(5)

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20363;&#22914;&#65306;&#29992;&#24120;&#37327;&#21021;&#22987;&#21270;&#25968;&#32452;&#20013;&#30340;&#20540;</span>
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22823;&#23567;&#20026; 5&#12289;&#20540;&#20026; [42, 42, 42, 42, 42] &#30340;&#25972;&#22411;&#25968;&#32452;</span>
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">arr</span> = <span style="color: #98f5ff;">IntArray</span>(5) { 42 }

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20363;&#22914;&#65306;&#20351;&#29992; lambda &#34920;&#36798;&#24335;&#21021;&#22987;&#21270;&#25968;&#32452;&#20013;&#30340;&#20540;</span>
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22823;&#23567;&#20026; 5&#12289;&#20540;&#20026; [0, 1, 2, 3, 4] &#30340;&#25972;&#22411;&#25968;&#32452;&#65288;&#20540;&#21021;&#22987;&#21270;&#20026;&#20854;&#32034;&#24341;&#20540;&#65289;</span>
<span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">arr</span> = <span style="color: #98f5ff;">IntArray</span>(5) { <span style="color: #00bfff; font-weight: bold;">it</span> * 1 }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8610644" class="outline-2">
<h2 id="org8610644">字符串</h2>
<div class="outline-text-2" id="text-org8610644">
<p>
字符串用 <span class="underline">String</span> 类型表示：
</p>
<ul class="org-ul">
<li>字符串是 <b>不可变</b> 的</li>
<li>字符串的 <span class="underline">元素</span> (字符)可以使用 <span class="underline">索引</span> 运算符访问: <span class="underline">s[i]</span></li>
<li>可以用 <span class="underline">for</span> 循环迭代字符串:</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">str</span> = <span style="color: #deb887;">"abcd"</span>
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">for</span> (c <span style="color: #00bfff; font-weight: bold;">in</span> str) {
        println(c)
    }
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
可以用 <span class="underline">+</span> 操作符连接字符串。这也适用于连接字符串与其他类型的值， 只要表达式中的 <b>第一个元素是字符串</b> ： 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">s</span> = <span style="color: #deb887;">"abc"</span> + 1
    println(s + <span style="color: #deb887;">"def"</span>)
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<pre class="example">
    请注意，在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接
</pre>
</div>

<div id="outline-container-orgef8a91e" class="outline-3">
<h3 id="orgef8a91e">字符串字面值</h3>
<div class="outline-text-3" id="text-orgef8a91e">
<p>
Kotlin 有两种类型的字符串字面值: 
</p>
<ol class="org-ol">
<li><p>
转义字符串可以有转义字符
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">s</span> = <span style="color: #deb887;">"Hello, world!\n"</span>
</pre>
</div></li>
<li><p>
原始字符串可以包含换行以及任意文本：原始字符串 使用三个引号 <span class="underline">"""</span> 分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">text</span> = <span style="color: #deb887;">"""</span>
<span style="color: #deb887;">    for (c in "foo")</span>
<span style="color: #deb887;">        print(c)</span>
<span style="color: #deb887;">"""</span>
</pre>
</div></li>
</ol>



<p>
可以通过 <span class="underline">trimMargin()</span> 函数去除前导空格：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">text</span> = <span style="color: #deb887;">"""</span>
<span style="color: #deb887;">    |Tell me and I forget.</span>
<span style="color: #deb887;">    |Teach me and I remember.</span>
<span style="color: #deb887;">    |Involve me and I learn.</span>
<span style="color: #deb887;">    |(Benjamin Franklin)</span>
<span style="color: #deb887;">    """</span>.trimMargin()
</pre>
</div>

<p>
默认 <span class="underline">|</span> 用作边界前缀
</p>

<pre class="example">
     但可以选择其他字符并作为参数传入，比如 trimMargin("&gt;")
</pre>
</div>
</div>

<div id="outline-container-orgd18f514" class="outline-3">
<h3 id="orgd18f514">字符串模板</h3>
<div class="outline-text-3" id="text-orgd18f514">
<p>
字符串字面值可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符 <span class="underline">$</span> 开头，由一个简单的名字构成: 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">i</span> = 10
    println(<span style="color: #deb887;">"i = </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20986;&#8220;i = 10&#8221;</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
或者用 <span class="underline">花括号</span> 括起来的任意表达式:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">s</span> = <span style="color: #deb887;">"abc"</span>
    println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$s</span><span style="color: #deb887;">.length is ${</span>s.length<span style="color: #deb887;">}"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20986;&#8220;abc.length is 3&#8221;</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
原始字符串与转义字符串内部都支持模板。 如果需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），可以用下列语法：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">price</span> = <span style="color: #deb887;">"""</span>
<span style="color: #deb887;">${'$'}9.99</span>
<span style="color: #deb887;">"""</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8c53375" class="outline-2">
<h2 id="org8c53375">非符号整数</h2>
<div class="outline-text-2" id="text-org8c53375">
<pre class="example">
    还处于实验性，略去
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="package.html">Next：包</a></td>
<td class="org-left"><a href="basic.html">Home：基础</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
