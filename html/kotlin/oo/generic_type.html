<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>范型</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./sealed_class.html"> UP </a>
 |
 <a accesskey="H" href="./oo.html"> HOME </a>
</div><div id="content">
<h1 class="title">范型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org55a6b54">型变</a>
<ul>
<li><a href="#org2c3bc77">声明处型变</a></li>
<li><a href="#org5073237">类型投影</a>
<ul>
<li><a href="#org024a75e">使用处型变：类型投影</a></li>
<li><a href="#org8e9ae4c">星投影</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org952c2be">泛型函数</a></li>
<li><a href="#org798055f">泛型约束</a>
<ul>
<li><a href="#org0d5a312">上界</a></li>
</ul>
</li>
<li><a href="#org761afe1">类型擦除</a></li>
</ul>
</div>
</div>
<p>
与 Java 类似，Kotlin 中的类也可以有类型参数：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Box&lt;T&gt;</span>(t: <span style="color: #98f5ff;">T</span>) {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">value</span> = t
}
</pre>
</div>

<p>
一般来说，要创建这样类的实例，需要提供类型参数：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">box</span>: <span style="color: #98f5ff;">Box&lt;Int&gt;</span> = <span style="color: #98f5ff;">Box&lt;Int&gt;</span>(1)
</pre>
</div>

<p>
但是如果类型参数可以推断出来，允许省略类型参数：
</p>

<pre class="example">
  例如：从构造函数的参数或者从其他途径
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">box</span> = <span style="color: #98f5ff;">Box</span>(1) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">1 &#20855;&#26377;&#31867;&#22411; Int&#65292;&#25152;&#20197;&#32534;&#35793;&#22120;&#30693;&#36947;&#25105;&#20204;&#35828;&#30340;&#26159; Box&lt;Int&gt;</span>
</pre>
</div>
<div id="outline-container-org55a6b54" class="outline-2">
<h2 id="org55a6b54">型变</h2>
<div class="outline-text-2" id="text-org55a6b54">
<pre class="example">
Java 类型系统中最棘手的部分之一是通配符类型。 而 Kotlin 中没有
</pre>

<p>
相反，它有两个其他的东西： <span class="underline">声明处型变</span> (declaration-site variance)与 <span class="underline">类型投影</span> (type projections)
</p>

<pre class="example">
    首先，思考为什么 Java 需要那些神秘的通配符。答案是：利用有限制通配符来提升 API 的灵活性

    首先，Java 中的泛型是不型变的，这意味着 List&lt;String&gt; 并不是 List&lt;Object&gt; 的子类型
</pre>

<p>
如果 List 不是不型变的，它就没比 Java 的数组好到哪去，因为如下代码会通过编译然后导致运行时异常：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Java</span>
<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">strs</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ArrayList</span>&lt;<span style="color: #98f5ff;">String</span>&gt;();
<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">objs</span> = strs; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#65281;&#65281;&#65281;&#21363;&#23558;&#26469;&#20020;&#30340;&#38382;&#39064;&#30340;&#21407;&#22240;&#23601;&#22312;&#36825;&#37324;&#12290;Java &#31105;&#27490;&#36825;&#26679;&#65281;</span>
objs.add(1); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#25105;&#20204;&#25226;&#19968;&#20010;&#25972;&#25968;&#25918;&#20837;&#19968;&#20010;&#23383;&#31526;&#20018;&#21015;&#34920;</span>
<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s</span> = strs.get(0); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#65281;&#65281;&#65281; ClassCastException&#65306;&#26080;&#27861;&#23558;&#25972;&#25968;&#36716;&#25442;&#20026;&#23383;&#31526;&#20018;</span>
</pre>
</div>

<pre class="example">
    因此，Java 禁止这样的事情以保证运行时的安全
</pre>
<p>
但这样会有一些影响，例如，考虑 Collection 接口中的 addAll() 方法。该方法的签名应该是什么？直觉上会这样：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">E</span>&gt; &#8230;&#8230; {
  <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">addAll</span>(<span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">E</span>&gt; <span style="color: #4eee94;">items</span>);
}
</pre>
</div>

<p>
但随后，就无法做到以下简单的事情（这是完全安全）：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">copyAll</span>(<span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">to</span>, <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">from</span>) {
  to.addAll(from);
  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#65281;&#65281;&#65281;&#23545;&#20110;&#36825;&#31181;&#31616;&#21333;&#22768;&#26126;&#30340; addAll &#23558;&#19981;&#33021;&#32534;&#35793;&#65306;</span>
  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Collection&lt;String&gt; &#19981;&#26159; Collection&lt;Object&gt; &#30340;&#23376;&#31867;&#22411;</span>
}
</pre>
</div>

<pre class="example">
    在 Java 中，艰难地学到了这个教训
</pre>

<p>
这就是为什么 addAll() 的实际签名是以下这样：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">E</span>&gt; &#8230;&#8230; {
  <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">addAll</span>(<span style="color: #98f5ff;">Collection</span>&lt;? <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">E</span>&gt; <span style="color: #4eee94;">items</span>);
}
</pre>
</div>

<p>
<b>通配符类型参数</b> <span class="underline">? extends E</span> 表示此方法接受 <span class="underline">E</span> 或者 <span class="underline">E</span> 的 一些 <b>子类型对象</b> 的集合，而不只是 <span class="underline">E</span> 自身
</p>

<pre class="example">
    这意味着可以安全地从其中（该集合中的元素是 E 的子类的实例）读取 E，但不能写入， 因为不知道什么对象符合那个未知的 E 的子类型

    反过来，该限制可以让Collection&lt;String&gt;表示为Collection&lt;? extends Object&gt;的子类型

    简而言之，带 extends 限定（上界）的通配符类型使得类型是协变的（covariant）
</pre>

<p>
理解为什么这个技巧能够工作的关键相当简单：
</p>
<ul class="org-ul">
<li>如果只能从集合中 <b>获取</b> 项目，那么使用 String 的集合， 并且从其中读取 Object 也没问题</li>
<li><p>
反过来，如果只能向集合中 <b>放入</b> 项目，就可以用 Object 集合并向其中放入 String
</p>
<pre class="example">
      在 Java 中有 List&lt;? super String&gt; 是 List&lt;Object&gt; 的一个超类
</pre></li>
</ul>


<p>
后者称为 <b>逆变性</b> <span class="underline">contravariance</span> ：
</p>


<pre class="example">
    对于 List &lt;? super String&gt; 只能调用接受 String 作为参数的方法 （例如，你可以调用 add(String) 或者 set(int, String)）


    当然如果调用函数返回 List&lt;T&gt; 中的 T，得到的并非一个 String 而是一个 Object
</pre>

<pre class="example">
Joshua Bloch 称那些你只能从中读取的对象为生产者，并称那些只能写入的对象为消费者

他建议：“为了灵活性最大化，在表示生产者或消费者的输入参数上使用通配符类型”，并提出了以下助记符：

PECS 代表生产者-Extens，消费者-Super（Producer-Extends, Consumer-Super）
</pre>

<p>
注意：如果使用一个生产者对象，如 List&lt;? extends Foo&gt;，在该对象上不允许调用 add() 或 set()。但这并不意味着该对象是不可变的
</p>

<pre class="example">
    例如，没有什么阻止调用 clear()从列表中删除所有项目，因为 clear() 根本无需任何参数

    通配符（或其他类型的型变）保证的唯一的事情是类型安全。不可变性完全是另一回事
</pre>
</div>
<div id="outline-container-org2c3bc77" class="outline-3">
<h3 id="org2c3bc77">声明处型变</h3>
<div class="outline-text-3" id="text-org2c3bc77">
<p>
假设有一个泛型接口 <span class="underline">Source&lt;T&gt;</span> ，该接口中不存在任何以 <span class="underline">T</span> 作为 <b>参数</b> 的方法，只是方法 <b>返回</b> <span class="underline">T</span> 类型值：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Java</span>
<span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Source</span>&lt;<span style="color: #98f5ff;">T</span>&gt; {
  <span style="color: #98f5ff;">T</span> <span style="color: #daa520; font-weight: bold;">nextT</span>();
}
</pre>
</div>

<pre class="example">
     那么，在 Source &lt;Object&gt; 类型的变量中存储 Source &lt;String&gt; 实例的引用是极为安全的：没有消费者-方法可以调用
</pre>

<p>
但是 Java 并不知道这一点，并且仍然禁止这样操作：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Java</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">demo</span>(<span style="color: #98f5ff;">Source</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">strs</span>) {
  <span style="color: #98f5ff;">Source</span>&lt;<span style="color: #98f5ff;">Object</span>&gt; <span style="color: #4eee94;">objects</span> = strs; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#65281;&#65281;&#65281;&#22312; Java &#20013;&#19981;&#20801;&#35768;</span>
  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#8230;&#8230;</span>
}
</pre>
</div>

<pre class="example">
     为了修正这一点，必须声明对象的类型为 Source&lt;? extends Object&gt;

     这是毫无意义的，因为可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。但编译器并不知道
</pre>

<p>
在 Kotlin 中，有一种方法向编译器解释这种情况。这称为 <b>声明处型变</b> ：我们 <b>标注</b> <span class="underline">Source</span> 的类型参数 <span class="underline">T</span> 来确保它仅从 Source&lt;T&gt; 成员中 <b>返回</b> （生产），并 <b>从不被消费</b> 。 为此提供 <span class="underline">out</span> 修饰符：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Source&lt;out</span> <span style="color: #98f5ff;">T&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">nextT</span>(): <span style="color: #98f5ff;">T</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">demo</span>(strs: <span style="color: #98f5ff;">Source&lt;String&gt;</span>) {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">objects</span>: <span style="color: #98f5ff;">Source&lt;Any&gt;</span> = strs <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#20010;&#27809;&#38382;&#39064;&#65292;&#22240;&#20026; T &#26159;&#19968;&#20010; out-&#21442;&#25968;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#8230;&#8230;</span>
}
</pre>
</div>

<p>
一般原则是：当一个 <span class="underline">类 C</span> 的 <span class="underline">类型参数 T</span> 被声明为 <b>out</b> 时，它就只能出现在 C 的成员的 <span class="underline">输出-位置</span> ，但回报是 C&lt;Base&gt; 可以安全地作为 C&lt;Derived&gt;的超类
</p>

<pre class="example">
     简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。 可以认为 C 是 T 的生产者，而不是 T 的消费者
</pre>

<p>
out修饰符称为 <span class="underline">型变注解</span> ，并且由于它在类型参数声明处提供，所以称之为声明处型变
</p>

<pre class="example">
     这与 Java 的使用处型变相反，其类型用途通配符使得类型协变
</pre>

<p>
另外除了 out，Kotlin 又补充了一个型变注释：<sub>in</sub>_ 。它使得一个类型参数逆变：只可以 <b>被消费</b> 而 <b>不可以被生产</b> 。逆变类型的一个很好的例子是 Comparable：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Comparable</span>&lt;<span style="color: #00bfff; font-weight: bold;">in</span> <span style="color: #98f5ff;">T&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">compareTo</span>(other: <span style="color: #98f5ff;">T</span>): <span style="color: #98f5ff;">Int</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">demo</span>(x: <span style="color: #98f5ff;">Comparable&lt;Number&gt;</span>) {
    x.compareTo(1.0) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">1.0 &#25317;&#26377;&#31867;&#22411; Double&#65292;&#23427;&#26159; Number &#30340;&#23376;&#31867;&#22411;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22240;&#27492;&#65292;&#25105;&#20204;&#21487;&#20197;&#23558; x &#36171;&#32473;&#31867;&#22411;&#20026; Comparable &lt;Double&gt; &#30340;&#21464;&#37327;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">y</span>: <span style="color: #98f5ff;">Comparable&lt;Double&gt;</span> = x <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">OK&#65281;</span>
}
</pre>
</div>

<pre class="example">
       我们相信 in 和 out 两词是自解释的（因为它们已经在 C# 中成功使用很长时间了）， 因此上面提到的助记符不是真正需要的，并且可以将其改写为更高的目标：

       存在性（The Existential） 转换：消费者 in, 生产者 out!
</pre>
</div>
</div>

<div id="outline-container-org5073237" class="outline-3">
<h3 id="org5073237">类型投影</h3>
<div class="outline-text-3" id="text-org5073237">
</div>
<div id="outline-container-org024a75e" class="outline-4">
<h4 id="org024a75e">使用处型变：类型投影</h4>
<div class="outline-text-4" id="text-org024a75e">
<pre class="example">
      将类型参数 T 声明为 out 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回 T
</pre>
<p>
一个很好的例子是 Array：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Array&lt;T&gt;</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">Int</span>) {
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">get</span>(index: <span style="color: #98f5ff;">Int</span>): <span style="color: #98f5ff;">T</span> { &#8230;&#8230; }
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">set</span>(index: <span style="color: #98f5ff;">Int</span>, value: <span style="color: #98f5ff;">T</span>) { &#8230;&#8230; }
}
</pre>
</div>

<p>
该类在 T 上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">copy</span>(from: <span style="color: #98f5ff;">Array&lt;Any&gt;</span>, to: <span style="color: #98f5ff;">Array&lt;Any&gt;</span>) {
    assert(from.size == to.size)
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> from.indices)
        to[i] = from[i]
}
</pre>
</div>

<p>
这个函数应该将项目从一个数组复制到另一个数组。尝试在实践中应用它：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">ints</span>: <span style="color: #98f5ff;">Array&lt;Int&gt;</span> = arrayOf(1, 2, 3)
<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">any</span> = <span style="color: #98f5ff;">Array&lt;Any&gt;</span>(3) { <span style="color: #deb887;">""</span> } 
copy(ints, any)
<span style="color: #5f9ea0; font-style: italic;">//   </span><span style="color: #5f9ea0; font-style: italic;">^ &#20854;&#31867;&#22411;&#20026; Array&lt;Int&gt; &#20294;&#27492;&#22788;&#26399;&#26395; Array&lt;Any&gt;</span>
</pre>
</div>

<pre class="example">
      这里遇到同样熟悉的问题：Array &lt;T&gt; 在 T 上是不型变的，因此 Array &lt;Int&gt; 和 Array &lt;Any&gt; 都不是另一个的子类型。为什么？

      再次重复，因为 copy 可能做坏事，也就是说，例如它可能尝试写一个 String 到 from， 并且如果实际上传递一个 Int 的数组，一段时间后将会抛出一个 ClassCastException 异常
</pre>


<p>
那么，唯一要确保的是 copy() 不会做任何坏事。如果想阻止它写到 from，可以：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">copy</span>(from: <span style="color: #98f5ff;">Array&lt;out</span> <span style="color: #98f5ff;">Any&gt;</span>, to: <span style="color: #98f5ff;">Array&lt;Any&gt;</span>) { &#8230;&#8230; }
</pre>
</div>

<p>
这里发生的事情称为 <span class="underline">类型投影</span> ：from不仅仅是一个数组，而是一个受 *限制的( （投影的）数组，只可以调用返回类型为类型参数 T 的方法
</p>

<pre class="example">
      如上，这意味着只能调用 get()，这就是我们的使用处型变的用法，并且是对应于 Java 的 Array&lt;? extends Object&gt;、 但使用更简单些的方式
</pre>

<p>
也可以使用 in 投影一个类型：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">fill</span>(dest: Array&lt;<span style="color: #00bfff; font-weight: bold;">in</span> <span style="color: #98f5ff;">String&gt;</span>, value: <span style="color: #98f5ff;">String</span>) { &#8230;&#8230; }
</pre>
</div>

<pre class="example">
Array&lt;in String&gt; 对应于 Java 的 Array&lt;? super String&gt;

也就是说，可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数
</pre>
</div>
</div>

<div id="outline-container-org8e9ae4c" class="outline-4">
<h4 id="org8e9ae4c">星投影</h4>
<div class="outline-text-4" id="text-org8e9ae4c">
<pre class="example">
      有时你对类型参数一无所知，但仍然希望以安全的方式使用它

      这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型
</pre>
<p>
Kotlin 为此提供了所谓的 <b>星投影</b> 语法：
</p>
<ul class="org-ul">
<li><p>
对于 <span class="underline">Foo &lt;out T : TUpper&gt;</span> ，其中 T 是一个具有上界 <span class="underline">TUpper</span> 的 <span class="underline">协变类型</span> 参数 。 <span class="underline">Foo &lt;*&gt;</span>  等价于 <span class="underline">Foo &lt;out TUpper&gt;</span> 
</p>
<pre class="example">
	这意味着当 T 未知时，你可以安全地从 Foo &lt;*&gt; 读取 TUpper 的值
</pre></li>
<li><p>
对于 Foo <span class="underline">&lt;in T&gt;</span> ，其中 <span class="underline">T</span> 是一个 <span class="underline">逆变类型</span> 参数， <span class="underline">Foo &lt;*&gt;</span> 等价于 <span class="underline">Foo &lt;in Nothing&gt;</span>
</p>
<pre class="example">
	这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo &lt;*&gt;
</pre></li>
<li>对于 <span class="underline">Foo &lt;T : TUpper&gt;</span> ，其中 T 是一个具有上界 TUpper 的 <span class="underline">不型变类型</span> 参数，Foo&lt;*&gt; ：
<ul class="org-ul">
<li><span class="underline">读</span> 值时等价于 <span class="underline">Foo&lt;out TUpper&gt;</span></li>
<li><span class="underline">写</span> 值时等价于 <span class="underline">Foo&lt;in Nothing&gt;</span></li>
</ul></li>
<li>如果泛型类型具有多个类型参数，则 <span class="underline">每个类型</span> 参数都可以 <b>单独</b> 投影。 例如，如果类型被声明为 <span class="underline">interface Function &lt;in T, out U&gt;</span> ，可以想象以下星投影：
<ul class="org-ul">
<li>Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;</li>
</ul></li>
</ul>

<pre class="example">
      注意：星投影非常像 Java 的原始类型，但是安全
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org952c2be" class="outline-2">
<h2 id="org952c2be">泛型函数</h2>
<div class="outline-text-2" id="text-org952c2be">
<pre class="example">
    不仅类可以有类型参数。函数也可以有
</pre>

<p>
<span class="underline">类型参数</span> 要放在 <span class="underline">函数名称</span> 之前： 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> &lt;<span style="color: #98f5ff;">T&gt;</span> singletonList(item: <span style="color: #98f5ff;">T</span>): <span style="color: #98f5ff;">List&lt;T&gt;</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#8230;&#8230;</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> &lt;<span style="color: #98f5ff;">T&gt;</span> <span style="color: #98f5ff;">T.basicToString</span>(): <span style="color: #98f5ff;">String</span> {  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25193;&#23637;&#20989;&#25968;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#8230;&#8230;</span>
}
</pre>
</div>

<p>
要调用泛型函数，在调用处 <span class="underline">函数名</span> 之后 <b>指定</b> 类型参数即可：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">l</span> = singletonList&lt;<span style="color: #98f5ff;">Int&gt;</span>(1)
</pre>
</div>

<p>
如果可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">l</span> = singletonList(1)
</pre>
</div>
</div>
</div>

<div id="outline-container-org798055f" class="outline-2">
<h2 id="org798055f">泛型约束</h2>
<div class="outline-text-2" id="text-org798055f">
<p>
能够替换给定类型参数的所有可能类型的集合可以由 <span class="underline">泛型约束</span> 限制 
</p>
</div>

<div id="outline-container-org0d5a312" class="outline-3">
<h3 id="org0d5a312">上界</h3>
<div class="outline-text-3" id="text-org0d5a312">
<p>
最常见的约束类型是与 Java 的 <span class="underline">extends</span> 关键字对应的 <span class="underline">上界</span> ： 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> &lt;<span style="color: #98f5ff;">T</span> : <span style="color: #98f5ff;">Comparable&lt;T&gt;&gt;</span> sort(list: <span style="color: #98f5ff;">List&lt;T&gt;</span>) {  &#8230;&#8230; }
</pre>
</div>


<p>
冒号之后指定的类型是上界：只有 Comparable&lt;T&gt; 的子类型可以替代 T。 例如：
</p>

<div class="org-src-container">
<pre class="src src-kotlin">sort(listOf(1, 2, 3)) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">OK&#12290;Int &#26159; Comparable&lt;Int&gt; &#30340;&#23376;&#31867;&#22411;</span>
sort(listOf(<span style="color: #98f5ff;">HashMap&lt;Int</span>, <span style="color: #98f5ff;">String&gt;</span>())) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38169;&#35823;&#65306;HashMap&lt;Int, String&gt; &#19981;&#26159; Comparable&lt;HashMap&lt;Int, String&gt;&gt;</span>
</pre>
</div>

<ul class="org-ul">
<li>默认的上界（如果没有声明）是 <span class="underline">Any?</span></li>
<li>在尖括号中只能指定一个上界</li>
<li>如果同一类型参数需要多个上界，需要一个单独的 where-子句：</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> &lt;<span style="color: #98f5ff;">T&gt;</span> copyWhenGreater(list: <span style="color: #98f5ff;">List&lt;T&gt;</span>, threshold: <span style="color: #98f5ff;">T</span>): <span style="color: #98f5ff;">List&lt;String&gt;</span>
    <span style="color: #00bfff; font-weight: bold;">where</span> <span style="color: #98f5ff;">T</span> : <span style="color: #98f5ff;">CharSequence</span>,
          <span style="color: #98f5ff;">T</span> : <span style="color: #98f5ff;">Comparable&lt;T&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">return</span> list.filter { <span style="color: #00bfff; font-weight: bold;">it</span> &gt; threshold }.map { <span style="color: #00bfff; font-weight: bold;">it</span>.toString() }
}
</pre>
</div>


<p>
所传递的类型必须同时满足 where 子句的所有条件
</p>

<pre class="example">
     在上述示例中，类型 T 必须既实现了 CharSequence 也实现了 Comparable
</pre>
</div>
</div>
</div>


<div id="outline-container-org761afe1" class="outline-2">
<h2 id="org761afe1">类型擦除</h2>
<div class="outline-text-2" id="text-org761afe1">
<p>
Kotlin 为泛型声明用法执行的类型安全检测仅在 <span class="underline">编译期</span> 进行。 运行时泛型类型的实例不保留关于其类型实参的任何信息。其类型信息称为 <b>被擦除</b> 
</p>

<pre class="example">
    例如，Foo&lt;Bar&gt; 与 Foo&lt;Baz?&gt; 的实例都会被擦除为 Foo&lt;*&gt;
</pre>

<p>
因此，并没有通用的方法在运行时检测一个泛型类型的实例是否通过指定类型参数所创建 ，并且编译器禁止这种 is 检测。类型转换为带有具体类型参数的泛型类型，如 foo as List&lt;String&gt; 无法在运行时检测
</p>

<pre class="example">
    当高级程序逻辑隐含了类型转换的类型安全而无法直接通过编译器推断时， 可以使用这种非受检类型转换

    编译器会对非受检类型转换发出警告，并且在运行时只对非泛型部分检测（相当于 foo as List&lt;*&gt;）
</pre>

<p>
泛型函数调用的类型参数也同样只在编译期检测。在函数体内部， 类型参数不能用于类型检测，并且类型转换为类型参数（foo as T）也是非受检的
</p>

<pre class="example">
    然而， 内联函数的具体化的类型参数会由调用处内联函数体中的类型实参所代入，因此可以用于类型检测与转换， 与上述泛型类型的实例具有相同限制
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="inner_class.html">Next：嵌套类</a></td>
<td class="org-left"><a href="sealed_class.html">Previous：密封类</a></td>
<td class="org-left"><a href="oo.html">Home：面向对象</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
