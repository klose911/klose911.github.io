<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>委托</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./inline_class.html"> UP </a>
 |
 <a accesskey="H" href="./oo.html"> HOME </a>
</div><div id="content">
<h1 class="title">委托</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgfd88526">委托类</a>
<ul>
<li><a href="#org995e60d">覆盖由委托实现的接口成员</a></li>
</ul>
</li>
<li><a href="#orgfaf551f">委托属性</a>
<ul>
<li><a href="#orgb589739">标准委托</a>
<ul>
<li><a href="#orgd558cdc">延迟属性 Lazy</a></li>
<li><a href="#orgdda21ca">可观察属性 Observable</a></li>
<li><a href="#org0aff7c2">把属性储存在映射中</a></li>
<li><a href="#org4ed815d">局部委托属性（自 1.1 起）</a></li>
</ul>
</li>
<li><a href="#orge92dccd">属性委托要求</a></li>
<li><a href="#orgadac367">翻译规则</a></li>
<li><a href="#orgec20540">提供委托（自 1.1 起）</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgfd88526" class="outline-2">
<h2 id="orgfd88526">委托类</h2>
<div class="outline-text-2" id="text-orgfd88526">
<pre class="example">
    委托模式已经证明是实现继承的一个很好的替代方式， 而 Kotlin 可以零样板代码地原生支持它
</pre>
<p>
<span class="underline">Derived</span> 类可以通过将其所有公有成员都委托给指定对象来实现一个接口 Base：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Base</span> {
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">print</span>()
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">BaseImpl</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">Int</span>) : <span style="color: #98f5ff;">Base</span> {
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">print</span>() { print(x) }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Derived</span>(b: <span style="color: #98f5ff;">Base</span>) : <span style="color: #98f5ff;">Base</span> <span style="color: #00bfff; font-weight: bold;">by</span> b

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span> = <span style="color: #98f5ff;">BaseImpl</span>(10)
    <span style="color: #98f5ff;">Derived</span>(b).print()
}
</pre>
</div>

<p>
Derived 的超类型列表中的 <span class="underline">by 子句</span> 表示 <span class="underline">b</span> 将会在 <span class="underline">Derived</span> 中 <b>内部存储</b> ， 并且 <span class="underline">编译器</span> 将 <b>生成</b> <span class="underline">转发</span> 给 b 的所有 <span class="underline">Base</span> 的方法
</p>
</div>

<div id="outline-container-org995e60d" class="outline-3">
<h3 id="org995e60d">覆盖由委托实现的接口成员</h3>
<div class="outline-text-3" id="text-org995e60d">
<p>
覆盖符合预期：编译器会使用 override <b>覆盖的实现</b> 而不是 <span class="underline">委托对象</span> 中的
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Base</span> {
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">printMessage</span>()
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">printMessageLine</span>()
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">BaseImpl</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">Int</span>) : <span style="color: #98f5ff;">Base</span> {
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">printMessage</span>() { print(x) }
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">printMessageLine</span>() { println(x) }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Derived</span>(b: <span style="color: #98f5ff;">Base</span>) : <span style="color: #98f5ff;">Base</span> <span style="color: #00bfff; font-weight: bold;">by</span> b {
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">printMessage</span>() { print(<span style="color: #deb887;">"abc"</span>) }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span> = <span style="color: #98f5ff;">BaseImpl</span>(10)
    <span style="color: #98f5ff;">Derived</span>(b).printMessage()
    <span style="color: #98f5ff;">Derived</span>(b).printMessageLine()
}
</pre>
</div>

<pre class="example">
     如果将 override fun printMessage() { print("abc") } 添加到 Derived，那么当调用 printMessage 时程序会输出“abc”而不是“10”
</pre>

<p>
但请注意，以这种方式重写的成员不会在 <span class="underline">委托对象的成员</span> 中调用 ，委托对象的成员只能访问其 <b>自身对接口成员</b> 实现：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">Base</span> {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">message</span>: <span style="color: #98f5ff;">String</span>
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">print</span>()
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">BaseImpl</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">Int</span>) : <span style="color: #98f5ff;">Base</span> {
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">message</span> = <span style="color: #deb887;">"BaseImpl: x = </span><span style="color: #4eee94;">$x</span><span style="color: #deb887;">"</span>
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">print</span>() { println(message) }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Derived</span>(b: <span style="color: #98f5ff;">Base</span>) : <span style="color: #98f5ff;">Base</span> <span style="color: #00bfff; font-weight: bold;">by</span> b {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312; b &#30340; `print` &#23454;&#29616;&#20013;&#19981;&#20250;&#35775;&#38382;&#21040;&#36825;&#20010;&#23646;&#24615;</span>
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">message</span> = <span style="color: #deb887;">"Message of Derived"</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span> = <span style="color: #98f5ff;">BaseImpl</span>(10)
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">derived</span> = <span style="color: #98f5ff;">Derived</span>(b)
    derived.print()
    println(derived.message)
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfaf551f" class="outline-2">
<h2 id="orgfaf551f">委托属性</h2>
<div class="outline-text-2" id="text-orgfaf551f">
<p>
有一些常见的属性类型，虽然可以在每次需要的时候手动实现它们， 但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括：
</p>
<ul class="org-ul">
<li><span class="underline">延迟</span> 属性（lazy properties）: 其值只在首次访问时计算</li>
<li><span class="underline">可观察</span> 属性（observable properties）: 监听器会收到有关此属性变更的通知</li>
<li>把多个属性储存在一个 <span class="underline">映射</span> （map）中，而不是每个存在单独的字段中</li>
</ul>

<p>
为了涵盖这些（以及其他）情况，Kotlin 支持 <b>委托</b> 属性:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Example</span> {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">p</span>: <span style="color: #98f5ff;">String</span> <span style="color: #00bfff; font-weight: bold;">by</span> <span style="color: #98f5ff;">Delegate</span>()
}
</pre>
</div>

<pre class="example">
    语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;
</pre>

<p>
在 by 后面的表达式是该 <span class="underline">委托</span> ， 因为属性对应的 <span class="underline">get()</span> 与 <span class="underline">set()</span> 会被委托给它的 <span class="underline">getValue()</span> 与 <span class="underline">setValue()</span> 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（与 setValue() 对于 var 属性）。 例如:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlin.reflect.KProperty</span>

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Delegate</span> {
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">getValue</span>(thisRef: <span style="color: #98f5ff;">Any?</span>, property: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>): <span style="color: #98f5ff;">String</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #deb887;">"</span><span style="color: #4eee94;">$thisRef</span><span style="color: #deb887;">, thank you for delegating '${</span>property.name<span style="color: #deb887;">}' to me!"</span>
    }

    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">setValue</span>(thisRef: <span style="color: #98f5ff;">Any?</span>, property: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>, value: <span style="color: #98f5ff;">String</span>) {
        println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$value</span><span style="color: #deb887;"> has been assigned to '${</span>property.name<span style="color: #deb887;">}' in </span><span style="color: #4eee94;">$thisRef</span><span style="color: #deb887;">."</span>)
    }
}
</pre>
</div>

<p>
当从委托到一个 Delegate 实例的 p 读取时，将调用 Delegate 中的 <span class="underline">getValue()</span> 函数， 所以它第一个参数是读出 p 的对象、第二个参数保存了对 p 自身的描述 （例如你可以取它的名字)。 例如:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">e</span> = <span style="color: #98f5ff;">Example</span>()
println(e.p)
</pre>
</div>

<p>
输出结果：
</p>

<pre class="example">
Example@33a17727, thank you for delegating ‘p’ to me!
</pre>

<p>
类似地，给 p 赋值时，将调用 setValue() 函数。前两个参数相同，第三个参数保存将要被赋予的值：
</p>

<div class="org-src-container">
<pre class="src src-kotlin">e.p = <span style="color: #deb887;">"NEW"</span>
</pre>
</div>

<p>
输出结果：
</p>
<pre class="example">
NEW has been assigned to ‘p’ in Example@33a17727.
</pre>
</div>

<div id="outline-container-orgb589739" class="outline-3">
<h3 id="orgb589739">标准委托</h3>
<div class="outline-text-3" id="text-orgb589739">
<p>
Kotlin 标准库为几种有用的委托提供了工厂方法
</p>
</div>

<div id="outline-container-orgd558cdc" class="outline-4">
<h4 id="orgd558cdc">延迟属性 Lazy</h4>
<div class="outline-text-4" id="text-orgd558cdc">
<p>
<span class="underline">lazy()</span> 是接受一个 <span class="underline">lambda</span> 并返回一个 <span class="underline">Lazy &lt;T&gt;</span> 实例的函数，返回的实例可以作为实现延迟属性的委托： 
</p>
<ul class="org-ul">
<li>第一次调用 <span class="underline">get()</span> 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">lazyValue</span>: <span style="color: #98f5ff;">String</span> <span style="color: #00bfff; font-weight: bold;">by</span> lazy {
    println(<span style="color: #deb887;">"computed!"</span>)
    <span style="color: #deb887;">"Hello"</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    println(lazyValue)
    println(lazyValue)
}
</pre>
</div>

<p>
默认情况下，对于 lazy 属性的求值是 <b>同步锁</b> 的（synchronized），该值只在一个线程中计算，并且所有线程会看到相同的值：
</p>
<ul class="org-ul">
<li>如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 <span class="underline">LazyThreadSafetyMode.PUBLICATION</span> 作为参数传递给 lazy() 函数</li>
<li>而如果确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用 <span class="underline">LazyThreadSafetyMode.NONE</span> 模式：它不会有任何线程安全的保证以及相关的开销</li>
</ul>
</div>
</div>

<div id="outline-container-orgdda21ca" class="outline-4">
<h4 id="orgdda21ca">可观察属性 Observable</h4>
<div class="outline-text-4" id="text-orgdda21ca">
<p>
<span class="underline">Delegates.observable()</span> 接受两个参数： 
</p>
<ul class="org-ul">
<li><span class="underline">初始值</span></li>
<li><span class="underline">修改时处理程序</span> （handler）：每当给属性赋值时会调用该处理程序（在赋值后执行）
<ul class="org-ul">
<li>它有三个参数： <span class="underline">被赋值的属性</span> 、 <span class="underline">旧值</span> 与 <span class="underline">新值</span></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlin.properties.Delegates</span>

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">User</span> {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">name</span>: <span style="color: #98f5ff;">String</span> <span style="color: #00bfff; font-weight: bold;">by</span> <span style="color: #98f5ff;">Delegates.observable</span>(<span style="color: #deb887;">"&lt;no name&gt;"</span>) {
        prop, old, new -&gt;
            println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$old</span><span style="color: #deb887;"> -&gt; </span><span style="color: #4eee94;">$new</span><span style="color: #deb887;">"</span>)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">user</span> = <span style="color: #98f5ff;">User</span>()
    user.name = <span style="color: #deb887;">"first"</span>
    user.name = <span style="color: #deb887;">"second"</span>
}
</pre>
</div>
<p>
如果想截获赋值并“否决”它们，那么使用 <span class="underline">vetoable()</span> 取代 observable()。 在属性被赋新值生效之前会调用传递给 vetoable 的处理程序 
</p>
</div>
</div>

<div id="outline-container-org0aff7c2" class="outline-4">
<h4 id="org0aff7c2">把属性储存在映射中</h4>
<div class="outline-text-4" id="text-org0aff7c2">
<p>
一个常见的用例是在一个映射（map）里存储属性的值
</p>

<pre class="example">
      这经常出现在像解析 JSON 或者做其他“动态”事情的应用中
</pre>

<p>
在这种情况下，可以使用映射实例自身作为委托来实现委托属性
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">User</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">map</span>: <span style="color: #98f5ff;">Map&lt;String</span>, <span style="color: #98f5ff;">Any?&gt;</span>) {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">name</span>: <span style="color: #98f5ff;">String</span> <span style="color: #00bfff; font-weight: bold;">by</span> map
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">age</span>: <span style="color: #98f5ff;">Int</span>     <span style="color: #00bfff; font-weight: bold;">by</span> map
}
</pre>
</div>

<p>
在这个例子中，构造函数接受一个映射参数：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">user</span> = <span style="color: #98f5ff;">User</span>(mapOf(
    <span style="color: #deb887;">"name"</span> to <span style="color: #deb887;">"John Doe"</span>,
    <span style="color: #deb887;">"age"</span>  to 25
))
</pre>
</div>


<p>
委托属性会从这个映射中取值（通过字符串键 <span class="underline">属性的名称</span> ）： 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">User</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">map</span>: <span style="color: #98f5ff;">Map&lt;String</span>, <span style="color: #98f5ff;">Any?&gt;</span>) {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">name</span>: <span style="color: #98f5ff;">String</span> <span style="color: #00bfff; font-weight: bold;">by</span> map
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">age</span>: <span style="color: #98f5ff;">Int</span>     <span style="color: #00bfff; font-weight: bold;">by</span> map
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">user</span> = <span style="color: #98f5ff;">User</span>(mapOf(
        <span style="color: #deb887;">"name"</span> to <span style="color: #deb887;">"John Doe"</span>,
        <span style="color: #deb887;">"age"</span>  to 25
    ))
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    println(user.name) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Prints "John Doe"</span>
    println(user.age)  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Prints 25</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
}
</pre>
</div>

<p>
这也适用于 <span class="underline">var</span> 属性，如果把只读的 Map 换成 <span class="underline">MutableMap</span> 的话：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MutableUser</span>(<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">map</span>: <span style="color: #98f5ff;">MutableMap&lt;String</span>, <span style="color: #98f5ff;">Any?&gt;</span>) {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">name</span>: <span style="color: #98f5ff;">String</span> <span style="color: #00bfff; font-weight: bold;">by</span> map
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">age</span>: <span style="color: #98f5ff;">Int</span>     <span style="color: #00bfff; font-weight: bold;">by</span> map
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ed815d" class="outline-4">
<h4 id="org4ed815d">局部委托属性（自 1.1 起）</h4>
<div class="outline-text-4" id="text-org4ed815d">
<p>
以将局部变量声明为委托属性。 例如 可以使一个局部变量惰性初始化：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">example</span>(computeFoo: () -&gt; <span style="color: #98f5ff;">Foo</span>) {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">memoizedFoo</span> <span style="color: #00bfff; font-weight: bold;">by</span> lazy(computeFoo)

    <span style="color: #00bfff; font-weight: bold;">if</span> (someCondition &amp;&amp; memoizedFoo.isValid()) {
        memoizedFoo.doSomething()
    }
}
</pre>
</div>

<pre class="example">
memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算
</pre>
</div>
</div>
</div>

<div id="outline-container-orge92dccd" class="outline-3">
<h3 id="orge92dccd">属性委托要求</h3>
<div class="outline-text-3" id="text-orge92dccd">
<ul class="org-ul">
<li>对于一个只读属性（即 <span class="underline">val</span> 声明的），委托必须提供一个操作符函数 <span class="underline">getValue()</span> ，该函数具有以下参数：
<ul class="org-ul">
<li>thisRef: 必须与 属性所有者 类型（对于扩展属性 <span class="underline">指被扩展的类型</span> ）相同或者是其超类型</li>
<li>property: 必须是类型 KProperty&lt;*&gt; 或其超类型</li>
<li>getValue() 必须返回与属性相同的类型（或其子类型）。</li>
</ul></li>
<li>对于一个可变属性（即 <span class="underline">var</span> 声明的），委托必须额外提供一个操作符函数 <span class="underline">setValue()</span> ， 该函数具有以下参数：
<ul class="org-ul">
<li>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是其超类型</li>
<li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型</li>
<li>value &#x2014; 必须与属性类型相同（或者是其超类型）。</li>
</ul></li>
</ul>

<p>
getValue() 或/与 setValue() 函数可以通过 <span class="underline">委托类的成员函数</span> 提供或者由 <span class="underline">扩展函数</span> 提供
</p>
<ul class="org-ul">
<li>当需要委托属性到原本未提供的这些函数的对象时后者会更便利</li>
<li>两函数都需要用 <span class="underline">operator</span> 关键字来进行标记</li>
</ul>

<p>
委托类可以实现包含所需 operator 方法的 <span class="underline">ReadOnlyProperty</span> 或 <span class="underline">ReadWriteProperty</span> 接口之一。 这俩接口是在 Kotlin 标准库中声明的：
</p>


<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">ReadOnlyProperty</span>&lt;<span style="color: #00bfff; font-weight: bold;">in</span> <span style="color: #98f5ff;">R</span>, <span style="color: #00bfff; font-weight: bold;">out</span> <span style="color: #98f5ff;">T&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">getValue</span>(thisRef: <span style="color: #98f5ff;">R</span>, property: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>): <span style="color: #98f5ff;">T</span>
}

<span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">ReadWriteProperty</span>&lt;<span style="color: #00bfff; font-weight: bold;">in</span> <span style="color: #98f5ff;">R</span>, <span style="color: #98f5ff;">T&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">getValue</span>(thisRef: <span style="color: #98f5ff;">R</span>, property: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>): <span style="color: #98f5ff;">T</span>
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">setValue</span>(thisRef: <span style="color: #98f5ff;">R</span>, property: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>, value: <span style="color: #98f5ff;">T</span>)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgadac367" class="outline-3">
<h3 id="orgadac367">翻译规则</h3>
<div class="outline-text-3" id="text-orgadac367">
<p>
在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 <span class="underline">prop$delegate</span> ，而访问器的代码只是简单地委托给这个附加属性：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">C</span> {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">prop</span>: <span style="color: #98f5ff;">Type</span> <span style="color: #00bfff; font-weight: bold;">by</span> <span style="color: #98f5ff;">MyDelegate</span>()
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#27573;&#26159;&#30001;&#32534;&#35793;&#22120;&#29983;&#25104;&#30340;&#30456;&#24212;&#20195;&#30721;&#65306;</span>
<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">C</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">prop$delegate</span> = <span style="color: #98f5ff;">MyDelegate</span>()
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">prop</span>: <span style="color: #98f5ff;">Type</span>
        <span style="color: #00bfff; font-weight: bold;">get</span>() = prop$delegate.getValue(<span style="color: #00bfff; font-weight: bold;">this</span>, <span style="color: #00bfff; font-weight: bold;">this</span>::prop)
        <span style="color: #00bfff; font-weight: bold;">set</span>(value: <span style="color: #98f5ff;">Type</span>) = prop$delegate.setValue(<span style="color: #00bfff; font-weight: bold;">this</span>, <span style="color: #00bfff; font-weight: bold;">this</span>::prop, value)
}
</pre>
</div>

<p>
Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：
</p>
<ul class="org-ul">
<li>第一个参数 this 引用到类 C 的实例</li>
<li>this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身</li>
</ul>

<pre class="example">
     请注意，直接在代码中引用绑定的可调用引用的语法 this::prop 自 Kotlin 1.1 起才可用
</pre>
</div>
</div>

<div id="outline-container-orgec20540" class="outline-3">
<h3 id="orgec20540">提供委托（自 1.1 起）</h3>
<div class="outline-text-3" id="text-orgec20540">
<p>
通过定义 <span class="underline">provideDelegate</span> 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来创建属性委托实例
</p>

<pre class="example">
provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检测属性一致性
</pre>

<p>
例如，如果要在绑定之前检测属性名称，可以这样写：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ResourceDelegate&lt;T&gt;</span> : <span style="color: #98f5ff;">ReadOnlyProperty&lt;MyUI</span>, <span style="color: #98f5ff;">T&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">override</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">getValue</span>(thisRef: <span style="color: #98f5ff;">MyUI</span>, property: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>): <span style="color: #98f5ff;">T</span> { ... }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ResourceLoader&lt;T&gt;</span>(id: <span style="color: #98f5ff;">ResourceID&lt;T&gt;</span>) {
    <span style="color: #00bfff; font-weight: bold;">operator</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">provideDelegate</span>(
            thisRef: <span style="color: #98f5ff;">MyUI</span>,
            prop: <span style="color: #98f5ff;">KProperty&lt;*&gt;</span>
    ): <span style="color: #98f5ff;">ReadOnlyProperty&lt;MyUI</span>, <span style="color: #98f5ff;">T&gt;</span> {
        checkProperty(thisRef, prop.name)
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#22996;&#25176;</span>
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #98f5ff;">ResourceDelegate</span>()
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">checkProperty</span>(thisRef: <span style="color: #98f5ff;">MyUI</span>, name: <span style="color: #98f5ff;">String</span>) { &#8230;&#8230; }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyUI</span> {
    <span style="color: #00bfff; font-weight: bold;">fun</span> &lt;<span style="color: #98f5ff;">T&gt;</span> bindResource(id: <span style="color: #98f5ff;">ResourceID&lt;T&gt;</span>): <span style="color: #98f5ff;">ResourceLoader&lt;T&gt;</span> { &#8230;&#8230; }

    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">image</span> <span style="color: #00bfff; font-weight: bold;">by</span> bindResource(<span style="color: #98f5ff;">ResourceID.image</span>_id)
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">text</span> <span style="color: #00bfff; font-weight: bold;">by</span> bindResource(<span style="color: #98f5ff;">ResourceID.text</span>_id)
}
</pre>
</div>

<p>
provideDelegate 的参数与 getValue 相同：
</p>
<ul class="org-ul">
<li>thisRef: 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li>
<li>property: 必须是类型 KProperty&lt;*&gt; 或其超类型</li>
</ul>

<pre class="example">
     在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证
</pre>

<p>
如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 必须显式传递属性名，这不是很方便：
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26816;&#27979;&#23646;&#24615;&#21517;&#31216;&#32780;&#19981;&#20351;&#29992;&#8220;provideDelegate&#8221;&#21151;&#33021;</span>
<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyUI</span> {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">image</span> <span style="color: #00bfff; font-weight: bold;">by</span> bindResource(<span style="color: #98f5ff;">ResourceID.image</span>_id, <span style="color: #deb887;">"image"</span>)
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">text</span> <span style="color: #00bfff; font-weight: bold;">by</span> bindResource(<span style="color: #98f5ff;">ResourceID.text</span>_id, <span style="color: #deb887;">"text"</span>)
}

<span style="color: #00bfff; font-weight: bold;">fun</span> &lt;<span style="color: #98f5ff;">T&gt;</span> <span style="color: #98f5ff;">MyUI.bindResource</span>(
        id: <span style="color: #98f5ff;">ResourceID&lt;T&gt;</span>,
        propertyName: <span style="color: #98f5ff;">String</span>
): <span style="color: #98f5ff;">ReadOnlyProperty&lt;MyUI</span>, <span style="color: #98f5ff;">T&gt;</span> {
   checkProperty(<span style="color: #00bfff; font-weight: bold;">this</span>, propertyName)
   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#22996;&#25176;</span>
}
</pre>
</div>

<p>
再来比较一下，当 provideDelegate 方法存在时对于属性声明 val prop: Type by MyDelegate() 生成的代码则为：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">C</span> {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">prop</span>: <span style="color: #98f5ff;">Type</span> <span style="color: #00bfff; font-weight: bold;">by</span> <span style="color: #98f5ff;">MyDelegate</span>()
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#27573;&#20195;&#30721;&#26159;&#24403;&#8220;provideDelegate&#8221;&#21151;&#33021;&#21487;&#29992;&#26102;</span>
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#30001;&#32534;&#35793;&#22120;&#29983;&#25104;&#30340;&#20195;&#30721;&#65306;</span>
<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">C</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35843;&#29992;&#8220;provideDelegate&#8221;&#26469;&#21019;&#24314;&#39069;&#22806;&#30340;&#8220;delegate&#8221;&#23646;&#24615;</span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">prop$delegate</span> = <span style="color: #98f5ff;">MyDelegate</span>().provideDelegate(<span style="color: #00bfff; font-weight: bold;">this</span>, <span style="color: #00bfff; font-weight: bold;">this</span>::prop)
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">prop</span>: <span style="color: #98f5ff;">Type</span>
        <span style="color: #00bfff; font-weight: bold;">get</span>() = prop$delegate.getValue(<span style="color: #00bfff; font-weight: bold;">this</span>, <span style="color: #00bfff; font-weight: bold;">this</span>::prop)
        <span style="color: #00bfff; font-weight: bold;">set</span>(value: <span style="color: #98f5ff;">Type</span>) = prop$delegate.setValue(<span style="color: #00bfff; font-weight: bold;">this</span>, <span style="color: #00bfff; font-weight: bold;">this</span>::prop, value)
}
</pre>
</div>

<pre class="example">
     在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性

     请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="inline_class.html">Previous：内联类</a></td>
<td class="org-left"><a href="oo.html">Home：面向对象</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
