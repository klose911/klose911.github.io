<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>异常处理</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./channel.html"> UP </a>
 |
 <a accesskey="H" href="./coroutine.html"> HOME </a>
</div><div id="content">
<h1 class="title">异常处理</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org40d1735">异常的传播</a></li>
<li><a href="#org5022eed">CoroutineExceptionHandler</a></li>
<li><a href="#orgc182af8">取消与异常</a></li>
<li><a href="#org7a09708">异常聚合</a></li>
<li><a href="#org17df1a9">监督</a>
<ul>
<li><a href="#org2ccd408">监督作业</a></li>
<li><a href="#org39701f1">监督作业的作用域</a></li>
<li><a href="#orgd790dca">监督作业中的异常</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
这部分内容包括 <span class="underline">异常处理</span> 以及 <span class="underline">取消异常</span> 
</p>

<pre class="example">
  当协程被取消的时候会在挂起点抛出 CancellationException，并且它在协程机制中被忽略了

  但是如果一个异常在取消期间被抛出或多个子协程在同一个父协程中抛出异常将会发生什么？
</pre>
<div id="outline-container-org40d1735" class="outline-2">
<h2 id="org40d1735">异常的传播</h2>
<div class="outline-text-2" id="text-org40d1735">
<p>
协程构建器有两种风格：
</p>
<ol class="org-ol">
<li><p>
<b>自动</b> 的传播异常 <span class="underline">launch</span> 以及 <span class="underline">actor</span> 对待异常是不处理的
</p>
<pre class="example">
       类似于 Java 的 Thread.uncaughtExceptionHandler
</pre></li>
<li><p>
将它们暴露给 <b>用户</b> <span class="underline">async</span> 以及 <span class="underline">produce</span> 依赖用户来最终消耗异常
</p>
<pre class="example">
       比如说，通过 await 或 receive 
</pre></li>
</ol>

<p>
可以通过一个在 GlobalScope 中创建协程的简单示例来进行演示：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.GlobalScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.async</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">GlobalScope.launch</span> {
        println(<span style="color: #deb887;">"Throwing exception from launch"</span>)
        <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">IndexOutOfBoundsException</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25105;&#20204;&#23558;&#22312;&#25511;&#21046;&#21488;&#25171;&#21360; Thread.defaultUncaughtExceptionHandler</span>
    }
    job.join()
    println(<span style="color: #deb887;">"Joined failed job"</span>)

    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">deferred</span> = <span style="color: #98f5ff;">GlobalScope.async</span> {
        println(<span style="color: #deb887;">"Throwing exception from async"</span>)
        <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">ArithmeticException</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#26377;&#25171;&#21360;&#20219;&#20309;&#19996;&#35199;&#65292;&#20381;&#36182;&#29992;&#25143;&#21435;&#35843;&#29992;&#31561;&#24453;</span>
    }
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        deferred.await()
        println(<span style="color: #deb887;">"Unreached"</span>)
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (e: <span style="color: #98f5ff;">ArithmeticException</span>) {
        println(<span style="color: #deb887;">"Caught ArithmeticException"</span>)
    }
} 
</pre>
</div>

<p>
这段代码的输出如下（调试）：
</p>

<div class="org-src-container">
<pre class="src src-sh">Throwing exception from launch
Exception<span style="color: #00bfff; font-weight: bold;"> in</span> thread <span style="color: #deb887;">"DefaultDispatcher-worker-2 @coroutine#2"</span> java.lang.IndexOutOfBoundsException
Joined failed job
Throwing exception from async
Caught ArithmeticException
</pre>
</div>
</div>
</div>
<div id="outline-container-org5022eed" class="outline-2">
<h2 id="org5022eed">CoroutineExceptionHandler</h2>
<div class="outline-text-2" id="text-org5022eed">
<pre class="example">
    但是如果不想将所有的异常打印在控制台中呢？ 
</pre>
<p>
<span class="underline">CoroutineExceptionHandler</span> 上下文元素被用来将 <span class="underline">通用的 catch 代码块</span> 用于在 <b>协程</b> 中自定义日志记录或异常处理
</p>

<pre class="example">
    它和使用 Thread.uncaughtExceptionHandler 很相似
</pre>

<p>
在 JVM 中可以重定义一个 <b>全局的</b> <span class="underline">异常处理者</span> 来将所有的 <span class="underline">协程</span> 通过 <span class="underline">ServiceLoader</span>  <b>注册</b> 到 CoroutineExceptionHandler
</p>

<pre class="example">
    全局异常处理者就如同 Thread.defaultUncaughtExceptionHandler 一样，在没有更多的指定的异常处理者被注册的时候被使用

    在 Android 中， uncaughtExceptionPreHandler 被设置在全局协程异常处理者中
</pre>

<p>
CoroutineExceptionHandler 仅在预计不会由用户处理的异常上调用， 所以在 async 构建器中注册它没有任何效果 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">handler</span> = <span style="color: #98f5ff;">CoroutineExceptionHandler</span> { _, exception -&gt; println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$exception</span><span style="color: #deb887;">"</span>) }

    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">GlobalScope.launch</span>(handler) {
        <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">AssertionError</span>()
    }

    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">deferred</span> = <span style="color: #98f5ff;">GlobalScope.async</span>(handler) {
        <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">ArithmeticException</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#26377;&#25171;&#21360;&#20219;&#20309;&#19996;&#35199;&#65292;&#20381;&#36182;&#29992;&#25143;&#21435;&#35843;&#29992; deferred.await()</span>
    }
    joinAll(job, deferred)
} 
</pre>
</div>

<p>
输出如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">Caught java.lang.AssertionError
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc182af8" class="outline-2">
<h2 id="orgc182af8">取消与异常</h2>
<div class="outline-text-2" id="text-orgc182af8">
<p>
取消与异常紧密相关。协程内部使用 <span class="underline">CancellationException</span> 来进行取消，这个异常会被 <span class="underline">所有的处理者</span> <b>忽略</b>
</p>

<pre class="example">
    所以那些可以被 catch 代码块捕获的异常仅仅应该被用来作为额外调试信息的资源
</pre>

<p>
当一个协程使用 <span class="underline">Job.cancel</span> 取消的时候，它会被 <b>终止</b> ，但是它 <b>不会取消</b> 它的 <span class="underline">父协程</span> 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.yield</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = launch {
        <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">child</span> = launch {
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                delay(<span style="color: #98f5ff;">Long.MAX</span>_<span style="color: #98f5ff;">VALUE</span>)
            } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                println(<span style="color: #deb887;">"Child is cancelled"</span>)
            }
        }

        yield()
        println(<span style="color: #deb887;">"Cancelling child"</span>)
        child.cancel()
        child.join()
        yield()
        println(<span style="color: #deb887;">"Parent is not cancelled"</span>)
    }
    job.join()
} 
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Cancelling child
Child is cancelled
Parent is not cancelled
</pre>
</div>

<p>
如果协程遇到 <span class="underline">除 CancellationException 以外</span> 的异常，它将 <b>取消</b> 具有该异常的 <span class="underline">父协程</span> ：
</p>
<ul class="org-ul">
<li>这种行为不能被覆盖</li>
<li>它被用来提供一个稳定的协程层次结构来进行结构化并发而无需依赖 CoroutineExceptionHandler 的实现</li>
<li>且当所有的 <span class="underline">子协程</span> 被 <b>终止</b> 的时候，原本的异常被 <span class="underline">父协程</span> 所 <b>处理</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">handler</span> = <span style="color: #98f5ff;">CoroutineExceptionHandler</span> { _, exception -&gt; println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$exception</span><span style="color: #deb887;">"</span>) }
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">GlobalScope.launch</span>(handler) {
        launch { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31532;&#19968;&#20010;&#23376;&#21327;&#31243;</span>
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                delay(<span style="color: #98f5ff;">Long.MAX</span>_<span style="color: #98f5ff;">VALUE</span>)
            } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                withContext(<span style="color: #98f5ff;">NonCancellable</span>) {
                    println(<span style="color: #deb887;">"Children are cancelled, but exception is not handled until all children terminate"</span>)
                    delay(100)
                    println(<span style="color: #deb887;">"The first child finished its non cancellable block"</span>)
                }
            }
        }
        launch { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31532;&#20108;&#20010;&#23376;&#21327;&#31243;</span>
            delay(10)
            println(<span style="color: #deb887;">"Second child throws an exception"</span>)
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">ArithmeticException</span>()
        }
    }
    job.join()
} 
</pre>
</div>

<p>
输出如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">Second child throws an exception
Children are cancelled, but exception is not handled until all children terminate
The first child finished its non cancellable block
Caught java.lang.ArithmeticException
</pre>
</div>

<pre class="example">
CoroutineExceptionHandler 总是被设置在由 GlobalScope 启动的协程中

将异常处理者设置在 runBlocking 主作用域内启动的协程中是没有意义的，尽管子协程已经设置了异常处理者， 但是主协程也总是会被取消的
</pre>
</div>
</div>
<div id="outline-container-org7a09708" class="outline-2">
<h2 id="org7a09708">异常聚合</h2>
<div class="outline-text-2" id="text-org7a09708">
<pre class="example">
    如果一个协程的多个子协程抛出异常将会发生什么？ 
</pre>

<p>
通常的规则是“第一个异常赢得了胜利”，所以第一个被抛出的异常将会暴露给处理者
</p>

<pre class="example">
    但也许这会是异常丢失的原因，比如说一个协程在 finally 块中抛出了一个异常。这时，多余的异常将会被压制
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">java.io.IOException</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">handler</span> =
        <span style="color: #98f5ff;">CoroutineExceptionHandler</span> { _, exception -&gt; println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$exception</span><span style="color: #deb887;"> with suppressed ${</span>exception.suppressed.contentToString()<span style="color: #deb887;">}"</span>) }
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">GlobalScope.launch</span>(handler) {
        launch {
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                delay(<span style="color: #98f5ff;">Long.MAX</span>_<span style="color: #98f5ff;">VALUE</span>)
            } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">ArithmeticException</span>()
            }
        }

        launch {
            delay(100)
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">IOException</span>()
        }
        delay(<span style="color: #98f5ff;">Long.MAX</span>_<span style="color: #98f5ff;">VALUE</span>)
    }
    job.join()
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Caught java.io.IOException with suppressed [java.lang.ArithmeticException]
</pre>
</div>

<pre class="example">
    其中一个解决方法是分别抛出异常， 但是接下来 Deferred.await 应该有相同的机制来避免行为不一致并且会导致协程的实现细节（是否已将其部分工作委托给子协程） 泄漏到异常处理者中
</pre>

<p>
<span class="underline">CancellationException</span> 是 <b>透明</b> 的并且会在默认情况下 <span class="underline">解包</span> ：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">java.io.IOException</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">handler</span> = <span style="color: #98f5ff;">CoroutineExceptionHandler</span> { _, exception -&gt; println(<span style="color: #deb887;">"Caught original </span><span style="color: #4eee94;">$exception</span><span style="color: #deb887;">"</span>) }
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">GlobalScope.launch</span>(handler) {
        <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">inner</span> = launch {
            launch {
                launch {
                    <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">IOException</span>()
                }
            }
        }
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #00bfff; font-weight: bold;">inner</span>.join()
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (e: <span style="color: #98f5ff;">CancellationException</span>) {
            println(<span style="color: #deb887;">"Rethrowing CancellationException with original cause"</span>)
            <span style="color: #00bfff; font-weight: bold;">throw</span> e
        }
    }
    job.join()
} 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">Rethrowing CancellationException with original cause
Caught original java.io.IOException
</pre>
</div>
</div>
</div>
<div id="outline-container-org17df1a9" class="outline-2">
<h2 id="org17df1a9">监督</h2>
<div class="outline-text-2" id="text-org17df1a9">
<pre class="example">
    取消是一种双向机制，在协程的整个层次结构之间传播。但是如果需要单向取消怎么办？

    一个良好示例是在其作用域内定义作业的 UI 组件。如果任何一个 UI 的子作业执行失败了，它并不总是有必要取消（有效地杀死）整个 UI 组件， 但是如果 UI 组件被销毁了（并且它的作业也被取消了），由于它的结果不再被需要了，它有必要使所有的子作业执行失败

    另一个例子是服务进程孵化了一些子作业并且需要 监督 它们的执行，追踪它们的故障并在这些子作业执行失败的时候重启
</pre>
</div>
<div id="outline-container-org2ccd408" class="outline-3">
<h3 id="org2ccd408">监督作业</h3>
<div class="outline-text-3" id="text-org2ccd408">
<p>
<span class="underline">SupervisorJob</span> 可以被用于这些目的。它类似于常规的 Job，唯一的不同是：SupervisorJob 的 <span class="underline">取消</span> 只会 <b>向下</b> <span class="underline">传播</span> 。这是非常容易从示例中观察到的：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">supervisor</span> = <span style="color: #98f5ff;">SupervisorJob</span>()
    with(<span style="color: #98f5ff;">CoroutineScope</span>(coroutineContext + supervisor)) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#31532;&#19968;&#20010;&#23376;&#20316;&#19994;&#8212;&#8212;&#36825;&#20010;&#31034;&#20363;&#23558;&#20250;&#24573;&#30053;&#23427;&#30340;&#24322;&#24120;&#65288;&#19981;&#35201;&#22312;&#23454;&#36341;&#20013;&#36825;&#20040;&#20570;&#65281;&#65289;</span>
        <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">firstChild</span> = launch(<span style="color: #98f5ff;">CoroutineExceptionHandler</span> { _, _ -&gt; }) {
            println(<span style="color: #deb887;">"First child is failing"</span>)
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">AssertionError</span>(<span style="color: #deb887;">"First child is cancelled"</span>)
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#31532;&#20004;&#20010;&#23376;&#20316;&#19994;</span>
        <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">secondChild</span> = launch {
            firstChild.join()
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#20102;&#31532;&#19968;&#20010;&#23376;&#20316;&#19994;&#19988;&#27809;&#26377;&#20256;&#25773;&#32473;&#31532;&#20108;&#20010;&#23376;&#20316;&#19994;</span>
            println(<span style="color: #deb887;">"First child is cancelled: ${</span>firstChild.isCancelled<span style="color: #deb887;">}, but second one is still active"</span>)
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                delay(<span style="color: #98f5ff;">Long.MAX</span>_<span style="color: #98f5ff;">VALUE</span>)
            } <span style="color: #00bfff; font-weight: bold;">finally</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20294;&#26159;&#21462;&#28040;&#20102;&#30417;&#30563;&#30340;&#20256;&#25773;</span>
                println(<span style="color: #deb887;">"Second child is cancelled because supervisor is cancelled"</span>)
            }
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#30452;&#21040;&#31532;&#19968;&#20010;&#23376;&#20316;&#19994;&#22833;&#36133;&#19988;&#25191;&#34892;&#23436;&#25104;</span>
        firstChild.join()
        println(<span style="color: #deb887;">"Cancelling supervisor"</span>)
        supervisor.cancel()
        secondChild.join()
    }
}
</pre>
</div>

<p>
这段代码的输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">First child is failing
First child is cancelled: true, but second one is still active
Cancelling supervisor
Second child is cancelled because supervisor is cancelled
</pre>
</div>
</div>
</div>

<div id="outline-container-org39701f1" class="outline-3">
<h3 id="org39701f1">监督作业的作用域</h3>
<div class="outline-text-3" id="text-org39701f1">
<p>
对于作用域的并发，supervisorScope 可以被用来替代 coroutineScope 来实现相同的目的：
</p>
<ul class="org-ul">
<li>它只会单向的传播并且当 <span class="underline">作业</span> <b>自身</b> 执行 <span class="underline">失败</span> 的时候将 <b>所有子作业</b> 全部 <span class="underline">取消</span></li>
<li>作业 <b>自身</b> 也会在 <span class="underline">所有的子作业</span> 执行结束前 <b>等待</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        supervisorScope {
            <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">child</span> = launch {
                <span style="color: #00bfff; font-weight: bold;">try</span> {
                    println(<span style="color: #deb887;">"Child is sleeping"</span>)
                    delay(<span style="color: #98f5ff;">Long.MAX</span>_<span style="color: #98f5ff;">VALUE</span>)
                } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                    println(<span style="color: #deb887;">"Child is cancelled"</span>)
                }
            }
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992; yield &#26469;&#32473;&#25105;&#20204;&#30340;&#23376;&#20316;&#19994;&#19968;&#20010;&#26426;&#20250;&#26469;&#25191;&#34892;&#25171;&#21360;</span>
            yield()
            println(<span style="color: #deb887;">"Throwing exception from scope"</span>)
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">AssertionError</span>()
        }
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (e: <span style="color: #98f5ff;">AssertionError</span>) {
        println(<span style="color: #deb887;">"Caught assertion error"</span>)
    }
} 
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Child is sleeping
Throwing exception from scope
Child is cancelled
Caught assertion error
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd790dca" class="outline-3">
<h3 id="orgd790dca">监督作业中的异常</h3>
<div class="outline-text-3" id="text-orgd790dca">
<p>
常规的作业和监督作业之间的另一个重要区别是 <span class="underline">异常处理</span> ，监督协程中的 <span class="underline">每一个子作业</span> 应该通过 <span class="underline">异常处理机制</span> <b>处理</b> <span class="underline">自身的异常</span> 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineExceptionHandler</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.supervisorScope</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">handler</span> = <span style="color: #98f5ff;">CoroutineExceptionHandler</span> { _, exception -&gt; println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$exception</span><span style="color: #deb887;">"</span>) }
    supervisorScope {
        <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">child</span> = launch(handler) {
            println(<span style="color: #deb887;">"Child throws an exception"</span>)
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">AssertionError</span>()
        }
        println(<span style="color: #deb887;">"Scope is completing"</span>)
    }
    println(<span style="color: #deb887;">"Scope is completed"</span>)
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Scope is completing
Child throws an exception
Caught java.lang.AssertionError
Scope is completed
</pre>
</div>

<pre class="example">
     这种差异来自于子作业的执行失败不会传播给它的父作业的事实
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="shared_state.html">Next：共享状态</a></td>
<td class="org-left"><a href="channel.html">Previous：通道</a></td>
<td class="org-left"><a href="coroutine.html">Home：协程</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
