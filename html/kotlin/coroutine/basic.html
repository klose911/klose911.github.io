<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>基础</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="./coroutine.html"> HOME </a>
</div><div id="content">
<h1 class="title">基础</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5980cdb">第一个协程程序</a>
<ul>
<li><a href="#orgea2d0b9">阻塞与非阻塞</a></li>
<li><a href="#org257de27">等待一个作业</a></li>
<li><a href="#org224e94f">结构化的并发</a></li>
<li><a href="#org924b565">作用域构建器</a></li>
<li><a href="#orgd230146">提取函数重构</a></li>
<li><a href="#orgef61680">协程很轻量</a></li>
</ul>
</li>
<li><a href="#orgfc8161f">全局协程</a></li>
</ul>
</div>
</div>
<div id="outline-container-org5980cdb" class="outline-2">
<h2 id="org5980cdb">第一个协程程序</h2>
<div class="outline-text-2" id="text-org5980cdb">
<p>
运行以下代码：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #98f5ff;">GlobalScope.launch</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#21518;&#21488;&#21551;&#21160;&#19968;&#20010;&#26032;&#30340;&#21327;&#31243;&#24182;&#32487;&#32493;</span>
                         delay(1000L) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38750;&#38459;&#22622;&#30340;&#31561;&#24453; 1 &#31186;&#38047;&#65288;&#40664;&#35748;&#26102;&#38388;&#21333;&#20301;&#26159;&#27627;&#31186;&#65289;</span>
                         println(<span style="color: #deb887;">"World!"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#24310;&#36831;&#21518;&#25171;&#21360;&#36755;&#20986;</span>
    }
    println(<span style="color: #deb887;">"Hello,"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21327;&#31243;&#24050;&#22312;&#31561;&#24453;&#26102;&#20027;&#32447;&#31243;&#36824;&#22312;&#32487;&#32493;</span>
    <span style="color: #98f5ff;">Thread.sleep</span>(2000L) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38459;&#22622;&#20027;&#32447;&#31243; 2 &#31186;&#38047;&#26469;&#20445;&#35777; JVM &#23384;&#27963;</span>
}
</pre>
</div>

<p>
代码运行的结果：
</p>

<div class="org-src-container">
<pre class="src src-sh">Hello,
World!
</pre>
</div>

<p>
本质上， <span class="underline">协程</span> 是 <b>轻量级</b> 的 <span class="underline">线程</span> 。 它们在某些 <span class="underline">CoroutineScope</span> <b>上下文</b> 中与 <span class="underline">launch</span> *协程构建器( 一起启动
</p>

<pre class="example">
    这里在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制 
</pre>

<p>
可以将 <span class="underline">GlobalScope.launch { …… }</span> 替换为 thread { …… }，将 <span class="underline">delay(……)</span> 替换为 Thread.sleep(……) 达到同样目的
</p>

<pre class="example">
    不要忘记导入 kotlin.concurrent.thread
</pre>

<p>
如果首先将 GlobalScope.launch 替换为 thread，编译器会报以下错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend <span style="color: #00bfff; font-weight: bold;">function</span>
</pre>
</div>

<p>
这是因为 <span class="underline">delay</span> 是一个特殊的 <b>挂起</b> 函数 ，它不会造成线程阻塞，但是会 <span class="underline">挂起</span> 协程，并且 <b>只能</b> 在 <span class="underline">协程</span> 中使用 
</p>
</div>
<div id="outline-container-orgea2d0b9" class="outline-3">
<h3 id="orgea2d0b9">阻塞与非阻塞</h3>
<div class="outline-text-3" id="text-orgea2d0b9">
<pre class="example">
     上个示例在同一段代码中混用了 非阻塞的 delay(……) 与 阻塞的 Thread.sleep(……)

     这容易记混哪个是阻塞的、哪个是非阻塞的
</pre>
<p>
显式使用 <span class="underline">runBlocking</span> 协程构建器来阻塞：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.GlobalScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24320;&#22987;&#25191;&#34892;&#20027;&#21327;&#31243;</span>
    <span style="color: #98f5ff;">GlobalScope.launch</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#21518;&#21488;&#21551;&#21160;&#19968;&#20010;&#26032;&#30340;&#21327;&#31243;&#24182;&#32487;&#32493;</span>
        delay(1000L)
        println(<span style="color: #deb887;">"World!"</span>)
    }
    println(<span style="color: #deb887;">"Hello,"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20027;&#21327;&#31243;&#22312;&#36825;&#37324;&#20250;&#31435;&#21363;&#25191;&#34892;</span>
    delay(2000L)
}
</pre>
</div>

<p>
这里的 <span class="underline">runBlocking&lt;Unit&gt; { …… }</span> 作为用来 <b>启动</b> <span class="underline">顶层主协程</span> 的 <span class="underline">适配器</span> ， 调用了 runBlocking 的主线程会一直 <b>阻塞</b> 直到 runBlocking 内部的协程执行完毕 
</p>

<pre class="example">
     显式指定了其返回类型 Unit，因为在 Kotlin 中 main 函数必须返回 Unit 类型
</pre>

<p>
这也是为挂起函数编写单元测试的一种方式：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyTest</span> {
    @<span style="color: #98f5ff;">Test</span>
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">testMySuspendingFunction</span>() = runBlocking {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">...</span>
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org257de27" class="outline-3">
<h3 id="org257de27">等待一个作业</h3>
<div class="outline-text-3" id="text-org257de27">
<pre class="example">
     延迟一段时间来等待另一个协程运行并不是一个好的选择
</pre>

<p>
显式（以非阻塞方式）等待所启动的后台 Job 执行结束：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">GlobalScope.launch</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#19968;&#20010;&#26032;&#21327;&#31243;&#24182;&#20445;&#25345;&#23545;&#36825;&#20010;&#20316;&#19994;&#30340;&#24341;&#29992;</span>
        delay(1000L)
        println(<span style="color: #deb887;">"World!"</span>)
    }
    println(<span style="color: #deb887;">"Hello,"</span>)
    job.join() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#30452;&#21040;&#23376;&#21327;&#31243;&#25191;&#34892;&#32467;&#26463;</span>
}
</pre>
</div>

<pre class="example">
     现在，结果仍然相同，但是主协程与后台作业的持续时间没有任何关系了。好多了
</pre>
</div>
</div>
<div id="outline-container-org224e94f" class="outline-3">
<h3 id="org224e94f">结构化的并发</h3>
<div class="outline-text-3" id="text-org224e94f">
<pre class="example">
     协程的实际使用还有一些需要改进的地方：当使用 GlobalScope.launch 时，会创建一个顶层协程。虽然它很轻量，但它运行时仍会消耗一些内存资源

     如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样（例如，错误地延迟了太长时间）

     如果启动了太多的协程并导致内存不足会怎么样？ 必须手动保持对所有已启动协程的引用并 join 是很容易出错
</pre>

<p>
有一个更好的解决办法。可以在代码中使用结构化并发：在 <span class="underline">执行操作</span> 所在的 <b>指定作用域</b> 内启动协程， 而不是像通常使用线程（线程总是全局的）那样在 GlobalScope 中启动 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">this: CoroutineScope</span>
    launch { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312; runBlocking &#20316;&#29992;&#22495;&#20013;&#21551;&#21160;&#19968;&#20010;&#26032;&#21327;&#31243;</span>
        delay(1000L)
        println(<span style="color: #deb887;">"World!"</span>)
    }
    println(<span style="color: #deb887;">"Hello,"</span>)
}
</pre>
</div>
<p>
在示例中，使用 runBlocking 协程构建器将 main 函数转换为协程。 包括 runBlocking 在内的每个协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中
</p>

<pre class="example">
     可以在这个作用域中启动协程而无需显式 join 之，因为外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束
</pre>
</div>
</div>
<div id="outline-container-org924b565" class="outline-3">
<h3 id="org924b565">作用域构建器</h3>
<div class="outline-text-3" id="text-org924b565">
<p>
除了由不同的构建器提供协程作用域之外，还可以使用 <span class="underline">coroutineScope</span> 构建器声明自己的作用域。它会 <b>创建</b> 一个 <span class="underline">协程作用域</span> 并且在 <b>所有</b> <span class="underline">已启动子协程</span> <b>执行完毕</b> 之前 <b>不会</b> <span class="underline">结束</span> 。runBlocking 与 coroutineScope 可能看起来很类似，因为它们都会等待其协程体以及所有子协程结束。 这两者的主要区别在于：
</p>
<ul class="org-ul">
<li>runBlocking 方法会 <b>阻塞</b> 当前线程来等待</li>
<li>coroutineScope 只是 <b>挂起</b> ，会释放底层线程用于其他用途</li>
</ul>

<pre class="example">
     由于存在这点差异，runBlocking 是常规函数，而 coroutineScope 是挂起函数
</pre>

<p>
可以通过以下示例来演示：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.coroutineScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">this: CoroutineScope</span>
    launch {
        delay(200L)
        println(<span style="color: #deb887;">"Task from runBlocking"</span>)
    }
    coroutineScope { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#19968;&#20010;&#21327;&#31243;&#20316;&#29992;&#22495;</span>
        launch {
            delay(500L)
            println(<span style="color: #deb887;">"Task from nested launch"</span>)
        }
        delay(100L)
        println(<span style="color: #deb887;">"Task from coroutine scope"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#19968;&#34892;&#20250;&#22312;&#20869;&#23884; launch &#20043;&#21069;&#36755;&#20986;</span>
    }
        println (<span style="color: #deb887;">"Coroutine scope is over"</span>)
}
</pre>
</div>

<pre class="example">
     请注意，当等待内嵌 launch 时，紧挨“Task from coroutine scope”消息之后， 就会执行并输出“Task from runBlocking”，尽管 coroutineScope 尚未结束，正好说明非阻塞
</pre>
</div>
</div>

<div id="outline-container-orgd230146" class="outline-3">
<h3 id="orgd230146">提取函数重构</h3>
<div class="outline-text-3" id="text-orgd230146">
<p>
将 <span class="underline">launch { …… }</span> 内部的代码块提取到独立的函数中。当对这段代码执行 <span class="underline">提取函数</span> 重构时，会得到一个带有 <span class="underline">suspend</span> 修饰符的新函数
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.coroutineScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">this: CoroutineScope</span>
    launch {
        delay(200L)
        println(<span style="color: #deb887;">"Task from runBlocking"</span>)
    }
    doWorld()
    println (<span style="color: #deb887;">"Coroutine scope is over"</span>)
}

<span style="color: #00bfff; font-weight: bold;">suspend</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">doWorld</span>() {
    coroutineScope { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#19968;&#20010;&#21327;&#31243;&#20316;&#29992;&#22495;</span>
        launch {
            delay(500L)
            println(<span style="color: #deb887;">"Task from nested launch"</span>)
        }
        delay(100L)
        println(<span style="color: #deb887;">"Task from coroutine scope"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#19968;&#34892;&#20250;&#22312;&#20869;&#23884; launch &#20043;&#21069;&#36755;&#20986;</span>
    }
}
</pre>
</div>
<p>
这是第一个挂起函数。在协程内部可以像普通函数一样使用挂起函数， 不过其额外特性是，可以使用 <b>其他</b> <span class="underline">挂起</span> 函数（如本例中的 delay）来挂起协程的执行
</p>


<pre class="example">
     但是如果提取出的函数包含一个在当前作用域中调用的协程构建器的话，该怎么办？ 在这种情况下，所提取函数上只有 suspend 修饰符是不够的

     为 CoroutineScope 写一个 doWorld 扩展方法是其中一种解决方案，但这可能并非总是适用，因为它并没有使 API 更加清晰

     惯用的解决方案是要么显式将 CoroutineScope 作为包含该函数的类的一个字段， 要么当外部类实现了 CoroutineScope 时隐式取得

     作为最后的手段，可以使用 CoroutineScope(coroutineContext)，不过这种方法结构上不安全， 因为不能再控制该方法执行的作用域

     只有私有 API 才能使用这个构建器 
</pre>
</div>
</div>

<div id="outline-container-orgef61680" class="outline-3">
<h3 id="orgef61680">协程很轻量</h3>
<div class="outline-text-3" id="text-orgef61680">
<p>
运行以下代码：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    repeat(100_000) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#22823;&#37327;&#30340;&#21327;&#31243;</span>
        launch {
            delay(1000L)
            print(<span style="color: #deb887;">"."</span>)
        }
    }
}
</pre>
</div>

<pre class="example">
     它启动了 10 万个协程，并且在一秒钟后，每个协程都输出一个点

     现在，尝试使用线程来实现。会发生什么？（很可能代码会产生某种内存不足的错误）
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfc8161f" class="outline-2">
<h2 id="orgfc8161f">全局协程</h2>
<div class="outline-text-2" id="text-orgfc8161f">
<p>
以下代码在 GlobalScope 中启动了一个长期运行的协程，该协程每秒输出“I'm sleeping”两次，之后在主函数中延迟一段时间后返回
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.GlobalScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>


<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #98f5ff;">GlobalScope.launch</span> {
        repeat(1000) { i -&gt;
            println(<span style="color: #deb887;">"I'm sleeping </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;"> ..."</span>)
            delay(500L)
        }
    }
    delay(1300L)
}
</pre>
</div>


<p>
运行这个程序并看到它输出了以下三行后终止：
</p>
<div class="org-src-container">
<pre class="src src-sh">I<span style="color: #deb887;">'m sleeping 0 ...</span>
<span style="color: #deb887;">I'</span>m sleeping 1 ...
I<span style="color: #deb887;">'m sleeping 2 ...</span>
</pre>
</div>

<pre class="example">
    在 GlobalScope 中启动的活动协程并不会使进程保活。它们就像守护线程
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="cancel.html">Next：取消和超时</a></td>
<td class="org-left"><a href="coroutine.html">Home：协程</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
