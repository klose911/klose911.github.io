<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>通道</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./flow.html"> UP </a>
 |
 <a accesskey="H" href="./coroutine.html"> HOME </a>
</div><div id="content">
<h1 class="title">通道</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga34ec59">基础</a></li>
<li><a href="#orgf41b50b">关闭与迭代通道</a></li>
<li><a href="#orgc4693ce">构建通道生产者</a></li>
<li><a href="#org81a2287">管道</a>
<ul>
<li><a href="#org0d37e5f">素数管道</a></li>
<li><a href="#orgf35c150">fan out</a></li>
<li><a href="#org847fa9c">fan in</a></li>
</ul>
</li>
<li><a href="#orga97805c">带缓冲的通道</a></li>
<li><a href="#org18ea520">通道是公平的</a></li>
<li><a href="#org3fc70b3">计时器通道</a></li>
</ul>
</div>
</div>
<pre class="example">
  延期的值提供了一种便捷的方法使单个值在多个协程之间进行相互传输
</pre>

<p>
通道提供了一种在 <span class="underline">流</span> 中 <b>传输</b> 值的方法
</p>
<div id="outline-container-orga34ec59" class="outline-2">
<h2 id="orga34ec59">基础</h2>
<div class="outline-text-2" id="text-orga34ec59">
<pre class="example">
Channel 是一个和 BlockingQueue 非常相似的概念
</pre>
<p>
一个不同是它代替了阻塞的 put 操作并提供了 <b>挂起</b> 的 <span class="underline">send</span> ，还替代了阻塞的 take 操作并提供了 <b>挂起</b> 的 <span class="underline">receive</span> 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.Channel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">channel</span> = <span style="color: #98f5ff;">Channel&lt;Int&gt;</span>()

    launch {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#21487;&#33021;&#26159;&#28040;&#32791;&#22823;&#37327; CPU &#36816;&#31639;&#30340;&#24322;&#27493;&#36923;&#36753;&#65292;&#25105;&#20204;&#23558;&#20165;&#20165;&#20570; 5 &#27425;&#25972;&#25968;&#30340;&#24179;&#26041;&#24182;&#21457;&#36865;</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> 1..5)
            channel.send(x * x)
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#25105;&#20204;&#25171;&#21360;&#20102; 5 &#27425;&#34987;&#25509;&#25910;&#30340;&#25972;&#25968;&#65306;</span>
    repeat(5) {
        println(channel.receive())
    }
    println(<span style="color: #deb887;">"Done!"</span>)
}
</pre>
</div>

<p>
输出如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">1
4
9
16
25
Done!
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf41b50b" class="outline-2">
<h2 id="orgf41b50b">关闭与迭代通道</h2>
<div class="outline-text-2" id="text-orgf41b50b">
<p>
和队列不同，一个通道可以通过被 <span class="underline">关闭</span> 来表明 <b>没有更多</b> 的 <span class="underline">元素</span> 将会 <b>进入</b> 通道。 在 <span class="underline">接收者</span> 中可以 <b>定期</b> 的使用 <span class="underline">for</span> 循环来从通道中 <b>接收</b> 元素
</p>

<pre class="example">
    从概念上来说，一个 close 操作就像向通道发送了一个特殊的关闭指令，这个迭代停止就说明关闭指令已经被接收了

    所以这里保证所有先前发送出去的元素都在通道关闭前被接收到
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.Channel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">channel</span> = <span style="color: #98f5ff;">Channel&lt;Int&gt;</span>()
    launch {
        <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> 1..5)
            channel.send(x * x)
        channel.close() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25105;&#20204;&#32467;&#26463;&#21457;&#36865;</span>
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#25105;&#20204;&#20351;&#29992; `for` &#24490;&#29615;&#26469;&#25171;&#21360;&#25152;&#26377;&#34987;&#25509;&#25910;&#21040;&#30340;&#20803;&#32032;&#65288;&#30452;&#21040;&#36890;&#36947;&#34987;&#20851;&#38381;&#65289;</span>
    <span style="color: #00bfff; font-weight: bold;">for</span> (y <span style="color: #00bfff; font-weight: bold;">in</span> channel)
        println(y)
    println(<span style="color: #deb887;">"Done!"</span>)
} 
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4693ce" class="outline-2">
<h2 id="orgc4693ce">构建通道生产者</h2>
<div class="outline-text-2" id="text-orgc4693ce">
<pre class="example">
    协程生成一系列元素的模式很常见。 这是 生产者——消费者 模式的一部分，并且经常能在并发的代码中看到它

    可以将生产者抽象成一个函数，并且使通道作为它的参数，但这与必须从函数中返回结果的常识相违悖
</pre>


<p>
下面实例中有一个名为 <span class="underline">produce</span> 的便捷的协程构建器，可以很容易的在 <b>生产者端</b> 正确工作， 并且使用扩展函数 <span class="underline">consumeEach</span> 在 <b>消费者端</b> 替代 <span class="underline">for</span> 循环：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.ReceiveChannel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.consumeEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.produce</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.produceSquares</span>(): <span style="color: #98f5ff;">ReceiveChannel&lt;Int&gt;</span> = produce {
    <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> 1..5)
        send(x * x)
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">squares</span> = produceSquares()
    squares.consumeEach {
        println(<span style="color: #00bfff; font-weight: bold;">it</span>)
    }
    println(<span style="color: #deb887;">"Done!"</span>)
} 
</pre>
</div>
</div>
</div>
<div id="outline-container-org81a2287" class="outline-2">
<h2 id="org81a2287">管道</h2>
<div class="outline-text-2" id="text-org81a2287">
<p>
管道是一个 <span class="underline">协程</span> 在 <span class="underline">流</span> 中开始 <span class="underline">生产</span> 可能 <b>无穷多</b> 个 <span class="underline">元素</span> 的模式：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.produceNumbers</span>() = produce {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">x</span> = 1
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>)
        send(x++) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#27969;&#20013;&#24320;&#22987;&#20174; 1 &#29983;&#20135;&#26080;&#31351;&#22810;&#20010;&#25972;&#25968;</span>
}
</pre>
</div>

<p>
并且另一个或多个协程开始 <b>消费</b> 这些流，做一些操作，并生产了一些额外的结果。 在下面的例子中，对这些数字仅仅做了平方操作：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.square</span>(numbers: <span style="color: #98f5ff;">ReceiveChannel</span>): <span style="color: #98f5ff;">ReceiveChannel</span> = produce {
    <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> numbers)
        send(x * x)
}
</pre>
</div>

<p>
更完整的一个例子：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.cancelChildren</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.ReceiveChannel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.produce</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">numbers</span> = produceNumbers() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20174; 1 &#24320;&#22987;&#29983;&#25104;&#25972;&#25968;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">squares</span> = square(numbers) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25972;&#25968;&#27714;&#24179;&#26041;</span>
    repeat(5) {
        println(squares.receive()) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20986;&#21069;&#20116;&#20010;</span>
    }
    println(<span style="color: #deb887;">"Done!"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#33267;&#27492;&#24050;&#23436;&#25104;</span>
    coroutineContext.cancelChildren() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#23376;&#21327;&#31243;</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.produceNumbers</span>() = produce {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">x</span> = 1
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>)
        send(x++) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20174; 1 &#24320;&#22987;&#30340;&#26080;&#38480;&#30340;&#25972;&#25968;&#27969;</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.square</span>(numbers: <span style="color: #98f5ff;">ReceiveChannel&lt;Int&gt;</span>): <span style="color: #98f5ff;">ReceiveChannel&lt;Int&gt;</span> = produce {
    <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> numbers)
        send(x * x)
}
</pre>
</div>

<pre class="example">
    所有创建了协程的函数被定义在了 CoroutineScope 的扩展上， 所以可以依靠结构化并发来确保没有常驻在应用程序中的全局协程
</pre>
</div>
<div id="outline-container-org0d37e5f" class="outline-3">
<h3 id="org0d37e5f">素数管道</h3>
<div class="outline-text-3" id="text-org0d37e5f">
<pre class="example">
     现在展示一个极端的例子：在协程中使用一个管道来生成素数
</pre>
<p>
首先开启一个数字的无限序列：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.numbersFrom</span>(start: <span style="color: #98f5ff;">Int</span>) = produce {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">x</span> = start
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>)
        send(x++) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24320;&#21551;&#20102;&#19968;&#20010;&#26080;&#38480;&#30340;&#25972;&#25968;&#27969;</span>
} 
</pre>
</div>

<p>
在下面的管道阶段中过滤了来源于流中的数字，删除了所有可以被给定素数整除的数字：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.filter</span>(numbers: <span style="color: #98f5ff;">ReceiveChannel</span>, prime: <span style="color: #98f5ff;">Int</span>) = produce {
    <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> numbers)
        <span style="color: #00bfff; font-weight: bold;">if</span> (x % prime != 0)
        send(x)
} 
</pre>
</div>

<p>
现在开启了一个从 <span class="underline">2</span> 开始的数字流管道，从当前的通道中取一个素数， 并为每一个发现的素数启动一个流水线阶段：
</p>

<pre class="example">
numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ……
</pre>


<p>
下面的例子打印了前十个素数， 在主线程的上下文中运行整个管道。直到所有的协程在该主协程 runBlocking 的作用域中被启动完成。不必使用一个显式的列表来保存所有被已经启动的协程。 而是使用 <span class="underline">cancelChildren</span> 扩展函数在打印了前十个素数以后来取消所有的子协程：
</p>

<div class="org-src-container">
<pre class="src src-kotlin">
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.cancelChildren</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.ReceiveChannel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.produce</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">cur</span> = numbersFrom(2)
    repeat(10) {
        <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">prime</span> = cur.receive()
        println(prime)
        cur = filter(cur, prime)
    }
    coroutineContext.cancelChildren() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#25152;&#26377;&#30340;&#23376;&#21327;&#31243;&#26469;&#35753;&#20027;&#21327;&#31243;&#32467;&#26463;</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.numbersFrom</span>(start: <span style="color: #98f5ff;">Int</span>) = produce {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">x</span> = start
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>)
        send(x++) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20174; start &#24320;&#22987;&#36807;&#28388;&#25972;&#25968;&#27969;</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.filter</span>(numbers: <span style="color: #98f5ff;">ReceiveChannel&lt;Int&gt;</span>, prime: <span style="color: #98f5ff;">Int</span>) = produce {
    <span style="color: #00bfff; font-weight: bold;">for</span> (x <span style="color: #00bfff; font-weight: bold;">in</span> numbers)
        <span style="color: #00bfff; font-weight: bold;">if</span> (x % prime != 0)
            send(x)
} 
</pre>
</div>

<p>
可以在标准库中使用 iterator 协程构建器来构建一个相似的管道：
</p>
<ul class="org-ul">
<li>使用 iterator 替换 produce</li>
<li>yield 替换 send</li>
<li>next 替换 receive</li>
<li>Iterator 替换 ReceiveChannel 来摆脱协程作用域，将不再需要 runBlocking</li>
</ul>

<pre class="example">
     如上所示，如果在 Dispatchers.Default 上下文中运行它，使用通道的管道的好处在于它可以充分利用多核心 CPU


     不过，这是一种非常不切实际的寻找素数的方法

     在实践中，管道调用了另外的一些挂起中的调用（就像异步调用远程服务）并且这些管道不能内置使用 sequence/iterator，因为它们不被允许随意的挂起，不像 produce 是完全异步的
</pre>
</div>
</div>
<div id="outline-container-orgf35c150" class="outline-3">
<h3 id="orgf35c150">fan out</h3>
<div class="outline-text-3" id="text-orgf35c150">
<p>
多个协程也许会接收相同的管道，在它们之间进行分布式工作。启动一个定期产生整数的生产者协程 （每秒十个数字）：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.produceNumbers</span>() = produce {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">x</span> = 1
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20174; 1 &#24320;&#22987;</span>
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
        send(x++) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;&#19979;&#19968;&#20010;&#25968;&#23383;</span>
        delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453; 0.1 &#31186;</span>
    }
} 
</pre>
</div>

<p>
接下来可以创建几个处理器协程。在这个示例中，它们只是打印它们的 id 和接收到的数字：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.launchProcessor</span>(id: <span style="color: #98f5ff;">Int</span>, channel: <span style="color: #98f5ff;">ReceiveChannel</span>) = launch {
    <span style="color: #00bfff; font-weight: bold;">for</span> (msg <span style="color: #00bfff; font-weight: bold;">in</span> channel) {
        println(<span style="color: #deb887;">"Processor #</span><span style="color: #4eee94;">$id</span><span style="color: #deb887;"> received </span><span style="color: #4eee94;">$msg</span><span style="color: #deb887;">"</span>)
    }
}
</pre>
</div>

<p>
现在启动五个处理器协程并让它们工作将近一秒。看看发生了什么：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.ReceiveChannel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.produce</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">producer</span> = produceNumbers1()
    repeat (5) {
        launchProcessor(<span style="color: #00bfff; font-weight: bold;">it</span>, producer)
    }
    delay(950)
    producer.cancel() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#21327;&#31243;&#29983;&#20135;&#32773;&#20174;&#32780;&#23558;&#23427;&#20204;&#20840;&#37096;&#26432;&#27515;</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.produceNumbers1</span>() = produce {
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">x</span> = 1 <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">start from 1</span>
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
        send(x++) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;&#19979;&#19968;&#20010;&#25968;&#23383;</span>
        delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453; 0.1 &#31186;</span>
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #98f5ff;">CoroutineScope.launchProcessor</span>(id: <span style="color: #98f5ff;">Int</span>, channel: <span style="color: #98f5ff;">ReceiveChannel&lt;Int&gt;</span>) = launch {
    <span style="color: #00bfff; font-weight: bold;">for</span> (msg <span style="color: #00bfff; font-weight: bold;">in</span> channel) {
        println(<span style="color: #deb887;">"Processor #</span><span style="color: #4eee94;">$id</span><span style="color: #deb887;"> received </span><span style="color: #4eee94;">$msg</span><span style="color: #deb887;">"</span>)
    }
}
</pre>
</div>

<p>
该输出将类似于如下所示，尽管接收每个特定整数的处理器 id 可能会不同：
</p>

<div class="org-src-container">
<pre class="src src-sh">Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">0 received 1</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">0 received 2</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">1 received 3</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">2 received 4</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">3 received 5</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">4 received 6</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">0 received 7</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">1 received 8</span>
Processor <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">2 received 9</span>
</pre>
</div>

<p>
注意：取消生产者协程将关闭它的通道，从而最终终止处理器协程正在执行的此通道上的迭代 
</p>

<pre class="example">
     注意如何使用 for 循环显式迭代通道以在 launchProcessor 代码中执行扇出，与 consumeEach 不同，这个 for 循环是安全完美地使用多个协程的

     如果其中一个处理器协程执行失败，其它的处理器协程仍然会继续处理通道，而通过 consumeEach 编写的处理器始终在正常或非正常完成时消耗（取消）底层通道 
</pre>
</div>
</div>
<div id="outline-container-org847fa9c" class="outline-3">
<h3 id="org847fa9c">fan in</h3>
<div class="outline-text-3" id="text-org847fa9c">
<p>
多个协程可以发送到同一个通道
</p>

<pre class="example">
     比如说，创建一个字符串的通道，和一个在这个通道中以指定的延迟反复发送一个指定字符串的挂起函数
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">suspend</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">sendString</span>(channel: <span style="color: #98f5ff;">SendChannel</span>, s: <span style="color: #98f5ff;">String</span>, time: <span style="color: #98f5ff;">Long</span>) {
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
        delay(time)
        channel.send(s)
    }
}
</pre>
</div>

<p>
现在，启动了几个发送字符串的协程，看看会发生什么：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.cancelChildren</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.Channel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.SendChannel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">channel</span> = <span style="color: #98f5ff;">Channel&lt;String&gt;</span>()
    launch {
        sendString(channel, <span style="color: #deb887;">"foo"</span>, 200L)
    }

    launch {
        sendString(channel, <span style="color: #deb887;">"BAR!"</span>, 500L)
    }

    repeat(6) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25509;&#25910;&#21069;&#20845;&#20010;</span>
        println(channel.receive())
    }
    coroutineContext.cancelChildren() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#25152;&#26377;&#23376;&#21327;&#31243;&#26469;&#35753;&#20027;&#21327;&#31243;&#32467;&#26463;</span>
}

<span style="color: #00bfff; font-weight: bold;">suspend</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">sendString</span>(channel: <span style="color: #98f5ff;">SendChannel&lt;String&gt;</span>, s: <span style="color: #98f5ff;">String</span>, time: <span style="color: #98f5ff;">Long</span>) {
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
        delay(time)
        channel.send(s)
    }
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">foo
foo
BAR!
foo
foo
BAR!
</pre>
</div>

<pre class="example">
     在示例中，在主线程的上下文中作为主协程的子协程来启动它们
</pre>
</div>
</div>
</div>
<div id="outline-container-orga97805c" class="outline-2">
<h2 id="orga97805c">带缓冲的通道</h2>
<div class="outline-text-2" id="text-orga97805c">
<p>
到目前为止展示的通道都是没有缓冲区的。无缓冲的通道在发送者和接收者相遇时传输元素：
</p>
<ul class="org-ul">
<li>如果发送先被调用，则它将被挂起直到接收被调用</li>
<li>如果接收先被调用，它将被挂起直到发送被调用</li>
</ul>

<pre class="example">
aka rendezvous 这句话应该是个俚语，意思好像是“又是约会”的意思
</pre>

<p>
Channel() 工厂函数与 produce 建造器通过一个可选的参数 <span class="underline">capacity</span> 来指定 <b>缓冲区大小</b>  。缓冲允许发送者在被挂起前发送多个元素
</p>

<pre class="example">
     就像 BlockingQueue 有指定的容量一样，当缓冲区被占满的时候将会引起阻塞
</pre>

<p>
使用缓冲通道并给 capacity 参数传入 4：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.Channel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">channel</span> = <span style="color: #98f5ff;">Channel&lt;Int&gt;</span>(4) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#24102;&#32531;&#20914;&#30340;&#36890;&#36947;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">sender</span> = launch { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#21457;&#36865;&#32773;&#21327;&#31243;</span>
                          repeat(10) {
                              println(<span style="color: #deb887;">"Sending </span><span style="color: #4eee94;">$it</span><span style="color: #deb887;">"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#27599;&#19968;&#20010;&#20803;&#32032;&#21457;&#36865;&#21069;&#25171;&#21360;&#23427;&#20204;</span>
                              channel.send(<span style="color: #00bfff; font-weight: bold;">it</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#22312;&#32531;&#20914;&#21306;&#34987;&#21344;&#28385;&#26102;&#25346;&#36215;</span>
                          }
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#26377;&#25509;&#25910;&#21040;&#19996;&#35199;&#8230;&#8230;&#21482;&#26159;&#31561;&#24453;&#8230;&#8230;</span>
    delay(1000)
    sender.cancel() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#21457;&#36865;&#32773;&#21327;&#31243;</span>
}
</pre>
</div>

<p>
它将打印“sending” 5 次：
</p>

<div class="org-src-container">
<pre class="src src-sh">Sending 0
Sending 1
Sending 2
Sending 3
Sending 4
</pre>
</div>

<pre class="example">
    前四个元素被加入到了缓冲区并且发送者在试图发送第五个元素的时候被挂起
</pre>
</div>
</div>
<div id="outline-container-org18ea520" class="outline-2">
<h2 id="org18ea520">通道是公平的</h2>
<div class="outline-text-2" id="text-org18ea520">
<p>
发送和接收操作是 <b>公平的</b> 并且尊重调用它们的多个协程。它们遵守 <span class="underline">先进先出</span> 原则，可以看到第一个协程调用 receive 并得到了元素
</p>

<pre class="example">
    在下面的例子中两个协程“乒”和“乓”都从共享的“桌子”通道接收到这个“球”元素
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.cancelChildren</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.Channel</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">data</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Ball</span>(<span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">hits</span>: <span style="color: #98f5ff;">Int</span>)

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">table</span> = <span style="color: #98f5ff;">Channel&lt;Ball&gt;</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19968;&#20010;&#20849;&#20139;&#30340; table&#65288;&#26700;&#23376;&#65289;</span>
    launch {
        player(<span style="color: #deb887;">"ping"</span>, table)
    }

    launch {
        player(<span style="color: #deb887;">"pong"</span>, table)
    }

    table.send(<span style="color: #98f5ff;">Ball</span>(0)) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20050;&#20051;&#29699;</span>
    delay(1000) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24310;&#36831; 1 &#31186;&#38047;</span>
    coroutineContext.cancelChildren() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#28216;&#25103;&#32467;&#26463;&#65292;&#21462;&#28040;&#23427;&#20204;</span>
}

<span style="color: #00bfff; font-weight: bold;">suspend</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">player</span>(name: <span style="color: #98f5ff;">String</span>, table: <span style="color: #98f5ff;">Channel&lt;Ball&gt;</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (ball <span style="color: #00bfff; font-weight: bold;">in</span> table) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#24490;&#29615;&#20013;&#25509;&#25910;&#29699;</span>
        ball.hits++
        println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$name</span><span style="color: #deb887;"> </span><span style="color: #4eee94;">$ball</span><span style="color: #deb887;">"</span>)
        delay(300) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#19968;&#27573;&#26102;&#38388;</span>
        table.send(ball) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#29699;&#21457;&#36865;&#22238;&#21435;</span>
    }
}
</pre>
</div>

<p>
“乒”协程首先被启动，所以它首先接收到了球。甚至虽然“乒” 协程在将球发送会桌子以后立即开始接收，但是球还是被“乓” 协程接收了，因为它一直在等待着接收球
</p>

<div class="org-src-container">
<pre class="src src-sh">ping Ball(<span style="color: #4eee94;">hits</span>=1)
pong Ball(<span style="color: #4eee94;">hits</span>=2)
ping Ball(<span style="color: #4eee94;">hits</span>=3)
pong Ball(<span style="color: #4eee94;">hits</span>=4)
</pre>
</div>

<pre class="example">
    注意：有时候通道执行时由于执行者的性质而看起来不那么公平
</pre>
</div>
</div>
<div id="outline-container-org3fc70b3" class="outline-2">
<h2 id="org3fc70b3">计时器通道</h2>
<div class="outline-text-2" id="text-org3fc70b3">
<p>
<span class="underline">计时器通道</span> 是一种特别的会合通道，每次经过 <b>特定的延迟</b> 都会从该 <span class="underline">通道</span> 进行 <b>消费</b> 并 <b>产生</b> <span class="underline">Unit</span> 
</p>

<pre class="example">
    虽然它看起来似乎没用，它被用来构建分段来创建复杂的基于时间的 produce 管道和进行窗口化操作以及其它时间相关的处理

    可以在 select 中使用计时器通道来进行“打勾”操作
</pre>

<p>
使用工厂方法 <span class="underline">ticker</span> 来创建这些通道。 为了表明不需要其它元素，请使用 <span class="underline">ReceiveChannel.cancel</span> 方法：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.channels.ticker</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.withTimeoutOrNull</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">tickerChannel</span> = ticker(delayMillis = 100, initialDelayMillis = 0) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#35745;&#26102;&#22120;&#36890;&#36947;</span>
    <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">nextElement</span> = withTimeoutOrNull(1) {
        tickerChannel.receive()
    }
    println(<span style="color: #deb887;">"Initial element is available immediately: </span><span style="color: #4eee94;">$nextElement</span><span style="color: #deb887;">"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21021;&#22987;&#23578;&#26410;&#32463;&#36807;&#30340;&#24310;&#36831;</span>
    nextElement = withTimeoutOrNull(50) {
        tickerChannel.receive()
    } 
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25152;&#26377;&#38543;&#21518;&#21040;&#26469;&#30340;&#20803;&#32032;&#37117;&#32463;&#36807;&#20102; 100 &#27627;&#31186;&#30340;&#24310;&#36831;</span>
    println(<span style="color: #deb887;">"Next element is not ready in 50 ms: </span><span style="color: #4eee94;">$nextElement</span><span style="color: #deb887;">"</span>)
    nextElement = withTimeoutOrNull(60) {
        tickerChannel.receive()
    }
    println(<span style="color: #deb887;">"Next element is ready in 100 ms: </span><span style="color: #4eee94;">$nextElement</span><span style="color: #deb887;">"</span>) 
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#25311;&#22823;&#37327;&#28040;&#36153;&#24310;&#36831;</span>
    println(<span style="color: #deb887;">"Consumer pauses for 150ms"</span>)
    delay(150) 
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19979;&#19968;&#20010;&#20803;&#32032;&#31435;&#21363;&#21487;&#29992;</span>
    nextElement = withTimeoutOrNull(1) {
        tickerChannel.receive()
    }
    println(<span style="color: #deb887;">"Next element is available immediately after large consumer delay: </span><span style="color: #4eee94;">$nextElement</span><span style="color: #deb887;">"</span>)
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35831;&#27880;&#24847;&#65292;`receive` &#35843;&#29992;&#20043;&#38388;&#30340;&#26242;&#20572;&#34987;&#32771;&#34385;&#22312;&#20869;&#65292;&#19979;&#19968;&#20010;&#20803;&#32032;&#30340;&#21040;&#36798;&#36895;&#24230;&#26356;&#24555;</span>
    nextElement = withTimeoutOrNull(60) {
        tickerChannel.receive()
    }
    println(<span style="color: #deb887;">"Next element is ready in 50ms after consumer pause in 150ms: </span><span style="color: #4eee94;">$nextElement</span><span style="color: #deb887;">"</span>)
    tickerChannel.cancel() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#34920;&#26126;&#19981;&#20877;&#38656;&#35201;&#26356;&#22810;&#30340;&#20803;&#32032;</span>
}
</pre>
</div>

<p>
它的打印如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Initial element is available immediately: kotlin.Unit
Next element is not ready<span style="color: #00bfff; font-weight: bold;"> in</span> 50 ms: null
Next element is ready<span style="color: #00bfff; font-weight: bold;"> in</span> 100 ms: kotlin.Unit
Consumer pauses for 150ms
Next element is available immediately after large consumer delay: kotlin.Unit
Next element is ready<span style="color: #00bfff; font-weight: bold;"> in</span> 50ms after consumer pause<span style="color: #00bfff; font-weight: bold;"> in</span> 150ms: kotlin.Unit
</pre>
</div>


<pre class="example">
    请注意，ticker 知道可能的消费者暂停，并且默认情况下会调整下一个生成的元素如果发生暂停则延迟，试图保持固定的生成元素率
</pre>

<p>
给可选的 mode 参数传入 TickerMode.FIXED<sub>DELAY</sub> 可以保持固定元素之间的延迟
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="exception.html">Next：异常处理</a></td>
<td class="org-left"><a href="flow.html">Previous：异步流</a></td>
<td class="org-left"><a href="coroutine.html">Home：协程</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
