<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>上下文与调度器</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./combination.html"> UP </a>
 |
 <a accesskey="H" href="./coroutine.html"> HOME </a>
</div><div id="content">
<h1 class="title">上下文与调度器</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3de0396">协程调度器</a></li>
<li><a href="#org1da26dc">非受限调度器</a></li>
<li><a href="#org96ac00a">调试协程与线程</a>
<ul>
<li><a href="#orgfc1d307">在不同线程间跳转</a></li>
</ul>
</li>
<li><a href="#org761b854">上下文中的作业</a></li>
<li><a href="#org37592d8">子协程</a></li>
<li><a href="#orgb88804c">父协程</a></li>
<li><a href="#org357cdfc">命名协程</a></li>
<li><a href="#orgeb016db">组合上下文中的元素</a></li>
<li><a href="#org12bb01b">协程作用域</a></li>
<li><a href="#org80cbe9a">线程局部数据</a></li>
</ul>
</div>
</div>
<p>
协程总是运行在一些以 <span class="underline">CoroutineContext</span> 类型为代表的上下文中
</p>

<pre class="example">
  这些上下文被定义在了 Kotlin 的标准库里，它是各种不同元素的集合，其中主元素是协程中的 Job
</pre>

<p>
接下来将对它的调度器进行介绍
</p>
<div id="outline-container-org3de0396" class="outline-2">
<h2 id="org3de0396">协程调度器</h2>
<div class="outline-text-2" id="text-org3de0396">
<p>
<span class="underline">协程上下文</span> 包含一个 <b>协程调度器</b> ，它确定了哪些 <span class="underline">线程</span> 或与线程相对应的协程执行。协程调度器可以：
</p>
<ul class="org-ul">
<li>将协程限制在一个特定的线程执行</li>
<li>或将它分派到一个线程池</li>
<li>亦或是让它不受限地运行</li>
</ul>

<p>
所有的协程构建器诸如 <span class="underline">launch</span> 和 <span class="underline">async</span> 接收一个 <b>可选</b> 的 <span class="underline">CoroutineContext</span> 参数，它可以被用来 <b>显式</b> 的为一个新协程或其它上下文元素指定一个 <span class="underline">调度器</span> 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.Dispatchers</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.newSingleThreadContext</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    launch {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36816;&#34892;&#22312;&#29238;&#21327;&#31243;&#30340;&#19978;&#19979;&#25991;&#20013;&#65292;&#21363; runBlocking &#20027;&#21327;&#31243;</span>
        println(<span style="color: #deb887;">"main runBlocking : I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }
    launch(<span style="color: #98f5ff;">Dispatchers.Unconfined</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#21463;&#38480;&#30340;&#65306;&#23558;&#24037;&#20316;&#22312;&#20027;&#32447;&#31243;&#20013;</span>
        println(<span style="color: #deb887;">"Unconfined : I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }
    launch(<span style="color: #98f5ff;">Dispatchers.Default</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#20250;&#33719;&#21462;&#40664;&#35748;&#35843;&#24230;&#22120;</span>
        println(<span style="color: #deb887;">"Default : I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }
    launch(newSingleThreadContext(<span style="color: #deb887;">"MyOwnThread"</span>)) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#20351;&#23427;&#33719;&#24471;&#19968;&#20010;&#26032;&#30340;&#32447;&#31243;</span>
        println(<span style="color: #deb887;">"newSingleThreadContext: I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }
}
</pre>
</div>

<p>
它执行后得到了如下输出（也许顺序会有所不同）：
</p>

<div class="org-src-container">
<pre class="src src-sh">Unconfined : I<span style="color: #deb887;">'m working in thread main</span>
<span style="color: #deb887;">Default : I'</span>m working<span style="color: #00bfff; font-weight: bold;"> in</span> thread DefaultDispatcher-worker-1
main runBlocking : I<span style="color: #deb887;">'m working in thread main</span>
<span style="color: #deb887;">newSingleThreadContext: I'</span>m working<span style="color: #00bfff; font-weight: bold;"> in</span> thread MyOwnThread
</pre>
</div>

<p>
当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）
</p>

<pre class="example">
    在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文
</pre>
<ul class="org-ul">
<li><p>
<span class="underline">Dispatchers.Unconfined</span> 是一个特殊的调度器且似乎也运行在 main 线程中
</p>
<pre class="example">
      但实际上， 它是一种不同的机制，接下来会。
</pre></li>
<li><p>
<span class="underline">Dispatchers.Default</span> : 默认调度器，当协程在 GlobalScope 中启动的时候使用， 它代表 Dispatchers.Default 使用了 <b>共享</b> 的 <span class="underline">后台线程池</span> 
</p>
<pre class="example">
      所以 GlobalScope.launch { …… } 也可以使用相同的调度器: launch(Dispatchers.Default) { …… }
</pre></li>
<li><p>
<span class="underline">newSingleThreadContext</span> : 为协程的运行 <b>启动</b> 了一个 <span class="underline">线程</span> 
</p>
<pre class="example">
      一个专用的线程是一种非常昂贵的资源

      在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org1da26dc" class="outline-2">
<h2 id="org1da26dc">非受限调度器</h2>
<div class="outline-text-2" id="text-org1da26dc">
<p>
<span class="underline">Dispatchers.Unconfined</span> :
</p>
<ul class="org-ul">
<li><p>
协程调度器在调用它的线程启动了一个协程，但它仅仅只是运行到第一个挂起点。挂起后，它恢复线程中的协程，而这完全由被调用的挂起函数来决定
</p>
<pre class="example">
      非受限的调度器非常适用于执行不消耗 CPU 时间的任务，以及不更新局限于特定线程的任何共享数据（如UI）的协程
</pre></li>
<li><p>
另一方面，该调度器默认继承了外部的 CoroutineScope
</p>
<pre class="example">
      比如 runBlocking 协程的默认调度器，当它被限制在了调用者线程时，继承自它将会有效地限制协程在该线程运行并且具有可预测的 FIFO 调度
</pre></li>
</ul>


<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.Dispatchers</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>


<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>():<span style="color: #98f5ff;">Unit</span> = runBlocking {
    launch(<span style="color: #98f5ff;">Dispatchers.Unconfined</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38750;&#21463;&#38480;&#30340;: &#23558;&#21644;&#20027;&#32447;&#31243;&#19968;&#36215;&#24037;&#20316;</span>
        println(<span style="color: #deb887;">"Unconfined : I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
        delay(500)
        println(<span style="color: #deb887;">"Unconfined : After delay in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }

    launch {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#21327;&#31243;&#30340;&#19978;&#19979;&#25991;&#65292;&#20027; runBlocking &#21327;&#31243;</span>
        println(<span style="color: #deb887;">"main runBlocking: I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
        delay(1000)
        println(<span style="color: #deb887;">"main runBlocking: After delay in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }
} 
</pre>
</div>

<p>
执行后的输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">Unconfined      : I<span style="color: #deb887;">'m working in thread main</span>
<span style="color: #deb887;">main runBlocking: I'</span>m working<span style="color: #00bfff; font-weight: bold;"> in</span> thread main
Unconfined      : After delay<span style="color: #00bfff; font-weight: bold;"> in</span> thread kotlinx.coroutines.DefaultExecutor
main runBlocking: After delay<span style="color: #00bfff; font-weight: bold;"> in</span> thread main
</pre>
</div>

<p>
该协程的上下文继承自 runBlocking {&#x2026;} 协程并在 main 线程中运行，当 delay 函数调用的时候，非受限的那个协程在默认的执行者线程中恢复执行 
</p>

<pre class="example">
    非受限的调度器是一种高级机制：可以在某些极端情况下提供帮助而不需要调度协程以便稍后执行或产生不希望的副作用，因为某些操作必须立即在协程中执行

    非受限调度器不应该在通常的代码中使用
</pre>
</div>
</div>
<div id="outline-container-org96ac00a" class="outline-2">
<h2 id="org96ac00a">调试协程与线程</h2>
<div class="outline-text-2" id="text-org96ac00a">
<p>
协程可以在一个线程上挂起并在其它线程上恢复。甚至一个单线程的调度器也是难以弄清楚协程在何时何地正在做什么事情
</p>

<pre class="example">
    使用通常调试应用程序的方法是让线程在每一个日志文件的日志声明中打印线程的名字，这种特性在日志框架中是普遍受支持的

    但是在使用协程时，单独的线程名称不会给出很多协程上下文信息，所以 kotlinx.coroutines 包含了调试工具来让它更简单
</pre>

<p>
使用 <span class="underline">-Dkotlinx.coroutines.debug JVM</span> 参数运行下面的代码：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.async</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">log</span>(msg: <span style="color: #98f5ff;">String</span>) = println(<span style="color: #deb887;">"[${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}] </span><span style="color: #4eee94;">$msg</span><span style="color: #deb887;">"</span>)

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>(): <span style="color: #98f5ff;">Unit</span> = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">a</span> = async {
        log(<span style="color: #deb887;">"I'm computing a piece of the answer"</span>)
        6
    }
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">b</span> = async {
        log(<span style="color: #deb887;">"I'm computing another piece of the answer"</span>)
        7
    }
    log(<span style="color: #deb887;">"The answer is ${</span>a.await() * b.await()<span style="color: #deb887;">}"</span>)
} 
</pre>
</div>

<p>
这里有三个协程，包括：
</p>
<ol class="org-ol">
<li>runBlocking 内的主协程 (#1)</li>
<li>计算延期的值的协程 a (#2)</li>
<li>计算延期的值的协程 b (#3)</li>
</ol>

<p>
它们都在 runBlocking 上下文中执行并且被限制在了主线程内。 这段代码的输出如下： 
</p>

<div class="org-src-container">
<pre class="src src-sh">[main @coroutine#2] I<span style="color: #deb887;">'m computing a piece of the answer</span>
<span style="color: #deb887;">[main @coroutine#3] I'</span>m computing another piece of the answer
[main @coroutine#1] The answer is 42
</pre>
</div>

<p>
这个 log 函数在方括号种打印了线程的名字，并且可以看到它是 main 线程，并且附带了当前正在其上执行的协程的标识符。这个标识符在调试模式开启时，将连续分配给所有创建的协程 
</p>

<pre class="example">
    当 JVM 以 -ea 参数配置运行时，调试模式也会开启
</pre>
</div>

<div id="outline-container-orgfc1d307" class="outline-3">
<h3 id="orgfc1d307">在不同线程间跳转</h3>
<div class="outline-text-3" id="text-orgfc1d307">
<p>
使用 -Dkotlinx.coroutines.debug JVM 参数运行下面的代码：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.newSingleThreadContext</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.withContext</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
    newSingleThreadContext(<span style="color: #deb887;">"Ctx1"</span>).use { ctx1 -&gt;
        newSingleThreadContext(<span style="color: #deb887;">"Ctx2"</span>).use { ctx2 -&gt;
            runBlocking(ctx1) {
                log(<span style="color: #deb887;">"Started in ctx1"</span>)
                withContext(ctx2) {
                    log(<span style="color: #deb887;">"Working in ctx2"</span>)
                }
                log(<span style="color: #deb887;">"Back to ctx1"</span>)
            }
        }
    }
}
</pre>
</div>

<p>
它演示了一些新技术。使用 <span class="underline">runBlocking</span> 来 <b>显式指定</b> 了一个 <span class="underline">上下文</span> ，并且使用 <span class="underline">withContext</span> 函数来 <b>改变</b> 协程的 <span class="underline">上下文</span> ，而仍然驻留在相同的协程中，正如可以在下面的输出中所见到的：
</p>

<div class="org-src-container">
<pre class="src src-sh">[Ctx1 @coroutine#1] Started<span style="color: #00bfff; font-weight: bold;"> in</span> ctx1
[Ctx2 @coroutine#1] Working<span style="color: #00bfff; font-weight: bold;"> in</span> ctx2
[Ctx1 @coroutine#1] Back to ctx1
</pre>
</div>

<pre class="example">
     注意，在这个例子中，当不再需要某个在 newSingleThreadContext 中创建的线程的时候， 它使用了 Kotlin 标准库中的 use 函数来释放该线程
</pre>
</div>
</div>
</div>

<div id="outline-container-org761b854" class="outline-2">
<h2 id="org761b854">上下文中的作业</h2>
<div class="outline-text-2" id="text-org761b854">
<p>
协程的 Job 是上下文的一部分，并且可以使用 <span class="underline">coroutineContext [Job]</span> 表达式在上下文中检索它：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.Job</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    println(<span style="color: #deb887;">"My job is ${</span>coroutineContext[<span style="color: #98f5ff;">Job</span>]<span style="color: #deb887;">}"</span>)
} 
</pre>
</div>

<p>
在调试模式下，它将输出如下这些信息：
</p>

<div class="org-src-container">
<pre class="src src-sh">My job is <span style="color: #deb887;">"coroutine#1"</span>:BlockingCoroutine{Active}@6d311334
</pre>
</div>

<pre class="example">
    请注意，CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式
</pre>
</div>
</div>

<div id="outline-container-org37592d8" class="outline-2">
<h2 id="org37592d8">子协程</h2>
<div class="outline-text-2" id="text-org37592d8">
<p>
当一个协程被其它协程在 CoroutineScope 中启动的时候， 它将通过 CoroutineScope.coroutineContext 来承袭上下文，并且这个新协程的 Job 将会成为父协程作业的 <span class="underline">子</span> 作业：
</p>
<ul class="org-ul">
<li>当一个父协程被取消的时候，所有它的子协程也会被 <b>递归</b> 地取消</li>
<li><p>
然当使用 GlobalScope 来启动一个协程时，则新协程的作业 <b>没有</b> 父作业
</p>
<pre class="example">
      因此它与这个启动的作用域无关且独立运作
</pre></li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.GlobalScope</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#19968;&#20010;&#21327;&#31243;&#26469;&#22788;&#29702;&#26576;&#31181;&#20256;&#20837;&#35831;&#27714;&#65288;request&#65289;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">request</span> = launch {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23413;&#21270;&#20102;&#20004;&#20010;&#23376;&#20316;&#19994;, &#20854;&#20013;&#19968;&#20010;&#36890;&#36807; GlobalScope &#21551;&#21160;</span>
        <span style="color: #98f5ff;">GlobalScope.launch</span> {
            println(<span style="color: #deb887;">"job1: I run in GlobalScope and execute independently!"</span>)
            delay(1000)
            println(<span style="color: #deb887;">"job1: I am not affected by cancellation of the request"</span>)
        }
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21478;&#19968;&#20010;&#21017;&#25215;&#34989;&#20102;&#29238;&#21327;&#31243;&#30340;&#19978;&#19979;&#25991;</span>
        launch {
            delay(100)
            println(<span style="color: #deb887;">"job2: I am a child of the request coroutine"</span>)
            delay(1000)
            println(<span style="color: #deb887;">"job2: I will not execute this line if my parent request is cancelled"</span>)
        }
    }
    delay(500)
    request.cancel() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#35831;&#27714;&#65288;request&#65289;&#30340;&#25191;&#34892;</span>
    delay(1000) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24310;&#36831;&#19968;&#31186;&#38047;&#26469;&#30475;&#30475;&#21457;&#29983;&#20102;&#20160;&#20040;</span>
    println(<span style="color: #deb887;">"main: Who has survived request cancellation?"</span>)
}
</pre>
</div>

<p>
这段代码的输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">job1: I run<span style="color: #00bfff; font-weight: bold;"> in</span> GlobalScope and execute independently!
job2: I am a child of the request coroutine
job1: I am not affected by cancellation of the request
main: Who has survived request cancellation?
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb88804c" class="outline-2">
<h2 id="orgb88804c">父协程</h2>
<div class="outline-text-2" id="text-orgb88804c">
<p>
一个父协程总是 <b>等待</b> 所有的 <span class="underline">子协程</span> 执行 <span class="underline">结束</span> 。父协程并不显式的跟踪所有子协程的启动，并且不必使用 Job.join 在最后的时候等待它们：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#19968;&#20010;&#21327;&#31243;&#26469;&#22788;&#29702;&#26576;&#31181;&#20256;&#20837;&#35831;&#27714;&#65288;request&#65289;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">request</span> = launch {
        repeat(3) { i -&gt;
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#23569;&#37327;&#30340;&#23376;&#20316;&#19994;</span>
            launch {
                delay((i + 1) * 200L) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24310;&#36831; 200 &#27627;&#31186;&#12289;400 &#27627;&#31186;&#12289;600 &#27627;&#31186;&#30340;&#26102;&#38388;</span>
                println(<span style="color: #deb887;">"Coroutine </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;"> is done"</span>)
            }
        }
        println(<span style="color: #deb887;">"request: I'm done and I don't explicitly join my children that are still active"</span>)
    }
    request.join() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#35831;&#27714;&#30340;&#23436;&#25104;&#65292;&#21253;&#25324;&#20854;&#25152;&#26377;&#23376;&#21327;&#31243;</span>
    println(<span style="color: #deb887;">"Now processing of the request is complete"</span>)
}
</pre>
</div>

<p>
结果如下所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">request: I<span style="color: #deb887;">'m done and I don'</span>t explicitly join my children that are still active
Coroutine 0 is done
Coroutine 1 is done
Coroutine 2 is done
Now processing of the request is complete
</pre>
</div>
</div>
</div>

<div id="outline-container-org357cdfc" class="outline-2">
<h2 id="org357cdfc">命名协程</h2>
<div class="outline-text-2" id="text-org357cdfc">
<pre class="example">
    当协程经常打印日志并且只需要关联来自同一个协程的日志记录时， 则自动分配的 id 是非常好的

    然而，当一个协程与特定请求的处理相关联时或做一些特定的后台任务，最好将其明确命名以用于调试目的
</pre>
<p>
<span class="underline">CoroutineName</span> 上下文元素与线程名具有相同的目的。当调试模式开启时，它被包含在正在执行此协程的线程名中 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineName</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.async</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>(): <span style="color: #98f5ff;">Unit</span> = runBlocking(<span style="color: #98f5ff;">CoroutineName</span>(<span style="color: #deb887;">"main"</span>)) {
    log(<span style="color: #deb887;">"Started main coroutine"</span>)
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36816;&#34892;&#20004;&#20010;&#21518;&#21488;&#20540;&#35745;&#31639;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">v1</span> = async(<span style="color: #98f5ff;">CoroutineName</span>(<span style="color: #deb887;">"v1coroutine"</span>)) {
        delay(500)
        log(<span style="color: #deb887;">"Computing v1"</span>)
        252
    }
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">v2</span> = async(<span style="color: #98f5ff;">CoroutineName</span>(<span style="color: #deb887;">"v2coroutine"</span>)) {
        delay(1000)
        log(<span style="color: #deb887;">"Computing v2"</span>)
        6
    }
    log(<span style="color: #deb887;">"The answer for v1 / v2 = ${</span>v1.await() / v2.await()<span style="color: #deb887;">}"</span>)
} 
</pre>
</div>

<p>
程序执行使用了 <span class="underline">-Dkotlinx.coroutines.debug</span> JVM 参数，输出如下所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">[main @main#1] Started main coroutine
[main @v1coroutine#2] Computing v1
[main @v2coroutine#3] Computing v2
[main @main#1] The answer for v1 / v2 = 42
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeb016db" class="outline-2">
<h2 id="orgeb016db">组合上下文中的元素</h2>
<div class="outline-text-2" id="text-orgeb016db">
<p>
有时需要在协程上下文中定义多个元素。可以使用 <span class="underline">+</span> 操作符来实现
</p>

<pre class="example">
    比如说，们可以显式指定一个调度器来启动协程并且同时显式指定一个命名
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.CoroutineName</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.Dispatchers</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>(): <span style="color: #98f5ff;">Unit</span> = runBlocking {
    launch(<span style="color: #98f5ff;">Dispatchers.Default</span> + <span style="color: #98f5ff;">CoroutineName</span>(<span style="color: #deb887;">"test"</span>)) {
        println(<span style="color: #deb887;">"I'm working in thread ${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}"</span>)
    }
}
</pre>
</div>

<p>
这段代码使用了 <span class="underline">-Dkotlinx.coroutines.debug</span> JVM 参数，输出如下所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">I<span style="color: #deb887;">'m working in thread DefaultDispatcher-worker-1 @test#2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org12bb01b" class="outline-2">
<h2 id="org12bb01b">协程作用域</h2>
<div class="outline-text-2" id="text-org12bb01b">
<p>
接下来将关于上下文，子协程以及作业的知识综合在一起
</p>

<pre class="example">
    假设应用程序拥有一个具有生命周期的对象，但这个对象并不是一个协程

    举例来说，编写了一个 Android 应用程序并在 Android 的 activity 上下文中启动了一组协程来使用异步操作拉取并更新数据以及执行动画等等

    所有这些协程必须在这个 activity 销毁的时候取消以避免内存泄漏

    当然也可以手动操作上下文与作业，以结合 activity 的生命周期与它的协程，但是 kotlinx.coroutines 提供了一个封装：CoroutineScope 的抽象

    我们应该已经熟悉了协程作用域，因为所有的协程构建器都声明为在它之上的扩展
</pre>

<p>
通过创建一个 <span class="underline">CoroutineScope</span> 实例来管理协程的生命周期，并使它与 <span class="underline">activit</span> 的生命周期相关联。CoroutineScope 可以通过 <span class="underline">CoroutineScope()</span> 创建或者通过 <span class="underline">MainScope()</span> 工厂函数
</p>

<pre class="example">
    前者创建了一个通用作用域

    后者为使用 Dispatchers.Main 作为默认调度器的 UI 应用程序 创建作用域
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Activity</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">mainScope</span> = <span style="color: #98f5ff;">MainScope</span>()
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">destroy</span>() {
        mainScope.cancel()
    } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#32487;&#32493;&#36816;&#34892;&#8230;&#8230;</span>
}
</pre>
</div>


<p>
或者，可以在这个 Activity 类中实现 CoroutineScope 接口。最好的方法是使用具有 <span class="underline">默认工厂函数</span> 的 <b>委托</b> 。 我们也可以将所需的调度器与作用域合并（我们在这个示例中使用 Dispatchers.Default）。
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Activity</span> : <span style="color: #98f5ff;">CoroutineScope</span> <span style="color: #00bfff; font-weight: bold;">by</span> <span style="color: #98f5ff;">CoroutineScope</span>(<span style="color: #98f5ff;">Dispatchers.Default</span>) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#32487;&#32493;&#36816;&#34892;&#8230;&#8230; </span>
</pre>
</div>

<pre class="example">
    现在可以在这个 Activity 的作用域中启动协程，且没有明确指定它们的上下文
</pre>
<p>
接下来启动了十个协程并延迟不同的时间：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312; Activity &#31867;&#20013;</span>
<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">doSomething</span>() {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#31034;&#20363;&#20013;&#21551;&#21160;&#20102; 10 &#20010;&#21327;&#31243;&#65292;&#19988;&#27599;&#20010;&#37117;&#24037;&#20316;&#20102;&#19981;&#21516;&#30340;&#26102;&#38271;</span>
    repeat(10) {
        i -&gt; launch {
            delay((i + 1) * 200L) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24310;&#36831; 200 &#27627;&#31186;&#12289;400 &#27627;&#31186;&#12289;600 &#27627;&#31186;&#31561;&#31561;&#19981;&#21516;&#30340;&#26102;&#38388;</span>
            println(<span style="color: #deb887;">"Coroutine </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;"> is done"</span>)
        }
    }
}
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Activity &#31867;&#32467;&#26463; </span>
</pre>
</div>

<p>
在 main 函数中创建 activity，调用测试函数 doSomething，并且在 500 毫秒后销毁这个 activity
</p>

<pre class="example">
    这取消了从 doSomething 启动的所有协程

    可以观察到这些是由于在销毁之后， 即使再等一会儿，activity 也不再打印消息
</pre>

<p>
完整的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Activity</span> : <span style="color: #98f5ff;">CoroutineScope</span> <span style="color: #00bfff; font-weight: bold;">by</span> <span style="color: #98f5ff;">CoroutineScope</span>(<span style="color: #98f5ff;">Dispatchers.Default</span>) {
    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">destroy</span>() {
        cancel() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Extension on CoroutineScope</span>
    }

    <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">doSomething</span>() {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#31034;&#20363;&#20013;&#21551;&#21160;&#20102; 10 &#20010;&#21327;&#31243;&#65292;&#19988;&#27599;&#20010;&#37117;&#24037;&#20316;&#20102;&#19981;&#21516;&#30340;&#26102;&#38271;</span>
        repeat(10) { i -&gt;
            launch {
                delay((i + 1) * 200L) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24310;&#36831; 200 &#27627;&#31186;&#12289;400 &#27627;&#31186;&#12289;600 &#27627;&#31186;&#31561;&#31561;&#19981;&#21516;&#30340;&#26102;&#38388;</span>
                println(<span style="color: #deb887;">"Coroutine </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;"> is done"</span>)
            }
        }
    }
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Activity &#31867;&#32467;&#26463;</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">activity</span> = <span style="color: #98f5ff;">Activity</span>()
    activity.doSomething() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36816;&#34892;&#27979;&#35797;&#20989;&#25968;</span>
    println(<span style="color: #deb887;">"Launched coroutines"</span>)
    delay(500L) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24310;&#36831;&#21322;&#31186;&#38047;</span>
    println(<span style="color: #deb887;">"Destroying activity!"</span>)
    activity.destroy() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#25152;&#26377;&#30340;&#21327;&#31243;</span>
    delay(1000) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20026;&#20102;&#22312;&#35270;&#35273;&#19978;&#30830;&#35748;&#23427;&#20204;&#27809;&#26377;&#24037;&#20316;</span>
} 
</pre>
</div>

<p>
输出如下所示：
</p>
<div class="org-src-container">
<pre class="src src-sh">Launched coroutines
Coroutine 0 is done
Coroutine 1 is done
Destroying activity!
</pre>
</div>

<pre class="example">
    可以看到，只有前两个协程打印了消息，而另一个协程在 Activity.destroy() 中单次调用了 job.cancel()
</pre>
</div>
</div>

<div id="outline-container-org80cbe9a" class="outline-2">
<h2 id="org80cbe9a">线程局部数据</h2>
<div class="outline-text-2" id="text-org80cbe9a">
<pre class="example">
    有时，能够将一些线程局部数据传递到协程与协程之间是很方便的

    然而，由于它们不受任何特定线程的约束，如果手动完成，可能会导致出现样板代码
</pre>
<p>
<span class="underline">ThreadLocal</span> ，  <span class="underline">asContextElement</span> 扩展函数在这里会充当救兵。它创建了额外的上下文元素， 且保留给定 ThreadLocal 的值，并在每次协程切换其上下文时恢复它 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*

<span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">threadLocal</span> = <span style="color: #98f5ff;">ThreadLocal&lt;String?&gt;</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22768;&#26126;&#32447;&#31243;&#23616;&#37096;&#21464;&#37327;</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    threadLocal.<span style="color: #00bfff; font-weight: bold;">set</span>(<span style="color: #deb887;">"main"</span>)
    println(<span style="color: #deb887;">"Pre-main, current thread: ${</span><span style="color: #98f5ff;">Thread.currentThread</span>()<span style="color: #deb887;">}, thread local value: '${</span>threadLocal.<span style="color: #00bfff; font-weight: bold;">get</span>()<span style="color: #deb887;">}'"</span>)
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">job</span> = launch(<span style="color: #98f5ff;">Dispatchers.Default</span> + threadLocal.asContextElement(value = <span style="color: #deb887;">"launch"</span>)) {
        println(<span style="color: #deb887;">"Launch start, current thread: ${</span><span style="color: #98f5ff;">Thread.currentThread</span>()<span style="color: #deb887;">}, thread local value: '${</span>threadLocal.<span style="color: #00bfff; font-weight: bold;">get</span>()<span style="color: #deb887;">}'"</span>)
        yield()
        println(<span style="color: #deb887;">"After yield, current thread: ${</span><span style="color: #98f5ff;">Thread.currentThread</span>()<span style="color: #deb887;">}, thread local value: '${</span>threadLocal.<span style="color: #00bfff; font-weight: bold;">get</span>()<span style="color: #deb887;">}'"</span>)
    }
    job.join()
    println(<span style="color: #deb887;">"Post-main, current thread: ${</span><span style="color: #98f5ff;">Thread.currentThread</span>()<span style="color: #deb887;">}, thread local value: '${</span>threadLocal.<span style="color: #00bfff; font-weight: bold;">get</span>()<span style="color: #deb887;">}'"</span>)
}
</pre>
</div>

<pre class="example">
    在这个例子中使用 Dispatchers.Default 在后台线程池中启动了一个新的协程，所以它工作在线程池中的不同线程中，但它仍然具有线程局部变量的值

    指定使用 threadLocal.asContextElement(value = "launch")， 无论协程执行在什么线程中都是没有问题的
</pre>
<p>
因此，其输出如所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: <span style="color: #deb887;">'main'</span>
Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: <span style="color: #deb887;">'launch'</span>
After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: <span style="color: #deb887;">'launch'</span>
Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: <span style="color: #deb887;">'main'</span>
</pre>
</div>

<pre class="example">
    但这很容易忘记去设置相应的上下文元素

    如果运行协程的线程不同， 在协程中访问的线程局部变量则可能会产生意外的值

    为了避免这种情况，建议使用 ensurePresent 方法并且在不正确的使用时快速失败

</pre>
<p>
ThreadLocal 具有一流的支持，可以与任何 kotlinx.coroutines 提供的原语一起使用
</p>

<pre class="example">
    但它有一个关键限制，即：当一个线程局部变量变化时，则这个新值不会传播给协程调用者（因为上下文元素无法追踪所有 ThreadLocal 对象访问），并且下次挂起时更新的值将丢失
</pre>

<p>
所以不得不使用 <span class="underline">withContext</span> 在协程中更新线程局部变量
</p>

<pre class="example">
    另外，一个值可以存储在一个可变的域中，例如 class Counter(var i: Int)，但是就必须手动保证对对这个可变的属性正确地并发修改 

    对于高级的使用，例如，那些在内部使用线程局部传递数据的用于与日志记录 MDC 集成，以及事务上下文或任何其它库，可以参考 ThreadContextElement 接口的文档
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="flow.html">Next：异步流</a></td>
<td class="org-left"><a href="combination.html">Previous：组合挂起函数</a></td>
<td class="org-left"><a href="coroutine.html">Home：协程</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
