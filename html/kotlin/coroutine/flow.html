<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>异步流</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./scheduler.html"> UP </a>
 |
 <a accesskey="H" href="./coroutine.html"> HOME </a>
</div><div id="content">
<h1 class="title">异步流</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbb0ce32">表示多个值</a>
<ul>
<li><a href="#orgaf4da82">序列</a></li>
<li><a href="#org5795a4e">挂起</a></li>
<li><a href="#orgae7a2bd">流</a></li>
</ul>
</li>
<li><a href="#org201cabb">流是异步的</a></li>
<li><a href="#org2540ada">取消流</a></li>
<li><a href="#org8b026b5">流构建器</a></li>
<li><a href="#orgf1540ec">过渡流操作符</a>
<ul>
<li><a href="#orgc3e15b7">转换操作符</a></li>
<li><a href="#org273bddf">限长操作符</a></li>
</ul>
</li>
<li><a href="#org263ae97">末端流操作符</a></li>
<li><a href="#org7dd2745">流是连续的</a></li>
<li><a href="#org6a53612">流上下文</a>
<ul>
<li><a href="#orgb375e3d">withContext 发出错误</a></li>
<li><a href="#orgae9e9ec">flowOn 操作符</a></li>
</ul>
</li>
<li><a href="#org70939ad">缓冲</a>
<ul>
<li><a href="#orge8fbfe4">合并</a></li>
<li><a href="#org8f87842">处理最新值</a></li>
</ul>
</li>
<li><a href="#orgfa2504e">组合多个流</a>
<ul>
<li><a href="#orgb652f67">zip</a></li>
<li><a href="#org64a9e57">Combine</a></li>
</ul>
</li>
<li><a href="#org7b31137">流展平</a>
<ul>
<li><a href="#orge779abd">flatMapConcat</a></li>
<li><a href="#org5d88700">flatMapMerge</a></li>
<li><a href="#org0e5fe2f">flatMapLatest</a></li>
</ul>
</li>
<li><a href="#orgc1ef899">流异常</a>
<ul>
<li><a href="#orgf1c9831">收集器 try 与 catch</a></li>
<li><a href="#org92f4490">一切都已捕获</a></li>
</ul>
</li>
<li><a href="#orgf905472">异常透明性</a>
<ul>
<li><a href="#org3efbb41">异常逃逸</a></li>
<li><a href="#orgfb3bcba">声明式捕获</a></li>
</ul>
</li>
<li><a href="#orgb566d28">流完成</a>
<ul>
<li><a href="#org2287e6c">命令式 finally 块</a></li>
<li><a href="#org57b4df3">声明式处理</a>
<ul>
<li><a href="#org9c6f92b">仅限上游异常</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5afd9bd">流启动</a></li>
<li><a href="#org9538d77">流 与 响应式流</a></li>
</ul>
</div>
</div>
<p>
挂起函数可以异步的返回单个值，但是该如何异步返回多个计算好的值呢
</p>

<pre class="example">
  这正是 Kotlin 流（Flow）的用武之地
</pre>
<div id="outline-container-orgbb0ce32" class="outline-2">
<h2 id="orgbb0ce32">表示多个值</h2>
<div class="outline-text-2" id="text-orgbb0ce32">
<p>
在 Kotlin 中可以使用集合来表示多个值
</p>

<pre class="example">
    比如说，可以拥有一个函数 foo()，它返回一个包含三个数字的 List， 然后使用 forEach 打印它们
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">List&lt;Int&gt;</span> = listOf(1, 2, 3)

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    foo().forEach { value -&gt; println(value) } 
}
</pre>
</div>
</div>
<div id="outline-container-orgaf4da82" class="outline-3">
<h3 id="orgaf4da82">序列</h3>
<div class="outline-text-3" id="text-orgaf4da82">
<p>
如果使用一些消耗 CPU 资源的阻塞代码计算数字（每次计算需要 100 毫秒）那么可以使用 <span class="underline">Sequence</span> 来表示数字：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">Sequence&lt;Int&gt;</span> = sequence { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24207;&#21015;&#26500;&#24314;&#22120;</span>
                                      <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
                                          <span style="color: #98f5ff;">Thread.sleep</span>(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#27491;&#22312;&#35745;&#31639;</span>
                                          yield(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;&#19979;&#19968;&#20010;&#20540;</span>
                                      }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    foo().forEach { value -&gt; println(value) } 
}
</pre>
</div>


<pre class="example">
     这段代码输出相同的数字，但在打印每个数字之前等待 100 毫秒
</pre>
</div>
</div>
<div id="outline-container-org5795a4e" class="outline-3">
<h3 id="org5795a4e">挂起</h3>
<div class="outline-text-3" id="text-org5795a4e">
<pre class="example">
     然而，计算过程阻塞运行该代码的主线程
</pre>
<p>
当这些值由异步代码计算时，可以使用 <span class="underline">suspend</span> 修饰符标记函数 foo， 这样它就可以在 <b>不阻塞</b> 的情况下执行其工作并将结果作为列表返回：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*                 

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleStart</span>
<span style="color: #00bfff; font-weight: bold;">suspend</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">List&lt;Int&gt;</span> {
    delay(1000) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#22312;&#36825;&#37324;&#20570;&#20102;&#19968;&#20123;&#24322;&#27493;&#30340;&#20107;&#24773;</span>
    <span style="color: #00bfff; font-weight: bold;">return</span> listOf(1, 2, 3)
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> {
    foo().forEach { value -&gt; println(value) } 
}
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">sampleEnd</span>
</pre>
</div>

<pre class="example">
     这段代码将会在等待一秒之后打印数字
</pre>
</div>
</div>
<div id="outline-container-orgae7a2bd" class="outline-3">
<h3 id="orgae7a2bd">流</h3>
<div class="outline-text-3" id="text-orgae7a2bd">
<pre class="example">
     使用 List 结果类型，意味着只能一次返回所有值
</pre>

<p>
为了表示异步计算的值流 <span class="underline">stream</span> ，可以使用 <b>Flow</b> 类型（正如同步计算值会使用 Sequence 类型）： 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.launch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo3</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27969;&#26500;&#24314;&#22120;</span>
                               <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
                                   delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#22312;&#36825;&#37324;&#20570;&#20102;&#19968;&#20123;&#26377;&#29992;&#30340;&#20107;&#24773;</span>
                                   emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#36865;&#19979;&#19968;&#20010;&#20540;</span>
                               }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#24182;&#21457;&#30340;&#21327;&#31243;&#20197;&#39564;&#35777;&#20027;&#32447;&#31243;&#24182;&#26410;&#38459;&#22622;</span>
    launch {
        <span style="color: #00bfff; font-weight: bold;">for</span> (k <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
            println(<span style="color: #deb887;">"I'm not blocked </span><span style="color: #4eee94;">$k</span><span style="color: #deb887;">"</span>)
            delay(100)
        }
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25910;&#38598;&#36825;&#20010;&#27969;</span>
    foo3().collect { value -&gt; println(value) }
}
</pre>
</div>

<pre class="example">
     这段代码在不阻塞主线程的情况下每等待 100 毫秒打印一个数字

     在主线程中运行一个单独的协程每 100 毫秒打印一次 “I'm not blocked” 已经经过了验证
</pre>

<p>
输出如下： 
</p>

<div class="org-src-container">
<pre class="src src-sh">I<span style="color: #deb887;">'m not blocked 1</span>
<span style="color: #deb887;">1</span>
<span style="color: #deb887;">I'</span>m not blocked 2
2
I<span style="color: #deb887;">'m not blocked 3</span>
<span style="color: #deb887;">3</span>
</pre>
</div>

<p>
注意使用 Flow 的代码与先前示例的下述区别：
</p>
<ul class="org-ul">
<li>名为 <span class="underline">flow</span> 的 <b>Flow 类型构建器</b> 函数</li>
<li><span class="underline">flow { &#x2026; } 构建块</span> 中的代码 <b>可以挂起</b></li>
<li>函数 <span class="underline">foo</span> () <b>不再</b> 标有 <span class="underline">suspend</span> 修饰符</li>
<li>流使用 <span class="underline">emit</span> 函数 <b>发射</b> 值</li>
<li>流使用 <span class="underline">collect</span> 函数 <b>收集</b> 值</li>
</ul>

<pre class="example">
     可以在 foo 的 flow { ... } 函数体内使用 delay 代替 Thread.sleep 以观察主线程在本案例中被阻塞了
</pre>
</div>
</div>
</div>
<div id="outline-container-org201cabb" class="outline-2">
<h2 id="org201cabb">流是异步的</h2>
<div class="outline-text-2" id="text-org201cabb">
<p>
Flow 是一种类似于序列的异步流
</p>
<pre class="example">
flow 构建器中的代码直到流被收集的时候才运行
</pre>

<p>
这在以下的示例中非常明显：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo4</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    println(<span style="color: #deb887;">"Flow started"</span>)
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        delay(100)
        emit(i)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    println(<span style="color: #deb887;">"Calling foo..."</span>)
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">flow</span> = foo4()
    println(<span style="color: #deb887;">"Calling collect..."</span>)
    flow.collect { value -&gt; println(value) }
    println(<span style="color: #deb887;">"Calling collect again..."</span>)
    flow.collect { value -&gt; println(value) }
}
</pre>
</div>

<p>
输出如下： 
</p>

<div class="org-src-container">
<pre class="src src-sh">Calling foo...
Calling collect...
Flow started
1
2
3
Calling collect again...
Flow started
1
2
3
</pre>
</div>

<pre class="example">
    返回一个流的 foo() 函数没有标记 suspend 修饰符的主要原因：通过它自己，foo() 会尽快返回且不会进行任何等待


    流在每次收集的时候启动：当再次调用 collect 时会看到“Flow started”
</pre>
</div>
</div>
<div id="outline-container-org2540ada" class="outline-2">
<h2 id="org2540ada">取消流</h2>
<div class="outline-text-2" id="text-org2540ada">
<p>
流采用与协程同样的协作取消。然而，流的基础设施未引入其他取消点。取消完全透明
</p>

<pre class="example">
    像往常一样，流的收集只有在当流在一个可取消的挂起函数（例如 delay）中挂起的时候取消，否则不能取消
</pre>

<p>
下面的示例展示了当 withTimeoutOrNull 块中代码在运行的时候流是如何在超时的情况下取消并停止执行其代码的：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.withTimeoutOrNull</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo5</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        delay(100)
        println(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    withTimeoutOrNull(250) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312; 250 &#27627;&#31186;&#21518;&#36229;&#26102;</span>
                             foo5().collect { value -&gt; println(value) }
    }
    println(<span style="color: #deb887;">"Done"</span>)
}
</pre>
</div>

<p>
在 foo() 函数中流仅发射两个数字，产生以下输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">Emitting 1
1
Emitting 2
2
Done
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b026b5" class="outline-2">
<h2 id="org8b026b5">流构建器</h2>
<div class="outline-text-2" id="text-org8b026b5">
<pre class="example">
    先前示例中的 flow { ... } 构建器是最基础的一个
</pre>
<p>
还有其它构建器使流的声明更简单：
</p>
<ul class="org-ul">
<li><span class="underline">flowOf</span> 构建器定义了一个发射 <span class="underline">固定值</span> 集的流</li>
<li>使用 <span class="underline">.asFlow()</span> 扩展函数，可以将各种集合与序列转换为流</li>
</ul>

<p>
因此，从流中打印从 1 到 3 的数字的示例可以写成：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#19968;&#20010;&#25972;&#25968;&#21306;&#38388;&#36716;&#21270;&#20026;&#27969;</span>
    (1..3).asFlow().collect { value -&gt; println(value) }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf1540ec" class="outline-2">
<h2 id="orgf1540ec">过渡流操作符</h2>
<div class="outline-text-2" id="text-orgf1540ec">
<pre class="example">
    可以使用操作符转换流，就像使用集合与序列一样
</pre>

<p>
过渡操作符 <b>应用</b> 于 <span class="underline">上游流</span> ，并 <b>返回</b> <span class="underline">下游流</span> ，基础的操作符拥有相似的名字，比如 map 与 filter
</p>
<ul class="org-ul">
<li><p>
这些操作符也是冷操作符，就像流一样
</p>
<pre class="example">
      这类操作符本身不是挂起函数。它运行的速度很快，返回新的转换流的定义
</pre></li>
<li>流与序列的主要区别在于这些操作符中的代码 <b>可以</b> 调用 <span class="underline">挂起</span> 函数</li>
</ul>

<p>
举例来说，一个请求中的流可以使用 map 操作符映射出结果，即使执行一个长时间的请求操作也可以使用挂起函数来实现：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.map</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">suspend</span> <span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">performRequest</span>(request: <span style="color: #98f5ff;">Int</span>): <span style="color: #98f5ff;">String</span> {
    delay(1000) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#20223;&#38271;&#26102;&#38388;&#36816;&#34892;&#30340;&#24322;&#27493;&#24037;&#20316;</span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #deb887;">"response </span><span style="color: #4eee94;">$request</span><span style="color: #deb887;">"</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    (1..3).asFlow() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19968;&#20010;&#35831;&#27714;&#27969;</span>
        .map { request -&gt; performRequest(request) }
        .collect { response -&gt; println(response) }
}
</pre>
</div>

<p>
它产生以下三行，每一行每秒出现一次：
</p>

<div class="org-src-container">
<pre class="src src-sh">response 1
response 2
response 3
</pre>
</div>
</div>
<div id="outline-container-orgc3e15b7" class="outline-3">
<h3 id="orgc3e15b7">转换操作符</h3>
<div class="outline-text-3" id="text-orgc3e15b7">
<p>
在流转换操作符中，最通用的一种称为 <span class="underline">transform</span> 。它可以用来模仿简单的转换，例如 map 与 filter，以及实施更复杂的转换。 使用 transform 操作符，可以 <b>发射</b> 任意值任意次
</p>

<pre class="example">
     比如说，使用 transform 可以在执行长时间运行的异步请求之前发射一个字符串并跟踪这个响应
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.transform</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    (1..3).asFlow() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19968;&#20010;&#35831;&#27714;&#27969;</span>
        .transform { request -&gt;
                         emit(<span style="color: #deb887;">"Making request </span><span style="color: #4eee94;">$request</span><span style="color: #deb887;">"</span>)
                     emit(performRequest(request))
        }
        .collect { response -&gt; println(response) }
}
</pre>
</div>

<p>
这段代码的输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Making request 1
response 1
Making request 2
response 2
Making request 3
response 3
</pre>
</div>
</div>
</div>
<div id="outline-container-org273bddf" class="outline-3">
<h3 id="org273bddf">限长操作符</h3>
<div class="outline-text-3" id="text-org273bddf">
<p>
<span class="underline">限长</span> 过渡操作符（例如 <span class="underline">take</span> ）在流 <b>触及</b> 相应 <span class="underline">限制</span> 的时候会将它的 <span class="underline">执行</span> <b>取消</b> 
</p>

<pre class="example">
     协程中的取消操作总是通过抛出异常来执行，这样所有的资源管理函数（如 try {...} finally {...} 块）会在取消的情况下正常运行
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.take</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">numbers</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">try</span> {                          
                                   emit(1)
                                   emit(2) 
                                   println(<span style="color: #deb887;">"This line will not execute"</span>)
                                   emit(3)    
    } <span style="color: #00bfff; font-weight: bold;">finally</span> {
        println(<span style="color: #deb887;">"Finally in numbers"</span>)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> {
    numbers() 
        .take(2) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21482;&#33719;&#21462;&#21069;&#20004;&#20010;</span>
        .collect { value -&gt; println(value) }
}  
</pre>
</div>

<pre class="example">
     这段代码的输出清楚地表明，numbers() 函数中对 flow {...} 函数体的执行在发射出第二个数字后停止
</pre>

<div class="org-src-container">
<pre class="src src-sh">1
2
Finally<span style="color: #00bfff; font-weight: bold;"> in</span> numbers
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org263ae97" class="outline-2">
<h2 id="org263ae97">末端流操作符</h2>
<div class="outline-text-2" id="text-org263ae97">
<p>
<span class="underline">末端操作符</span> 是在流上用于 <b>启动</b> <span class="underline">流收集</span> 的 <b>挂起</b> 函数
</p>

<pre class="example">
collect 是最基础的末端操作符
</pre>

<p>
还有另外一些更方便使用的末端操作符：
</p>
<ul class="org-ul">
<li>转化为各种集合，例如 <span class="underline">toList</span> 与 <span class="underline">toSet</span></li>
<li>获取第一个 <span class="underline">first</span> 值与确保流发射单个 <span class="underline">single</span> 值的操作符</li>
<li>使用 <span class="underline">reduce</span> 与 <span class="underline">fold</span> 将流规约到单个值</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.map</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.reduce</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">sum</span> = (1..5).asFlow()
        .map { <span style="color: #00bfff; font-weight: bold;">it</span> * <span style="color: #00bfff; font-weight: bold;">it</span> } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25968;&#23383; 1 &#33267; 5 &#30340;&#24179;&#26041;</span>
        .reduce { a, b -&gt; a + b } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27714;&#21644;&#65288;&#26411;&#31471;&#25805;&#20316;&#31526;&#65289;</span>
    println(sum)
}
</pre>
</div>

<pre class="example">
  打印单个数字： 55 
</pre>
</div>
</div>
<div id="outline-container-org7dd2745" class="outline-2">
<h2 id="org7dd2745">流是连续的</h2>
<div class="outline-text-2" id="text-org7dd2745">
<p>
流的每次单独收集都是按 <b>顺序</b> 执行的，除非进行特殊操作的操作符使用多个流。该收集过程直接在 <span class="underline">协程</span> 中运行，该协程 <b>调用</b> <span class="underline">末端操作符</span> ：
</p>
<ul class="org-ul">
<li>默认情况下不启动新协程</li>
<li>从上游到下游 <b>每个</b> <span class="underline">过渡操作符</span> 都会 <b>处理</b> 每个 <span class="underline">发射出的值</span> 然后再交给末端操作符</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.filter</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.map</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    (1..5).asFlow()
        .filter {
            println(<span style="color: #deb887;">"Filter </span><span style="color: #4eee94;">$it</span><span style="color: #deb887;">"</span>)
            <span style="color: #00bfff; font-weight: bold;">it</span> % 2 == 0
        }
        .map {
            println(<span style="color: #deb887;">"Map </span><span style="color: #4eee94;">$it</span><span style="color: #deb887;">"</span>)
            <span style="color: #deb887;">"string </span><span style="color: #4eee94;">$it</span><span style="color: #deb887;">"</span>
        }.collect {
            println(<span style="color: #deb887;">"Collect </span><span style="color: #4eee94;">$it</span><span style="color: #deb887;">"</span>)
        }
}
</pre>
</div>

<p>
输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">Filter 1
Filter 2
Map 2
Collect string 2
Filter 3
Filter 4
Map 4
Collect string 4
Filter 5
</pre>
</div>

<pre class="example">
    过滤偶数并将其映射到字符串
</pre>
</div>
</div>
<div id="outline-container-org6a53612" class="outline-2">
<h2 id="org6a53612">流上下文</h2>
<div class="outline-text-2" id="text-org6a53612">
<p>
流的收集总是在 <b>调用</b> <span class="underline">协程</span> 的 <span class="underline">上下文</span> 中发生
</p>

<pre class="example">
    例如，如果有一个流 foo，然后以下代码在它的编写者指定的上下文中运行，而无论流 foo 的实现细节如何
</pre>

<div class="org-src-container">
<pre class="src src-kotlin">withContext(context) {
    foo.collect { value -&gt;
                      println(value) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36816;&#34892;&#22312;&#25351;&#23450;&#19978;&#19979;&#25991;&#20013;</span>
    }
}
</pre>
</div>

<p>
流的该属性称为 <span class="underline">上下文保存</span> 
</p>

<pre class="example">
    默认的，flow { ... } 构建器中的代码运行在相应流的收集器提供的上下文中

    举例来说，考虑打印线程的 foo 的实现， 它被调用并发射三个数字
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">log</span>(msg: <span style="color: #98f5ff;">String</span>) = println(<span style="color: #deb887;">"[${</span><span style="color: #98f5ff;">Thread.currentThread</span>().name<span style="color: #deb887;">}] </span><span style="color: #4eee94;">$msg</span><span style="color: #deb887;">"</span>)

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    log(<span style="color: #deb887;">"Started foo flow"</span>)
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        emit(i)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo().collect { value -&gt; log(<span style="color: #deb887;">"Collected </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span>) }
}
</pre>
</div>

<p>
运行这段代码：
</p>

<div class="org-src-container">
<pre class="src src-sh">[main @coroutine#1] Started foo flow
[main @coroutine#1] Collected 1
[main @coroutine#1] Collected 2
[main @coroutine#1] Collected 3
</pre>
</div>

<pre class="example">
  由于 foo().collect 是在主线程调用的，则 foo 的流主体也是在主线程调用的
</pre>

<p>
这是快速运行或异步代码的理想默认形式，它 <b>不关心执行的上下文</b> 并且 <b>不会阻塞调用者</b> 
</p>
</div>
<div id="outline-container-orgb375e3d" class="outline-3">
<h3 id="orgb375e3d">withContext 发出错误</h3>
<div class="outline-text-3" id="text-orgb375e3d">
<pre class="example">
     然而，长时间运行的消耗 CPU 的代码也许需要在 Dispatchers.Default 上下文中执行，并且更新 UI 的代码也许需要在 Dispatchers.Main 中执行
</pre>
<p>
通常，withContext 用于在 Kotlin 协程中改变代码的上下文，但是 flow {&#x2026;} 构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit） 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.Dispatchers</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.withContext</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo7</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#27969;&#26500;&#24314;&#22120;&#20013;&#26356;&#25913;&#28040;&#32791; CPU &#20195;&#30721;&#30340;&#19978;&#19979;&#25991;&#30340;&#38169;&#35823;&#26041;&#24335;</span>
    withContext(<span style="color: #98f5ff;">Dispatchers.Default</span>) {
        <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
            <span style="color: #98f5ff;">Thread.sleep</span>(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#20197;&#28040;&#32791; CPU &#30340;&#26041;&#24335;&#36827;&#34892;&#35745;&#31639;</span>
            emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#19979;&#19968;&#20010;&#20540;</span>
        }
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo7().collect { value -&gt; println(value) }
}    
</pre>
</div>

<p>
这段代码产生如下的异常：
</p>

<div class="org-src-container">
<pre class="src src-sh">Exception<span style="color: #00bfff; font-weight: bold;"> in</span> thread <span style="color: #deb887;">"main"</span> java.lang.IllegalStateException: Flow invariant is violated:
Flow was collected<span style="color: #00bfff; font-weight: bold;"> in</span> [BlockingCoroutine{Active}@2eb45460, BlockingEventLoop@4861502a],
but emission happened<span style="color: #00bfff; font-weight: bold;"> in</span> [DispatchedCoroutine{Active}@31ddf337, Dispatchers.Default].
Please refer to <span style="color: #deb887;">'flow'</span> documentation or use <span style="color: #deb887;">'flowOn'</span> instead
</pre>
</div>
</div>
</div>
<div id="outline-container-orgae9e9ec" class="outline-3">
<h3 id="orgae9e9ec">flowOn 操作符</h3>
<div class="outline-text-3" id="text-orgae9e9ec">
<p>
<span class="underline">flowOn</span> 函数用于 <b>更改</b> <span class="underline">流发射的上下文</span> 
</p>

<pre class="example">
     以下示例展示了更改流上下文的正确方法，该示例还通过打印相应线程的名字以展示它们的工作方式
</pre>


<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.Dispatchers</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flowOn</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo8</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        <span style="color: #98f5ff;">Thread.sleep</span>(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#20197;&#28040;&#32791; CPU &#30340;&#26041;&#24335;&#36827;&#34892;&#35745;&#31639;</span>
        log(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#19979;&#19968;&#20010;&#20540;</span>
    }
}.flowOn(<span style="color: #98f5ff;">Dispatchers.Default</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#27969;&#26500;&#24314;&#22120;&#20013;&#25913;&#21464;&#28040;&#32791; CPU &#20195;&#30721;&#19978;&#19979;&#25991;&#30340;&#27491;&#30830;&#26041;&#24335;</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo8().collect { value -&gt; log(<span style="color: #deb887;">"Collected </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span>) }
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1
[main @coroutine#1] Collected 1
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2
[main @coroutine#1] Collected 2
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3
[main @coroutine#1] Collected 3
</pre>
</div>

<pre class="example">
     收集发生在一个协程中（“coroutine#1”）而发射发生在运行于另一个线程中与收集协程并发运行的另一个协程（“coroutine#2”）中
</pre>

<p>
当上游流必须改变其上下文中的 CoroutineDispatcher 的时候，flowOn 操作符 <b>创建</b> 了 <span class="underline">另一个协程</span> 
</p>
</div>
</div>
</div>
<div id="outline-container-org70939ad" class="outline-2">
<h2 id="org70939ad">缓冲</h2>
<div class="outline-text-2" id="text-org70939ad">
<p>
从收集流所花费的时间来看，将流的不同部分运行在不同的协程中将会很有帮助，特别是当涉及到长时间运行的异步操作时
</p>

<pre class="example">
    例如 foo() 流的发射很慢，它每花费 100 毫秒才产生一个元素；而收集器也非常慢， 需要花费 300 毫秒来处理元素

    看看从该流收集三个数字要花费多长时间
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlin.system.measureTimeMillis</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo9</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#24322;&#27493;&#31561;&#24453;&#20102; 100 &#27627;&#31186;</span>
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#19979;&#19968;&#20010;&#20540;</span>
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">time</span> = measureTimeMillis {
        foo9().collect { value -&gt;
                             delay(300) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#33457;&#36153; 300 &#27627;&#31186;&#26469;&#22788;&#29702;&#23427;</span>
                         println(value)
        }
    }
    println(<span style="color: #deb887;">"Collected in </span><span style="color: #4eee94;">$time</span><span style="color: #deb887;"> ms"</span>)
}
</pre>
</div>

<p>
它会产生这样的结果，整个收集过程大约需要 1200 毫秒（3 个数字，每个花费 400 毫秒）：
</p>

<div class="org-src-container">
<pre class="src src-sh">1
2
3
Collected<span style="color: #00bfff; font-weight: bold;"> in</span> 1279 ms
</pre>
</div>

<p>
可以在流上使用 <span class="underline">buffer</span> 操作符来 <b>并发</b> 运行 foo() 中发射元素的代码以及收集的代码， 而不是顺序运行它们：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#24322;&#27493;&#31561;&#24453;&#20102; 100 &#27627;&#31186;</span>
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#19979;&#19968;&#20010;&#20540;</span>
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> { 
                                 <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">time</span> = measureTimeMillis {
                                     foo()
                                         .buffer() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#32531;&#20914;&#21457;&#23556;&#39033;&#65292;&#26080;&#38656;&#31561;&#24453;</span>
                                         .collect { value -&gt; 
                                                        delay(300) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#33457;&#36153; 300 &#27627;&#31186;&#26469;&#22788;&#29702;&#23427;</span>
                                                    println(value) 
                                         } 
                                 }   
                                 println(<span style="color: #deb887;">"Collected in </span><span style="color: #4eee94;">$time</span><span style="color: #deb887;"> ms"</span>)
}
</pre>
</div>

<p>
它产生了相同的数字，只是更快了：
</p>

<div class="org-src-container">
<pre class="src src-sh">1
2
3
Collected<span style="color: #00bfff; font-weight: bold;"> in</span> 1071 ms
</pre>
</div>

<pre class="example">
    由于高效地创建了处理流水线， 仅仅需要等待第一个数字产生的 100 毫秒以及处理每个数字各需花费的 300 毫秒

    这种方式大约花费了 1000 毫秒来运行
</pre>
</div>
<div id="outline-container-orge8fbfe4" class="outline-3">
<h3 id="orge8fbfe4">合并</h3>
<div class="outline-text-3" id="text-orge8fbfe4">
<pre class="example">
     当流代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的那个
</pre>

<p>
在本示例中，当收集器处理它们太慢的时候， <span class="underline">conflate</span> 操作符可以用于跳过中间值
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.conflate</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlin.system.measureTimeMillis</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo10</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#24322;&#27493;&#31561;&#24453;&#20102; 100 &#27627;&#31186;</span>
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#19979;&#19968;&#20010;&#20540;</span>
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">time</span> = measureTimeMillis {
        foo10()
            .conflate() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21512;&#24182;&#21457;&#23556;&#39033;&#65292;&#19981;&#23545;&#27599;&#20010;&#20540;&#36827;&#34892;&#22788;&#29702;</span>
            .collect { value -&gt;
                           delay(300) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#33457;&#36153; 300 &#27627;&#31186;&#26469;&#22788;&#29702;&#23427;</span>
                       println(value)
            }
    }
    println(<span style="color: #deb887;">"Collected in </span><span style="color: #4eee94;">$time</span><span style="color: #deb887;"> ms"</span>)
}
</pre>
</div>

<p>
虽然第一个数字仍在处理中，但第二个和第三个数字已经产生，因此第二个是 conflated ，只有最新的（第三个）被交付给收集器：
</p>

<div class="org-src-container">
<pre class="src src-sh">1
3
Collected<span style="color: #00bfff; font-weight: bold;"> in</span> 758 ms
</pre>
</div>
</div>
</div>
<div id="outline-container-org8f87842" class="outline-3">
<h3 id="org8f87842">处理最新值</h3>
<div class="outline-text-3" id="text-org8f87842">
<pre class="example">
     当发射器和收集器都很慢的时候，合并是加快处理速度的一种方式。它通过删除发射值来实现
</pre>
<p>
另一种方式是 <b>取消</b> 缓慢的收集器，并在每次 <span class="underline">发射</span> 新值的时候 <b>重新启动</b> 它。有一组与 xxx 操作符执行相同基本逻辑的 <span class="underline">xxxLatest</span> 操作符，但是在新值产生的时候取消执行其块中的代码。在先前的示例中尝试更换 conflate 为 <span class="underline">collectLatest</span> ：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.collectLatest</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlin.system.measureTimeMillis</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        delay(100) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#24322;&#27493;&#31561;&#24453;&#20102; 100 &#27627;&#31186;</span>
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#19979;&#19968;&#20010;&#20540;</span>
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">time</span> = measureTimeMillis {
        foo()
            .collectLatest { value -&gt; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21462;&#28040;&#24182;&#37325;&#26032;&#21457;&#23556;&#26368;&#21518;&#19968;&#20010;&#20540;</span>
                             println(<span style="color: #deb887;">"Collecting </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span>)
                             delay(300) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35013;&#25105;&#20204;&#33457;&#36153; 300 &#27627;&#31186;&#26469;&#22788;&#29702;&#23427;</span>
                             println(<span style="color: #deb887;">"Done </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span>)
            }
    }
    println(<span style="color: #deb887;">"Collected in </span><span style="color: #4eee94;">$time</span><span style="color: #deb887;"> ms"</span>)
}
</pre>
</div>

<p>
由于 collectLatest 的函数体需要花费 300 毫秒，但是新值每 100 秒发射一次，看到该代码块对每个值运行，但是只收集最后一个值：
</p>

<div class="org-src-container">
<pre class="src src-sh">Collecting 1
Collecting 2
Collecting 3
Done 3
Collected<span style="color: #00bfff; font-weight: bold;"> in</span> 741 ms
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfa2504e" class="outline-2">
<h2 id="orgfa2504e">组合多个流</h2>
<div class="outline-text-2" id="text-orgfa2504e">
<p>
组合多个流有很多种方式 
</p>
</div>
<div id="outline-container-orgb652f67" class="outline-3">
<h3 id="orgb652f67">zip</h3>
<div class="outline-text-3" id="text-orgb652f67">
<pre class="example">
   就像 Kotlin 标准库中的 Sequence.zip 扩展函数一样
</pre>
<p>
流拥有一个 <span class="underline">zip</span> 操作符用于 <b>组合</b> 两个流中的相关值：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flowOf</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.zip</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">nums</span> = (1..3).asFlow() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25968;&#23383; 1..3</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">strs</span> = flowOf(<span style="color: #deb887;">"one"</span>, <span style="color: #deb887;">"two"</span>, <span style="color: #deb887;">"three"</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23383;&#31526;&#20018;</span>
    nums.zip(strs) { a, b -&gt; <span style="color: #deb887;">"</span><span style="color: #4eee94;">$a</span><span style="color: #deb887;"> -&gt; </span><span style="color: #4eee94;">$b</span><span style="color: #deb887;">"</span> } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#32452;&#21512;&#21333;&#20010;&#23383;&#31526;&#20018;</span>
        .collect { println(<span style="color: #00bfff; font-weight: bold;">it</span>) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25910;&#38598;&#24182;&#25171;&#21360;</span>
}
</pre>
</div>
<p>
示例打印如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">1 -&gt; one
2 -&gt; two
3 -&gt; three
</pre>
</div>
</div>
</div>
<div id="outline-container-org64a9e57" class="outline-3">
<h3 id="org64a9e57">Combine</h3>
<div class="outline-text-3" id="text-org64a9e57">
<p>
当流表示一个变量或操作的最新值时，可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。这种相应的操作符家族称为 <span class="underline">combine</span> 
</p>

<pre class="example">
     例如，先前示例中的数字如果每 300 毫秒更新一次，但字符串每 400 毫秒更新一次， 然后使用 zip 操作符合并它们，但仍会产生相同的结果， 尽管每 400 毫秒打印一次结果
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flowOf</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.zip</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">nums</span> = (1..3).asFlow().onEach { delay(300) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#25968;&#23383; 1..3&#65292;&#38388;&#38548; 300 &#27627;&#31186;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">strs</span> = flowOf(<span style="color: #deb887;">"one"</span>, <span style="color: #deb887;">"two"</span>, <span style="color: #deb887;">"three"</span>).onEach { delay(400) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27599; 400 &#27627;&#31186;&#21457;&#23556;&#19968;&#27425;&#23383;&#31526;&#20018;</span>
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">startTime</span> = <span style="color: #98f5ff;">System.currentTimeMillis</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35760;&#24405;&#24320;&#22987;&#30340;&#26102;&#38388;</span>
    nums.zip(strs) { a, b -&gt; <span style="color: #deb887;">"</span><span style="color: #4eee94;">$a</span><span style="color: #deb887;"> -&gt; </span><span style="color: #4eee94;">$b</span><span style="color: #deb887;">"</span> } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#8220;zip&#8221;&#32452;&#21512;&#21333;&#20010;&#23383;&#31526;&#20018;</span>
        .collect { value -&gt; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25910;&#38598;&#24182;&#25171;&#21360;</span>
                   println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$value</span><span style="color: #deb887;"> at ${</span><span style="color: #98f5ff;">System.currentTimeMillis</span>() - startTime<span style="color: #deb887;">} ms from start"</span>)
        }
}
</pre>
</div>

<p>
输出如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">1 -&gt; one at 493 ms from start
2 -&gt; two at 893 ms from start
3 -&gt; three at 1297 ms from start
</pre>
</div>

<pre class="example">
     示例中使用 onEach 过渡操作符来延时每次元素发射并使该流更具说明性以及更简洁
</pre>

<p>
然而，当在这里使用 <span class="underline">combine</span> 操作符来替换 zip：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.</span>*
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.</span>*

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> { 
                                 <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">nums</span> = (1..3).asFlow().onEach { delay(300) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#23556;&#25968;&#23383; 1..3&#65292;&#38388;&#38548; 300 &#27627;&#31186;</span>
                                 <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">strs</span> = flowOf(<span style="color: #deb887;">"one"</span>, <span style="color: #deb887;">"two"</span>, <span style="color: #deb887;">"three"</span>).onEach { delay(400) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27599; 400 &#27627;&#31186;&#21457;&#23556;&#19968;&#27425;&#23383;&#31526;&#20018;</span>
                                 <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">startTime</span> = <span style="color: #98f5ff;">System.currentTimeMillis</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35760;&#24405;&#24320;&#22987;&#30340;&#26102;&#38388;</span>
                                 nums.combine(strs) { a, b -&gt; <span style="color: #deb887;">"</span><span style="color: #4eee94;">$a</span><span style="color: #deb887;"> -&gt; </span><span style="color: #4eee94;">$b</span><span style="color: #deb887;">"</span> } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#8220;combine&#8221;&#32452;&#21512;&#21333;&#20010;&#23383;&#31526;&#20018;</span>
                                     .collect { value -&gt; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25910;&#38598;&#24182;&#25171;&#21360;</span>
                                                println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$value</span><span style="color: #deb887;"> at ${</span><span style="color: #98f5ff;">System.currentTimeMillis</span>() - startTime<span style="color: #deb887;">} ms from start"</span>) 
                                     } 
}
</pre>
</div>

<p>
这次得到了完全不同的输出，其中，nums 或 strs 流中的每次发射都会打印一行：
</p>

<div class="org-src-container">
<pre class="src src-sh">1 -&gt; one at 532 ms from start
2 -&gt; one at 737 ms from start
2 -&gt; two at 933 ms from start
3 -&gt; two at 1038 ms from start
3 -&gt; three at 1334 ms from start
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7b31137" class="outline-2">
<h2 id="org7b31137">流展平</h2>
<div class="outline-text-2" id="text-org7b31137">
<pre class="example">
    流是用来异步地接收一系列的值，所以它很容易遇到这样的场景：每个值都会触发一个请求去获取另外一系列的值
</pre>


<p>
例如：下面的函数会先发射字符串 "First"，再间隔500ms发射另一个字符串 "Second" 
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">requestFlow</span>(i: <span style="color: #98f5ff;">Int</span>): <span style="color: #98f5ff;">Flow&lt;String&gt;</span> = flow {
    emit(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">: First"</span>) 
    delay(500) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">wait 500 ms</span>
    emit(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">: Second"</span>)    
}
</pre>
</div>

<p>
现在有一条由三个整形值组成的流，其中每一个值都去调用 requestFlow 函数：
</p>

<div class="org-src-container">
<pre class="src src-kotlin">(1..3).asFlow().map { requestFlow(<span style="color: #00bfff; font-weight: bold;">it</span>) }
</pre>
</div>

<p>
最后就得到了一条由流组成的流 <span class="underline">Flow&lt;Flow&lt;String&gt;&gt;</span> ，如果要进一步处理，就需要把它 <b>展平</b> 到一条单独的流去
</p>

<pre class="example">
    集合和Sequence有对应的 flatten 和 flattenMap 操作符

    然而由于流的异步特性，展平的时候会有不同的模式，因此流也有一系列的操作符对应不同的模式
</pre>
</div>
<div id="outline-container-orge779abd" class="outline-3">
<h3 id="orge779abd">flatMapConcat</h3>
<div class="outline-text-3" id="text-orge779abd">
<p>
Concatenating 模式通过 <span class="underline">flatMapConcat</span> 和 <span class="underline">flattenConcat</span> 操作符实现. 这是最直接的一种模式，内部流的每一个值都收集完毕才开始外部流下一个值的收集:
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.</span>*
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>


<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">requestFlow</span>(i: <span style="color: #98f5ff;">Int</span>): <span style="color: #98f5ff;">Flow&lt;String&gt;</span> = flow {
    emit(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">: First"</span>)
    delay(500) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">wait 500 ms</span>
    emit(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">: Second"</span>)
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">startTime</span> = <span style="color: #98f5ff;">System.currentTimeMillis</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">remember the start time</span>
    (1..3).asFlow().onEach { delay(100) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">a number every 100 ms</span>
        .flatMapConcat { requestFlow(<span style="color: #00bfff; font-weight: bold;">it</span>) }
        .collect { value -&gt; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">collect and print</span>
                   println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$value</span><span style="color: #deb887;"> at ${</span><span style="color: #98f5ff;">System.currentTimeMillis</span>() - startTime<span style="color: #deb887;">} ms from start"</span>)
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5d88700" class="outline-3">
<h3 id="org5d88700">flatMapMerge</h3>
<div class="outline-text-3" id="text-org5d88700">
<p>
这种模式是 <b>并发</b> 地 <span class="underline">收集</span> 流输入然后把值 <b>合并</b> 到一条单独的流，这样可以让值尽可能快地发射出来。这种模式由  <span class="underline">flatMapMerge</span> and <span class="underline">flattenMerge</span> 操作符实现
</p>

<pre class="example">
     这两个操作符都接受一个可选的并发参数，用来限制在同一时间并发收集的流数量

     默认值 DEFAULT_CONCURRENCY 
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flatMapMerge</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">startTime</span> = <span style="color: #98f5ff;">System.currentTimeMillis</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">remember the start time</span>
    (1..3).asFlow().onEach { delay(100) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">a number every 100 ms</span>
        .flatMapMerge { requestFlow(<span style="color: #00bfff; font-weight: bold;">it</span>) }
        .collect { value -&gt; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">collect and print</span>
                   println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$value</span><span style="color: #deb887;"> at ${</span><span style="color: #98f5ff;">System.currentTimeMillis</span>() - startTime<span style="color: #deb887;">} ms from start"</span>)
        }
}
</pre>
</div>

<p>
输出结果如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">1: First at 136 ms from start
2: First at 231 ms from start
3: First at 333 ms from start
1: Second at 639 ms from start
2: Second at 732 ms from start
3: Second at 833 ms from start
</pre>
</div>

<pre class="example">
     注意：flatMapMerge 顺序地调用  ({ requestFlow(it) } 代码段, 但是对于结果流的收集是并发地

     这等同于执行一个顺序地映射 { requestFlow(it) } 然后在对结果调用 flattenMerge 
</pre>
</div>
</div>
<div id="outline-container-org0e5fe2f" class="outline-3">
<h3 id="org0e5fe2f">flatMapLatest</h3>
<div class="outline-text-3" id="text-org0e5fe2f">
<p>
类似于 collectLatest，另外一种展平模式是只收集最新的值：如果新的流开始发射，前面流的集合就会被抛弃。这种模式是由 flatMapLatest 操作符实现：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flatMapLatest</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">val</span> <span style="color: #4eee94;">startTime</span> = <span style="color: #98f5ff;">System.currentTimeMillis</span>() <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">remember the start time</span>
    (1..3).asFlow().onEach { delay(100) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">a number every 100 ms</span>
        .flatMapLatest { requestFlow(<span style="color: #00bfff; font-weight: bold;">it</span>) }
        .collect { value -&gt; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">collect and print</span>
                   println(<span style="color: #deb887;">"</span><span style="color: #4eee94;">$value</span><span style="color: #deb887;"> at ${</span><span style="color: #98f5ff;">System.currentTimeMillis</span>() - startTime<span style="color: #deb887;">} ms from start"</span>)
        }
}
</pre>
</div>

<p>
下面的输出是一个很好的例子：
</p>

<div class="org-src-container">
<pre class="src src-sh">1: First at 320 ms from start
2: First at 430 ms from start
3: First at 533 ms from start
3: Second at 1044 ms from start
</pre>
</div>

<pre class="example">
     注意：每当有一个新的值 在 ({ requestFlow(it) } 产生，会取消所有已经收集到的数字流

     哪怕这里 requestFlow 函数运行很快，非挂起，不允许取消，行为也是这样
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc1ef899" class="outline-2">
<h2 id="orgc1ef899">流异常</h2>
<div class="outline-text-2" id="text-orgc1ef899">
<p>
流收集可能以异常来完成收集：
</p>
<ul class="org-ul">
<li>发射值的时候抛出异常</li>
<li><p>
收集的时候抛出异常
</p>

<p>
有不同的方式来处理这些异常
</p></li>
</ul>
</div>

<div id="outline-container-orgf1c9831" class="outline-3">
<h3 id="orgf1c9831">收集器 try 与 catch</h3>
<div class="outline-text-3" id="text-orgf1c9831">
<p>
收集操作符可以使用  <span class="underline">try/catch</span> 代码块来处理异常：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo11</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        println(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">emit next value</span>
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        foo11().collect { value -&gt;
                              println(value)
                          check(value &lt;= 1) { <span style="color: #deb887;">"Collected </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span> }
        }
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (e: <span style="color: #98f5ff;">Throwable</span>) {
        println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$e</span><span style="color: #deb887;">"</span>)
    }
}
</pre>
</div>

<p>
在成功捕获了 <span class="underline">collect</span> 操作符内产生的异常后， <b>不再</b> 有新的值被 <span class="underline">发射</span> 出来：
</p>

<div class="org-src-container">
<pre class="src src-sh">Emitting 1
1
Emitting 2
2
Caught java.lang.IllegalStateException: Collected 2
</pre>
</div>
</div>
</div>

<div id="outline-container-org92f4490" class="outline-3">
<h3 id="org92f4490">一切都已捕获</h3>
<div class="outline-text-3" id="text-org92f4490">
<pre class="example">
     实际上前面的例子会捕获任何来自于发射或收集时候产生的异常
</pre>

<p>
现在试着让异常产生于发射的代码内：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo</span>(): <span style="color: #98f5ff;">Flow&lt;String&gt;</span> = 
flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        println(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">emit next value</span>
    }
}
.map { value -&gt;
           check(value &lt;= 1) { <span style="color: #deb887;">"Crashed on </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span> }                 
       <span style="color: #deb887;">"string </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> {
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        foo().collect { value -&gt; println(value) }
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (e: <span style="color: #98f5ff;">Throwable</span>) {
        println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$e</span><span style="color: #deb887;">"</span>)
    } 
}
</pre>
</div>

<p>
类似地，异常同样被捕获，收集也被停止了
</p>
<div class="org-src-container">
<pre class="src src-sh">Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf905472" class="outline-2">
<h2 id="orgf905472">异常透明性</h2>
<div class="outline-text-2" id="text-orgf905472">
<pre class="example">
    美中不足的是，这里的代码无法隐藏处理异常的逻辑

    一般来说流应该对异常透明，因为这保证了在收集时候捕获的异常是收集时候的代码所产生的
</pre>
<p>
发射器可以使用 <span class="underline">catch</span> 操作符来维持异常透明性，并 <b>包装</b> <span class="underline">异常处理逻辑</span> 。一般是分析错误，并且根据不同的错误做出不同的反应：
</p>
<ul class="org-ul">
<li>异常被再次扔出</li>
<li>异常转换成另外一个值发射出去</li>
<li>异常被忽略，记录，或被其他代码处理</li>
</ul>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo15</span>(): <span style="color: #98f5ff;">Flow&lt;String&gt;</span> =
flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        println(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">emit next value</span>
    }
}
.map { value -&gt;
           check(value &lt;= 1) { <span style="color: #deb887;">"Crashed on </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span> }
       <span style="color: #deb887;">"string </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span>
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking&lt;<span style="color: #98f5ff;">Unit&gt;</span> {
    foo15()
        .<span style="color: #00bfff; font-weight: bold;">catch</span> { e -&gt; emit(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$e</span><span style="color: #deb887;">"</span>) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">emit on exception</span>
        .collect { value -&gt; println(value) }
}
</pre>
</div>

<p>
虽然这里的输出和前面一样，但是不再有 try/catch 显示处理了
</p>

<div class="org-src-container">
<pre class="src src-sh">Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
</pre>
</div>
</div>

<div id="outline-container-org3efbb41" class="outline-3">
<h3 id="org3efbb41">异常逃逸</h3>
<div class="outline-text-3" id="text-org3efbb41">
<pre class="example">
     然而上面的例子却无法处理收集器内 collect 代码块产生的异常
</pre>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> kotlinx.coroutines.flow.<span style="color: #00bfff; font-weight: bold;">catch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo16</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        println(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo16()
        .<span style="color: #00bfff; font-weight: bold;">catch</span> { e -&gt; println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$e</span><span style="color: #deb887;">"</span>) } <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">does not catch downstream exceptions</span>
        .collect { value -&gt;
                       check(value &lt;= 1) { <span style="color: #deb887;">"Collected </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span> }
                   println(value)
        }
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Emitting 1
1
Emitting 2
Exception<span style="color: #00bfff; font-weight: bold;"> in</span> thread <span style="color: #deb887;">"main"</span> java.lang.IllegalStateException: Collected 2
at tutorial.coroutine.flow.FlowExceptionEscapeKt$<span style="color: #4eee94;">main</span>$<span style="color: #4eee94;">1</span>$<span style="color: #4eee94;">2</span>.emit(FlowExceptionEscape.kt:19)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgfb3bcba" class="outline-3">
<h3 id="orgfb3bcba">声明式捕获</h3>
<div class="outline-text-3" id="text-orgfb3bcba">
<p>
做为改进可以把 collect 操作符里的代码移动到一个 <span class="underline">onEach</span> 操作符内，并把 onEach 操作符放在 <span class="underline">catch</span> 操作符前面：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> kotlinx.coroutines.flow.<span style="color: #00bfff; font-weight: bold;">catch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo17</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i <span style="color: #00bfff; font-weight: bold;">in</span> 1..3) {
        println(<span style="color: #deb887;">"Emitting </span><span style="color: #4eee94;">$i</span><span style="color: #deb887;">"</span>)
        emit(i)
    }
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo17()
        .onEach { value -&gt;
                      check(value &lt;= 1) { <span style="color: #deb887;">"Collected </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span> }
                  println(value)
        }
        .<span style="color: #00bfff; font-weight: bold;">catch</span> { e -&gt; println(<span style="color: #deb887;">"Caught </span><span style="color: #4eee94;">$e</span><span style="color: #deb887;">"</span>) }
        .collect {}
}
</pre>
</div>

<p>
现在可以看到一条类似以 "Caught&#x2026;" 开头的消息被打印出来
</p>

<div class="org-src-container">
<pre class="src src-sh">Emitting 1
1
Emitting 2
Caught java.lang.IllegalStateException: Collected 2
</pre>
</div>

<pre class="example">
     这里既使用了 catch 操作符的声明性，并且也处理了所有的异常

     但也要注意：这里的 collect 不能有任何额外的逻辑
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb566d28" class="outline-2">
<h2 id="orgb566d28">流完成</h2>
<div class="outline-text-2" id="text-orgb566d28">
<p>
当流收集完成以后（无论正常或有异常），可能会需要执行某些逻辑。这同样可以通过两种方式实现：命令式和声明式
</p>
</div>

<div id="outline-container-org2287e6c" class="outline-3">
<h3 id="org2287e6c">命令式 finally 块</h3>
<div class="outline-text-3" id="text-org2287e6c">
<p>
在 try/catch 块之外，收集器可以使用 <span class="underline">finally</span> 块来执行某些收集完成之后的逻辑：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo18</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = (1..3).asFlow()

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        foo18().collect { value -&gt; println(value) }
    } <span style="color: #00bfff; font-weight: bold;">finally</span> {
        println(<span style="color: #deb887;">"Done"</span>)
    }
}    
</pre>
</div>

<p>
打印了3个数字，最后会打印 "Done" 字符串
</p>

<div class="org-src-container">
<pre class="src src-sh">1
2
3
Done
</pre>
</div>
</div>
</div>

<div id="outline-container-org57b4df3" class="outline-3">
<h3 id="org57b4df3">声明式处理</h3>
<div class="outline-text-3" id="text-org57b4df3">
<p>
流同样也有一个声明式的操作符 onCompletion 来调用流收集完成后的逻辑。相对于命令式的做法，最主要的优点在于 onCompletion 有一个可为空的 <span class="underline">Throwable</span> 参数来表示 <span class="underline">收集</span> 是否 <b>正常</b> 结束：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> kotlinx.coroutines.flow.<span style="color: #00bfff; font-weight: bold;">catch</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onCompletionOn</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo19</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = flow {
    emit(1)
    <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #98f5ff;">RuntimeException</span>()
}

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo19()
        .onCompletion { cause -&gt; <span style="color: #00bfff; font-weight: bold;">if</span> (cause != <span style="color: #ffd700;">null</span>) println(<span style="color: #deb887;">"Flow completed exceptionally"</span>) }
        .<span style="color: #00bfff; font-weight: bold;">catch</span> { cause -&gt; println(<span style="color: #deb887;">"Caught exception"</span>) }
        .collect { value -&gt; println(value) }
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">1
Flow completed exceptionally
Caught exception
</pre>
</div>

<pre class="example">
onCompletion 操作符 与 catch 不同，它并不处理异常

异常是传递给下一个方法，然后在 catch 操作符里被处理
</pre>
</div>

<div id="outline-container-org9c6f92b" class="outline-4">
<h4 id="org9c6f92b">仅限上游异常</h4>
<div class="outline-text-4" id="text-org9c6f92b">
<p>
和 catch 操作符类似， onCompletion 操作符也仅能捕获到上游传过来的异常，而无法感知下游产生的异常：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onCompletion</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">foo20</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = (1..3).asFlow()

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    foo20()
        .onCompletion { cause -&gt; println(<span style="color: #deb887;">"Flow completed with </span><span style="color: #4eee94;">$cause</span><span style="color: #deb887;">"</span>) }
        .collect { value -&gt;
            check(value &lt;= 1) { <span style="color: #deb887;">"Collected </span><span style="color: #4eee94;">$value</span><span style="color: #deb887;">"</span> }
            println(value)
        }
}
</pre>
</div>

<p>
可以看到 onCompletion 里的 cause 为空，但整个收集依旧是以异常而终止：
</p>

<div class="org-src-container">
<pre class="src src-sh">1
Flow completed with java.lang.IllegalStateException: Collected 2
Exception<span style="color: #00bfff; font-weight: bold;"> in</span> thread <span style="color: #deb887;">"main"</span> java.lang.IllegalStateException: Collected 2
</pre>
</div>

<pre class="example">
      现在已经看过分别用命令式和声明式来处理错误和完成收集，那么究竟应该使用哪种呢？

      做为一个库，两种方式都是有效的。如何选择应该由个人爱好和编程风格所决定
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5afd9bd" class="outline-2">
<h2 id="org5afd9bd">流启动</h2>
<div class="outline-text-2" id="text-org5afd9bd">
<pre class="example">
    流非常适合用来表示从某些源头异步发送的事件

    这种情况下，需要注册一个类似于 AddEventListener 的函数，这个函数代码里包含了如何处理接收到的事件
</pre>

<p>
<span class="underline">onEach</span> 操作符可以起到注册的职责。然而 onEach 操作符只是一个中端操作符，仍然需要一个末端操作符来收集流，否则只调用 onEach 不起作用
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.delay</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.Flow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.asFlow</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">events</span>(): <span style="color: #98f5ff;">Flow&lt;Int&gt;</span> = (1..3).asFlow().onEach { delay(1000) }

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    events()
        .onEach { event -&gt; println(<span style="color: #deb887;">"Event: </span><span style="color: #4eee94;">$event</span><span style="color: #deb887;">"</span>) }
        .collect{} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&lt;--- Collecting the flow waits</span>
    println(<span style="color: #deb887;">"Done"</span>)
}
</pre>
</div>

<p>
输出如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">Event: 1
Event: 2
Event: 3
Done
</pre>
</div>

<pre class="example">
    在 onEach 后面加上 collect 操作符，所有 collect {} 之后的代码（打印 "Done" 字符串）会在流被收集完毕之后才执行
</pre>

<p>
如果使用 <span class="underline">lauchIn</span> 来替换 collect 操作符，可以让 <span class="underline">流收集</span> 运行在另外一个 <b>单独</b> 的 <span class="underline">协程</span> 中，lauchIn 后面的代码会 <b>立刻</b> 执行：
</p>

<div class="org-src-container">
<pre class="src src-kotlin"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.launchIn</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.flow.onEach</span>
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #deb887;">kotlinx.coroutines.runBlocking</span>

<span style="color: #00bfff; font-weight: bold;">fun</span> <span style="color: #daa520; font-weight: bold;">main</span>() = runBlocking {
    events()
        .onEach { event -&gt; println(<span style="color: #deb887;">"Event: </span><span style="color: #4eee94;">$event</span><span style="color: #deb887;">"</span>) }
        .launchIn(<span style="color: #00bfff; font-weight: bold;">this</span>) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&lt;--- Launching the flow in a separate coroutine</span>
    println(<span style="color: #deb887;">"Done"</span>)
}  
</pre>
</div>

<p>
这时的输出如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">Done
Event: 1
Event: 2
Event: 3
</pre>
</div>

<p>
lauchIn 必须的参数是一个 <span class="underline">CoroutineScope</span> : 流收集跑在哪个协程上下文里
</p>
<pre class="example">
    实例中这个协程上下文参数是来自于 runBlocking 构造器

    因此当流在运行时，会继续执行main函数里其他代码，并等待所有子协程跑完
</pre>

<p>
实际应用中如果这个上下文来自于一个有限生命周期的实例，当这个实例终止时，协程会被取消，同样收集流的协程也会被取消
</p>
<pre class="example">
    这时候，onEach { ... }.launchIn(scope) 的工作方式和 addEventListener 相似

    然而不需要显示地调用 removeEventListener ，因为协程取消隐式地包含了这一点
</pre>

<p>
注意： launchIn 也会返回一个 Job。这个 Job 也可以被用来单独取消流收集
</p>

<pre class="example">
    这种情况适用于 不取消 CoroutineScope 参数对应的协程，只取消收集流对应的协程
</pre>
</div>
</div>

<div id="outline-container-org9538d77" class="outline-2">
<h2 id="org9538d77">流 与 响应式流</h2>
<div class="outline-text-2" id="text-org9538d77">
<pre class="example">
    对于熟悉响应式流（Reactive Streams）或诸如 RxJava 与 Project Reactor 这样的响应式框架的人来说， Flow 的设计也许看起来会非常熟悉
</pre>

<p>
确实，其设计灵感来源于响应式流以及其各种实现。但是 Flow 的主要目标是拥有尽可能简单的设计， 对 Kotlin 以及挂起友好且遵从结构化并发
</p>

<pre class="example">
虽然有所不同，但从概念上讲，Flow 依然是响应式流，并且可以将它转换为响应式（规范及符合 TCK）的发布者（Publisher），反之亦然

这些开箱即用的转换器可以在 kotlinx.coroutines 提供的相关响应式模块：
1. kotlinx-coroutines-reactive 用于 Reactive Streams
2. kotlinx-coroutines-reactor 用于 Project Reactor
3. kotlinx-coroutines-rx2 用于 RxJava2

集成模块包含 Flow 与其他实现之间的转换，与 Reactor 的 Context 集成以及与一系列响应式实体配合使用的挂起友好的使用方式
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="channel.html">Next：通道</a></td>
<td class="org-left"><a href="scheduler.html">Previous：调度器</a></td>
<td class="org-left"><a href="coroutine.html">Home：协程</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
