<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>执行引擎</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="class_loader.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">执行引擎</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org98ef496">运行时栈帧结构</a>
<ul>
<li><a href="#org2d3d8a1">局部变量表</a></li>
<li><a href="#orgb63adad">操作数栈</a></li>
<li><a href="#org3bbfd4f">动态连接</a></li>
<li><a href="#org8d1f6fa">方法返回地址</a></li>
<li><a href="#org83291b1">附加信息</a></li>
</ul>
</li>
<li><a href="#org691b641">方法调用</a>
<ul>
<li><a href="#org01cfaf2">解析</a></li>
<li><a href="#orgdb59c08">分派</a>
<ul>
<li><a href="#org8370acc">静态分派</a></li>
<li><a href="#org2480f68">动态分派</a></li>
<li><a href="#org7a3696d">单分派与多分派</a></li>
<li><a href="#orgbb475b6">动态分派的实现</a></li>
</ul>
</li>
<li><a href="#orgdb4de79">动态类型语言支持</a>
<ul>
<li><a href="#orgd329244">java.lang.invoke包</a></li>
<li><a href="#orgf095c51">invokedynamic指令</a></li>
<li><a href="#orgac30d9a">掌控方法分派规则</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org32e1821">执行引擎</a>
<ul>
<li><a href="#org5f76ba3">解释执行</a></li>
<li><a href="#org4e13848">基于栈的指令集</a>
<ul>
<li><a href="#orgf1b7cdc">基于栈的指令集优缺点</a></li>
</ul>
</li>
<li><a href="#org72d5e97">基于栈的解释器执行过程</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>执行引擎</b> 是Java虚拟机最核心的组成部分之一。 <span class="underline">虚拟机</span> 是一个相对于 <span class="underline">物理机</span> 的概念，这两种机器都有代码执行能力，其区别：
</p>
<ul class="org-ul">
<li>物理机的执行引擎是 <b>直接建立在处理器、硬件、指令集和操作系统</b> 层面上的</li>
<li>虚拟机的执行引擎则是由 <b>自己实现的</b> ，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式</li>
</ul>

<p>
在Java虚拟机规范中制定了 <span class="underline">虚拟机字节码执行引擎</span> 的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有 <span class="underline">解释执行</span> (通过解释器执行)和 <span class="underline">编译执行</span> (通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的:
</p>
<ul class="org-ul">
<li>输入：字节码文件</li>
<li>处理：字节码解析的等效过程</li>
<li>输出：执行结果</li>
</ul>

<pre class="example">
  有一些虚拟机(如Sun Classic VM)的内部只存在解释器，只能解释执行

  另外一些虚拟机(如BEA JRockit)的内部只存在即时编译器，只能编译执行 
</pre>

<div id="outline-container-org98ef496" class="outline-2">
<h2 id="org98ef496">运行时栈帧结构</h2>
<div class="outline-text-2" id="text-org98ef496">
<p>
<b>栈帧</b> ( <span class="underline">Stack Frame</span> )是用于支持虚拟机进行 <b>方法调用和方法执行的数据结构</b> ，它是虚拟机运行时数据区中的 <b>虚拟机栈</b> ( <span class="underline">Virtual Machine Stack</span> )的栈元素。栈帧存储了方法的 
</p>
<ul class="org-ul">
<li><b>局部变量表</b></li>
<li><b>操作数栈</b></li>
<li><b>动态连接</b></li>
<li><b>方法返回地址</b></li>
<li>&#x2026;..</li>
</ul>

<p>
每一个方法从调用开始至执行完成的过程，都对应着 <b>一个栈帧在虚拟机栈里面从入栈到出栈的过程</b> 
</p>

<pre class="example">
    在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中

    一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现
</pre>

<p>
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中， <b>只有位于栈顶的栈帧才是有效的</b> ，称为 <span class="underline">当前栈帧</span> ( <span class="underline">Current Stack Frame</span> )，与这个栈帧相关联的方法称为 <span class="underline">当前方法</span> 。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示：
</p>


<div class="figure">
<p><img src="pic/jvm-stack-frame.png" alt="jvm-stack-frame.png" width="50%" /> 
</p>
</div>
</div>

<div id="outline-container-org2d3d8a1" class="outline-3">
<h3 id="org2d3d8a1">局部变量表</h3>
<div class="outline-text-3" id="text-org2d3d8a1">
<p>
<b>局部变量表</b> 是一组变量值存储空间，用于存放 <b>方法参数和方法内部定义的局部查量</b> 。在Java程序编译为Class文件时，就在 <span class="underline">方法的Code属性</span> 的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
</p>

<p>
局部变量表的容量以 <b>变量槽</b> ( <span class="underline">Slot</span> )为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出 <span class="underline">每个Slot占用32位长度的内存空间</span> 是有一些差别的，它允许Slot的长度可以 <b>随着处理器、操作系统或虚拟机的不同而发生变化</b> 。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致
</p>

<pre class="example">
一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型

reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构
但一般来说，虚拟机实现至少都应当能通过这个引用做到两点
  1. 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引
  2. 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息


returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址
很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替
</pre>
<p>
对于64位的数据类型，虚拟机会以 <span class="underline">高位对齐</span> 的方式为其 <span class="underline">分配两个连续的Slot空间</span> 。Java语言中明确的(reference类型则可能是32位也可能是64位)64位的数据类型只有long和double两种
</p>
<pre class="example">
     把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似

     不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题
</pre>

<p>
虚拟机通过 <span class="underline">索引定位</span> 的方式使用局部变量表，索引值的范围是从 <span class="underline">0开始至局部变量表最大的Slot数量</span> 
</p>
<ul class="org-ul">
<li>如果访问的是 <span class="underline">32位</span> 数据类型的变量，索引 <span class="underline">n</span> 就代表了使用第 <span class="underline">n个Slot</span></li>
<li>如果是 <span class="underline">64位</span> 数据类型的变量，则说明会同时使用 <span class="underline">n</span> 和 <span class="underline">n+1</span> 两个Slot
<ul class="org-ul">
<li>对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在 <span class="underline">类加载的校验阶段拋出异常</span></li>
</ul></li>
</ul>

<p>
在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static的方法)，那 <b>局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用</b> ，在方法中可以通过关键字 <span class="underline">this</span> 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot
</p>

<p>
为了尽可能节省栈帧空间，局部变量表中的Slot是可以 <b>重用</b> 的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体， <b>如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用</b> 。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接 <span class="underline">影响到系统的垃圾收集行为</span> 
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>)() {
    <span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">placeholder</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">byte</span>[64 * 1024 * 1024];
    System.gc();
}
</pre>
</div>
<p>
首先向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。在虚拟机运行参数中加上 <span class="underline">-verbose:gc</span> 来看看垃圾收集的过程，发现在 <span class="underline">System.gc()</span> 运行后并没有回收这64MB的内存，运行结果:
</p>

<pre class="example">
[GC 66846K-&gt;65824K (125632K ) ,0.0032678 secs] [Full GC 65824K-&gt; 65746K (125632K) ,0.0064131 secs] 

</pre>

<p>
因为在执行 <span class="underline">Systemgc()</span> 时，变量 placeholder 还处于作用域之内,虚拟机自然不敢回收 placeholder 的内存。那把代码修改一下
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>)() {
    {
        <span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">placeholder</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">byte</span>[64 * 1024 * 1024];
    }
    System.gc();
}
</pre>
</div>

<p>
加入了花括号之后， placeholder 的作用域被限制在花括号之内，从代码逻辑上讲，在执行 <span class="underline">System.gc()</span> 的时候，placeholder 已经不可能再被访问了,但执行一下这段程序,会发现运行结果如下,还是有64MB的内存没有被回收
</p>

<p>
在调用System.gc() 之前加入—行 <span class="underline">int a=0;</span> 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>)() {
    {
        <span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">placeholder</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">byte</span>[64 * 1024 * 1024];
    }
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">a</span> = 0;
    System.gc();
}
</pre>
</div>

<pre class="example">
[GC 66401K-&gt; 65778K (125632K ) ,0.0035471 secs] [Full GC 65778K-&gt;218K (125632K) ,0.0140596 secs]

</pre>

<p>
placeholder能否被回收的根本原因是:局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，没有任何对局部变量表的读写操作， <b>placeholder原本所占用的Slot还没有被其他变量所复用</b> ，所以作为GC Roots—部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微 
</p>

<pre class="example">
     如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值(把变量对应的局部变量表Slot清空)便不见得是一个绝对无意义的操作

     这种操作可以作为一种在极特殊情形(对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件)下的“奇技”来使用

     一本非常著名的书籍《Practical Java》中把“不使用的对象应手动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读者对这条规则感到疑惑
</pre>

<p>
虽然代码示例说明了 <span class="underline">赋null值的操作</span> 在某些情况下确实是有用的，但不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因：
</p>
<ol class="org-ol">
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法</li>
<li>从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，以前面例子来看，第二种代码方式在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须写成手动操作</li>
</ol>

<p>
局部变量不像前面介绍的类变量那样存在 <span class="underline">准备阶段</span> 。即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样， <b>如果一个局部变量定义了但没有赋初始值是不能使用的</b> ，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">a</span>;
    System.out.println(a);
}
</pre>
</div>

<pre class="example">
Test.java:4: error: variable a might not have been initialized
		System.out.println(a);
		                   ^
1 error

</pre>

<p>
编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虛拟机发现而导致类加载失败
</p>
</div>
</div>

<div id="outline-container-orgb63adad" class="outline-3">
<h3 id="orgb63adad">操作数栈</h3>
<div class="outline-text-3" id="text-orgb63adad">
<p>
<b>操作数栈</b> ( <span class="underline">Operand Stack</span> )也常称为操作栈，它是一个 <span class="underline">后入先出</span> (LIFO)栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_Stacks数据项中
</p>

<p>
操作数栈的每一个元素可以是任意的Java数据类型，包括 <span class="underline">long</span> 和 <span class="underline">double</span> 。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的 <b>深度都不会超过在max_Stacks数据项中设定的最大值</b> 
</p>

<p>
当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作
</p>
<ul class="org-ul">
<li>做算术运算的时候是通过操作数栈来进行的</li>
<li>调用其他方法的时候是通过操作数栈来进行参数传递</li>
</ul>

<pre class="example">
     比如，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值

     当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈
</pre>


<p>
操作数栈中 <b>元素的数据类型必须与字节码指令的序列严格匹配</b> ，在编译程序代码的时候， <span class="underline">编译器要严格保证这一点</span> ，在 <span class="underline">类校验阶段的数据流分析</span> 中还要再次验证这一点
</p>

<pre class="example">
     以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况
</pre>


<p>
在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。 <b>让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据</b> ，无须进行额外的参数复制传递，重叠的过程如图所示：
</p>


<div class="figure">
<p><img src="pic/stack-frame-share.png" alt="stack-frame-share.png" width="50%" /> 
</p>
</div>

<p>
Java虚拟机的解释执行引擎称为 <span class="underline">基于栈的执行引擎</span> ,其中所指的 <span class="underline">栈</span> 就是 <b>操作数栈</b> 
</p>
</div>
</div>


<div id="outline-container-org3bbfd4f" class="outline-3">
<h3 id="org3bbfd4f">动态连接</h3>
<div class="outline-text-3" id="text-org3bbfd4f">
<p>
每个栈帧都包含一个 <b>指向运行时常量池中该栈帧所属方法的引用</b> ，持有这个引用是为了 <b>支持方法调用过程中的动态连接</b> ( <span class="underline">Dynamic Linking</span> )
</p>

<p>
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以 <b>常量池中指向方法的符号引用作为参数</b> 。这些符号引用可以被：
</p>
<ul class="org-ul">
<li>静态解析：类加载阶段或者第一次使用的时候就转化为直接引用</li>
<li>动态链接：在每一次运行期间转化为直接引用</li>
</ul>
</div>
</div>

<div id="outline-container-org8d1f6fa" class="outline-3">
<h3 id="org8d1f6fa">方法返回地址</h3>
<div class="outline-text-3" id="text-org8d1f6fa">
<p>
当一个方法开始执行后，只有两种方式可以退出这个方法:
</p>
<ul class="org-ul">
<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为 <span class="underline">正常完成出口</span> (Normal Method Invocation Completion)</li>
<li>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用 <b>athrow</b> 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为 <span class="underline">异常完成出口</span> (Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是 <b>不会给它的上层调用者产生任何返回值</b></li>
</ul>

<p>
无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说
</p>
<ol class="org-ol">
<li>方法正常退出时， <span class="underline">调用者的PC计数器的值</span> 可以作为返回地址，栈帧中 <b>很可能会保存这个计数器值</b></li>
<li>而方法异常退出时，返回地址是要通过 <span class="underline">异常处理器表</span> 来确定的，栈帧中 <b>一般不会保存这部分信息</b></li>
</ol>

<p>
方法退出的过程实际上就等同于把 <b>当前栈帧出栈</b> ，因此退出时可能执行的操作有:
</p>
<ul class="org-ul">
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>把返回值(如果有的话)压入调用者栈帧的操作数栈中</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令等</li>
</ul>
</div>
</div>


<div id="outline-container-org83291b1" class="outline-3">
<h3 id="org83291b1">附加信息</h3>
<div class="outline-text-3" id="text-org83291b1">
<p>
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现
</p>

<pre class="example">
     在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息
</pre>
</div>
</div>
</div>

<div id="outline-container-org691b641" class="outline-2">
<h2 id="org691b641">方法调用</h2>
<div class="outline-text-2" id="text-org691b641">
<p>
<b>方法调用</b> 阶段唯一的任务就是 <b>确定被调用方法的版本(即调用哪一个方法)</b> ，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的链接步骤，一切方法调用在Class文件里面存储的都只是 <span class="underline">符号引用</span> ，而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用
</p>

<p>
在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。
</p>
<ul class="org-ul">
<li><b>invokestatic</b> : 调用 <b>静态</b> 方法</li>
<li><b>invokespecial</b> : 调用实例构造器 <span class="underline">&lt;init&gt;</span> 方法、私有方法和父类方法</li>
<li><b>invokevirtual</b> : 调用所有的 <b>虚</b> 方法</li>
<li><b>invokeinterface</b> : 调用 <b>接口</b> 方法，会在运行时再确定一个实现此接口的对象</li>
<li><b>invokedynamic</b> : 先在运行时 <b>动态解析出调用点限定符所引用的方法</b> ，然后再执行该方法</li>
</ul>

<p>
在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
</p>
</div>

<div id="outline-container-org01cfaf2" class="outline-3">
<h3 id="org01cfaf2">解析</h3>
<div class="outline-text-3" id="text-org01cfaf2">
<p>
所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是： <b>方法在程序真正运行之前就有一个确定的调用版本，并且这个方法的调用版本在运行期是不可改变的</b> 。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析
</p>

<p>
在Java语言中符合 <span class="underline">编译器可知，运行期不可变</span> 这个要求的方法，主要包括 <b>静态</b> 方法和 <b>私有</b> 方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各个的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析
</p>

<p>
只要能被 <span class="underline">invokestatic</span> 和 <span class="underline">invokespecial</span> 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有 <b>静态方法</b> 、 <b>私有方法</b> 、 <b>实例构造器</b> 、 <b>父类方法</b> 4类，它们在 <b>类加载的时候就会把符号引用解析为该方法的直接引用</b> 。这些方法可以称为 <span class="underline">非虚方法</span> ，与之相反，其他方法称为 <span class="underline">虚方法</span> (除去 <b>final</b> 方法，后文会提到)。下面代码中静态方法 <span class="underline">sayHello()</span> 只可能属于类型 <span class="underline">StaticResolution</span> ，没有任何手段可以覆盖或隐藏这个方法
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26041;&#27861;&#38745;&#24577;&#35299;&#26512;&#28436;&#31034;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * </span><span style="color: #ffd700;">@author</span><span style="color: #ffebcd;"> zzm</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">StaticResolution</span> {
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>() {
        System.out.println(<span style="color: #deb887;">"hello world"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        StaticResolution.sayHello();
    }
}
</pre>
</div>

<p>
使用 <span class="underline">javap</span> 命令查看这段程序的字节码，会发现的确是通过 <span class="underline">invokestatic</span> 命令来调用 <span class="underline">sayHello()</span> 方法的
</p>

<div class="org-src-container">
<pre class="src src-sh">$ javap -verbose StaticResolution.class

.....
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      <span style="color: #4eee94;">stack</span>=0, <span style="color: #4eee94;">locals</span>=1, <span style="color: #4eee94;">args_size</span>=1
         0: invokestatic  <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">5                  // Method sayHello:()V</span>
         3: return
      LineNumberTable:
        line 13: 0
        line 14: 3
}
</pre>
</div>

<pre class="example">
Java中的非虚方法还有一种，就是被final修饰的方法

虽然final方法是使用 invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的

在Java语言规范中明确说明了final方法是一种非虚方法
</pre>

<p>
解析调用一定是个 <b>静态</b> 的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成
</p>
</div>
</div>

<div id="outline-container-orgdb59c08" class="outline-3">
<h3 id="orgdb59c08">分派</h3>
<div class="outline-text-3" id="text-orgdb59c08">
<p>
<b>分派</b> 调用则可能是
</p>
<ul class="org-ul">
<li>静态的</li>
<li>动态的</li>
</ul>

<p>
根据分派依据的宗量数可分为 
</p>
<ul class="org-ul">
<li><span class="underline">单分派</span></li>
<li><span class="underline">多分派</span></li>
</ul>

<p>
这两类分派方式的两两组合就构成了 
</p>
<ul class="org-ul">
<li><span class="underline">静态单分派</span></li>
<li><span class="underline">静态多分派</span></li>
<li><span class="underline">动态单分派</span></li>
<li><span class="underline">动态多分派</span></li>
</ul>
</div>

<div id="outline-container-org8370acc" class="outline-4">
<h4 id="org8370acc">静态分派</h4>
<div class="outline-text-4" id="text-org8370acc">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26041;&#27861;&#38745;&#24577;&#20998;&#27966;&#28436;&#31034;</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">StaticDispatch</span> {

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Human</span> {
    }

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Man</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Human</span> {
    }

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Woman</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Human</span> {
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">guy</span>) {
        System.out.println(<span style="color: #deb887;">"hello,guy!"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">Man</span> <span style="color: #4eee94;">guy</span>) {
        System.out.println(<span style="color: #deb887;">"hello,gentleman!"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">Woman</span> <span style="color: #4eee94;">guy</span>) {
        System.out.println(<span style="color: #deb887;">"hello,lady!"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        <span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">man</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Man</span>();
        <span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">woman</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Woman</span>();
        <span style="color: #98f5ff;">StaticDispatch</span> <span style="color: #4eee94;">sr</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">StaticDispatch</span>();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}
</pre>
</div>

<p>
运行结果：
</p>
<pre class="example">
hello,guy!
hello,guy!

</pre>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">man</span>=<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Man</span>();
</pre>
</div>

<p>
上面代码中的 <span class="underline">Human</span> 称为变量的 <b>静态类型</b> ，后面的 <span class="underline">Man</span> 则称为变量的 <b>实际类型</b> ，区别:
</p>
<ul class="org-ul">
<li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的</li>
<li>而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23454;&#38469;&#31867;&#22411;&#21464;&#21270;</span>
<span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">man</span>=<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Man</span>(); 
man=<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Woman</span>();

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38745;&#24577;&#31867;&#22411;&#21464;&#21270;</span>
sr.sayHello((<span style="color: #98f5ff;">Man</span>)man);
sr.sayHello((<span style="color: #98f5ff;">Woman</span>)man);
</pre>
</div>

<p>
回到最开始的代码， <span class="underline">main()</span> 里面的两次 <span class="underline">sayHello()</span> 方法调用，在方法接收者已经确定是对象 <span class="underline">sr</span> 的前提下，使用哪个重载版本，就完全取决于 <b>传入参数的数量</b> 和 <b>数据类型</b> 。刻意地定义了两个静态类型相同但实际类型不同的变量，但虚拟机(准确地说是编译器)在 <b>重载时是通过参数的静态类型而不是实际类型</b> 作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了 <span class="underline">sayHello(Human)</span> 作为调用目标，并把这个方法的符号引用写到 <span class="underline">main()</span> 方法里的两条 <b>invokevirtual</b> 指令中
</p>

<p>
<b>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派</b> 。静态分派的典型应用是 <b>方法重载</b> 。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是  <span class="underline">唯一的</span> ，往往只能确定一个 <span class="underline">更加合适的</span> 版本
</p>

<pre class="example">
      产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断
</pre>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Overload</span> {

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">Object</span> <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello Object"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello int"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello long"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">Character</span> <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello Character"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello char"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">char</span>... <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello char ..."</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>(<span style="color: #98f5ff;">Serializable</span> <span style="color: #4eee94;">arg</span>) {
        System.out.println(<span style="color: #deb887;">"hello Serializable"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        sayHello(<span style="color: #deb887;">'a'</span>);
    }
}
</pre>
</div>

<p>
运行结果：
</p>
<pre class="example">
hello char

</pre>

<p>
这很好理解， 'a'  是一个 <span class="underline">char</span> 类型的数据，自然会寻找参数类型为char的重载方法,如果注释掉 <span class="underline">sayHello(char arg)</span> 方法，那输出会变为:
</p>

<pre class="example">
hello int

</pre>

<p>
这时发生了一次自动类型转换， 'a' 除了可以代表一个字符串，还可以代表数字97(字符a的Unicode数值为十进制数字97)，因此参数类型为 <span class="underline">int</span> 的重载也是合适的。继续注释掉 <span class="underline">sayHello(int arg)</span> 方法，那输出会变为:
</p>

<pre class="example">
hello long

</pre>

<p>
这时发生了两次自动类型转换， 'a' 转型为整数97之后，进一步转型为长整数 <span class="underline">97L</span> ，匹配了参数类型为 <span class="underline">long</span> 的重载。实际上自动转型还能继续发生多次，按照 <b>char-&gt;int-&gt;long-&gt;float-&gt;double</b> 的顺序转型进行匹配。但不会匹配到 <b>byte</b> 和 <b>short</b> 类型的重载，因为 <span class="underline">char</span> 到 <span class="underline">byte</span> 或 <span class="underline">short</span> 的转型是不安全的。继续注释掉 <span class="underline">sayHello(long arg)</span> 方法，那输会变为:
</p>

<pre class="example">
hello Character

</pre>

<p>
这时发生了一次自动装箱， 'a' 被包装为它的封装类型 <span class="underline">java.lang.Character</span> ，所以匹配到了参数类型为 <span class="underline">Character</span> 的重载，继续注释掉 <span class="underline">sayHello(Character arg)</span> 方法，那输出会变为:
</p>

<pre class="example">
hello Serializable

</pre>

<p>
出现hello Serializable，是因为 <span class="underline">java.lang.Serializable</span> 是 <span class="underline">java.lang.Character</span> 类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型
</p>
<pre class="example">
char可以转型成int，但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类

Character还实现了另外一个接口java.lang.Comparable&lt;Character&gt;

如果同时出现两个参数分别为Serializable和Comparable&lt;Character&gt;的重载方法，那它们在此时的优先级是一样的

编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译

程序必须在调用时显式地指定字面量的静态类型，如:sayHello((Comparable&lt;Character&gt;) 'a' )，才能编译通过
</pre>

<p>
下面继续注释掉 <span class="underline">sayHello(Serializable arg)</span> 方法，输出会变为:
</p>

<pre class="example">
hello Object

</pre>

<p>
这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。把 <span class="underline">sayHello(Object arg)</span> 也注释掉，输出将会变为:
</p>

<pre class="example">
hello char...

</pre>

<p>
7个重载方法已经被注释得只剩一个了，可见 <b>变长参数的重载优先级是最低的</b> ，这时候字符 'a' 被当做了一个 <b>数组元素</b> 
</p>
<pre class="example">
      这里使用的是char类型的变长参数，还可以选择int类型、Character类型、Object类型等的变长参数重载来演示一遍

      但要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的
</pre>

<p>
解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的
</p>
</div>
</div>

<div id="outline-container-org2480f68" class="outline-4">
<h4 id="org2480f68">动态分派</h4>
<div class="outline-text-4" id="text-org2480f68">
<p>
动态分派和多态性的另外一个重要体现： <b>重写</b> ( <span class="underline">Override</span> )有着很密切的关联
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26041;&#27861;&#21160;&#24577;&#20998;&#27966;&#28436;&#31034;</span>
<span style="color: #ffebcd;"> * </span><span style="color: #ffd700;">@author</span><span style="color: #ffebcd;"> zzm</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">DynamicDispatch</span> {

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Human</span> {
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>();
    }

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Man</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Human</span> {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>() {
            System.out.println(<span style="color: #deb887;">"man say hello"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Woman</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Human</span> {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sayHello</span>() {
            System.out.println(<span style="color: #deb887;">"woman say hello"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        <span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">man</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Man</span>();
        <span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">woman</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Woman</span>();
        man.sayHello();
        woman.sayHello();
        man = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Woman</span>();
        man.sayHello();
    }
}
</pre>
</div>

<p>
运行结果：
</p>
<pre class="example">
man say hello
woman say hello
woman say hello

</pre>

<p>
显然这里不可能再根据静态类型来决定，因为静态类型同样都是 <span class="underline">Human</span> 的两个变量 <span class="underline">man</span> 和 <span class="underline">woman</span> 在调用 <span class="underline">sayHello()</span> 方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的 <b>实际类型</b> 不同。使用 <span class="underline">javap</span> 命令输出这段代码的字节码，输出结果如下所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">  $ javap -verbose DynamicDispatch.class

  ......
    public static void main(java.lang.String[]);
      descriptor: ([Ljava/lang/String;)V
      flags: ACC_PUBLIC, ACC_STATIC
      Code:
        <span style="color: #4eee94;">stack</span>=2, <span style="color: #4eee94;">locals</span>=3, <span style="color: #4eee94;">args_size</span>=1
           0: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">2                  // class DynamicDispatch$Man</span>
           3: dup
           4: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">3                  // Method DynamicDispatch$Man."&lt;init&gt;":()V</span>
           7: astore_1
           8: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">4                  // class DynamicDispatch$Woman</span>
          11: dup
          12: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">5                  // Method DynamicDispatch$Woman."&lt;init&gt;":()V</span>
          15: astore_2
          16: aload_1
          17: invokevirtual <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">6                  // Method DynamicDispatch$Human.sayHello:()V</span>
          20: aload_2
          21: invokevirtual <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">6                  // Method DynamicDispatch$Human.sayHello:()V</span>
          24: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">4                  // class DynamicDispatch$Woman</span>
          27: dup
          28: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">5                  // Method DynamicDispatch$Woman."&lt;init&gt;":()V</span>
          31: astore_1
          32: aload_1
          33: invokevirtual <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">6                  // Method DynamicDispatch$Human.sayHello:()V</span>
          36: return
......
  }
</pre>
</div>

<p>
0~15行的字节码是准备动作：
</p>
<ul class="org-ul">
<li>建立man和woman的内存空间</li>
<li>调用Man和Woman类型的实例构造器</li>
<li>将这两个实例的引用存放在第1、2个局部变量表Slot之中</li>
</ul>

<p>
这个动作也就对应了代码中的这两句:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">man</span>=<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Man</span>(); 
<span style="color: #98f5ff;">Human</span> <span style="color: #4eee94;">woman</span>=<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Woman</span>();
</pre>
</div>

<ul class="org-ul">
<li>16、20两句分别把 <b>刚刚创建的两个对象的引用压到栈顶</b> ，这两个对象是将要执行的 <span class="underline">sayHello()</span> 方法的所有者，称为接收者(Receiver)</li>
<li>17和21句是方法调用指令</li>
</ul>

<p>
这两条调用指令单从字节码角度来看，无论是指令(都是 <span class="underline">invokevirtual</span> )还是参数(都是常量池中第22项的常量，注释显示了这个常量是 <span class="underline">Human.sayHello()</span> 的符号引用)完全一样的，但是这两句指令最终执行的目标方法并不相同。原因就在于invokevirtual指令的 <b>多态查找</b> 过程。invokevirtual指令的运行时解析过程大致分为以下几个步骤:
</p>
<ol class="org-ol">
<li>找到 <b>操作数栈顶的第一个元素所指向的对象的实际类型</b> ，记作 <span class="underline">C</span></li>
<li>如果 <b>在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验</b> 
<ul class="org-ul">
<li>如果通过则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回 <span class="underline">java.lang.IllegalAccessError</span> 异常</li>
</ul></li>
<li>否则， <b>按照继承关系从下往上依次对C的各个父类</b> 进行第2步的搜索和验证过程</li>
<li>如果始终没有找到合适的方法，则抛出 <span class="underline">java.lang.AbstractMethodError</span> 异常</li>
</ol>

<p>
由于 <span class="underline">invokevirtual</span> 指令执行的第一步就是在 <b>运行期确定接收者的实际类型</b> ，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法 <span class="underline">重写</span> 的本质。把这种 <b>在运行期根据实际类型确定方法执行版本的分派</b> 过程称为 <b>动态分派</b>
</p>
</div>
</div>

<div id="outline-container-org7a3696d" class="outline-4">
<h4 id="org7a3696d">单分派与多分派</h4>
<div class="outline-text-4" id="text-org7a3696d">
<p>
<b>方法的接收者与方法的参数</b> 统称为方法的 <span class="underline">宗量</span> 。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种
</p>
<ul class="org-ul">
<li>单分派是根据 <b>一个宗量</b> 对目标方法进行选择</li>
<li>多分派则是根据 <b>多于一个宗量</b> 对目标方法进行选择</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21333;&#20998;&#27966;&#12289;&#22810;&#20998;&#27966;&#28436;&#31034;</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Dispatch</span> {

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">QQ</span> {}

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">_360</span> {}

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Father</span> {
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">hardChoice</span>(<span style="color: #98f5ff;">QQ</span> <span style="color: #4eee94;">arg</span>) {
            System.out.println(<span style="color: #deb887;">"father choose qq"</span>);
        }

        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">hardChoice</span>(<span style="color: #98f5ff;">_360</span> <span style="color: #4eee94;">arg</span>) {
            System.out.println(<span style="color: #deb887;">"father choose 360"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Son</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Father</span> {
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">hardChoice</span>(<span style="color: #98f5ff;">QQ</span> <span style="color: #4eee94;">arg</span>) {
            System.out.println(<span style="color: #deb887;">"son choose qq"</span>);
        }

        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">hardChoice</span>(<span style="color: #98f5ff;">_360</span> <span style="color: #4eee94;">arg</span>) {
            System.out.println(<span style="color: #deb887;">"son choose 360"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        <span style="color: #98f5ff;">Father</span> <span style="color: #4eee94;">father</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Father</span>();
        <span style="color: #98f5ff;">Father</span> <span style="color: #4eee94;">son</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Son</span>();
        father.hardChoice(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">_360</span>());
        son.hardChoice(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">QQ</span>());
    }
}
</pre>
</div>

<p>
运行结果：
</p>

<pre class="example">
father choose 360
son choose qq

</pre>

<p>
在 <span class="underline">main</span> 函数中调用了两次 <span class="underline">hardChoice()</span> 方法，这两次 <span class="underline">hardChoice()</span> 方法的选择结果在程序输出中已经显示得很清楚了
</p>

<div class="org-src-container">
<pre class="src src-sh">$ javap -verbose Dispatch.class

.......
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      <span style="color: #4eee94;">stack</span>=3, <span style="color: #4eee94;">locals</span>=3, <span style="color: #4eee94;">args_size</span>=1
         0: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">2                  // class Dispatch$Father</span>
         3: dup
         4: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">3                  // Method Dispatch$Father."&lt;init&gt;":()V</span>
         7: astore_1
         8: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">4                  // class Dispatch$Son</span>
        11: dup
        12: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">5                  // Method Dispatch$Son."&lt;init&gt;":()V</span>
        15: astore_2
        16: aload_1
        17: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">6                  // class Dispatch$_360</span>
        20: dup
        21: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">7                  // Method Dispatch$_360."&lt;init&gt;":()V</span>
        24: invokevirtual <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">8                  // Method Dispatch$Father.hardChoice:(LDispatch$_360;)V</span>
        27: aload_2
        28: new           <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">9                  // class Dispatch$QQ</span>
        31: dup
        32: invokespecial <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">10                 // Method Dispatch$QQ."&lt;init&gt;":()V</span>
        35: invokevirtual <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">11                 // Method Dispatch$Father.hardChoice:(LDispatch$QQ;)V</span>
        38: return
</pre>
</div>

<p>
来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点:
</p>
<ol class="org-ol">
<li>静态类型是 <span class="underline">Father</span> 还是 <span class="underline">Son</span></li>
<li>方法参数是 <span class="underline">QQ</span> 还是 <span class="underline">360</span></li>
</ol>

<p>
这次选择结果的最终产物是产生了两条 <b>invokevirtual</b> 指令，两条指令的参数分别为常量池中指向 <span class="underline">Father.hardChoice(360)</span> 及 <span class="underline">Father.hardChoice(QQ)</span> 方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的 <b>静态分派属于多分派类型</b> 
</p>

<p>
运行阶段虚拟机的选择，也就是动态分派的过程。在执行 <span class="underline">son.hardChoice(newQQ())</span> 这句代码时，更准确地说，是在执行这句代码所对应的
<b>invokevirtual</b> 指令时，由于编译期已经决定目标方法的签名必须为 <span class="underline">hardChoice(QQ)</span> ，虚拟机此时不会关心传递过来的参数 <span class="underline">QQ</span> 到底是 <span class="underline">腾讯QQ</span> 还是 <span class="underline">奇瑞QQ</span> ，因为这时 <b>参数的静态类型、实际类型都对方法的选择</b> 不会构成任何影响，唯一可以影响虚拟机选择的因素只有此 <b>方法的接受者的实际类型</b> 是 <span class="underline">Father</span> 还是 <span class="underline">Son</span> 。因为 <b>只有一个宗量作为选择依据</b> ，所以Java语言的 <b>动态分派属于单分派类型</b> 
</p>

<p>
总之：1.8之前的Java语言是一门 <b>静态多分派、动态单分派</b> 的语言
</p>

<pre class="example">
JDK1.8之前而是通过内置动态语言(如JavaScript)执行引擎的方式来满足动态性的需求

但是Java虚拟机层面上则不是如此，在JDK 1.7中实现的JSR-292里面就已经开始提供对动态语言的支持了

JDK 1.7中新增的invokedymmic指令也成为了最复杂的一条方法调用的字节码指令
</pre>
</div>
</div>

<div id="outline-container-orgbb475b6" class="outline-4">
<h4 id="orgbb475b6">动态分派的实现</h4>
<div class="outline-text-4" id="text-orgbb475b6">
<p>
由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。面对这种情况，最常用的 <span class="underline">稳定优化</span> 手段就是为 <b>类在方法区中建立一个虚方法表</b> ( <span class="underline">Vritual Method Table</span> ，也称为 <span class="underline">vtable</span> ，与此对应的，在 <span class="underline">invokeinterface</span> 执行时也会用到接口方法表 <span class="underline">Inteface Method Table</span> ，简称 <span class="underline">itable</span> )，使用 <b>虚方法表索引</b> 来代替元数据查找以提高性能。虚方法表结构示例，如图所示：
</p>


<div class="figure">
<p><img src="pic/virtual-method-table.jpg" alt="virtual-method-table.jpg" width="70%" /> 
</p>
</div>

<p>
虚方法表中存放着 <span class="underline">各个方法的实际入口地址</span> 。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址
</p>
<ul class="org-ul">
<li>Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头</li>
<li>但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型</li>
</ul>

<p>
为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址
</p>

<p>
方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕
</p>

<pre class="example">
      虚拟机除了使用方法表之外,在条件允许的情况下,还会使用内联缓存( Inline Cache )和基于“类型继承关系分析” ( Class Hierarchy Analysis,CHA ) 技术的守护内联( Guarded Mining ) 两种非稳定的“激进优化”手段来获得更高的性能
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb4de79" class="outline-3">
<h3 id="orgdb4de79">动态类型语言支持</h3>
<div class="outline-text-3" id="text-orgdb4de79">
<p>
Java虚拟机毫无疑问是Java语言的运行平台，但它的使命并不仅限于此，早在1997年出版的《Java虚拟机规范》中就规划了这样一个愿景:“在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”。而目前确实已经有许多 <b>动态类型</b> 语言运行于Java虚拟机之上了，如 <span class="underline">Clojure</span> 、 <span class="underline">Groovy</span> 、 <span class="underline">Jython</span> 和 <span class="underline">JRuby</span> 等，能够在同一个虚拟机上可以达到静态类型语言的严谨性与动态类型语言的灵活性，这是一件很美妙的事情
</p>

<p>
但遗憾的是， <b>Java虚拟机层面对动态类型语言的支持一直都有所欠缺</b> ，主要表现在 <b>方法调用</b> 方面: JDK1.7以前的字节码指令集中，4条方法调用指令( <span class="underline">invokevirtual</span> 、 <span class="underline">invokespecial</span> 、 <span class="underline">invokestatic</span> 、 <span class="underline">invokeinterface</span> )的第一个参数都是 <b>被调用的方法的符号引用</b> (CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量)， <b>方法的符号引用在编译时产生，而动态类型语言只有在运行时才能确定接收者类型</b> 。这样，在Java虚拟机上实现的动态类型语言就不得不使用其他方式( <span class="underline">如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配</span> )来实现，这样势必让动态类型语言实现的复杂度增加，也可能带来额外的性能或者内存开销
</p>

<p>
尽管可以利用一些办法(如CallSiteCaching)让这些开销尽量变小，但这种底层问题终归是应当在虚拟机层次上去解决才最合适，因此在Java虚拟机层面上提供动态类型的直接支持就成为了Java平台的发展趋势之一，这就是JDK1.7(JSR-292)中 <span class="underline">invokedynamic</span> 指令以及 <span class="underline">java.lang.invoke</span> 包出现的技术背景
</p>
</div>

<div id="outline-container-orgd329244" class="outline-4">
<h4 id="orgd329244">java.lang.invoke包</h4>
<div class="outline-text-4" id="text-orgd329244">
<p>
JDK1.7实现了JSR-292，新加入的 <span class="underline">java.lang.invoke</span> 包就是JSR-292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的 <b>动态确定目标方法的机制</b> ，称为 <span class="underline">MethodHandle</span> 。不妨把 <span class="underline">MethodHandle</span> 与C/C++中的 <span class="underline">FunctionPointer</span> ，或者C#里面的 <span class="underline">Delegate</span> 类比一下。如果要实现一个带谓词的排序函数，在C/C++中常用的做法是把谓词定义为函数，用函数指针把谓词传递到排序方法，如下:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sort</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">list</span>[], <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">int</span>(*<span style="color: #daa520; font-weight: bold;">compare</span>)(<span style="color: #98f5ff;">int</span>,<span style="color: #98f5ff;">int</span>));
</pre>
</div>

<p>
但Java语言做不到这一点，即没有办法单独地把一个函数作为参数进行传递。普遍的做法是设计一个带有 <span class="underline">compare()</span> 方法的 <span class="underline">Comparator</span> 接口，以实现了这个接口的对象作为参数，例如Collections.sort()就是这样定义的:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sort</span> (<span style="color: #98f5ff;">List</span> <span style="color: #4eee94;">list</span>, <span style="color: #98f5ff;">Comparator</span> <span style="color: #4eee94;">c</span>);
</pre>
</div>

<p>
不过，在拥有 <span class="underline">MethodHandle</span> 之后，Java语言也可以拥有类似于函数指针或者委托的方法别名的工具了。下面代码演示了 <span class="underline">MethodHandle</span> 的基本用途，无论 <span class="underline">obj</span> 是何种类型(临时定义的 <span class="underline">ClassA</span> 或是实现 <span class="underline">PrintStream</span> 接口的实现类 <span class="underline">System.out</span> )，都可以正确地调用到 <span class="underline">println()</span> 方法
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodHandle</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodHandles</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodType</span>;

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MethodHandleTest</span> {

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ClassA</span> {
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">println</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s</span>) {
            System.out.println(s);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Throwable</span> {
        <span style="color: #98f5ff;">Object</span> <span style="color: #4eee94;">obj</span> = System.currentTimeMillis() % 2 == 0 ? System.out : <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ClassA</span>();
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26080;&#35770;obj&#26368;&#32456;&#26159;&#21738;&#20010;&#23454;&#29616;&#31867;&#65292;&#19979;&#38754;&#36825;&#21477;&#37117;&#33021;&#27491;&#30830;&#35843;&#29992;&#21040;println&#26041;&#27861;&#12290;</span>
        getPrintlnMH(obj).invokeExact(<span style="color: #deb887;">"icyfenix"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">MethodHandle</span> <span style="color: #daa520; font-weight: bold;">getPrintlnMH</span>(<span style="color: #98f5ff;">Object</span> <span style="color: #4eee94;">receiver</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Throwable</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">MethodType&#65306;&#20195;&#34920;&#8220;&#26041;&#27861;&#31867;&#22411;&#8221;</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#21547;&#20102;&#26041;&#27861;&#30340;&#36820;&#22238;&#20540;&#65288;methodType()&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#65289;</span>
        <span style="color: #5f9ea0; font-style: italic;">//             </span><span style="color: #5f9ea0; font-style: italic;">&#21644;&#20855;&#20307;&#21442;&#25968;&#65288;methodType()&#31532;&#20108;&#20010;&#21450;&#20197;&#21518;&#30340;&#21442;&#25968;&#65289;&#12290;</span>
        <span style="color: #98f5ff;">MethodType</span> <span style="color: #4eee94;">mt</span> = MethodType.methodType(<span style="color: #98f5ff;">void</span>.<span style="color: #00bfff; font-weight: bold;">class</span>, String.<span style="color: #00bfff; font-weight: bold;">class</span>);
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">lookup()&#26041;&#27861;&#26469;&#33258;&#20110;MethodHandles.lookup</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#21477;&#30340;&#20316;&#29992;&#26159;&#22312;&#25351;&#23450;&#31867;&#20013;&#26597;&#25214;&#31526;&#21512;&#32473;&#23450;&#30340;&#26041;&#27861;&#21517;&#31216;&#12289;&#26041;&#27861;&#31867;&#22411;&#65292;&#24182;&#19988;&#31526;&#21512;&#35843;&#29992;&#26435;&#38480;&#30340;&#26041;&#27861;&#21477;&#26564;&#12290;</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22240;&#20026;&#36825;&#37324;&#35843;&#29992;&#30340;&#26159;&#19968;&#20010;&#34394;&#26041;&#27861;&#65292;&#25353;&#29031;Java&#35821;&#35328;&#30340;&#35268;&#21017;&#65292;</span>
        <span style="color: #5f9ea0; font-style: italic;">//     </span><span style="color: #5f9ea0; font-style: italic;">&#26041;&#27861;&#31532;&#19968;&#20010;&#21442;&#25968;&#26159;&#38544;&#24335;&#30340;&#65292;&#20195;&#34920;&#35813;&#26041;&#27861;&#30340;&#25509;&#25910;&#32773;&#65292;&#20063;&#21363;&#26159;this&#25351;&#21521;&#30340;&#23545;&#35937;&#65292;</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#20010;&#21442;&#25968;&#20197;&#21069;&#26159;&#25918;&#22312;&#21442;&#25968;&#21015;&#34920;&#20013;&#36827;&#34892;&#20256;&#36882;&#65292;&#29616;&#22312;&#25552;&#20379;&#20102;bindTo()&#26041;&#27861;&#26469;&#23436;&#25104;&#36825;&#20214;&#20107;&#24773;&#12290;</span>
        <span style="color: #00bfff; font-weight: bold;">return</span> MethodHandles.lookup().findVirtual(receiver.getClass(), <span style="color: #deb887;">"println"</span>, mt).bindTo(receiver);
    }
}
</pre>
</div>
<p>
实际上方法 <span class="underline">getPrintlnMH()</span> 中模拟了 <b>invokevirtual</b> 指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个具体方法来实现。而这个方法本身的返回值( <b>MethodHandle</b> 对象)，可以视为对最终调用方法的一个 <span class="underline">引用</span> 。以此为基础，有了MethodHandle就可以写出类似于下面这样的函数声明:  
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sort</span> (<span style="color: #98f5ff;">List</span> <span style="color: #4eee94;">list</span>, <span style="color: #98f5ff;">MethodHandle</span> <span style="color: #4eee94;">compare</span>);
</pre>
</div>

<p>
使用 <span class="underline">MethodHandle</span> 并没有什么困难，不过看完它的用法之后，相同的事情，用反射不是早就可以实现了吗?
</p>

<p>
确实，仅站在Java语言的角度来看， <span class="underline">MethodHandle</span> 的使用方法和效果与 <span class="underline">Reflection</span> 有众多相似之处，不过，它们还是有以下这些区别:
</p>
<ul class="org-ul">
<li>Reflection是在 <b>模拟Java代码层次的方法调用</b> ，而MethodHandle是在 <b>模拟字节码层次的方法调用</b> 。在 <b>MethodHandles.lookup</b> 中的3个方法: <span class="underline">findStatic()</span> 、 <span class="underline">findVirtual()</span> 、 <span class="underline">findSpecial()</span> 正是为了对应于 <span class="underline">invokestatic</span> 、 <span class="underline">invokevirtual</span> 、 <span class="underline">invokeinterface</span> 和 <span class="underline">invokespecial</span> 这几条字节码指令的 <b>执行权限校验行为</b> ，而这些底层细节在使用ReflectionAPI时是不需要关心的</li>
<li>Reflection中的 <span class="underline">java.lang.reflect.Method</span> 对象远比MethodHandle机制中的 <span class="underline">java.lang.invoke.MethodHandle</span> 对象所包含的信息多
<ul class="org-ul">
<li><span class="underline">java.lang.reflect.Method</span> : 是 <b>方法在Java一端的全面映像</b> ，包含了 <span class="underline">方法的签名</span> 、 <span class="underline">描述符</span> 以及 <span class="underline">方法属性表中各种属性的Java端表示方式</span> ，还包含 <span class="underline">执行权限等的运行期信息</span></li>
<li><span class="underline">java.lang.invoke.MethodHandle</span> : 仅仅包含与 <span class="underline">执行该方法相关的信息</span></li>
</ul></li>
<li>由于MethodHandle是对 <b>字节码的方法指令调用的模拟</b> ，所以理论上 <span class="underline">虚拟机在这方面做的各种优化</span> (如方法内联)，在MethodHandle上也应当可以采用类似思路去支持(但目前实现还不完善)。而通过反射去调用方法则不行</li>
<li>最关键的一点还在于去掉前面讨论施加的前提 <span class="underline">仅站在Java语言的角度来看</span> : 
<ul class="org-ul">
<li>Reflection API的设计目标是 <b>只为Java语言服务</b> 的</li>
<li>而MethodHandle则设计成可 <b>服务于所有Java虚拟机之上的语言</b> ，其中也包括Java语言</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf095c51" class="outline-4">
<h4 id="orgf095c51">invokedynamic指令</h4>
<div class="outline-text-4" id="text-orgf095c51">
<p>
上面使用 <span class="underline">MethodHandle</span> 的示例代码反编译后也不会看见 <b>invokedynamic</b> 的身影，它的应用之处在哪里呢?
</p>

<p>
在某种程度上， <span class="underline">invokedynamic</span> 指令与 <span class="underline">MethodHandle</span> 机制的作用是一样的，都是为了解决原有4条 <span class="underline">invoke</span> 指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户(包含其他语言的设计者)有更高的自由度。而且，它们两者的思路也是可类比的，可以把它们想象成为了达成同一个目的：
</p>
<ul class="org-ul">
<li>MethodHandle: 采用上层Java代码和API来实现</li>
<li>invokedynamic: 用字节码和Class中其他属性、常量来完成</li>
</ul>

<p>
每一处含有invokedynamic指令的位置都称做 <span class="underline">动态调用点</span> (Dynamic Call Site)，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而变为JDK1.7新加入的 <b>CONSTANT_InvokeDynamic_info</b> 常量，从这个新常量中可以得到3项信息:
</p>
<ul class="org-ul">
<li><span class="underline">BootstrapMethod</span>  : 引导方法，存放在新增的 <span class="underline">BootstrapMethods</span> 属性中
<ul class="org-ul">
<li>引导方法是有固定的参数，并且返回是 <span class="underline">java.langinvoke.CallSite</span> 对象，这个代表真正要执行的目标方法调用</li>
</ul></li>
<li><span class="underline">MethodType</span> : 方法类型</li>
<li>名称</li>
</ul>

<p>
根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.MethodHandles.<span style="color: #98f5ff;">lookup</span>;

<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">CallSite</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">ConstantCallSite</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodHandle</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodHandles</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodType</span>;

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">InvokeDynamicTest</span> {

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Throwable</span> {
        INDY_BootstrapMethod().invokeExact(<span style="color: #deb887;">"icyfenix"</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">testMethod</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s</span>) {
        System.out.println(<span style="color: #deb887;">"hello String:"</span> + s);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">CallSite</span> <span style="color: #daa520; font-weight: bold;">BootstrapMethod</span>(<span style="color: #ffd700;">MethodHandles</span>.<span style="color: #98f5ff;">Lookup</span> <span style="color: #4eee94;">lookup</span>, <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">MethodType</span> <span style="color: #4eee94;">mt</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Throwable</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ConstantCallSite</span>(lookup.findStatic(InvokeDynamicTest.<span style="color: #00bfff; font-weight: bold;">class</span>, name, mt));
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">MethodType</span> <span style="color: #daa520; font-weight: bold;">MT_BootstrapMethod</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> MethodType.fromMethodDescriptorString(
            <span style="color: #deb887;">"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"</span>,
            <span style="color: #ffd700;">null</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">MethodHandle</span> <span style="color: #daa520; font-weight: bold;">MH_BootstrapMethod</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Throwable</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> lookup().findStatic(InvokeDynamicTest.<span style="color: #00bfff; font-weight: bold;">class</span>,
                       <span style="color: #deb887;">"BootstrapMethod"</span>,
                       <span style="color: #98f5ff;">MT_BootstrapMethod</span>());
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">MethodHandle</span> <span style="color: #daa520; font-weight: bold;">INDY_BootstrapMethod</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Throwable</span> {
        <span style="color: #98f5ff;">CallSite</span> <span style="color: #4eee94;">cs</span> = (<span style="color: #98f5ff;">CallSite</span>) MH_BootstrapMethod().invokeWithArguments(lookup(),
                                          <span style="color: #deb887;">"testMethod"</span>,
                                          MethodType.fromMethodDescriptorString(
                                              <span style="color: #deb887;">"(Ljava/lang/String;)V"</span>, <span style="color: #ffd700;">null</span>));
        <span style="color: #00bfff; font-weight: bold;">return</span> cs.dynamicInvoker();
    }
}
</pre>
</div>

<p>
这段代码与前面 <span class="underline">MethodHandleTest</span> 的作用基本上是一样的
</p>
<pre class="example">
由于 invokedynamic 指令所面向的使用者并非Java语言，而是其他Java虚拟机之上的动态语言

因此仅依靠Java语言的编译器Javac没有办法生成带有invokedynamic指令的字节码

曾经有一个java.dyn.InvokeDymmic的语法糖可以实现，但后来被取消了

要使用Java语言来演示invokedynamic指令只能用一些变通的办法

John Rose编写了一个把程序的字节码转换为使用 invokedynamic 的简单工具 INDY 来完成这件事情

要使用这个工具来产生最终要的字节码，因此这个示例代码中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为它们是要被INDY工具读取的
</pre>

<p>
把上面代码编译、再使用 <span class="underline">INDY</span> 转换后重新生成的字节码：
</p>


<div class="figure">
<p><img src="pic/invoke-dynamic-indy.jpg" alt="invoke-dynamic-indy.jpg" width="70%" /> 
</p>
</div>

<p>
从main()方法的字节码可见，原本的方法调用指令已经替换为 <span class="underline">invokedynamic</span> ,它的参数为 <span class="underline">第123项常量</span> (第二个值为0的参数在HotSpot中用不到与invokeinterface指令那个值为0的参数一样都是占位的)
</p>

<div class="org-src-container">
<pre class="src src-sh">2 :invokedynamic#123 ,0//InvokeDynamic#0 :testMethod :(Ljava/lang/String ; )V
</pre>
</div>

<p>
从常量池中可见，第123项常量显示 <span class="underline">#123=InvokeDynamic#0:#121</span> 说明它是一项CONSTANT_InvokeDynamic_info类型常量
</p>
<ul class="org-ul">
<li><span class="underline">#0</span> ：引导方法取 <span class="underline">BootstrapMethods</span> 属性表的第 <span class="underline">0</span> 项(示例中仅有一个引导方法，即BootstrapMethod())</li>
<li><span class="underline">#121</span> ：引用第121项类型为CONSTANT_NameAndType_info的常量，从这个常量中可以获取方法名称和描述符，即后面输出的 <span class="underline">testMethod:(Ljava/lang/String;)V</span></li>
</ul>

<p>
再看一下 <span class="underline">BootstrapMethod()</span> ，这个方法Java源码中没有，是INDY产生的，但是它的字节码很容易读懂，逻辑
</p>
<ol class="org-ol">
<li>调用 <span class="underline">MethodHandles$Lookup的findStatic()</span> 方法，产生 <span class="underline">testMethod()</span> 方法的 <span class="underline">MethodHandle</span></li>
<li>用它创建一个 <span class="underline">ConstantCallSite</span> 对象</li>
<li>这个对象返回给 <span class="underline">invokedynamic</span> 指令，实现对 <span class="underline">testMethod()</span> 方法的调用</li>
</ol>
</div>
</div>

<div id="outline-container-orgac30d9a" class="outline-4">
<h4 id="orgac30d9a">掌控方法分派规则</h4>
<div class="outline-text-4" id="text-orgac30d9a">
<p>
invokedynamic指令与前面4条 invoke* 指令的最大差别就是 <b>它的分派逻辑不是由虚拟机决定的，而是由程序员决定</b> 
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">GrandFather</span> {
    <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">thinking</span>() {
        System.out.println(<span style="color: #deb887;">"i am grandfather"</span>);
    }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Father</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">GrandFather</span> {
    <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">thinking</span>() {
        System.out.println(<span style="color: #deb887;">"i am father"</span>);
    }
}

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Son</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Father</span> {
    <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">thinking</span>() {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35831;&#35835;&#32773;&#22312;&#36825;&#37324;&#22635;&#20837;&#36866;&#24403;&#30340;&#20195;&#30721;&#65288;&#19981;&#33021;&#20462;&#25913;&#20854;&#20182;&#22320;&#26041;&#30340;&#20195;&#30721;&#65289;</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23454;&#29616;&#35843;&#29992;&#31062;&#29238;&#31867;&#30340;thinking()&#26041;&#27861;&#65292;&#25171;&#21360;"i am grandfather"</span>
    }
}
</pre>
</div>

<p>
在JDK1.7之前，使用纯粹的Java语言很难处理这个问题(直接生成字节码就很简单，如使用 <span class="underline">ASM</span> 等字节码工具)，原因是在 <span class="underline">Son</span> 类的 <span class="underline">thinking()</span> 方法中 <b>无法获取一个实际类型是 <span class="underline">GrandFather</span> 的对象引用</b> ，而 <span class="underline">invokevirtual</span> 指令的分派逻辑就是 <span class="underline">按照方法接收者的实际类型进行分配</span> ，这个逻辑是固化在虚拟机中的，程序员无法改变。在JDK1.7中，可以使用下面代码的程序来解决这个问题：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.MethodHandles.<span style="color: #98f5ff;">lookup</span>;

<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodHandle</span>;
<span style="color: #00bfff; font-weight: bold;">import</span> <span style="color: #ffd700;">java</span>.<span style="color: #ffd700;">lang</span>.<span style="color: #ffd700;">invoke</span>.<span style="color: #98f5ff;">MethodType</span>;

<span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Test</span> {

    <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">GrandFather</span> {
        <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">thinking</span>() {
            System.out.println(<span style="color: #deb887;">"i am grandfather"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Father</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">GrandFather</span> {
        <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">thinking</span>() {
            System.out.println(<span style="color: #deb887;">"i am father"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Son</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Father</span> {
        <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">thinking</span>() {
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                <span style="color: #98f5ff;">MethodType</span> <span style="color: #4eee94;">mt</span> = MethodType.methodType(<span style="color: #98f5ff;">void</span>.<span style="color: #00bfff; font-weight: bold;">class</span>);
                <span style="color: #98f5ff;">MethodHandle</span> <span style="color: #4eee94;">mh</span> = lookup().findVirtual(GrandFather.<span style="color: #00bfff; font-weight: bold;">class</span>, <span style="color: #deb887;">"thinking"</span>, mt).bindTo(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">GrandFather</span>());
                mh.invokeExact();
            } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">e</span>) {
            }
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        (<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Test</span>().<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Son</span>()).thinking();
    }
}
</pre>
</div>

<pre class="example">
i am a grandfather

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org32e1821" class="outline-2">
<h2 id="org32e1821">执行引擎</h2>
<div class="outline-text-2" id="text-org32e1821">
<p>
许多Java虚拟机的执行引擎在执行Java代码的时候都有 <b>解释</b> 执行(通过解释器执行)和 <b>编译</b> 执行(通过即时编译器产生本地代码执行)两种选择
</p>
</div>

<div id="outline-container-org5f76ba3" class="outline-3">
<h3 id="org5f76ba3">解释执行</h3>
<div class="outline-text-3" id="text-org5f76ba3">
<p>
Java语言经常被人们定位为 <span class="underline">解释</span> 执行的语言，在Java初生的JDK1.0时代，这种定义还算是比较准确的，但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。后来，Java也发展出了可以直接生成本地代码的编译器(如GNU Compiler for the Java)，而C/C++语言也出现了通过解释器执行的版本(如CINT)，这时候再笼统地说 <span class="underline">解释</span> 执行，对于整个Java语言来说就成了几乎是没有意义的概念，只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切
</p>

<p>
不论是解释还是编译，也不论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后就获得了执行能力。大部分的程序代码到物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤:
</p>


<div class="figure">
<p><img src="pic/compile-process.jpg" alt="compile-process.jpg" width="30%" /> 
</p>
</div>

<ul class="org-ul">
<li>左边那条分支，就是解释执行的过程</li>
<li>右边那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程</li>
</ul>


<p>
如今，基于物理机、Java虚拟机，或者非Java的其他高级语言虚拟机(HLLVM)的语言，大多都会遵循这种基于现代经典编译原理的思路：在执行前先对程序源码进行 <span class="underline">词法分析</span> 和 <span class="underline">语法分析</span> 处理，把源码转化为 <span class="underline">抽象语法树</span> (AST)。对于一门具体语言的实现来说：
</p>
<ul class="org-ul">
<li><span class="underline">词法分析</span> 、 <span class="underline">语法分析</span> 以至后面的 <span class="underline">优化器</span> 和 <span class="underline">目标代码生成器</span> 都可以选择独立于执行引擎，形成一个完整意义的 <b>编译器</b> 去实现，这类代表是C/C++语言</li>
<li>把其中一部分步骤(如 <span class="underline">生成抽象语法树之前的步骤</span> )实现为一个半独立的编译器，这类代表是Java语言</li>
<li>把 <span class="underline">这些步骤和执行引擎全部集中封装在一个封闭的黑匣子</span> 之中，如大多数的JavaScript执行器</li>
</ul>

<p>
Java语言中: 
</p>
<ul class="org-ul">
<li><b>Javac编译器</b> ：完成了程序代码经过 <span class="underline">词法分析</span> 、 <span class="underline">语法分析</span> 到 <span class="underline">抽象语法树</span> ,再遍历语法树生成线性的 <span class="underline">字节码指令流</span> 的过程。这一切都是Java虚拟机之外</li>
<li><b>解释器</b> ：在虚拟机的内部,所以Java程序的编译就是半独立的实现</li>
</ul>
</div>
</div>

<div id="outline-container-org4e13848" class="outline-3">
<h3 id="org4e13848">基于栈的指令集</h3>
<div class="outline-text-3" id="text-org4e13848">
<p>
Java编译器输出的指令流，基本上是一种 <span class="underline">基于栈的指令集架构</span> (ISA)，指令流中的指令大部分都是 <b>零地址指令</b> ，它们依赖 <b>操作数栈</b> 进行工作
</p>
<pre class="example">
     与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集

     现在主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作
</pre>

<p>
使用这两种指令集计算 <span class="underline">1+1</span> 的结果，基于栈的指令集会是这样子的:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">iconst_1</span>
<span style="color: #daa520; font-weight: bold;">iconst_1</span>
<span style="color: #daa520; font-weight: bold;">iadd</span>
<span style="color: #daa520; font-weight: bold;">istore_0</span>
</pre>
</div>

<ol class="org-ol">
<li>两条 <span class="underline">iconst_1</span> 指令连续把两个常量1 <span class="underline">压入栈</span> 后</li>
<li><span class="underline">iadd</span> 指令把栈顶的两个值 <span class="underline">出栈</span> 、相加，然后把结果放回 <span class="underline">栈顶</span></li>
<li><span class="underline">istore_0</span> 把栈顶的值放到 <span class="underline">局部变量表的第0个Slot</span> 中</li>
</ol>

<p>
如果基于寄存器，那程序可能会是这个样子：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">mov</span> <span style="color: #00bfff; font-weight: bold;">eax</span> ,1 
<span style="color: #daa520; font-weight: bold;">add</span> <span style="color: #00bfff; font-weight: bold;">eax</span> ,1
</pre>
</div>

<ol class="org-ol">
<li><span class="underline">mov</span> 指令把 <span class="underline">EAX寄存器</span> 的值设为1</li>
<li><span class="underline">add</span> 指令再把这个值加1, 结果就保存在 <span class="underline">EAX寄存器</span> 里面</li>
</ol>
</div>

<div id="outline-container-orgf1b7cdc" class="outline-4">
<h4 id="orgf1b7cdc">基于栈的指令集优缺点</h4>
<div class="outline-text-4" id="text-orgf1b7cdc">
<ul class="org-ul">
<li>优点:
<ul class="org-ul">
<li><b>可移植</b> ，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。例如，现在32位80x86体系的处理器中提供了8个32位的寄存器，而ARM体系的CPU提供了16个32位的通用寄存器。如果使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据(程序计数器、栈顶缓存等)放到寄存器中以获取尽量好的性能，这样实现起来也更加简单一些</li>
<li><b>代码相对更加紧凑</b> ：字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数</li>
<li><b>编译器实现更加简单</b> ：不需要考虑空间分配的问题，所需空间都在栈上操作</li>
</ul></li>
<li>缺点：
<ul class="org-ul">
<li><b>执行速度相对来说会稍慢一些</b> ：由于 <span class="underline">指令数量</span> 和 <span class="underline">内存访问</span> 的原因，所以导致了栈架构指令集的执行速度会相对较慢：
<ul class="org-ul">
<li>虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量</li>
<li>更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法</li>
</ul></li>
</ul></li>
</ul>

<pre class="example">
      这里说的是物理机器上的寄存器，也有基于虚拟机寄存器的实现，如Android平台的Dalvik VM

      即使是基于寄存器的虚拟机，也希望把虚拟机寄存器尽量映射到物理寄存器上以获取尽可能高的性能
</pre>
</div>
</div>
</div>

<div id="outline-container-org72d5e97" class="outline-3">
<h3 id="org72d5e97">基于栈的解释器执行过程</h3>
<div class="outline-text-3" id="text-org72d5e97">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">calc</span>() {
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">a</span> = 100;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">b</span> = 200;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span> = 300;
    <span style="color: #00bfff; font-weight: bold;">return</span> (a + b) * c;
}
</pre>
</div>

<p>
使用 <span class="underline">javap</span> 命令后得如下反编译代码： 
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">int</span> calc()<span style="color: #5f9ea0; font-style: italic;">;</span>
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">....</span>
<span style="color: #daa520; font-weight: bold;">Code</span>:
      <span style="color: #00bfff; font-weight: bold;">stack=2</span>, locals=4, args_size=1
         <span style="color: #00bfff; font-weight: bold;">0</span>: bipush        100
         <span style="color: #00bfff; font-weight: bold;">2</span>: istore_1
         <span style="color: #00bfff; font-weight: bold;">3</span>: sipush        200
         <span style="color: #00bfff; font-weight: bold;">6</span>: istore_2
         <span style="color: #00bfff; font-weight: bold;">7</span>: sipush        300
        <span style="color: #00bfff; font-weight: bold;">10</span>: istore_3
        <span style="color: #00bfff; font-weight: bold;">11</span>: iload_1
        <span style="color: #00bfff; font-weight: bold;">12</span>: iload_2
        <span style="color: #00bfff; font-weight: bold;">13</span>: iadd
        <span style="color: #00bfff; font-weight: bold;">14</span>: iload_3
        <span style="color: #00bfff; font-weight: bold;">15</span>: imul
        <span style="color: #00bfff; font-weight: bold;">16</span>: ireturn
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">...</span>
</pre>
</div>

<p>
下面用图对该过程进行描述：
</p>


<div class="figure">
<p><img src="pic/stack-process-1.png" alt="stack-process-1.png" width="50%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/stack-process-2.png" alt="stack-process-2.png" width="50%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/stack-process-3.png" alt="stack-process-3.png" width="50%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/stack-process-4.png" alt="stack-process-4.png" width="50%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/stack-process-5.png" alt="stack-process-5.png" width="50%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/stack-process-6.png" alt="stack-process-6.png" width="50%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/stack-process-7.png" alt="stack-process-7.png" width="50%" /> 
</p>
</div>

<pre class="example">
     上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述

     更准确地说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化

     例如在HotSpot虚拟机中,有很多以"fast_"开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能,而即时编译的优化手段更加花样繁多
</pre>

<p>
从这段程序的执行中也可以看出栈结构指令集的一般运行过程,整个运算过程的中间变量都以 <b>操作数栈的出栈、入栈</b> 为 <b>信息交换</b> 途径
</p>

<p>
<a href="jvm_example.html">Next：虚拟机实践</a>
</p>

<p>
<a href="class_loader.html">Previous：类加载</a>
</p>

<p>
<a href="jvm.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
