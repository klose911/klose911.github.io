<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>内存模型</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="jvm_example.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">内存模型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3a66ffb">硬件的效率与一致性</a></li>
<li><a href="#orgfbe8f2d">JVM内存模型</a>
<ul>
<li><a href="#org6a3923d">主内存与工作内存</a></li>
<li><a href="#orgd5c32f5">内存间交互操作</a>
<ul>
<li><a href="#orgeefc6d9">执行顺序</a></li>
</ul>
</li>
<li><a href="#org2953955">volatile型变量的特殊规则</a>
<ul>
<li><a href="#org541f4af">可见性</a></li>
<li><a href="#org498d707">指令重排</a></li>
<li><a href="#org74bf303">总结</a></li>
<li><a href="#org41e78d7">对于long和double型变量的特殊规则</a></li>
</ul>
</li>
<li><a href="#org2506188">原子性、可见性与有序性</a>
<ul>
<li><a href="#org542da1a">原子性</a></li>
<li><a href="#org71e31f1">可见性</a></li>
<li><a href="#orgbdb3ed6">有序性</a>
<ul>
<li><a href="#orgabb6f63">先行发生原则</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org74dec75">JVM线程实现</a>
<ul>
<li><a href="#orgf3ae4ad">线程的实现</a>
<ul>
<li><a href="#org4a252da">使用内核线程实现</a></li>
<li><a href="#org1a0569d">使用用户线程实现</a></li>
<li><a href="#org9f319bc">使用用户线程加轻量级进程混合实现</a>
<ul>
<li><a href="#org883c6d3">JDK线程的实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb4f1a19">线程调度</a>
<ul>
<li><a href="#orge852d66">协同式</a></li>
<li><a href="#orgb9877b6">抢占式</a>
<ul>
<li><a href="#org1fe6a6c">Java线程调度</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdba3788">状态切换</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>多任务处理</b> 在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是 <b>计算机的 <span class="underline">运算</span> 速度与它的 <span class="underline">存储</span> 和 <span class="underline">通信</span> 子系统速度的差距太大</b> ，大量的时间都花费在 <span class="underline">磁盘I/O</span> 、 <span class="underline">网络通信</span> 或者 <span class="underline">数据库</span> 访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的“压榨”手段
</p>

<p>
除了充分利用计算机处理器的能力外， <b>一个服务端同时对多个客户端</b> 提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏， <b>每秒事务处理数</b> ( <span class="underline">TPS</span> )是最重要的指标之一，它代表着 <b>一秒内服务端平均能响应的请求总数</b> ，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间 <span class="underline">频繁阻塞</span> 甚至 <span class="underline">死锁</span> ，将会 <b>大大降低程序的并发能力</b> 
</p>


<p>
服务端是Java语言最擅长的领域之一，这个领域的应用占了Java应用中最大的一块份额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持。幸好Java语言和虚拟机提供了许多工具，把并发编程的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线程并发细节，使得程序员在编码时能更关注业务逻辑，而不是花费大部分时间去关注此服务会同时被多少人调用、如何协调硬件资源
</p>

<p>
但是无论语言、中间件和框架如何先进，开发人员都不能期望它们能独立完成所有并发处理的事情，了解并发的内幕也是成为一个高级程序员不可缺少的课程
</p>

<pre class="example">
Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力

摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系

这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程
</pre>
<div id="outline-container-org3a66ffb" class="outline-2">
<h2 id="org3a66ffb">硬件的效率与一致性</h2>
<div class="outline-text-2" id="text-org3a66ffb">
<p>
先花费一点时间去了解一下物理计算机中的 <b>并发</b> 问题
</p>
<pre class="example">
    物理机遇到的并发问题与虚拟机中的情况有不少相似之处

    物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义
</pre>

<p>
<span class="underline">让计算机并发执行若干个运算任务</span> 与 <span class="underline">更充分地利用计算机处理器的效能</span> 之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是 <b>绝大多数的运算任务都不可能只靠处理器 <span class="underline">计算</span> 就能完成</b> ，处理器至少要与 <b>内存交互</b> ，如 <span class="underline">读取运算数据</span> 、 <span class="underline">存储运算结果</span> 等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层 <b>读写速度尽可能接近处理器运算速度的高速缓存</b> 来作为内存与处理器之间的缓冲：
</p>
<ul class="org-ul">
<li>将运算 <b>需要使用到的数据复制到缓存</b> 中，让运算能快速进行</li>
<li>当运算结束后再从 <b>缓存同步计算结果回内存</b> 之中，这样处理器就无须等待缓慢的内存读写了</li>
</ul>

<p>
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题： <b>缓存一致性</b> 。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如下图所示：
</p>


<div class="figure">
<p><img src="pic/cache_coherence.png" alt="cache_coherence.png" width="50%" /> 
</p>
</div>

<pre class="example">
    当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致

    如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

    为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作

    这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等
</pre>
<p>
以后将会多次提到的 <span class="underline">内存模型</span> 一词，可以理解为 <b>在 <span class="underline">特定的操作协议</span> 下，对 <span class="underline">特定的内存</span> 或 <span class="underline">高速缓存</span> 进行读写访问的过程抽象</b> 
</p>
<pre class="example">
    不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型

    这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性
</pre>

<p>
除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行 <span class="underline">乱序执行</span> 优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其 <b>顺序性并不能靠代码的先后顺序来保证</b> 。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的 <span class="underline">指令重排序</span> 优化
</p>
</div>
</div>
<div id="outline-container-orgfbe8f2d" class="outline-2">
<h2 id="orgfbe8f2d">JVM内存模型</h2>
<div class="outline-text-2" id="text-orgfbe8f2d">
<p>
Java虚拟机规范中试图定义一种 <span class="underline">Java内存模型</span> (JMM)来 <b>屏蔽掉各种硬件和操作系统的内存访问差异</b> ，以实现让Java程序在各种平台下都能达到一致的内存访问效果
</p>
<pre class="example">
    在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型

    由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错

    因此在某些场景就必须针对不同的平台来编写程序
</pre>

<p>
定义Java内存模型并非一件容易的事情：
</p>
<ul class="org-ul">
<li>这个模型必须定义得 <b>足够严谨</b> ，才能让Java的并发内存访问操作不会产生歧义</li>
<li>也必须定义得 <b>足够宽松</b> ，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度</li>
</ul>

<p>
经过长时间的验证和修补，在 JDK 1.5（实现了 <span class="underline">JSR-133[2]</span> ）发布后，Java内存模型已经成熟和完善起来了
</p>
</div>
<div id="outline-container-org6a3923d" class="outline-3">
<h3 id="org6a3923d">主内存与工作内存</h3>
<div class="outline-text-3" id="text-org6a3923d">
<p>
Java内存模型的主要目标是 <b>定义程序中各个变量的访问规则</b> ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的 <span class="underline">变量</span> 与 <span class="underline">Java编程中所说的变量</span> 有所区别，它包括了 <span class="underline">实例字段</span> 、 <span class="underline">静态字段</span> 和 <span class="underline">构成数组对象的元素</span> ，但不包括 <b>局部变量</b> 与 <b>方法参数</b> ，因为后者是 <b>线程私有的</b> ，不会被共享，自然就不会存在竞争问题
</p>
<pre class="example">
为了获得较好的执行效能

Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互

也没有限制即时编译器进行调整代码执行顺序这类优化措施
</pre>

<p>
Java内存模型规定了 <b>所有的变量都存储在主内存</b> 中
</p>
<pre class="example">
     此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分
</pre>

<p>
每条 <b>线程</b> 还有自己的 <b>工作内存</b> ：
</p>
<ul class="org-ul">
<li>线程的工作内存中保存了被该线程使用到的 <b>变量的主内存副本拷贝</b></li>
<li>线程对变量的所有操作（ <span class="underline">读取</span> 、 <span class="underline">赋值</span> 等）都必须在 <b>工作内存</b> 中进行，而不能 <b>直接读写主内存中的变量</b></li>
<li><b>不同的线程</b> 之间也 <b>无法直接访问对方工作内存中的变量</b> ，线程间变量值的 <b>传递</b> 均需要通过 <span class="underline">主内存</span> 来完成</li>
</ul>
<pre class="example">
     可与前面讲的处理器高速缓存类比
</pre>

<p>
线程、主内存、工作内存三者的交互关系如下图所示：
</p>

<div class="figure">
<p><img src="pic/working_memory.png" alt="working_memory.png" width="50%" /> 
</p>
</div>


<p>
注意：
</p>
<ul class="org-ul">
<li>如果局部变量是一个 <span class="underline">reference</span> 类型，它引用的对象在 <b>Java堆中可被各个线程共享</b> ，但是reference本身在 <b>Java栈的局部变量表</b> 中，它是 <b>线程私有的</b></li>
<li>拷贝副本，假设线程中访问一个10MB的对象，也会把这10MB的内存复制一份拷贝出来吗？ 事实上并不会如此， 这个 <span class="underline">对象的引用</span> 、对象中 <span class="underline">某个在线程访问到的字段</span> 是 <b>有可能存在拷贝</b> 的，但不会有虚拟机实现成把整个对象拷贝一次</li>
<li><b>volatile</b> 变量依然有 <b>工作内存的拷贝</b> ，但是由于它 <b>特殊的操作顺序性</b> 规定，所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于volatile也并不存在例外</li>
<li>除了实例数据，Java堆还保存了对象的其他信息，对于HotSpot虚拟机来讲 
<ul class="org-ul">
<li>Mark Word
<ul class="org-ul">
<li>存储对象哈希码</li>
<li>GC标志</li>
<li>GC年龄</li>
<li>同步锁等信息</li>
</ul></li>
<li>Klass Point : 指向存储类型元数据的指针</li>
<li>字节对齐补白的填充数据 ： 如果实例数据刚好满足8字节对齐的话，则可以不存在补白</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5c32f5" class="outline-3">
<h3 id="orgd5c32f5">内存间交互操作</h3>
<div class="outline-text-3" id="text-orgd5c32f5">
<p>
关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下 <b>8种操作</b> 来完成，虚拟机实现时必须保证下面提及的 <b>每一种操作都是原子的、不可再分的</b> 
</p>
<pre class="example">
     对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外
</pre>
<ul class="org-ul">
<li><b>lock</b> （锁定）：作用于 <span class="underline">主内存</span> 的变量，它把一个变量 <b>标识为一条线程独占</b> 的状态</li>
<li><b>unlock</b> （解锁）：作用于 <span class="underline">主内存</span> 的变量，它把一个处于 <b>锁定状态的变量释放</b> 出来，释放后的变量才可以被 <span class="underline">其他线程</span> 锁定</li>
<li><b>read</b> （读取）：作用于 <span class="underline">主内存</span> 的变量，它把一个变量的值从 <b>主内存传输到线程的工作内存</b> 中，以便随后的 <span class="underline">load</span> 动作使用</li>
<li><b>load</b> （载入）：作用于 <span class="underline">工作内存</span> 的变量，它把 <span class="underline">read</span> 操作从主内存中得到的 <b>变量值放入工作内存的变量副本</b> 中</li>
<li><b>use</b> （使用）：作用于 <span class="underline">工作内存</span> 的变量，它把工作内存中一个 <b>变量的值传递给执行引擎</b> ，每当虚拟机遇到一个 <span class="underline">需要使用到变量的值</span> 的字节码指令时将会执行这个操作</li>
<li><b>assign</b> （赋值）：作用于 <span class="underline">工作内存</span> 的变量，它把一个 <b>从执行引擎接收到的值赋给工作内存的变量</b> ，每当虚拟机遇到一个给 <span class="underline">变量赋值</span> 的字节码指令时执行这个操作</li>
<li><b>store</b> （存储）：作用于 <span class="underline">工作内存</span> 的变量，它把工作内存中一个 <b>变量的值传送到主内存</b> 中，以便随后的 <span class="underline">write</span> 操作使用</li>
<li><b>write</b> （写入）：作用于 <span class="underline">主内存</span> 的变量，它把 <span class="underline">store</span> 操作从 <b>工作内存中得到的变量的值放入主内存的变量</b> 中</li>
</ul>
</div>

<div id="outline-container-orgeefc6d9" class="outline-4">
<h4 id="orgeefc6d9">执行顺序</h4>
<div class="outline-text-4" id="text-orgeefc6d9">
<ul class="org-ul">
<li>如果要把一个变量从 <b>主内存复制到工作内存</b> ，那就要 <b>顺序地执行 <span class="underline">read</span> 和 <span class="underline">load</span> 操作</b></li>
<li>如果要把变量从 <b>工作内存同步回主内存</b> ，就要 <b>顺序地执行 <span class="underline">store</span> 和 <span class="underline">write</span> 操作</b></li>
</ul>

<pre class="example">
      注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行

      也就是说，read与load之间、store与write之间是可插入其他指令的

      如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a
</pre>

<p>
除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
</p>
<ul class="org-ul">
<li>不允许 <span class="underline">read</span> 和 <span class="underline">load</span> 、 <span class="underline">store</span> 和 <span class="underline">write</span> 操作之一 <b>单独出现</b> ，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在 <b>工作内存中改变了之后必须把该变化同步回主内存</b></li>
<li>不允许一个线程无原因地， <b>没有发生过任何 <span class="underline">assign</span> 操作</b> ，把数据从线程的 <b>工作内存同步回主内存中</b></li>
<li>一个 <b>新的变量只能在主内存中诞生</b> ，不允许在工作内存中直接使用一个 <b>未被初始化</b> （ <span class="underline">load</span> 或 <span class="underline">assign</span> ）的变量，换句话说，就是 <b>对一个变量实施 <span class="underline">use</span> 、 <span class="underline">store</span> 操作之前，必须先执行过了 <span class="underline">assign</span> 和 <span class="underline">load</span> 操作</b></li>
<li>一个变量在 <b>同一个时刻只允许 <span class="underline">一条线程</span> 对其进行 <span class="underline">lock</span> 操作</b> 
<ul class="org-ul">
<li>但 <span class="underline">lock</span> 操作可以被 <span class="underline">同一条线程</span>  <b>重复执行多次</b> ，多次执行 lock 后，只有 <b>执行相同次数的 <span class="underline">unlock</span> 操作</b> ，变量才会被解锁</li>
<li>如果对一个变量执行 <span class="underline">lock</span> 操作，那将会 <b>清空工作内存中此变量的值</b> ，在 <span class="underline">执行引擎</span> 使用这个变量前，需要 <b>重新执行 <span class="underline">load</span> 或 <span class="underline">assign</span> 操作</b> 初始化变量的值</li>
</ul></li>
<li>如果一个变量 <b>事先没有被 <span class="underline">lock</span> 操作锁定</b> ，那就 <b>不允许对它执行 <span class="underline">unlock</span> 操作</b> ，也 <b>不允许去 unlock 一个 <span class="underline">被其他线程</span> 锁定</b> 住的变量
<ul class="org-ul">
<li>对一个变量执行 <span class="underline">unlock</span> 操作之前，必须 <b>先把此变量同步回主内存中</b> ，也就是执行 <span class="underline">store</span> 、 <span class="underline">write</span> 操作</li>
</ul></li>
</ul>

<pre class="example">
       基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了

      仅是描述方式改变了，Java内存模型并没有改变
</pre>
</div>
</div>
</div>

<div id="outline-container-org2953955" class="outline-3">
<h3 id="org2953955">volatile型变量的特殊规则</h3>
<div class="outline-text-3" id="text-org2953955">
<p>
关键字 <b>volatile</b> 可以说是Java虚拟机提供的 <b>最轻量级的同步机制</b> 
</p>

<pre class="example">
volatile 并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用 synchronized 来进行同步

了解volatile变量的语义对后面了解多线程操作的其他特性很有意义

Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用
</pre>
</div>

<div id="outline-container-org541f4af" class="outline-4">
<h4 id="org541f4af">可见性</h4>
<div class="outline-text-4" id="text-org541f4af">
<p>
当一个变量定义为 <b>volatile</b> 之后，它将保证此变量对所有线程的 <b>可见性</b> ，这里的 <span class="underline">可见性</span> 是指 <b>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</b> 。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成
</p>

<pre class="example">
      例如，线程A修改一个普通变量的值，然后向主内存进行回写

      另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见
</pre>

<p>
关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出 <b>基于volatile变量的运算在并发下是安全的</b> 这个结论。volatile变量在 <span class="underline">各个线程的工作内存中不存在一致性问题</span> （在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的 <b>运算并非原子操作</b> ，导致 <b>volatile变量的运算在并发下一样是不安全的</b> ，可以通过一段简单的演示来说明原因，请看下面代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">VolatileTest</span> {

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">race</span> = 0;

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">increase</span>() {
        race++;
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">THREADS_COUNT</span> = 20;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        <span style="color: #98f5ff;">Thread</span>[] <span style="color: #4eee94;">threads</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>[THREADS_COUNT];
        <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; <span style="color: #98f5ff;">THREADS_COUNT</span>; i++) {
            threads[i] = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(() -&gt; {
                    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i1</span> = 0; i1 &lt; 10000; i1++) {
                        increase();
                    }
            });
            threads[i].start();
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#25152;&#26377;&#32047;&#21152;&#32447;&#31243;&#37117;&#32467;&#26463;</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (Thread.activeCount() &gt; 1)
            Thread.yield();

        System.out.println(race);
    }
}
</pre>
</div>

<pre class="example">
      这段代码发起了20个线程，每个线程对race变量进行10000次自增操作

      如果这段代码能够正确并发的话，最后输出的结果应该是200000

      然而运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字
</pre>

<p>
问题就出现在自增运算 <span class="underline">race++</span> 之中，用Javap反编译这段代码后会得到下面代码，发现只有一行代码的 <span class="underline">increase()</span>  方法在Class文件中是由 <b>4条字节码指令构成的</b> （return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：
</p>
<ul class="org-ul">
<li>当 <span class="underline">getstatic</span> 指令把 <span class="underline">race的值</span> 取到 <span class="underline">操作栈顶</span> 时， <b>volatile关键字保证了race的值在此时是正确的</b></li>
<li>但是在执行 <span class="underline">iconst_1</span> 、 <span class="underline">iadd</span> 这些指令的时候， <b>其他线程可能已经把race的值加大了</b> ，而 <b>在操作栈顶的值就变成了过期的数据</b> ，所以 <span class="underline">putstatic</span> 指令执行后就可能 <b>把较小的race值同步回主内存</b> 之中</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">increase</span>();
  <span style="color: #ffd700;">descriptor</span>: ()V
  flags: ACC_PUBLIC, <span style="color: #98f5ff;">ACC_STATIC</span>
  <span style="color: #4eee94;">Code</span>:
    stack=2, locals=0, args_size=0
       0: getstatic     #2                  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Field race:I</span>
       3: iconst_1
       4: iadd
       5: putstatic     #2                  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Field race:I</span>
       8: <span style="color: #00bfff; font-weight: bold;">return</span>
    LineNumberTable:
      line 11: 0
      line 12: 8
</pre>
</div>

<pre class="example">
      客观地说，在此使用字节码来分析并发问题，仍然是不严谨的

      因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作

      一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义

      如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令

      此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析
</pre>

<p>
由于 <span class="underline">volatile</span> 变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过 <span class="underline">加锁</span> 来 <b>保证原子性</b> ：
</p>
<ul class="org-ul">
<li>运算结果并 <b>不依赖变量的当前值</b> ，或者能够确保只有 <b>单一的线程</b> 修改变量的值</li>
<li>变量 <b>不需要与其他的状态变量</b> 共同参与不变约束</li>
</ul>

<p>
如下的代码所示的这类场景就很适合使用 <span class="underline">volatile</span> 变量来控制并发，当 <span class="underline">shutdown()</span> 方法被调用时，能保证所有线程中执行的 <span class="underline">doWork()</span> 方法都立即停下来：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">shutdownRequested</span>&#65307;

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> shutdown&#65288;&#65289;{
    shutdownRequested=<span style="color: #ffd700;">true</span>&#65307;
        }

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #4eee94;">doWork</span>&#65288;&#65289;{
    <span style="color: #00bfff; font-weight: bold;">while</span>&#65288;&#65281;shutdownRequested&#65289;{
            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">do stuff</span>
        }
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org498d707" class="outline-4">
<h4 id="org498d707">指令重排</h4>
<div class="outline-text-4" id="text-org498d707">
<p>
使用volatile变量的第二个语义是 <b>禁止指令重排序优化</b> ，普通的变量仅仅会保证在 <b>该方法的执行过程中所有 <span class="underline">依赖赋值结果</span> 的地方都能获取到正确的结果</b> ，而 <b>不能保证 <span class="underline">变量赋值操作</span> 的顺序与 <span class="underline">程序代码中的执行顺序</span> 一致</b> 。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的 <span class="underline">线程内表现为串行的语义</span> 
</p>

<p>
继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码所示：
</p>
<div class="org-src-container">
<pre class="src src-java"> <span style="color: #98f5ff;">Map</span> <span style="color: #4eee94;">configOptions</span>&#65307;
 <span style="color: #98f5ff;">char</span>[] configText&#65307;

 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27492;&#21464;&#37327;&#24517;&#39035;&#23450;&#20041;&#20026;volatile</span>
 <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> initialized=<span style="color: #ffd700;">false</span>&#65307;
 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35774;&#20197;&#19979;&#20195;&#30721;&#22312;&#32447;&#31243;A&#20013;&#25191;&#34892;</span>

 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#25311;&#35835;&#21462;&#37197;&#32622;&#20449;&#24687;&#65292;&#24403;&#35835;&#21462;&#23436;&#25104;&#21518;&#23558;initialized&#35774;&#32622;&#20026;true&#20197;&#36890;&#30693;&#20854;&#20182;&#32447;&#31243;&#37197;&#32622;&#21487;&#29992;</span>
     configOptions = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">HashMap</span>()&#65307;
     configText = readConfigFile(fileName)&#65307;
     processConfigOptions(configText, configOptions)&#65307;
     initialized = <span style="color: #ffd700;">true</span>&#65307;

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35774;&#20197;&#19979;&#20195;&#30721;&#22312;&#32447;&#31243;B&#20013;&#25191;&#34892;</span>
 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;initialized&#20026;true&#65292;&#20195;&#34920;&#32447;&#31243;A&#24050;&#32463;&#25226;&#37197;&#32622;&#20449;&#24687;&#21021;&#22987;&#21270;&#23436;&#25104;</span>
     <span style="color: #00bfff; font-weight: bold;">while</span>(&#65281;initialized){
         sleep()&#65307;
     }
 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#32447;&#31243;A&#20013;&#21021;&#22987;&#21270;&#22909;&#30340;&#37197;&#32622;&#20449;&#24687;</span>
     doSomethingWithConfig()&#65307;
</pre>
</div>

<p>
上面的程序是一段伪代码，其中描述的场景十分常见，只是在处理配置文件时一般不会出现并发而已。如果定义 initialized 变量时没有使用volatile修饰，就可能会由于 <span class="underline">指令重排序的优化</span> ，导致 <b>位于线程A中最后一句的代码 <span class="underline">initialized=true</span> 被提前执行</b> ，这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生
</p>

<pre class="example">
      这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行
</pre>

<p>
指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。下面代码是一段标准的DCL单例代码，可以观察加入 volatile 和 未加入volatile关键字时所生成汇编代码的差别：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Singleton</span> {

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">Singleton</span> <span style="color: #4eee94;">instance</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">Singleton</span> <span style="color: #daa520; font-weight: bold;">getInstance</span>() {
        <span style="color: #00bfff; font-weight: bold;">if</span> (instance == <span style="color: #ffd700;">null</span>) {
            <span style="color: #00bfff; font-weight: bold;">synchronized</span> (Singleton.<span style="color: #00bfff; font-weight: bold;">class</span>) {
                <span style="color: #00bfff; font-weight: bold;">if</span> (instance == <span style="color: #ffd700;">null</span>) {
                    instance = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Singleton</span>();
                }
            }
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> instance;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        Singleton.getInstance();
    }
}
</pre>
</div>

<p>
编译后，这段代码对instance变量赋值部分如下所示： 
</p>

<div class="org-src-container">
<pre class="src src-sh">0x01a3de0f&#65306;mov$<span style="color: #4eee94;">0</span>x3375cdb0&#65292;%esi         &#65307;&#8230;&#8230;beb0cd75 33
                                        &#65307;{oop&#65288;<span style="color: #deb887;">'Singleton'</span>&#65289;}
0x01a3de14&#65306;mov%eax&#65292;0x150&#65288;%esi&#65289;      &#65307;&#8230;&#8230;89865001 0000
0x01a3de1a&#65306;shr$<span style="color: #4eee94;">0</span>x9&#65292;%esi                &#65307;&#8230;&#8230;c1ee09
0x01a3de1d&#65306;movb$<span style="color: #4eee94;">0</span>x0&#65292;0x1104800&#65288;%esi&#65289;    &#65307;&#8230;&#8230;c6860048 100100
0x01a3de24&#65306;lock addl$<span style="color: #4eee94;">0</span>x0&#65292;&#65288;%esp&#65289;        &#65307;&#8230;&#8230;f0830424 00
                                        &#65307;*putstatic instance
                                        &#65307;-
Singleton&#65306;getInstance@24
</pre>
</div>


<p>
通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面 <span class="underline">mov%eax，0x150(%esi)</span> 这句便是赋值操作）多执行了一个 <b>lock addl ＄0x0，(%esp)</b> 操作，这个操作相当于一个 <span class="underline">内存屏障</span> （指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。关键在于lock前缀，它的作用是使得 <b>本CPU的Cache写入了内存</b> ，该写入动作也会 <b>引起别的CPU或者别的内核无效化其Cache</b> ，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的 <span class="underline">store和write</span> 操作。所以通过这样一个空操作，可让前面volatile变量的 <b>修改对其他CPU立即可见</b> 
</p>

<pre class="example">
lock 指令中的 addl ＄0x0，(%esp) （把ESP寄存器的值加0）显然是一个 空操作

采用这个空操作而不是空操作指令nop是因为IA32手册规定 lock前缀不允许配合nop指令使用 
</pre>

<p>
从硬件架构上讲，指令重排序是指 CPU采用了允许将 <span class="underline">多条指令不按程序规定的顺序分开发送给各相应电路单元处理</span> 。但并不是说指令任意重排，CPU需要能 <b>正确处理指令依赖情况以保障程序能得出正确的执行结果</b> 
</p>
<pre class="example">
      譬如 指令1 把地址 A 中的值加10，指令2把地址 A 中的值乘以2，指令3把地址 B 中的值减去3

      这时指令1和指令2是有依赖的，它们之间的顺序不能重排，因为 (A+10) * 2 与 A * 2 +10 显然不相等

      但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可

      所以在本内CPU中，重排序看起来依然是有序的
</pre>
<p>
实际上， <span class="underline">lock addl＄0x0, (%esp)</span> 指令把 <span class="underline">修改同步到内存</span> 时，意味着 <b>所有之前的操作都已经执行完成</b> ，这样便形成了 <span class="underline">指令重排序无法越过内存屏障</span> 的效果
</p>
</div>
</div>


<div id="outline-container-org74bf303" class="outline-4">
<h4 id="org74bf303">总结</h4>
<div class="outline-text-4" id="text-org74bf303">
<p>
volatile 能让代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁，但是由于虚拟机对锁实行的许多消除和优化，使得很难量化地认为volatile就会比synchronized快多少。如果让volatile自己与自己比较，那可以确定一个原则:  volatile变量 <span class="underline">读操作的性能消耗与普通变量几乎没有什么差别</span> ，但是 <span class="underline">写操作则可能会慢一些</span> ，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，在volatile与锁之中选择的唯一依据仅仅是 <b>volatile的语义能否满足使用场景的需求</b> 
</p>

<p>
最后，回头看一下Java内存模型中对volatile变量定义的特殊规则。假定 <span class="underline">T</span> 表示一个 <span class="underline">线程</span> ， <span class="underline">V</span> 和 <span class="underline">W</span> 分别表示两个 <span class="underline">volatile型变量</span> ，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：
</p>
<ol class="org-ol">
<li>只有当线程 T 对变量 V 执行的前一个动作是 <span class="underline">load</span>  的时候，线程 T 才能对变量 V 执行 <span class="underline">use</span> 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 <span class="underline">use</span> 的时候，线程 T 才能对变量 V 执行 <span class="underline">load</span> 动作。线程T对变量V的use动作可以认为是和 线程 T 对变量 V 的 load、read动作相关联，必须连续一起出现。这条规则要求在 <span class="underline">工作内存</span> 中， <b>每次使用 V 前都必须先从主内存刷新最新的值</b> ，用于保证能看见其他线程对变量 V 所做的修改后的值</li>
<li>只有当线程 T 对变量 V 执行的前一个动作是 <span class="underline">assign</span> 的时候，线程 T 才能对变量 V 执行 <span class="underline">store</span> 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 <span class="underline">store</span> 的时候，线程 T 才能对变量 V 执行 <span class="underline">assign</span> 动作。线程 T 对变量 V 的 assign动作可以认为是和线程T对变量V的 <span class="underline">store、write</span> 动作相关联，必须连续一起出现。这条规则要求在工作内存中， <b>每次修改 V 后都必须立刻同步回主内存中</b> ，用于保证其他线程可以看到自己对变量V所做的修改</li>
</ol>

<pre class="example">
volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复

此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题）

这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因 
</pre>
</div>
</div>


<div id="outline-container-org41e78d7" class="outline-4">
<h4 id="org41e78d7">对于long和double型变量的特殊规则</h4>
<div class="outline-text-4" id="text-org41e78d7">
<p>
Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型 ( <span class="underline">long</span> 和 <span class="underline">double</span> )，在模型中特别定义了一条相对宽松的规定： <b>允许虚拟机将没有被 <span class="underline">volatile</span> 修饰的64位数据的读写操作划分为 <span class="underline">两次32位的操作</span> 来进行</b> ，即允许虚拟机实现选择可以不保证64位数据类型的 <span class="underline">load</span> 、_store_ 、 <span class="underline">read</span> 和 <span class="underline">write</span> 这4个操作的原子性，这点就是所谓的 <span class="underline">long和double的非原子性协定</span> 
</p>

<p>
如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了  <span class="underline">半个变量</span> 的数值
</p>

<pre class="example">
      不过这种读取到“半个变量”的情况非常罕见，在目前商用Java虚拟机中不会出现

      因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作

      但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现
</pre>
<p>
在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此在编写代码时 <b>一般不需要把用到的long和double变量专门声明为volatile</b> 
</p>
</div>
</div>
</div>

<div id="outline-container-org2506188" class="outline-3">
<h3 id="org2506188">原子性、可见性与有序性</h3>
<div class="outline-text-3" id="text-org2506188">
<p>
介绍完Java内存模型的相关操作和规则，再整体回顾一下这个模型的特征。Java内存模型是围绕着在并发过程中如何处理 <b>原子性</b> 、 <b>可见性</b> 和 <b>有序性</b> 这3个特征来建立的，逐个来看一下哪些操作实现了这3个特性
</p>
</div>

<div id="outline-container-org542da1a" class="outline-4">
<h4 id="org542da1a">原子性</h4>
<div class="outline-text-4" id="text-org542da1a">
<p>
由Java内存模型来直接保证的 <b>原子性</b> 变量操作包括 <span class="underline">read</span> 、 <span class="underline">load</span> 、 <span class="underline">assign</span> 、 <span class="underline">use</span> 、 <span class="underline">store</span> 和 <span class="underline">write</span> 
</p>

<pre class="example">
      大致可以认为基本数据类型的访问读写是具备原子性的，例外就是long和double的非原子性协定

      只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况
</pre>

<p>
如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 <b>lock</b> 和 <b>unlock</b> 操作来满足这种需求，尽管虚拟机未把 <span class="underline">lock</span> 和 <span class="underline">unlock</span> 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 <b>monitorenter</b> 和 <b>monitorexit</b> 来 <span class="underline">隐式</span> 地使用这两个操作，这两个字节码指令反映到Java代码中就是 <span class="underline">同步块</span> <b>synchronized</b> 关键字，因此在 <span class="underline">synchronized</span> 块之间的操作也具备 <span class="underline">原子性</span> 
</p>
</div>
</div>


<div id="outline-container-org71e31f1" class="outline-4">
<h4 id="org71e31f1">可见性</h4>
<div class="outline-text-4" id="text-org71e31f1">
<p>
可见性是指 <b>当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</b> 。在讲解 <span class="underline">volatile</span> 变量的时候已详细讨论过这一点。Java内存模型是通过 <span class="underline">在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值</span> 这种 <b>依赖主内存作为传递媒介</b> 的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。普通变量与 volatile 变量的区别是，volatile的 <b>特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</b> 。因此，可以说 <span class="underline">volatile</span> 保证了多线程操作时 <b>变量的可见性</b> ，而普通变量则不能保证这一点
</p>

<p>
除了 <span class="underline">volatile</span> 之外，Java还有两个关键字能实现可见性，即 <b>synchronized</b> 和 <b>final</b> ：
</p>
<ul class="org-ul">
<li>synchronized：可见性是由 <b>对一个变量执行 <span class="underline">unlock</span> 操作之前，必须先把此变量同步回主内存中（执行 <span class="underline">store</span> 、 <span class="underline">write</span> 操作）</b> 这条规则获得的</li>
<li>final: 可见性是由 <b>被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把 <span class="underline">this 的引用传递</span> 出去</b> ，那在其他线程中就能看见final字段的值。如下面代码所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问：</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>&#65307;
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> j&#65307;

<span style="color: #00bfff; font-weight: bold;">static</span>{
    i=0&#65307;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">do something</span>
}

{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20063;&#21487;&#20197;&#36873;&#25321;&#22312;&#26500;&#36896;&#20989;&#25968;&#20013;&#21021;&#22987;&#21270;</span>
    j=0&#65307;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">do something</span>
}
</pre>
</div>

<pre class="example">
this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象
</pre>
</div>
</div>


<div id="outline-container-orgbdb3ed6" class="outline-4">
<h4 id="orgbdb3ed6">有序性</h4>
<div class="outline-text-4" id="text-orgbdb3ed6">
<p>
Java内存模型的 <b>有序性</b> 在讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为：
</p>
<ul class="org-ul">
<li>如果在 <span class="underline">本线程</span> 内观察，所有的操作都是 <b>有序的</b> ：线程内表现为 <span class="underline">串行</span> 的语义</li>
<li>如果在 <span class="underline">一个线程中观察另一个线程</span> ，所有的操作都是 <b>无序的</b> ：
<ul class="org-ul">
<li><span class="underline">指令重排序</span> 现象</li>
<li><span class="underline">工作内存与主内存同步延迟</span> 现象</li>
</ul></li>
</ul>

<p>
Java语言提供了 <span class="underline">volatile</span> 和 <span class="underline">synchronized</span> 两个关键字来保证线程之间操作的 <b>有序性</b> ：
</p>
<ul class="org-ul">
<li>volatile关键字本身就包含了 <b>禁止指令重排序</b> 的语义</li>
<li>synchronized则是由 <span class="underline">一个变量在同一个时刻只允许一条线程对其进行lock操作</span> 这条规则获得的，这条规则决定了 <b>持有同一个锁的两个同步块只能 <span class="underline">串行地</span> 进入</b></li>
</ul>

<pre class="example">
介绍完并发中3种重要的特性后，synchronized 关键字在需要这3种特性的时候都可以作为其中一种的解决方案

因此大部分的并发控制操作都能使用 synchronized 来完成

synchronized的“万能”也间接造就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响
</pre>
</div>
<div id="outline-container-orgabb6f63" class="outline-5">
<h5 id="orgabb6f63">先行发生原则</h5>
<div class="outline-text-5" id="text-orgabb6f63">
<p>
如果Java内存模型中所有的有序性都仅仅靠 <span class="underline">volatile</span> 和 <span class="underline">synchronized</span> 来完成，那么有一些操作将会变得很烦琐，但是在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个 <b>先行发生</b> ( <span class="underline">happens-before</span> )的原则。这个原则非常重要，它是 <b>判断数据是否存在竞争、线程是否安全</b> 的主要依据，依靠这个原则，可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题
</p>

<p>
先行发生是Java内存模型中定义的 <b>两项操作之间的偏序关系</b> ，如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前， <b>操作 A 产生的影响能被操作 B 观察到</b> ， <b>影响</b> 包括 <span class="underline">修改了内存中共享变量的值</span> 、 <span class="underline">发送了消息</span> 、 <span class="underline">调用了方法</span> 等。可以举个例子来说明一下，如下面代码所示的这3句伪代码：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#19979;&#25805;&#20316;&#22312;&#32447;&#31243;A&#20013;&#25191;&#34892;</span>
i=1;

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#19979;&#25805;&#20316;&#22312;&#32447;&#31243;B&#20013;&#25191;&#34892;</span>
j=i;

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#19979;&#25805;&#20316;&#22312;&#32447;&#31243;C&#20013;&#25191;&#34892;</span>
i=2;
</pre>
</div>

<pre class="example">
假设线程 A 中的操作 i=1 先行发生于线程 B 的操作 j=i ，那么可以确定在线程 B 的操作执行后，变量 j 的值一定等于 1 ，得出这个结论的依据有两个：
1. 根据先行发生原则， i=1 的结果可以被观察到
2. 线程 C 还没登场，线程 A 操作结束之后 没有其他线程会修改变量 i 的值 

现在再来考虑线程 C，依然保持线程 A 和线程 B 之间的先行发生关系，而线程 C 出现在线程 A 和线程 B 的操作之间，但是 线程 C 与 线程 B 没有先行发生关系 ，那 j 的值会是多少呢？

答案是 不确定! ，1 和 2 都有可能

因为线程 C 对变量 i 的影响可能会被线程B观察到，也可能不会，这时候线程 B 就存在 读取到过期数据的风险，不具备多线程安全性
</pre>

<p>
下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系 <b>无须任何同步器协助</b> 就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们 <b>随意地进行重排序</b> ：
</p>
<ul class="org-ul">
<li>程序次序规则：在一个线程内，按照 <span class="underline">程序代码顺序</span> ，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是 <span class="underline">控制流顺序</span> 而不是程序代码顺序，因为要考虑分支、循环等结构</li>
<li>管程锁定规则：一个 <span class="underline">unlock</span> 操作 <b>先行发生</b> 于后面对 <span class="underline">同一个锁的lock</span> 操作。这里必须强调的是 <b>同一个锁</b> ，而 <span class="underline">后面</span> 是指 <b>时间上的先后顺序</b></li>
<li>volatile变量规则：对一个 <span class="underline">volatile变量的写操作</span> 先行发生于后面 <span class="underline">对这个变量的读操作</span> ，这里的 <span class="underline">后面</span> 同样是指 <b>时间上的先后顺序</b></li>
<li>线程启动规则： <span class="underline">Thread对象的start()</span> 方法先行发生于 <b>此线程的每一个动作</b></li>
<li>线程终止规则：线程中的 <span class="underline">所有操作</span> 都先行发生于对此线程的 <span class="underline">终止检测</span>
<ul class="org-ul">
<li>通过 <span class="underline">Thread.join()</span> 方法 <b>结束线程</b></li>
<li><span class="underline">Thread.isAlive()</span> 的返回值等手段 <b>检测到线程已经终止执行</b></li>
</ul></li>
<li>线程中断规则：对线程 <span class="underline">interrupt()方法的调用</span> 先行发生于被 <b>中断线程的代码检测到中断事件的发生</b>
<ul class="org-ul">
<li>通过 <span class="underline">Thread.interrupted()</span> 方法 <b>检测到是否有中断发生</b></li>
</ul></li>
<li>对象终结规则：一个 <span class="underline">对象的初始化完成</span> （构造函数执行结束）先行发生于它的 <span class="underline">finalize()</span> 方法的开始</li>
<li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论</li>
</ul>


<p>
Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了， <span class="underline">使用这些规则去判定操作间是否具备顺序性</span> ，对于 <span class="underline">读写共享变量</span> 的操作来说，就是 <b>线程是否安全</b> ，可以从下面这个例子中感受一下 <span class="underline">时间上的先后顺序</span> 与 <b>先行发生</b> 之间有什么不同。演示例子如下面所示：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">value</span>=0;

pubilc <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">setValue</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">value</span>){
    <span style="color: #00bfff; font-weight: bold;">this</span>.value=value;                
}

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getValue</span>(){
    <span style="color: #00bfff; font-weight: bold;">return</span> value;                
}
</pre>
</div>

<p>
这是是一组再普通不过的 getter/setter 方法，假设存在线程 A 和 B，线程A先（时间上的先后）调用了 <span class="underline">setValue(1)</span> ，然后线程B调用了同一个对象的 <span class="underline">getValue()</span> ，那么线程B 收到的返回值是什么？
</p>

<p>
依次分析一下先行发生原则中的各项规则：
</p>
<ul class="org-ul">
<li>由于两个方法分别由线程 A 和 线程 B 调用，不在一个线程中，所以 <span class="underline">程序次序</span> 规则在这里不适用</li>
<li>由于没有同步块，自然就不会发生lock和unlock操作，所以 <span class="underline">管程锁定</span> 规则不适用</li>
<li>由于value变量没有被volatile关键字修饰，所以 <span class="underline">volatile变量规则</span> 不适用</li>
<li>后面的 <span class="underline">线程启动</span> 、 <span class="underline">终止</span> 、 <span class="underline">中断</span> 规则和 <span class="underline">对象终结</span> 规则也和这里完全没有关系</li>
<li>因为没有一个适用的先行发生规则，所以最后一条 <span class="underline">传递性</span> 也无从谈起</li>
</ul>

<p>
因此可以判定 <span class="underline">尽管线程 A 在操作时间上先于线程 B</span> ，但是 <b>无法确定线程B中 <span class="underline">getValue()</span> 方法的返回结果</b> ，换句话说，这里面的操作不是 <b>线程安全</b> 的
</p>

<pre class="example">
至少有两种比较简单的方案可以选择来修复这个问题：

1. 把getter/setter方法都定义为 synchronized 方法，这样就可以套用管程锁定规则
2. 把value定义为 volatile 变量，由于 setter 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来实现先行发生关系
</pre>

<p>
通过上面的例子，可以得出结论： <b>一个操作 <span class="underline">时间上</span> 的先发生不代表这个操作会是 <span class="underline">先行</span> 发生</b> ，那如果一个操作 <span class="underline">先行发生</span> 是否就能推导出这个操作必定是 <span class="underline">时间上的先发生</span> 呢？很遗憾，这个推论也是不成立的，一个典型的例子就是多次提到的 <span class="underline">指令重排序</span> ，演示例子如下面所示：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#19979;&#25805;&#20316;&#22312;&#21516;&#19968;&#20010;&#32447;&#31243;&#20013;&#25191;&#34892;</span>
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 1;
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">j</span> = 2;
</pre>
</div>

<p>
这两条赋值语句在同一个线程之中，根据程序次序规则，_int i=1_ 的操作先行发生于 <span class="underline">int j=2</span> ，但是 <span class="underline">int j=2</span> 的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为 <b>在这条线程之中没有办法感知到这点</b> 
</p>

<p>
<b>结论是： <span class="underline">时间先后顺序</span> 与 <span class="underline">先行发生原则</span> 之间基本没有太大的关系</b> ，所以衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以 <b>先行发生原则为准</b> 
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org74dec75" class="outline-2">
<h2 id="org74dec75">JVM线程实现</h2>
<div class="outline-text-2" id="text-org74dec75">
<p>
<b>并发不一定要依赖多线程</b> （如很常见的多进程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。讲到Java线程，就从Java线程在虚拟机中的实现开始讲起
</p>
</div>

<div id="outline-container-orgf3ae4ad" class="outline-3">
<h3 id="orgf3ae4ad">线程的实现</h3>
<div class="outline-text-3" id="text-orgf3ae4ad">
<p>
<b>线程</b> 是 <b>比进程更轻量级的调度执行单位</b> ，线程的引入，可以把一个进程的 <span class="underline">资源分配</span> 和 <span class="underline">执行调度</span> 分开：
</p>
<ul class="org-ul">
<li>各个线程既可以 <b>共享进程资源</b> （ <span class="underline">内存地址</span> 、 <span class="underline">文件I/O</span> 等）</li>
<li>又可以 <b>独立调度</b> （线程是CPU调度的基本单位）</li>
</ul>

<p>
主流的 <span class="underline">操作系统</span> 都提供了 <span class="underline">线程实现</span> ，Java语言则提供了在 <b>不同 <span class="underline">硬件</span> 和 <span class="underline">操作系统</span> 平台下对线程操作的统一处理</b> ，每个已经执行 <span class="underline">start()</span> 且还未结束的 <span class="underline">java.lang.Thread</span> 类的 <span class="underline">实例</span> 就代表了一个 <b>线程</b> 
</p>

<pre class="example">
     注意：Thread类与大部分的 Java API有显著的差别，它的所有关键方法都是声明为 native 的

     在Java API中，一个 native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段）

     所以这里先谈的是“线程的实现”而不是“ Java 线程的实现”
</pre>


<p>
实现线程主要有3种方式：
</p>
<ol class="org-ol">
<li>使用 <span class="underline">内核</span> 线程实现</li>
<li>使用 <span class="underline">用户</span> 线程实现</li>
<li>使用用户线程加轻量级进程 <span class="underline">混合</span> 实现</li>
</ol>
</div>

<div id="outline-container-org4a252da" class="outline-4">
<h4 id="org4a252da">使用内核线程实现</h4>
<div class="outline-text-4" id="text-org4a252da">
<p>
<b>内核线程</b> ( <span class="underline">KLT</span> )就是直接由 <span class="underline">操作系统内核</span> 支持的线程，这种线程由内核来完成线程切换，内核通过操纵 <span class="underline">调度器</span> 对线程进行 <b>调度</b> ，并负责 将线程的任务 <b>映射</b> 到各个 <span class="underline">处理器</span> 上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做 <span class="underline">多线程内核</span> 
</p>

<p>
程序一般不会直接去使用内核线程，而是去使用内核线程的一种 <span class="underline">高级接口</span> ： <b>轻量级进程</b> ( <span class="underline">LWP</span> )，轻量级进程就是通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种 <span class="underline">轻量级进程</span> 与 <span class="underline">内核线程</span> 之间 <b>1:1</b> 的关系称为一对一的线程模型，如图所示：
</p>


<div class="figure">
<p><img src="pic/klt-lwp.png" alt="klt-lwp.png" width="70%" /> 
</p>
</div>


<ul class="org-ul">
<li>优点：内核线程保证了每个轻量级进程都成为一个 <span class="underline">独立的调度单元</span> ，即使有一个 <b>轻量级进程在系统调用中阻塞了，也不会影响整个进程的继续工作</b></li>
<li>缺点：
<ul class="org-ul">
<li>基于内核线程实现，因此各线程操作等 <span class="underline">需要系统调用</span> ， <b>系统调用代价高</b> ，需要在用户态和内核态来回切换</li>
<li>每个轻量级进程都需要一个内核线程的支持，因此 <span class="underline">轻量级进程要消耗一定的内核资源</span> ，如内核线程的栈空间，因此一个系统支持 <b>轻量级进程的数量是有限的</b></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1a0569d" class="outline-4">
<h4 id="org1a0569d">使用用户线程实现</h4>
<div class="outline-text-4" id="text-org1a0569d">
<p>
从广义上来讲，一个线程只要不是内核线程，就可以认为是 <b>用户线程</b> ( <span class="underline">UT</span> )，因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制
</p>

<p>
而狭义上的用户线程指的是 <b>完全建立在用户空间的线程库</b> 上，系统 <b>内核不能感知线程存在</b> 的实现。用户线程的 <span class="underline">建立</span> 、 <span class="underline">同步</span> 、 <span class="underline">销毁</span> 和 <span class="underline">调度</span> 完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种 <span class="underline">进程</span> 与 <span class="underline">用户线程</span> 之间 <b>1：N</b> 的关系称为一对多的线程模型，如图所示：
</p>


<div class="figure">
<p><img src="pic/ut.png" alt="ut.png" width="70%" /> 
</p>
</div>

<ul class="org-ul">
<li>优点：这种线程 <span class="underline">不需要切换内核态</span> ， <b>效率非常高</b> 且低消耗，也可以支持 <b>规模更大</b> 的线程数量</li>
<li>缺点：由于 <span class="underline">没有系统内核的支援</span> ，所有的线程操作都需要用户程序自己处理。 <span class="underline">阻塞处理</span> 等问题的解决十分困难 ，甚至不可能完成。所以使用用户线程会 <b>非常复杂</b></li>
</ul>
</div>
</div>

<div id="outline-container-org9f319bc" class="outline-4">
<h4 id="org9f319bc">使用用户线程加轻量级进程混合实现</h4>
<div class="outline-text-4" id="text-org9f319bc">
<p>
还有一种将 <span class="underline">内核线程</span> 与 <span class="underline">用户线程</span> <b>一起使用</b> 的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程：
</p>
<ul class="org-ul">
<li><span class="underline">用户线程</span> 还是 <b>完全建立在用户空间</b> 中，因此用户线程的 <span class="underline">创建</span> 、 <span class="underline">切换</span> 、 <span class="underline">析构</span> 等操作依然廉价，并且可以 <span class="underline">支持大规模</span> 的用户线程并发</li>
<li>操作系统提供支持的 <span class="underline">轻量级进程</span> 则作为 <span class="underline">用户线程</span> 和 <span class="underline">内核线程</span> 之间的 <b>桥梁</b> ，这样可以使用内核提供的 <span class="underline">线程调度</span> 功能及 <span class="underline">处理器映射</span>  ，并且 <b>用户线程的系统调用要通过轻量级线程</b> 来完成，大大降低了整个进程被完全阻塞的风险</li>
</ul>

<p>
在这种混合模式中， <span class="underline">用户线程</span> 与 <span class="underline">轻量级进程</span> 的 <b>数量比是不定的</b> ，即为 <b>N：M</b> 的关系，如图所示：这种就是多对多的线程模型
</p>


<div class="figure">
<p><img src="pic/lwp-ut-hybrid.png" alt="lwp-ut-hybrid.png" width="70%" /> 
</p>
</div>

<pre class="example">
      许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了N：M的线程模型实现
</pre>
</div>

<div id="outline-container-org883c6d3" class="outline-5">
<h5 id="org883c6d3">JDK线程的实现</h5>
<div class="outline-text-5" id="text-org883c6d3">
<pre class="example">
Java线程在 JDK 1.2 之前，是基于称为 绿色线程 的 用户线程 实现的

而在JDK 1.2中，线程模型替换为基于 操作系统原生线程 模型来实现

因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致

虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现

线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的
</pre>

<p>
对于Sun JDK来说：
</p>
<ul class="org-ul">
<li>它的 <span class="underline">Windows</span> 版与 <span class="underline">Linux</span> 版都是使用 <b>一对一</b> 的线程模型实现的，一条 <span class="underline">Java线程</span> 就映射到一条 <span class="underline">轻量级进程</span> 之中，因为Windows和Linux系统提供的线程模型就是一对一的</li>
<li>Solaris平台中，由于操作系统的线程特性可以同时支持 <span class="underline">一对一</span> 及 <span class="underline">多对多</span> 的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数来明确指定虚拟机使用哪种线程模型：
<ul class="org-ul">
<li><span class="underline">-XX：+UseLWPSynchronization</span> ：默认使用多对多模型</li>
<li><span class="underline">-XX：+UseBoundThreads</span> ：使用一对一模型</li>
</ul></li>
</ul>

<pre class="example">
Windows下有 Fiber Package，Linux下也有 NGPT 来实现N：M模型，但是它们都没有成为主流
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb4f1a19" class="outline-3">
<h3 id="orgb4f1a19">线程调度</h3>
<div class="outline-text-3" id="text-orgb4f1a19">
<p>
<b>线程调度</b> 是指 <b>系统为线程分配处理器使用权的过程</b> ，主要调度方式有两种：
</p>
<ol class="org-ol">
<li><span class="underline">协同式</span> 线程调度</li>
<li><span class="underline">抢占式</span> 线程调度</li>
</ol>
</div>

<div id="outline-container-orge852d66" class="outline-4">
<h4 id="orge852d66">协同式</h4>
<div class="outline-text-4" id="text-orge852d66">
<p>
如果使用 <span class="underline">协同式</span> 调度的多线程系统， <b>线程的执行时间由 <span class="underline">线程本身</span> 来控制</b> ，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上：
</p>
<ul class="org-ul">
<li>好处： 
<ul class="org-ul">
<li><b>实现简单</b></li>
<li>由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以 <b>没有什么线程同步</b> 的问题
<ul class="org-ul">
<li>Lua语言中的 <span class="underline">协同例程</span> 就是这类实现</li>
</ul></li>
</ul></li>
<li>坏处：线程 <b>执行时间不可控制</b> ，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里</li>
</ul>

<pre class="example">
      很久以前的Windows 3.x系统就是使用协同式来实现多进程多任务的，相当不稳定，一个进程坚持不让出CPU执行时间就可能会导致整个系统崩溃
</pre>
</div>
</div>

<div id="outline-container-orgb9877b6" class="outline-4">
<h4 id="orgb9877b6">抢占式</h4>
<div class="outline-text-4" id="text-orgb9877b6">
<p>
如果使用 <span class="underline">抢占式</span> 调度的多线程系统，那么每个线程将由 <b>系统来分配执行时间</b> ，线程的切换不由线程本身来决定
</p>

<pre class="example">
      在Java中，Thread.yield() 可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的 
</pre>

<p>
最大的优点：线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题
</p>

<pre class="example">
      与前面所说的Windows 3.x的例子相对，在Windows 9x/NT内核中就是使用抢占式来实现多进程的

      当一个进程出了问题，还可以使用任务管理器把这个进程“杀掉”，而不至于导致系统崩溃
</pre>
</div>


<div id="outline-container-org1fe6a6c" class="outline-5">
<h5 id="org1fe6a6c">Java线程调度</h5>
<div class="outline-text-5" id="text-org1fe6a6c">
<p>
Java的线程调度使用的是 <b>抢占式调度</b> 。虽然Java线程调度是系统自动完成的，但是还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点。这项操作可以通过 <span class="underline">设置线程优先级</span> 来完成。Java语言一共设置了10个级别的线程优先级（ <span class="underline">Thread.MIN_PRIORITY</span> 至 <span class="underline">Thread.MAX_PRIORITY</span> ），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行
</p>

<p>
不过，线程优先级并不是 <b>太靠谱</b> ，原因是 <span class="underline">Java的线程</span> 是通过 <b>映射</b> 到 <span class="underline">系统的原生线程</span> 上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，如Solaris中有232种优先级，但Windows中就只有7种，比Java线程优先级多的系统还好说，中间留下一点空位就可以了，但比Java线程优先级少的系统，就不得不出现几个优先级相同的情况了，下表显示了 <span class="underline">Java线程优先级</span> 与 <span class="underline">Windows线程优先级</span> 之间的对应关系，Windows平台的JDK中使用了除 <span class="underline">THREAD_PRIORITY_IDLE</span> 之外的其余6种线程优先级：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> Java线程优先级与Windows线程优先级的对应关系</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">Java线程优先级</td>
<td class="org-left">Windows线程优先级</td>
</tr>

<tr>
<td class="org-right">1(Thread.MIN_PRIORITY)</td>
<td class="org-left">THREAD_PERIORITY_LOWEST</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">THREAD_PERIORITY_LOWEST</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">THREAD_PERIORITY_BELOW_NORMAL</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">THREAD_PERIORITY_BELOW_NORMAL</td>
</tr>

<tr>
<td class="org-right">5(Thread.NORMAL_PRIORITY)</td>
<td class="org-left">THREAD_PERIORITY_NORMAL</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">THREAD_PERIORITY_ABOVE_NORMAL</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">THREAD_PERIORITY_ABOVE_NORMAL</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">THREAD_PERIORITY_HIGHEST</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">THREAD_PERIORITY_HIGHEST</td>
</tr>

<tr>
<td class="org-right">10(Thread.MAX_PRIORITY)</td>
<td class="org-left">THREAD_PERIORITY_CRITICAL</td>
</tr>
</tbody>
</table>

<pre class="example">
       线程优先级并不是太靠谱，不仅仅是说在一些平台上不同的优先级实际会变得相同这一点，还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变

       例如，在Windows系统中存在一个称为“优先级推进器”（当然它可以被关闭掉）的功能
       它的大致作用就是当系统发现一个线程执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间

       因此，不能在程序中通过优先级来完全准确地判断一组状态都为Ready的线程将会先执行哪一个
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdba3788" class="outline-3">
<h3 id="orgdba3788">状态切换</h3>
<div class="outline-text-3" id="text-orgdba3788">
<p>
Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下：
</p>
<ul class="org-ul">
<li><b>新建</b> ( <span class="underline">New</span> )： <b>创建后尚未启动</b> 的线程处于这种状态</li>
<li><b>运行</b> ( <span class="underline">Runable</span> ）：包括了操作系统线程状态中的 <span class="underline">Running</span> 和 <span class="underline">Ready</span> ，也就是处于此状态的线程 <b>有可能正在执行</b> ，也有 <b>可能正在等待着CPU为它分配执行时间</b></li>
<li><b>无限期等待</b> ( <span class="underline">Waiting</span> )：处于这种状态的线程 <b>不会被分配 CPU 执行时间</b> ，它们要等待 <b>被其他线程 <span class="underline">显式</span> 地唤醒</b> 。以下方法会让线程陷入无限期的等待状态：
<ul class="org-ul">
<li><b>没有</b> 设置 <span class="underline">Timeout</span> 参数的 <span class="underline">Object.wait()</span> 方法</li>
<li><b>没有</b> 设置 <span class="underline">Timeout</span> 参数的 <span class="underline">Thread.join()</span> 方法</li>
<li><span class="underline">LockSupport.park()</span> 方法</li>
</ul></li>
<li><b>限期等待</b> ( <span class="underline">Timed Waiting</span> )：处于这种状态的线程也 <b>不会被分配CPU执行时间</b> ，不过无须等待被其他线程显式地唤醒，在 <b>一定时间之后它们会由 <span class="underline">系统自动</span> 唤醒</b> 。以下方法会让线程进入限期等待状态：
<ul class="org-ul">
<li><span class="underline">Thread.sleep()</span> 方法</li>
<li>设置了 <span class="underline">Timeout</span> 参数的 <span class="underline">Object.wait()</span> 方法</li>
<li>设置了 <span class="underline">Timeout</span> 参数的 <span class="underline">Thread.join()</span> 方法</li>
<li><span class="underline">LockSupport.parkNanos()</span> 方法</li>
<li><span class="underline">LockSupport.parkUntil()</span> 方法</li>
</ul></li>
<li><b>阻塞</b> ( <span class="underline">Blocked</span> )：线程被阻塞了， <span class="underline">阻塞状态</span> 与 <span class="underline">等待状态</span> 的区别是：
<ul class="org-ul">
<li><span class="underline">阻塞状态</span> 在 <b>等待着获取到一个排他锁</b> ，这个事件将在 <b>另外一个线程放弃这个锁</b> 的时候发生。在程序 <b>等待进入同步区域</b> 的时候，线程将进入这种状态</li>
<li><span class="underline">等待状态</span> 则是在 <b>等待一段时间</b> ，或者 <b>唤醒动作</b> 的发生。</li>
</ul></li>
<li><b>结束</b> ( <span class="underline">Terminated</span> )：已终止线程的线程状态，线程已经 <b>结束执行</b></li>
</ul>

<p>
上述5种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图所示：
</p>



<div class="figure">
<p><img src="pic/java-thread-state.jpg" alt="java-thread-state.jpg" width="70%" /> 
</p>
</div>

<p>
<a href="thread_safe.html">Next：线程安全</a>
</p>

<p>
<a href="jvm_example.html">Previous：虚拟机实践</a>
</p>

<p>
<a href="jvm.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
