<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>线程安全</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="memory_model.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">线程安全</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5f69bf1">线程安全</a>
<ul>
<li><a href="#org0b9a724">Java语言中的线程安全</a>
<ul>
<li><a href="#org67f225c">不可变</a></li>
<li><a href="#orgb30ff6f">绝对线程安全</a></li>
<li><a href="#org73fefcb">相对线程安全</a></li>
<li><a href="#org2d30ee0">线程兼容</a></li>
<li><a href="#orgfa23b51">线程对立</a></li>
</ul>
</li>
<li><a href="#org5fb3184">实现方法</a>
<ul>
<li><a href="#orgea7ecb8">互斥同步</a>
<ul>
<li><a href="#org2cda805">synchronized</a></li>
<li><a href="#org012edf4">ReentrantLock</a></li>
<li><a href="#org76523b3">性能比较</a></li>
</ul>
</li>
<li><a href="#orgecdaed9">非阻塞同步</a>
<ul>
<li><a href="#orgb3c7bb1">CAS 指令</a></li>
</ul>
</li>
<li><a href="#org024b7e1">无同步方案</a>
<ul>
<li><a href="#org88745d3">可重入代码</a></li>
<li><a href="#orgcd139ed">线程本地存储</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb9392d0">锁优化</a>
<ul>
<li><a href="#org952bd88">自旋锁</a></li>
<li><a href="#org13930df">锁消除</a></li>
<li><a href="#orge9eb509">锁粗化</a></li>
<li><a href="#org8cdff66">轻量级锁</a></li>
<li><a href="#org531864a">偏向锁</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部分来考虑：
  数据代表问题空间中的客体，程序代码则用于处理这些数据

  这种思维方式直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想

  与此相对的是，面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分
  这样可以让程序员能以符合现实世界的思维方式来编写和组织程序
</pre>

<p>
面向过程的编程思想极大地提升了现代软件开发的生产效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，人们很难想象现实中的对象在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在中断期间被修改和变 <b>脏</b> ，而这些事件在计算机世界中则是很正常的事情。有时候，良好的设计原则不得不向现实做出一些让步，必须让程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。对于这部分的主题 <span class="underline">高效并发</span> 来讲，首先需要保证并发的正确性，然后在此基础上实现高效。先从如何 <b>保证并发的正确性</b> 和如何 <b>实现线程安全</b> 讲起
</p>
<div id="outline-container-org5f69bf1" class="outline-2">
<h2 id="org5f69bf1">线程安全</h2>
<div class="outline-text-2" id="text-org5f69bf1">
<p>
<span class="underline">线程安全</span> 这个名称，相信稍有经验的程序员都会听说过，甚至在代码编写和走查的时候可能还会经常挂在嘴边，但是如何找到一个不太拗口的概念来定义线程安全却不是一件容易的事情
</p>
<pre class="example">
    在Google中搜索它的概念，找到的是类似于 ：如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的

    这样的定义并不能说它不正确，但是人们无法从中获取到任何有用的信息
</pre>

<p>
《Java Concurrency In Practice》的作者Brian Goetz对 <span class="underline">线程安全</span> 有一个比较恰当的定义： <b>当 <span class="underline">多个线程</span>  <span class="underline">访问</span> 一个对象时，如果不用考虑这些线程在运行时环境下的 <span class="underline">调度和交替执行</span> ，也不需要进行 <span class="underline">额外的同步</span> ，或者在 <span class="underline">调用方进行任何其他的协调操作</span> ， <span class="underline">调用这个对象的行为</span> 都可以 <span class="underline">获得正确的结果</span> ，那这个对象是线程安全的</b> 
</p>

<p>
这个定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身 <b>封装了所有必要的正确性保障手段</b> （如 <span class="underline">互斥同步</span> 等），令 <b>调用者无须关心多线程</b> 的问题，更 <b>无须自己采取任何措施</b> 来保证多线程的正确调用
</p>
<pre class="example">
    这点听起来简单，但其实并不容易做到

    在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”
    这个定义的其他描述也能够成立的话，就可以称它是线程安全了
</pre>
</div>
<div id="outline-container-org0b9a724" class="outline-3">
<h3 id="org0b9a724">Java语言中的线程安全</h3>
<div class="outline-text-3" id="text-org0b9a724">
<p>
那接下来就讨论一下在Java语言中，线程安全具体是如何体现的？有哪些操作是线程安全的？
</p>

<pre class="example">
     这里讨论的线程安全，就限定于多个线程之间存在共享数据访问这个前提

     因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的
</pre>

<p>
为了更加深入地理解线程安全，在这里可以不把线程安全当做一个 <span class="underline">非真即假的二元排他</span> 选项来看待，按照线程安全的 <span class="underline">安全程度</span> 由 <b>强至弱</b> 来排序，可以将Java语言中各种操作共享的数据分为以下5类：
</p>
<ol class="org-ol">
<li>不可变</li>
<li>绝对线程安全</li>
<li>相对线程安全</li>
<li>线程兼容</li>
<li>线程对立</li>
</ol>
</div>
<div id="outline-container-org67f225c" class="outline-4">
<h4 id="org67f225c">不可变</h4>
<div class="outline-text-4" id="text-org67f225c">
<p>
在Java语言中（特指JDK 1.5以后，即Java内存模型被修正之后的Java语言）， <b>不可变</b> ( <span class="underline">Immutable</span> )的对象一定是 <b>线程安全</b> 的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施， <b>只要一个不可变的对象被正确地构建出来</b> （没有发生 <span class="underline">this引用逃逸</span> 的情况），那其外部的 <span class="underline">可见状态</span> 永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态
</p>
<pre class="example">
      “不可变”带来的安全性是最简单和最纯粹的
</pre>

<p>
Java语言中，如果共享数据：
</p>
<ul class="org-ul">
<li><span class="underline">基本数据类型</span> ：只要在定义时使用 <span class="underline">final</span> 关键字修饰它就可以保证它是不可变的</li>
<li><span class="underline">对象</span> ：需要保证 <b>对象的行为不会对其状态产生任何影响</b> 才行
<ul class="org-ul">
<li>java.lang.String类的对象，它是一个典型的不可变对象，调用它的 <span class="underline">substring()</span> 、 <span class="underline">replace()</span> 和 <span class="underline">concat()</span> 这些方法都不会影响它原来的值，只会 <b>返回一个新构造</b> 的字符串对象</li>
</ul></li>
</ul>

<p>
保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中 <b>带有状态的变量都声明为final</b> ，这样在构造函数结束之后，它就是不可变的，例如代码中中java.lang.Integer构造函数所示的，它通过将内部状态变量 value 定义为 final 来保障状态不变：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> *The value of the&#65308;code&#65310;Integer&#65308;/code&#65310;.</span>
<span style="color: #ffebcd;"> *</span><span style="color: #ffd700;">@serial</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">value</span>;
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> *Constructs a newly allocated&#65308;code&#65310;Integer&#65308;/code&#65310;object that</span>
<span style="color: #ffebcd;"> *represents the specified&#65308;code&#65310;int&#65308;/code&#65310;value.</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> *</span><span style="color: #ffd700;">@param</span><span style="color: #ffebcd;"> value the value to be represented by the</span>
<span style="color: #ffebcd;"> *&#65308;code&#65310;Integer&#65308;/code&#65310;object.</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">Integer</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">value</span>) {
    <span style="color: #00bfff; font-weight: bold;">this</span>.value=value;        
}
</pre>
</div>
<pre class="example">
      在Java API中符合不可变要求的类型，除了上面提到的String之外，常用的还有 枚举类型
      以及java.lang.Number的部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型

      但同为Number的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的
</pre>
</div>
</div>
<div id="outline-container-orgb30ff6f" class="outline-4">
<h4 id="orgb30ff6f">绝对线程安全</h4>
<div class="outline-text-4" id="text-orgb30ff6f">
<p>
绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价
</p>
<pre class="example">
      在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全

      可以通过Java API中一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思


</pre>
<p>
如果说 <span class="underline">java.util.Vector</span> 是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的 <span class="underline">add()</span> 、 <span class="underline">get()</span> 和 <span class="underline">size()</span> 这类方法都是被 <b>synchronized</b> 修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步，也不意味着 <b>调用它的时候永远都不再需要同步</b> 手段了，请看一下中的测试代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">Vector</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt; <span style="color: #4eee94;">vector</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Vector</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt;();

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
    <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
        <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; 10; i++) {
            vector.add(i);
        }

        <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">removeThread</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                <span style="color: #ffd700;">@Override</span>
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; vector.<span style="color: #98f5ff;">size</span>(); i++) {
                        vector.remove(i);
                    }
                }
            });

        <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">printThread</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                <span style="color: #ffd700;">@Override</span>
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; vector.<span style="color: #98f5ff;">size</span>(); i++) {
                        System.out.println((vector.get(i)));
                    }
                }
            });

        removeThread.start();
        printThread.start();

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#35201;&#21516;&#26102;&#20135;&#29983;&#36807;&#22810;&#30340;&#32447;&#31243;&#65292;&#21542;&#21017;&#20250;&#23548;&#33268;&#25805;&#20316;&#31995;&#32479;&#20551;&#27515;</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (Thread.activeCount() &gt; 20);
    }
}
</pre>
</div>

<pre class="example">
Exception in thread"Thread-132"java.lang.ArrayIndexOutOfBoundsException：
Array index out of range：17
at java.util.Vector.remove（Vector.java：777）
at org.klose.mulithread.VectorTest$1.run（VectorTest.java：21）
at java.lang.Thread.run（Thread.java：662）

</pre>

<p>
很明显，尽管这里使用到的 <span class="underline">Vector</span> 的 <span class="underline">get()</span> 、 <span class="underline">remove()</span> 和 <span class="underline">size()</span> 方法都是 <b>同步</b> 的，但是在多线程的环境中，如果不在 <b>方法调用端做额外的同步措施</b> 的话，使用这段代码仍然是不安全的，因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号 i 已经不再可用的话，再用 i 访问数组就会抛出一个 <span class="underline">ArrayIndexOutOfBoundsException</span> 。如果要保证这段代码能正确执行下去，不得不把 <span class="underline">removeThread</span> 和 <span class="underline">printThread</span> 的定义改成：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">removeThread</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
            <span style="color: #00bfff; font-weight: bold;">synchronized</span> (vector) {
                <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; vector.<span style="color: #98f5ff;">size</span>(); i++) {
                    vector.remove(i);
                }
            }
        }
    });

<span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">printThread</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
            <span style="color: #00bfff; font-weight: bold;">synchronized</span> (vector) {
                <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; vector.<span style="color: #98f5ff;">size</span>(); i++) {
                    System.out.println((vector.get(i)));
                }
            }
        }
    });
</pre>
</div>
</div>
</div>

<div id="outline-container-org73fefcb" class="outline-4">
<h4 id="org73fefcb">相对线程安全</h4>
<div class="outline-text-4" id="text-org73fefcb">
<p>
<span class="underline">相对的线程安全</span> 就是通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但是对于一些 <span class="underline">特定顺序的连续调用</span> ，就可能 <b>需要在调用端</b> 使用 <b>额外的同步手段</b> 来保证调用的正确性。上面代码就是相对线程安全的明显的案例
</p>

<pre class="example">
      在Java语言中，大部分的线程安全类都属于这种类型

      例如 Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等
</pre>
</div>
</div>

<div id="outline-container-org2d30ee0" class="outline-4">
<h4 id="org2d30ee0">线程兼容</h4>
<div class="outline-text-4" id="text-org2d30ee0">
<p>
<span class="underline">线程兼容</span> 是指 <b>对象本身并不是线程安全的</b> ，但是可以 <b>通过在 <span class="underline">调用端</span> 正确地使用 <span class="underline">同步</span> 手段</b> 来 <b>保证对象在并发环境中可以安全地使用</b> ，平常说一个类不是线程安全的，绝大多数时候指的是这一种情况
</p>
<pre class="example">
Java API中大部分的类都是属于线程兼容的

如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等
</pre>
</div>
</div>
<div id="outline-container-orgfa23b51" class="outline-4">
<h4 id="orgfa23b51">线程对立</h4>
<div class="outline-text-4" id="text-orgfa23b51">
<p>
<span class="underline">线程对立</span> 是指 <b>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用</b> 的代码。由于Java语言天生就具备多线程特性，线程对立这种 <span class="underline">排斥多线程</span> 的代码是很少出现的，而且通常都是 <b>有害的</b> ，应当 <b>尽量避免</b> 
</p>

<p>
一个线程对立的例子是 <span class="underline">Thread</span> 类的 <span class="underline">suspend()</span> 和 <span class="underline">resume()</span> 方法，如果有 <span class="underline">两个线程</span> 同时持有 <span class="underline">一个线程对象</span> ，一个 <span class="underline">尝试去中断</span> 线程，另一个 <span class="underline">尝试去恢复</span> 线程，而且并发进行的话，无论调用时 <b>是否进行了同步</b> ，目标线程都是 <b>存在死锁</b> 风险的：如果 suspend() 中断的线程就是即将要执行 resume() 的那个线程，那就肯定要产生死锁了
</p>

<pre class="example">
      也正是由于这个原因，suspend() 和 resume() 方法已经被 JDK 声明废弃(@Deprecated)了

      常见的线程对立的操作还有 System.setIn() 、Sytem.setOut() 和 System.runFinalizersOnExit() 等
</pre>
</div>
</div>
</div>
<div id="outline-container-org5fb3184" class="outline-3">
<h3 id="org5fb3184">实现方法</h3>
<div class="outline-text-3" id="text-org5fb3184">
<p>
应该如何实现线程安全，这听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码编写有很大的关系，但虚拟机提供的 <span class="underline">同步</span> 和 <span class="underline">锁机制</span> 也起到了非常重要的作用
</p>

<pre class="example">
     代码编写如何实现线程安全和虚拟机如何实现同步与锁这两者都会有所涉及，相对而言更偏重后者一些

     只要了解了虚拟机线程安全手段的运作过程，自己去思考代码如何编写会变得更加容易
</pre>
</div>
<div id="outline-container-orgea7ecb8" class="outline-4">
<h4 id="orgea7ecb8">互斥同步</h4>
<div class="outline-text-4" id="text-orgea7ecb8">
<p>
<b>互斥同步</b> 是常见的一种并发正确性保障手段：
</p>
<ul class="org-ul">
<li><span class="underline">同步</span> ：在多个线程 <span class="underline">并发</span> 访问 <span class="underline">共享数据</span> 时，保证共享数据在 <span class="underline">同一个时刻</span> 只被 <b>一个</b> （或者是 <span class="underline">一些</span> ，使用信号量的时候）线程使用</li>
<li><span class="underline">互斥</span> ：是实现同步的一种 <b>手段</b> ，下面是主要的互斥实现方式：
<ul class="org-ul">
<li>临界区</li>
<li>互斥量</li>
<li>信号量</li>
</ul></li>
</ul>

<pre class="example">
      因此，在这4个字里面：

      互斥是 因 ，同步是 果
      互斥是 方法 ，同步是 目的 
</pre>
</div>
<div id="outline-container-org2cda805" class="outline-5">
<h5 id="org2cda805">synchronized</h5>
<div class="outline-text-5" id="text-org2cda805">
<p>
在Java中，最基本的互斥同步手段就是 <b>synchronized</b> 关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成 <span class="underline">monitorenter</span> 和 <span class="underline">monitorexit</span> 这两个 <b>字节码指令</b> ，这两个字节码都需要一个 <span class="underline">reference</span> 类型的参数来 <span class="underline">指明</span> 要 <b>锁定</b> 和 <b>解锁</b> 的 <span class="underline">对象</span> ：
</p>
<ul class="org-ul">
<li>如果Java程序中的 synchronized <b>明确指定</b> 了 <span class="underline">对象参数</span> ，那就是这个 <b>对象的reference</b></li>
<li>如果 <b>没有明确指定</b> ，那就根据 synchronized 修饰的是 <span class="underline">实例方法</span> 还是 <span class="underline">类方法</span> ，去取对应的 <b>对象实例</b> 或 <b>Class对象</b> 来作为锁对象</li>
</ul>

<pre class="example">
有两点是需要特别注意的：

1. synchronized 同步块对 同一条线程 来说是 可重入 的，不会出现自己把自己锁死的问题
2. 同步块在已进入的线程执行完之前，会 阻塞后面 其他线程 的进入
</pre>

<p>
根据虚拟机规范的要求：
</p>
<ul class="org-ul">
<li>在执行 <span class="underline">monitorenter</span> 指令时： <b>尝试获取对象的锁</b> 
<ul class="org-ul">
<li>如果这个对象 <span class="underline">没被锁定</span> ，或者 <span class="underline">当前线程</span> 已经拥有了 <span class="underline">那个对象的锁</span> ，把 <b>锁的计数器加1</b></li>
</ul></li>
<li>在执行 <span class="underline">monitorexit</span> 指令时：会将 <b>锁计数器减1</b> ，当计数器为 <span class="underline">0</span> 时，锁就被 <b>释放</b></li>
<li>如果 <span class="underline">获取对象锁失败</span> ，那当前线程就要 <b>阻塞等待</b> ，直到对象 <b>锁被 <span class="underline">另外一个</span> 线程 <span class="underline">释放</span> 为止</b></li>
</ul>

<pre class="example">
Java的线程 是映射到 操作系统的原生线程 之上的

如果要阻塞或唤醒一个线程，都需要 操作系统 来帮忙完成
这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间

对于代码简单的同步块（如被synchronized修饰的 getter() 或 setter() 方法），状态转换消耗的时间有可能比用户代码执行的时间还要长
所以synchronized是Java语言中一个重量级的操作，有经验的程序员都会在确实必要的情况下才使用这种操作

而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中
</pre>
</div>
</div>

<div id="outline-container-org012edf4" class="outline-5">
<h5 id="org012edf4">ReentrantLock</h5>
<div class="outline-text-5" id="text-org012edf4">
<p>
还可以使用 <span class="underline">java.util.concurrent</span> 包中的 <b>重入锁</b> ( <span class="underline">ReentrantLock</span> )来实现同步
</p>

<pre class="example">
在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的 线程重入 特性，只是 代码写法 上有点区别：

ReentrantLock：表现为 API层面 的互斥锁
   lock() 和 unlock() 方法配合 try/finally 语句块来完成

synchronzed： 原生语法 层面的互斥锁
</pre>

<p>
同时 ReentrantLock增加了一些 <b>高级</b> 功能，主要有以下3项：
</p>
<ol class="org-ol">
<li><span class="underline">等待可中断</span> ：当持有锁的线程 <span class="underline">长期不释放锁</span> 的时候， <span class="underline">正在等待的线程</span> 可以选择 <b>放弃等待</b> ，改为处理其他事情，可中断特性对 <span class="underline">处理执行时间非常长的同步块</span> 很有帮助</li>
<li>实现 <span class="underline">公平锁</span> ：指多个线程在等待同一个锁时，必须 <b>按照 <span class="underline">申请锁的时间顺序</span> 来 <span class="underline">依次</span> 获得锁</b> ；而非公平锁则不保证这一点，在锁被释放时， <span class="underline">任何一个等待锁的线程</span> 都有机会获得锁
<ul class="org-ul">
<li>synchronized 中的锁是 <span class="underline">非公平的</span></li>
<li>ReentrantLock <span class="underline">默认</span> 情况下也是 <span class="underline">非公平的</span> ，但可以通过 <span class="underline">带布尔值的构造函数</span> 要求 <b>使用公平锁</b></li>
</ul></li>
<li>锁可以 <b>绑定多个条件</b> ：一个 <span class="underline">ReentrantLock 对象</span> 可以 <b>同时绑定多个 <span class="underline">Condition</span> 对象</b> 
<ul class="org-ul">
<li>synchronized中：锁对象的 <span class="underline">wait()</span> 和 <span class="underline">notify()</span> 或 <span class="underline">notifyAll()</span> 方法可以 <b>实现一个隐含的条件</b> ，如果要和 <span class="underline">多于一个的条件</span> 关联的时候，就不得不 <b>额外地添加一个锁</b></li>
<li>ReentrantLock则无须这样做，只需要 <b>多次调用 <span class="underline">newCondition()</span> 方法</b> 即可</li>
</ul></li>
</ol>

<pre class="example">
       如果需要使用上述功能，选用ReentrantLock是一个很好的选择
</pre>
</div>
</div>
<div id="outline-container-org76523b3" class="outline-5">
<h5 id="org76523b3">性能比较</h5>
<div class="outline-text-5" id="text-org76523b3">
<p>
关于 synchronized 和 ReentrantLock 的 <b>性能</b> 问题，Brian Goetz对这两种锁在 <span class="underline">JDK 1.5</span> 与 <span class="underline">单核</span> 处理器，以及JDK 1.5与 <span class="underline">双Xeon</span> 处理器环境下做了一组吞吐量对比的实验，实验结果如图所示：
</p>


<div class="figure">
<p><img src="pic/jdk5-single-cpu.jpg" alt="jdk5-single-cpu.jpg" width="70%" /> 
</p>
</div>


<div class="figure">
<p><img src="pic/jdk5-dual-xeon.jpg" alt="jdk5-dual-xeon.jpg" width="70%" /> 
</p>
</div>

<p>
从图中看出，多线程环境下 <span class="underline">synchronized</span> 的吞吐量 <b>下降得非常严重</b> ，而 <span class="underline">ReentrantLock</span> 则能基本 <b>保持在同一个比较稳定</b> 的水平上
</p>
<pre class="example">
与其说 ReentrantLock 性能好，还不如说 synchronized 还有非常大的优化余地

后续的技术发展也证明了这一点，JDK 1.6中加入了很多针对锁的优化措施
JDK 1.6发布之后，人们就发现 synchronized 与 ReentrantLock 的性能基本上是完全持平了

因此，如果读者的程序是使用JDK 1.6或以上部署的话，性能因素就不再是选择ReentrantLock的理由了
虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized

所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步
</pre>
</div>
</div>
</div>
<div id="outline-container-orgecdaed9" class="outline-4">
<h4 id="orgecdaed9">非阻塞同步</h4>
<div class="outline-text-4" id="text-orgecdaed9">
<p>
互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为 <b>阻塞同步</b> 。从处理问题的方式上说，互斥同步属于一种 <span class="underline">悲观的并发</span> 策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行 <span class="underline">加锁</span> （这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、 <span class="underline">用户态核心态转换</span> 、 <span class="underline">维护锁计数器</span> 和 <span class="underline">检查是否有被阻塞的线程需要唤醒</span> 等操作。随着硬件指令集的发展，有了另外一个选择： 基于 <span class="underline">冲突检测</span> 的 <span class="underline">乐观并发</span> 策略，就是先进行操作：
</p>
<ul class="org-ul">
<li>如果 <span class="underline">没有其他线程争用共享数据</span> ，那操作就成功了</li>
<li>如果 <span class="underline">共享数据有争用</span> ，产生了冲突，那就再 <b>采取其他的补偿措施</b> 
<ul class="org-ul">
<li>最常见的补偿措施就是 <span class="underline">不断地重试</span> ，直到成功为止</li>
</ul></li>
</ul>

<p>
这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为 <b>非阻塞同步</b> 
</p>

<pre class="example">
      为什么说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？

      因为需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？

      如果这里再使用互斥同步来保证就失去意义了，所以只能靠硬件来完成这件事情
</pre>

<p>
硬件保证一个从语义上 <span class="underline">看起来需要多次操作的行为</span> 只通过 <span class="underline">一条处理器指令</span> 就能完成，这类指令常用的有：
</p>
<ul class="org-ul">
<li>Test-and-Set : 测试并设置</li>
<li>Fetch-and-Increment : 获取并增加</li>
<li>Swap : 交换</li>
<li>Compare-and-Swap : 比较并交换，简称 <span class="underline">CAS</span></li>
<li>Load-Linked/Store-Conditional : 加载链接/条件存储，下文称 <span class="underline">LL/SC</span></li>
</ul>

<pre class="example">
      前面的 3条 是 20世纪就已经存在于大多数指令集之中的处理器指令
      后面的两条是现代处理器新增的，而且这两条指令的目的和功能是类似的

      在 IA64、 x86 指令集中有 cmpxchg 指令完成CAS功能
      在 sparc-TSO 也有 casa 指令实现
      而在 ARM 和 PowerPC 架构下，则需要使用一对 ldrex/strex 指令来完成LL/SC的功能
</pre>
</div>

<div id="outline-container-orgb3c7bb1" class="outline-5">
<h5 id="orgb3c7bb1">CAS 指令</h5>
<div class="outline-text-5" id="text-orgb3c7bb1">
<p>
<span class="underline">CAS指令</span> 需要有3个 <span class="underline">操作数</span> ：
</p>
<ol class="org-ol">
<li><b>内存位置</b> ：在 Java 中可以简单理解为 <span class="underline">变量的内存地址</span> ，用 <span class="underline">V</span> 表示</li>
<li><b>旧的预期值</b> : 用 <span class="underline">A</span> 表示</li>
<li><b>新值</b> : 用 <span class="underline">B</span> 表示</li>
</ol>

<p>
CAS指令执行时， <b>当且仅当</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">V</span> <b>符合</b> 旧预期值 <span class="underline">A</span> 时，处理器用新值 <span class="underline">B</span> <b>更新</b> <span class="underline">V</span> 的值</li>
<li>否则它就 <b>不执行更新</b></li>
<li>但是无论是否更新了 V 的值，都会 <b>返回 <span class="underline">V</span> 的旧值</b></li>
<li>上述的处理过程是一个 <b>原子</b> 操作</li>
</ul>

<pre class="example">
       在JDK 1.5之后，Java程序中才可以使用CAS操作

       该操作由 sun.misc.Unsafe类 里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供

       虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令

       没有方法调用的过程，或者可以认为是 无条件内联 进去了
</pre>

<p>
由于 <span class="underline">Unsafe</span> 类不是 <b>提供给用户程序调用的类</b> 
</p>
<pre class="example">
Unsafe.getUnsafe() 的代码中限制了只有启动类加载器 Bootstrap ClassLoader 加载的Class才能访问它
</pre>
<p>
因此，如果不采用反射手段，只能通过 <span class="underline">其他的 Java API</span> 来 <b>间接使用</b> 它，如J.U.C包里面的 <span class="underline">整数原子类</span> ，其中的 <span class="underline">compareAndSet()</span> 和 <span class="underline">getAndIncrement()</span> 等方法都使用了 <span class="underline">Unsafe类的CAS操作</span> 
</p>

<p>
曾经通过这段 20个线程 自增 10000次 的代码来证明 volatile 变量不具备原子性，那么如何才能让它具备原子性呢？把 <span class="underline">race++</span> 操作或 <span class="underline">increase()</span> 方法 <span class="underline">用同步块</span> 包裹起来当然是一个办法，但是如果改成如下面代码，那 <b>效率将会提高许多</b> ：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * Atomic&#21464;&#37327;&#33258;&#22686;&#36816;&#31639;&#27979;&#35797;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * </span><span style="color: #ffd700;">@author</span><span style="color: #ffebcd;"> zzm</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">AtomicTest</span> {

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">AtomicInteger</span> <span style="color: #4eee94;">race</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicInteger</span>(0);

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">increase</span>() {
        race.incrementAndGet();
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">THREADS_COUNT</span> = 20;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        <span style="color: #98f5ff;">Thread</span>[] <span style="color: #4eee94;">threads</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>[THREADS_COUNT];
        <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; <span style="color: #98f5ff;">THREADS_COUNT</span>; i++) {
            threads[i] = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                    <span style="color: #ffd700;">@Override</span>
                    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                        <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; 10000; i++) {
                            increase();
                        }
                    }
                });
            threads[i].start();
        }

        <span style="color: #00bfff; font-weight: bold;">while</span> (Thread.activeCount() &gt; 1)
            Thread.yield();

        System.out.println(race);
    }
}
</pre>
</div>

<pre class="example">
200000

</pre>

<p>
使用 <span class="underline">AtomicInteger</span> 代替 <span class="underline">int</span> 后，程序输出了正确的结果，一切都要归功于 <span class="underline">incrementAndGet()</span> 方法的 <b>原子性</b> 。它的实现其实非常简单，如下所示：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * Atomically increment by one the current value.</span>
<span style="color: #ffebcd;"> * </span><span style="color: #ffd700;">@return</span><span style="color: #ffebcd;"> the updated value</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">incrementAndGet</span>() {
    <span style="color: #00bfff; font-weight: bold;">for</span> (;;) {
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">current</span> = get();
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">next</span> = current + 1;
        <span style="color: #00bfff; font-weight: bold;">if</span> (compareAndSet(current, next))
            <span style="color: #00bfff; font-weight: bold;">return</span> next;
    }
}
</pre>
</div>

<p>
incrementAndGet() 方法在一个无限循环中，不断尝试将一个 <span class="underline">比当前值大1的新值</span> <b>赋给自己</b> ：
</p>
<ul class="org-ul">
<li>如果失败了，那说明在执行 <span class="underline">获取-设置</span> 操作的时候 <b>值已经有了修改</b> ，于是 <b>再次循环</b> 进行下一次操作，直到 <b>设置成功</b> 为止</li>
</ul>

<pre class="example">
尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景

并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为 A 值，那我们就能说它的值没有被其他线程改变过了吗？
如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过
这个漏洞称为CAS操作的“ABA”问题

J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”
它可以通过控制变量值的版本来保证CAS的正确性

不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性
如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效
</pre>
</div>
</div>
</div>

<div id="outline-container-org024b7e1" class="outline-4">
<h4 id="org024b7e1">无同步方案</h4>
<div class="outline-text-4" id="text-org024b7e1">
<pre class="example">
      要保证线程安全，并不是一定就要进行同步，两者没有因果关系

      同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性
</pre>

<p>
因此会有一些代码天生就是线程安全的，简单地介绍其中的两类
</p>
<ul class="org-ul">
<li>可重入代码</li>
<li>线程本地存储</li>
</ul>
</div>

<div id="outline-container-org88745d3" class="outline-5">
<h5 id="org88745d3">可重入代码</h5>
<div class="outline-text-5" id="text-org88745d3">
<p>
这种代码也叫做 <span class="underline">纯代码</span> ，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误
</p>
<pre class="example">
       相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全

       即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的
</pre>

<p>
可重入代码有一些共同的特征：
</p>
<ul class="org-ul">
<li>不依赖 <span class="underline">存储在堆上的数据</span> 和 <span class="underline">公用的系统资源</span></li>
<li>用到的 <span class="underline">状态量都由参数中</span> 传入</li>
<li><span class="underline">不调用非可重入的方法</span> 等</li>
</ul>

<p>
可以通过一个简单的原则来判断代码是否具备可重入性： 如果一个方法，它的 <b>返回结果是可以预测的</b> ，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的
</p>

<pre class="example">
     实际上函数式编程，产生的就是可重入的代码
</pre>
</div>
</div>

<div id="outline-container-orgcd139ed" class="outline-5">
<h5 id="orgcd139ed">线程本地存储</h5>
<div class="outline-text-5" id="text-orgcd139ed">
<p>
如果一段代码中所需要的数据必须与其他代码共享，那就看看 <b>这些 <span class="underline">共享数据的代码</span> 是否能 <span class="underline">保证在同一个线程</span> 中执行</b> ？如果能保证，就可以把 <span class="underline">共享数据的可见范围</span> <b>限制</b> 在 <span class="underline">同一个线程</span> 之内，这样，无须同步也能保证线程之间不出现数据争用的问题
</p>

<p>
符合这种特点的应用并不少见，大部分 <b>使用消费队列</b> 的架构模式（如 <span class="underline">生产者-消费者</span> 模式）都会将 <b>产品的消费过程尽量在一个线程中消费</b> 完，其中最重要的一个应用实例就是经典Web交互模型中的 <span class="underline">一个请求对应一个服务器线程</span> 的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用 <span class="underline">线程本地存储</span> 来解决线程安全问题
</p>

<pre class="example">
Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”

如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec 这样的关键字
不过还是可以通过 java.lang.ThreadLocal 类来实现线程本地存储的功能

每一个线程的Thread 对象中都有一个 ThreadLocalMap 对象
这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对

ThreadLocal对象就是当前线程的 ThreadLocalMap 的访问入口
每一个ThreadLocal对象都包含了一个独一无二的 ThreadLocalHashCode值，使用这个值就可以在线程 K-V值对中找回对应的本地线程变量
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb9392d0" class="outline-2">
<h2 id="orgb9392d0">锁优化</h2>
<div class="outline-text-2" id="text-orgb9392d0">
<p>
高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术：
</p>
<ul class="org-ul">
<li>适应性自旋</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>

<p>
这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率
</p>
</div>

<div id="outline-container-org952bd88" class="outline-3">
<h3 id="org952bd88">自旋锁</h3>
<div class="outline-text-3" id="text-org952bd88">
<pre class="example">
     前面讨论互斥同步的时候，提到了互斥同步对性能最大的影响是阻塞的实现

     挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力
</pre>
<p>
虚拟机的开发团队也注意到在许多应用上， <b>共享数据的锁定状态只会持续很短的一段时间</b> ，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，可以让 <span class="underline">后面请求锁</span> 的那个线程 <span class="underline">稍等一下</span> ，但 <b>不放弃处理器的执行时间</b> ，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需让线程 <b>执行一个忙循环</b> （自旋），这项技术就是所谓的 <span class="underline">自旋锁</span> 
</p>

<p>
自旋锁在 JDK 1.4.2 中就已经引入，只不过默认是关闭的，可以使用 <span class="underline">-XX:+UseSpinning</span> 参数来开启，在 JDK 1.6 中就已经改为 <b>默认开启</b> 了。 <b>自旋等待不能代替阻塞</b> ，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要 <span class="underline">占用处理器时间</span> 的：
</p>
<ul class="org-ul">
<li>如果锁被占用的时间很短，自旋等待的效果就会非常好</li>
<li>如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费</li>
</ul>

<p>
因此，自旋等待的时间必须要有一定的限度，如果 <b>自旋超过了限定的次数仍然没有成功获得锁</b> ，就应当使用传统的方式去 <span class="underline">挂起线程</span> 了。自旋次数的默认值是 <span class="underline">10</span> 次，用户可以使用参数 <span class="underline">-XX:PreBlockSpin</span> 来更改
</p>

<pre class="example">
     在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

     如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中
     那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环

     另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源

     有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。
</pre>
</div>
</div>

<div id="outline-container-org13930df" class="outline-3">
<h3 id="org13930df">锁消除</h3>
<div class="outline-text-3" id="text-org13930df">
<p>
<span class="underline">锁消除</span> 是指虚拟机 <span class="underline">即时编译器</span> 在运行时，对一些代码上要求同步，但是被检测到 <b>不可能存在共享数据竞争的锁进行消除</b> 。锁消除的主要判定依据来源于 <span class="underline">逃逸分析</span> 的数据支持，如果判断在一段代码中，堆上的所有 <b>数据都不会逃逸出去</b> 从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行
</p>

<pre class="example">
     变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定
     但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢？

     答案是有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分人的想象
</pre>
<p>
来看看下面代码中的例子，这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">String</span> <span style="color: #daa520; font-weight: bold;">concatString</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s1</span>,<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s2</span>,<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s3</span>){
    <span style="color: #00bfff; font-weight: bold;">return</span> s1+s2+s3;        
}
</pre>
</div>
<p>
由于 String 是一个 <span class="underline">不可变</span> 的类，对字符串的连接操作总是通过生成新的 String 对象来进行的，因此 <span class="underline">Javac编译器</span> 会对 <span class="underline">String连接</span> 做 <b>自动优化</b> 。在JDK 1.5之前，会转化为 <span class="underline">StringBuffer</span> 对象的连续 <span class="underline">append()</span> 操作，可能会变成下面的样子：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">String</span> <span style="color: #daa520; font-weight: bold;">concatString</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s1</span>, <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s2</span>, <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">s3</span>){
    <span style="color: #98f5ff;">StringBuffer</span> <span style="color: #4eee94;">sb</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">StringBuffer</span>();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    <span style="color: #00bfff; font-weight: bold;">return</span> sb.toString();
}
</pre>
</div>

<p>
每个 <span class="underline">StringBuffer.append()</span> 方法中都有一个 <b>同步块</b> ，锁就是 <span class="underline">sb</span> 对象。虚拟机观察变量 sb，很快就会发现它的 <b>动态作用域被限制在 <span class="underline">concatString()</span> 方法内部</b> 。也就是说， <b>sb的所有引用永远不会 <span class="underline">逃逸</span> 到 <span class="underline">concatString()</span> 方法之外</b> ，其他线程无法访问到它，因此，虽然这里有锁，但是可以被 <b>安全地消除掉</b> ，在即时编译之后，这段代码就会 <b>忽略掉所有的同步</b> 而直接执行了
</p>

<pre class="example">
     客观地说，既然谈到锁消除与逃逸分析，那虚拟机就不可能是JDK 1.5之前的版本

     上面的例子在JDK 1.5及以后的版本中，会转化为 StringBuilder 对象的连续 append() 操作

     非线程安全的StringBuilder来完成字符串拼接，并不会加锁

     但这也不影响用这个例子证明Java对象中同步的普遍性
</pre>
</div>
</div>

<div id="outline-container-orge9eb509" class="outline-3">
<h3 id="orge9eb509">锁粗化</h3>
<div class="outline-text-3" id="text-orge9eb509">
<pre class="example">
     原则上，在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小：只在共享数据的实际作用域中才进行同步

     这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁

</pre>

<p>
大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对 <span class="underline">同一个对象反复加锁和解锁</span> ，甚至 <span class="underline">加锁操作是出现在循环体</span> 中的，那即使没有线程竞争， <b>频繁地进行互斥同步操作</b> 也会导致 <b>不必要的性能损耗</b> 
</p>

<pre class="example">
     上面代码中 连续的append() 方法就属于这类情况

     如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把 加锁同步的范围扩展（粗化）到整个操作序列的外部 

     就是扩展到 第一个 append() 操作之前直至最后一个 append() 操作之后 ，这样只需要 加锁一次 就可以了
</pre>
</div>
</div>

<div id="outline-container-org8cdff66" class="outline-3">
<h3 id="org8cdff66">轻量级锁</h3>
<div class="outline-text-3" id="text-org8cdff66">
<p>
<span class="underline">轻量级锁</span> 是 JDK 1.6 之中加入的新型锁机制，它名字中的 <span class="underline">轻量级</span> 是相对于使用 <span class="underline">操作系统互斥量</span> 来实现的传统锁而言的，因此传统的锁机制就称为 <span class="underline">重量级</span> 锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在 <b>没有多线程竞争</b> 的前提下， <b>减少传统的重量级锁 <span class="underline">使用操作系统互斥量</span> 产生的性能消耗</b> 
</p>

<p>
要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的 <span class="underline">对象（对象头部分）的内存布局</span> 开始介绍。HotSpot虚拟机的 <span class="underline">对象头</span> 分为两部分信息：
</p>
<ol class="org-ol">
<li>存储 <span class="underline">对象自身的运行时数据</span> ：这部分数据的长度在 32位 和 64位 的虚拟机中分别为 <span class="underline">32bit</span> 和 <span class="underline">64bit</span> ，官方称它为 <span class="underline">Mark Word</span> ，它是 <b>实现 <span class="underline">轻量级锁</span> 和 <span class="underline">偏向锁</span> 的关键</b>
<ul class="org-ul">
<li>哈希码</li>
<li>GC分代年龄</li>
<li>&#x2026;</li>
</ul></li>
<li>存储 <span class="underline">指向方法区对象类型数据</span> 的指针
<ul class="org-ul">
<li>如果是数组对象的话，还会有一个额外的部分用于 <span class="underline">存储数组长度</span></li>
</ul></li>
</ol>

<pre class="example">
     对象头信息是与 对象自身定义的数据无关 的额外存储成本

     考虑到虚拟机的空间效率，Mark Word被设计成一个 非固定的数据结构
     以便在 极小的空间内存储尽量多的信息 ，它会根据对象的状态复用自己的存储空间

     例如，在 32位的 HotSpot虚拟机 中对象 未被锁定 的状态下，Mark Word的 32bit 空间：
       25bit : 存储 对象哈希码
       4bit：存储 对象分代年龄
       2bit：存储 锁标志位
       1bit: 固定为0
</pre>
<p>
在其他状态 <span class="underline">轻量级锁定</span> 、 <span class="underline">重量级锁定</span> 、 <span class="underline">GC标记</span> 、 <span class="underline">可偏向</span> 下对象的存储内容见下表：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> HotSpot 虚拟机对象头 Mark Word</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">存储内容</td>
<td class="org-right">标志位</td>
<td class="org-left">状态</td>
</tr>

<tr>
<td class="org-left">对象哈希码、对象分代年龄</td>
<td class="org-right">01</td>
<td class="org-left">未锁定</td>
</tr>

<tr>
<td class="org-left">指向锁记录的指针</td>
<td class="org-right">00</td>
<td class="org-left">轻量级锁定</td>
</tr>

<tr>
<td class="org-left">指向重量级锁的指针</td>
<td class="org-right">10</td>
<td class="org-left">膨胀（重量级锁定）</td>
</tr>

<tr>
<td class="org-left">空：不需要记录信息</td>
<td class="org-right">11</td>
<td class="org-left">GC 标记</td>
</tr>

<tr>
<td class="org-left">偏向线程 ID、偏向时间戳、对象分代年龄</td>
<td class="org-right">01</td>
<td class="org-left">可偏向</td>
</tr>
</tbody>
</table>

<p>
在轻量级锁的执行过程，在代码进入同步块的时候，如果此同步对象 <span class="underline">没有被锁定</span> （锁标志位为 <span class="underline">01</span> 状态），虚拟机首先将在 <span class="underline">当前线程的栈</span> 中建立一个名为 <span class="underline">锁记录</span> 的空间，用于存储 <b>锁对象目前的 <span class="underline">Mark Word</span> 的拷贝</b>  ( <span class="underline">Displaced Mark Word</span> ) ，这时候线程堆栈与对象头的状态如图所示：
</p>


<div class="figure">
<p><img src="pic/displaced-mark-word.jpg" alt="displaced-mark-word.jpg" width="50%" /> 
</p>
</div>

<p>
然后，虚拟机将 <b>使用CAS操作</b> 尝试将 <span class="underline">对象的Mark Word</span> 更新为 <span class="underline">指向Lock Record的指针</span> ：
</p>
<ul class="org-ul">
<li>如果这个更新动作成功了，那么这个 <b>线程就拥有了该对象的锁</b> ，并且对象Mark Word的 <span class="underline">锁标志位</span> 将转变为 <span class="underline">00</span> ，即表示此对象处于 <b>轻量级锁定</b> 状态，这时候线程堆栈与对象头的状态如图所示：</li>
</ul>


<div class="figure">
<p><img src="pic/light-weight-lock.jpg" alt="light-weight-lock.jpg" width="50%" />
</p>
</div>

<ul class="org-ul">
<li>如果这个更新操作失败了，虚拟机首先会 <b>检查</b> <span class="underline">对象的 Mark Word</span> 是否 <span class="underline">指向当前线程的栈帧</span> ：
<ul class="org-ul">
<li>指向说明：当前线程已经拥有了这个对象的锁，那就可以 <span class="underline">直接进入同步块</span> 继续执行</li>
<li>不指向：说明 <span class="underline">这个锁对象</span> 已经 <b>被其他线程抢占</b> 了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要 <b>膨胀为重量级锁</b> ：
<ul class="org-ul">
<li><span class="underline">锁标志</span> 的状态值变为 <span class="underline">10</span></li>
<li>Mark Word中存储的就是 <b>指向重量级锁（互斥量）的指针</b> ，后面 <b>等待锁的线程也要进入 <span class="underline">阻塞</span> 状态</b></li>
</ul></li>
</ul></li>
</ul>

<p>
上面描述的是轻量级锁的加锁过程，它的 <span class="underline">解锁过程</span> 也是 <b>通过CAS操作</b> 来进行的：如果对象的Mark Word仍然指向着 <span class="underline">线程的锁记录</span> ，那就用 <span class="underline">CAS操作</span> 把 <b>对象 <span class="underline">当前的Mark Word</span> 和线程中 <span class="underline">复制的Displaced Mark Word</span> 替换</b> 回来：
</p>
<ul class="org-ul">
<li>替换成功，整个同步过程就完成了</li>
<li>替换失败，说明有其他线程尝试过获取该锁，那就要在 <b>释放锁的同时，唤醒被挂起的线程</b></li>
</ul>

<pre class="example">
     轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据

     如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销

     但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢
</pre>
</div>
</div>

<div id="outline-container-org531864a" class="outline-3">
<h3 id="org531864a">偏向锁</h3>
<div class="outline-text-3" id="text-org531864a">
<p>
如果说 <span class="underline">轻量级锁</span> 是在 <span class="underline">无竞争的情况下</span> 使用 <span class="underline">CAS操作</span> 去 <span class="underline">消除同步使用的互斥量</span> ，那 <b>偏向锁就是在无竞争的情况下把整个同步都消除掉</b> ，连CAS操作都不做了。
</p>
<pre class="example">
     偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能

     偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程
     如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步
</pre>

<p>
假设当前虚拟机启用了偏向锁( <span class="underline">-XX:+UseBiasedLocking</span> ，JDK 1.6的默认值) ，那么，当锁对象第一次被线程获取的时候：
</p>
<ol class="org-ol">
<li>虚拟机将会把对象头中的 <span class="underline">标志位</span> 设为 <span class="underline">01</span> ，即 <b>偏向模式</b></li>
<li>使用 <span class="underline">CAS操作</span> 把获取到这个 <span class="underline">锁的线程的ID</span> 记录在 <span class="underline">对象的Mark Word</span> 之中</li>
</ol>

<pre class="example">
     如果CAS操作成功， 持有偏向锁的线程 以后 每次进入这个锁相关的同步块 时，虚拟机都可以 不再进行任何同步操作

     例如: Locking 、Unlocking 及对 Mark Word 的 Update 等
</pre>

<p>
当有 <span class="underline">另外一个线程</span> 去尝试 <span class="underline">获取这个锁</span> 时， <b>偏向模式就宣告结束</b> 。根据锁对象目前是否 <span class="underline">处于被锁定的状态</span> <b>撤销偏向</b> : 
</p>
<ul class="org-ul">
<li>恢复到未锁定：标志位为 <span class="underline">01</span></li>
<li>轻量级锁定：标志位为 <span class="underline">00</span></li>
</ul>

<p>
后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图所示：
</p>


<div class="figure">
<p><img src="pic/biased-lock.jpg" alt="biased-lock.jpg" width="70%" />
</p>
</div>

<pre class="example">
     偏向锁可以提高带有同步但无竞争的程序性能

     它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利

     如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的
</pre>

<p>
在具体问题具体分析的前提下，有时候使用参数 <span class="underline">-XX:-UseBiasedLocking</span> 来 <b>禁止偏向锁优化</b> 反而可以提升性能
</p>

<p>
<a href="compilation_optimize.html">Next：编译期优化</a>
</p>

<p>
<a href="memory_model.html">Previous：内存模型</a>
</p>

<p>
<a href="jvm.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
