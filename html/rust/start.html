<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>入门</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="rust.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">入门</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgef71588">Hello World</a>
<ul>
<li><a href="#orga6d75b3">编写rust程序</a></li>
<li><a href="#org360c884">编译并运行文件</a></li>
<li><a href="#org6cc5e4c">分析程序</a></li>
<li><a href="#org816ce18">编译和运行是独立的</a></li>
</ul>
</li>
<li><a href="#orgc51e108">Hello Cargo</a>
<ul>
<li><a href="#org5e85e0a">使用 Cargo 创建项目</a>
<ul>
<li><a href="#org4ab596a">Cargo.toml</a></li>
<li><a href="#org1efef61">main.rs</a></li>
</ul>
</li>
<li><a href="#orgf963fe6">构建并运行</a></li>
<li><a href="#org5e567e6">发布构建</a></li>
<li><a href="#org8a08446">把 Cargo 当成习惯</a></li>
</ul>
</li>
<li><a href="#orgd7706a9">猜猜看游戏</a>
<ul>
<li><a href="#orgdc01570">创建一个新项目</a></li>
<li><a href="#org4fe5daa">处理一次猜测</a>
<ul>
<li><a href="#org4dada23">导入包</a></li>
<li><a href="#orga7e0440">定义变量</a></li>
<li><a href="#orga3ab97e">new函数</a></li>
<li><a href="#orgeb08b24">引用</a></li>
<li><a href="#org5d30b85">使用 Result 类型来处理潜在的错误</a></li>
<li><a href="#org8ba3a86">使用 println! 占位符打印值</a></li>
<li><a href="#org349fee3">测试第一部分代码</a></li>
</ul>
</li>
<li><a href="#orga473168">生成一个秘密数字</a>
<ul>
<li><a href="#org2a1c8f4">使用 crate 来增加更多功能</a>
<ul>
<li><a href="#orgba1b6e6">Cargo.lock 文件确保构建是可重现的</a></li>
<li><a href="#org467ff1f">更新 crate 到一个新版本</a></li>
</ul>
</li>
<li><a href="#org0056a56">生成一个随机数字</a></li>
</ul>
</li>
<li><a href="#org5aabb56">比较猜测的数字和秘密数字</a>
<ul>
<li><a href="#org8cca9fe">模式匹配</a></li>
<li><a href="#org36b11ab">静态强类型</a></li>
</ul>
</li>
<li><a href="#orgecb5f53">使用循环来允许多次猜测</a>
<ul>
<li><a href="#orgdf44210">猜测正确后退出</a></li>
<li><a href="#org443b9a7">处理无效输入</a></li>
</ul>
</li>
<li><a href="#org58c844d">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgef71588" class="outline-2">
<h2 id="orgef71588">Hello World</h2>
<div class="outline-text-2" id="text-orgef71588">
</div>
<div id="outline-container-orga6d75b3" class="outline-3">
<h3 id="orga6d75b3">编写rust程序</h3>
<div class="outline-text-3" id="text-orga6d75b3">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Hello, world!"</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org360c884" class="outline-3">
<h3 id="org360c884">编译并运行文件</h3>
<div class="outline-text-3" id="text-org360c884">
<div class="org-src-container">
<pre class="src src-sh">$ rustc main.rs
$ ./main

Hello, world!
</pre>
</div>
</div>
</div>

<div id="outline-container-org6cc5e4c" class="outline-3">
<h3 id="org6cc5e4c">分析程序</h3>
<div class="outline-text-3" id="text-org6cc5e4c">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {

}
</pre>
</div>

<p>
这几行定义了一个 Rust 函数。 <span class="underline">main</span> 函数是一个 <b>特殊的</b> 函数：
</p>
<ul class="org-ul">
<li>在可执行的 Rust 程序中，它总是最先运行的代码</li>
<li>第一行代码声明了一个叫做 main 的函数
<ul class="org-ul">
<li>它 <b>没有参数</b> 也 <b>没有返回值</b></li>
<li>如果有参数的话，它们的名称应该出现在小括号中 <span class="underline">()</span></li>
</ul></li>
</ul>

<pre class="example">
还须注意，函数体被包裹在花括号中，{}

Rust 要求所有函数体都要用花括号包裹起来

一般来说，将左花括号与函数声明置于同一行并以空格分隔，是良好的代码风格
</pre>

<p>
在 <span class="underline">main</span> () 函数中是如下代码：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Hello, world!"</span>);
</pre>
</div>

<p>
这行代码完成这个简单程序的所有工作：在屏幕上打印文本。这里有四个重要的细节需要注意：
</p>
<ol class="org-ol">
<li>Rust 的缩进风格使用 <b>4 个空格</b> ，而不是 1 个制表符</li>
<li><span class="underline">println!</span> 调用了一个 <b>Rust 宏</b> 。如果是调用函数，则应输入 <span class="underline">println</span> （ 没有! ）</li>
<li><span class="underline">"Hello, world!"</span> 是一个字符串。把这个字符串作为一个参数传递给 println!，字符串将被打印到屏幕上</li>
<li>该行以 <b>分号结尾</b> <span class="underline">;</span> ，这代表一个表达式的结束和下一个表达式的开始。大部分 Rust 代码行以分号结尾</li>
</ol>
</div>
</div>

<div id="outline-container-org816ce18" class="outline-3">
<h3 id="org816ce18">编译和运行是独立的</h3>
<div class="outline-text-3" id="text-org816ce18">
<p>
Rust 是一种 <b>预编译静态</b> 类型语言，这意味着可以编译程序，并将 <span class="underline">可执行文件</span> 送给其他人，他们甚至不需要安装 Rust 就可以运行
</p>

<pre class="example">
     如果你给他人一个 .rb、.py 或 .js 文件，他们需要先分别安装 Ruby，Python，JavaScript 实现（运行时环境，VM）

     不过在这些语言中，只需要一句命令就可以编译和运行程序

     这一切都是语言设计上的权衡取舍
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc51e108" class="outline-2">
<h2 id="orgc51e108">Hello Cargo</h2>
<div class="outline-text-2" id="text-orgc51e108">
<pre class="example">
    仅仅使用 rustc 编译简单程序是没问题的，不过随着项目的增长，可能需要管理你项目的方方面面，并让代码易于分享

    接下来，要介绍一个叫做 Cargo 的工具，它会帮助编写真实世界中的 Rust 程序
</pre>

<p>
<span class="underline">Cargo</span> 是 Rust 的 <b>构建系统</b> 和 <b>包管理器</b> ，它可以为你处理很多任务，比如 <span class="underline">构建代码</span> 、 <span class="underline">下载依赖库</span> 并 <span class="underline">编译这些库</span> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo --version

cargo 1.40.0 (bc8e4c8be 2019-11-22)
</pre>
</div>

<p>
如果看到了版本号，说明已安装
</p>
</div>

<div id="outline-container-org5e85e0a" class="outline-3">
<h3 id="org5e85e0a">使用 Cargo 创建项目</h3>
<div class="outline-text-3" id="text-org5e85e0a">
<div class="org-src-container">
<pre class="src src-sh">$ cargo new hello_cargo
$ cd hello_cargo
</pre>
</div>

<ul class="org-ul">
<li>第一行命令 <b>新建</b> 了名为 hello_cargo 的目录。将项目命名为 hello_cargo，同时 Cargo 在一个同名目录中创建项目文件</li>
<li>进入 hello_cargo 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：
<ul class="org-ul">
<li>一个 <span class="underline">Cargo.toml</span> 文件</li>
<li>一个 <span class="underline">src</span> 目录
<ul class="org-ul">
<li>位于 src 目录中的 <span class="underline">main.rs</span> 文件</li>
</ul></li>
</ul></li>
</ul>
</div>


<div id="outline-container-org4ab596a" class="outline-4">
<h4 id="org4ab596a">Cargo.toml</h4>
<div class="outline-text-4" id="text-org4ab596a">
<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98f5ff;">package</span>]
<span style="color: #4eee94;">name</span> = <span style="color: #deb887;">"hello_cargo"</span>
<span style="color: #4eee94;">version</span> = <span style="color: #deb887;">"0.1.0"</span>
<span style="color: #4eee94;">authors</span> = [<span style="color: #deb887;">"i514692 <a href="mailto:klose.wu%40sap.com">&lt;klose.wu@sap.com&gt;</a>"</span>]
<span style="color: #4eee94;">edition</span> = <span style="color: #deb887;">"2018"</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

[<span style="color: #98f5ff;">dependencies</span>]
</pre>
</div>

<p>
这个文件使用 <span class="underline">TOML</span> 格式，这是 Cargo 配置文件的格式：
</p>
<ul class="org-ul">
<li>第一行 <span class="underline">[package]</span> ，是一个片段标题，表明下面的语句用来 <b>配置一个包</b> 
<ul class="org-ul">
<li>随着在这个文件增加更多的信息，还将增加其他片段</li>
</ul></li>
<li>接下来的四行设置了 Cargo 编译程序所需的配置：
<ul class="org-ul">
<li>项目的名称</li>
<li>版本</li>
<li>作者</li>
<li>要使用的 Rust 版本</li>
</ul></li>
</ul>
<pre class="example">
Cargo 从环境中获取你的名字和 email 信息，所以如果这些信息不正确，请修改并保存此文件
</pre>
<ul class="org-ul">
<li>最后一行 <span class="underline">[dependencies]</span> ，是罗列 <b>项目依赖</b> 的片段的开始</li>
</ul>
<pre class="example">
      在 Rust 中，代码包被称为 crates

      这个项目并不需要其他的 crate
</pre>
</div>
</div>

<div id="outline-container-org1efef61" class="outline-4">
<h4 id="org1efef61">main.rs</h4>
<div class="outline-text-4" id="text-org1efef61">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Hello, world!"</span>);
}
</pre>
</div>

<p>
Cargo 自动生成了一个 “Hello, world!” 程序
</p>

<pre class="example">
Cargo 期望源文件存放在 src 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件

使用 Cargo 帮助你保持项目干净整洁，一切井井有条。
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf963fe6" class="outline-3">
<h3 id="orgf963fe6">构建并运行</h3>
<div class="outline-text-3" id="text-orgf963fe6">
<div class="org-src-container">
<pre class="src src-sh">$ cargo build
   Compiling hello_cargo v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.71s
</pre>
</div>

<p>
这个命令会 <b>创建一个可执行文件</b> target/debug/hello_cargo 可以通过这个命令运行可执行文件：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./target/debug/hello_cargo
Hello, world!
</pre>
</div>

<p>
如果一切顺利，终端上应该会打印出 <span class="underline">Hello, world!</span> 
</p>

<pre class="example">
     首次运行 cargo build 时，也会使 Cargo 在项目根目录创建一个新文件：Cargo.lock。这个文件记录项目依赖的实际版本

     这个项目并没有依赖，所以其内容比较少。你自己永远也不需要碰这个文件，让 Cargo 处理它就行了。
</pre>

<p>
也可以使用 <span class="underline">cargo run</span> 在一个命令中 <b>同时编译并运行</b> 生成的可执行文件：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.04s
     Running <span style="color: #fa8072;">`target/debug/hello_cargo`</span>
Hello, world!
</pre>
</div>

<pre class="example">
注意这一次并没有出现表明 Cargo 正在编译 hello_cargo 的输出

Cargo 发现文件并没有被改变，就直接运行了二进制文件

如果修改了源文件的话，Cargo 会在运行之前重新构建项目
</pre>

<p>
Cargo 还提供了一个叫 <span class="underline">cargo check</span> 的命令。该命令 <b>快速检查代码确保其可以编译</b> ，但并不产生可执行文件：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo check
    Checking hello_cargo v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.22s
</pre>
</div>

<pre class="example">
     通常 cargo check 要比 cargo build 快得多，因为它省略了生成可执行文件的步骤

     如果你在编写代码时持续的进行检查，cargo check 会加速开发！

     为此很多 Rustaceans 编写代码时定期运行 cargo check 确保它们可以编译。当准备好使用可执行文件时才运行 cargo build
</pre>

<p>
回顾下已学习的 Cargo 内容：
</p>
<ul class="org-ul">
<li>可以使用 cargo build 或 cargo check 构建项目</li>
<li>可以使用 cargo run 一步构建并运行项目</li>
<li>有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 target/debug 目录</li>
</ul>
</div>
</div>

<div id="outline-container-org5e567e6" class="outline-3">
<h3 id="org5e567e6">发布构建</h3>
<div class="outline-text-3" id="text-org5e567e6">
<p>
当项目最终准备好发布时，可以使用 <span class="underline">cargo build &#x2013;release</span> 来 <b>优化编译</b> 项目。这会在 <b>target/release</b> 而不是 target/debug 下生成可执行文件
</p>

<pre class="example">
     这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间

     这也就是为什么会有两种不同的配置：
     一种是为了开发，你需要经常快速重新构建
     另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好

     如果你在测试代码的运行时间，请确保运行 cargo build --release 并使用 target/release 下的可执行文件进行测试
</pre>
</div>
</div>

<div id="outline-container-org8a08446" class="outline-3">
<h3 id="org8a08446">把 Cargo 当成习惯</h3>
<div class="outline-text-3" id="text-org8a08446">
<pre class="example">
     对于简单项目，Cargo 并不比 rustc 提供了更多的优势，不过随着开发的深入，终将证明其价值

     对于拥有多个 crate 的复杂项目，交给 Cargo 来协调构建将简单的多
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7706a9" class="outline-2">
<h2 id="orgd7706a9">猜猜看游戏</h2>
<div class="outline-text-2" id="text-orgd7706a9">
</div>
<div id="outline-container-orgdc01570" class="outline-3">
<h3 id="orgdc01570">创建一个新项目</h3>
<div class="outline-text-3" id="text-orgdc01570">
<div class="org-src-container">
<pre class="src src-sh">$ cargo new guessing_game
$ cd guessing_game
</pre>
</div>
</div>
</div>

<div id="outline-container-org4fe5daa" class="outline-3">
<h3 id="org4fe5daa">处理一次猜测</h3>
<div class="outline-text-3" id="text-org4fe5daa">
<pre class="example">
     猜猜看程序的第一部分请求和处理用户输入，并检查输入是否符合预期的格式
</pre>
<p>
首先，允许玩家输入猜测。在 src/main.rs 中输入的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Guess the number!"</span>);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Please input your guess."</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">guess</span> = <span style="color: #98f5ff;">String</span>::new();

    <span style="color: #ffd700;">io</span>::stdin().read_line(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> guess)
        .expect(<span style="color: #deb887;">"Failed to read line"</span>);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You guessed: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, guess);
}
</pre>
</div>
</div>

<div id="outline-container-org4dada23" class="outline-4">
<h4 id="org4dada23">导入包</h4>
<div class="outline-text-4" id="text-org4dada23">
<p>
为了获取用户输入并打印结果作为输出，需要将 <b>io</b> （ <span class="underline">输入/输出</span> ）库引入当前作用域。io 库来自于 <b>标准库</b> （也被称为 <span class="underline">std</span> ） 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
</pre>
</div>

<p>
默认情况下，Rust 将 <span class="underline">prelude</span> 模块中少量的类型引入到每个程序的作用域中。如果需要的类型不在 prelude 中，你必须使用 <b>use</b> 语句显式地将其引入作用域
</p>

<pre class="example">
std::io 库提供很多有用的功能，包括接收用户输入的功能
</pre>
</div>
</div>

<div id="outline-container-orga7e0440" class="outline-4">
<h4 id="orga7e0440">定义变量</h4>
<div class="outline-text-4" id="text-orga7e0440">
<p>
创建一个储存用户输入的地方：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">guess</span> = <span style="color: #98f5ff;">String</span>::new();
</pre>
</div>

<p>
这是一个 <span class="underline">let</span> 语句，用来 <b>创建变量</b> 。这里是另外一个例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">foo</span> = 5; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#21487;&#21464;&#30340;</span>
</pre>
</div>

<p>
在 Rust 中，变量 <b>默认是不可变</b> 的，程序里的 <b>mut</b> 用来定义 <b>可变的</b> 变量
</p>

<pre class="example">
      注意：// 语法开始一个注释，持续到行尾。Rust 忽略注释中的所有内容
</pre>
</div>
</div>

<div id="outline-container-orga3ab97e" class="outline-4">
<h4 id="orga3ab97e">new函数</h4>
<div class="outline-text-4" id="text-orga3ab97e">
<p>
现在已经知道了 <span class="underline">let mut guess</span> 会引入一个叫做 <span class="underline">guess</span> 的可变变量。等号(=) 的右边是 guess 所绑定的值，它是 <span class="underline">String::new</span> 的结果，这个函数会返回一个 String 的新实例
</p>

<pre class="example">
String 是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块
</pre>

<p>
<span class="underline">::new</span> 那一行的 <b>::</b>  语法表明 <span class="underline">new</span> 是 <span class="underline">String</span> 类型的一个 <b>关联函数</b> ，关联函数是针对类型实现的
</p>
<pre class="example">
一些语言中把它称为 静态方法

在这个例子中 new 函数是 String，而不是 String 的某个特定实例

new 函数创建了一个新的空字符串，很多类型上有 new 函数，因为它是创建类型实例的惯用函数名
</pre>
</div>
</div>

<div id="outline-container-orgeb08b24" class="outline-4">
<h4 id="orgeb08b24">引用</h4>
<div class="outline-text-4" id="text-orgeb08b24">
<p>
在程序的第一行使用 <span class="underline">use std::io</span> ; 从标准库中引入了输入/输出功能。现在调用 io 的关联函数 <span class="underline">stdin</span> ：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">io</span>::stdin().read_line(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> guess)
    .expect(<span style="color: #deb887;">"Failed to read line"</span>);
</pre>
</div>

<p>
<span class="underline">stdin</span> 函数返回一个 <span class="underline">std::io::Stdin</span> 的实例，这代表 <b>终端标准输入句柄的类型</b> 
</p>

<pre class="example">
      如果程序的开头没有 use std::io 这一行，可以把函数调用写成 std::io::stdin
</pre>

<p>
<span class="underline">.read_line(&amp;mut guess)</span> : 调用 <span class="underline">read_line</span> 方法从 <span class="underline">标准输入句柄</span> <b>获取</b> <span class="underline">用户输入</span> ，向 read_line() 传递了一个 <span class="underline">参数</span> <b>&amp;mut guess</b> 
</p>
<ul class="org-ul">
<li>无论用户在标准输入中键入什么内容，都将其存入一个字符串中，因此它需要字符串作为参数</li>
<li>这个字符串参数应该是 <b>可变的</b> ，以便 read_line 将用户输入附加上去</li>
</ul>

<pre class="example">
      引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用

      当然完成当前程序并不需要了解如此多细节
</pre>

<p>
<span class="underline">&amp;</span> 表示这个参数是一个 <b>引用</b> ，它允许 <b>多处代码访问同一处数据</b> ，而 <b>无需在内存中多次拷贝</b> 
</p>
<ul class="org-ul">
<li>它像变量一样，*默认是不可变的*</li>
<li>所以要写成 <b>&amp;mut guess</b> 来使其可变，而不是 &amp;guess</li>
</ul>
</div>
</div>

<div id="outline-container-org5d30b85" class="outline-4">
<h4 id="org5d30b85">使用 Result 类型来处理潜在的错误</h4>
<div class="outline-text-4" id="text-org5d30b85">
<p>
read_line 将用户输入附加到传递给它的字符串中，不过它也 <b>返回一个值</b> ：在这个例子中是 <span class="underline">io::Result</span> 
</p>

<pre class="example">
Rust 标准库中有很多叫做 Result 的类型

一个 Result 泛型以及对应子模块的特定版本，比如 io::Result
</pre>

<p>
Result 类型是 <b>枚举</b> ，通常也写作 <span class="underline">enums</span> 。枚举类型 <b>持有固定集合的值</b> ，这些值被称为枚举的 <span class="underline">成员</span> 。Result 的成员是 <span class="underline">Ok</span> 和 <span class="underline">Err</span> 
</p>
<ul class="org-ul">
<li>Ok 成员表示操作成功，内部包含成功时产生的值</li>
<li>Err 成员则意味着操作失败，并且包含失败的前因后果</li>
</ul>

<pre class="example">
      这些 Result 类型的作用是编码错误处理信息
</pre>

<p>
Result 类型的值，像其他类型一样，拥有定义于其上的方法。 <span class="underline">io::Result</span>  的实例拥有 <span class="underline">expect</span>  方法：
</p>
<ul class="org-ul">
<li>如果 io::Result 实例的值是 Err，expect 会导致 <b>程序崩溃</b> ，并 <b>显示当做参数传递给 expect 的信息</b> 
<ul class="org-ul">
<li>如果 read_line 方法返回 Err，则可能是来源于 <span class="underline">底层操作系统错误的结果</span></li>
</ul></li>
<li>如果 io::Result 实例的值是 Ok，expect 会 <b>获取 Ok 中的值</b> 并 <b>原样返回</b> 
<ul class="org-ul">
<li>这里这个值是 <span class="underline">用户输入到标准输入中的字节数</span></li>
</ul></li>
</ul>

<pre class="example">
如果不调用 expect，程序也能编译，不过会出现一个警告：


$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default

Rust 警告没有使用 read_line 的返回值 Result，说明有一个可能的错误没有处理

消除警告的正确做法是实际编写错误处理代码，不过由于就是希望程序在出现问题时立即崩溃，所以直接使用 expect。
</pre>
</div>
</div>

<div id="outline-container-org8ba3a86" class="outline-4">
<h4 id="org8ba3a86">使用 println! 占位符打印值</h4>
<div class="outline-text-4" id="text-org8ba3a86">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You guessed: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, guess);
</pre>
</div>

<p>
这行代码打印存储用户输入的字符串。第一个参数是 <b>格式化字符串</b> ：
</p>
<ul class="org-ul">
<li>里面的 <span class="underline">{}</span> 是 <b>预留在特定位置的占位符</b></li>
<li>使用 {} 也可以打印多个值：第一对 {} 使用格式化字符串之后的第一个值，第二对则使用第二个值，依此类推</li>
</ul>

<p>
调用一次 println! 打印多个值看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">#![allow(unused_variables)]</span>
<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">x</span> = 5;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">y</span> = 10;

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"x = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> and y = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, x, y);
}
</pre>
</div>

<p>
这行代码会打印出 x = 5 and y = 10
</p>
</div>
</div>

<div id="outline-container-org349fee3" class="outline-4">
<h4 id="org349fee3">测试第一部分代码</h4>
<div class="outline-text-4" id="text-org349fee3">
<p>
使用 cargo run 运行：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.76s
     Running <span style="color: #fa8072;">`target/debug/guessing_game`</span>
Guess the number!
Please input your guess.
8
You guessed: 8
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga473168" class="outline-3">
<h3 id="orga473168">生成一个秘密数字</h3>
<div class="outline-text-3" id="text-orga473168">
<p>
接下来，需要生成一个秘密数字，好让用户来猜
</p>

<pre class="example">
     秘密数字应该每次都不同，这样重复玩才不会乏味

     范围应该在 1 到 100 之间，这样才不会太困难

</pre>
<p>
Rust 标准库中尚未包含随机数功能。然而，Rust 团队还是提供了一个 <span class="underline">rand</span> crate
</p>
</div>

<div id="outline-container-org2a1c8f4" class="outline-4">
<h4 id="org2a1c8f4">使用 crate 来增加更多功能</h4>
<div class="outline-text-4" id="text-org2a1c8f4">
<p>
<span class="underline">crate</span> 是一个 <b>Rust 代码包</b> ：
</p>
<ul class="org-ul">
<li>正在构建的项目是一个 <span class="underline">二进制 crate</span> ，它 <b>生成一个可执行文件</b></li>
<li>rand crate 是一个 <span class="underline">库 crate</span> ，可以 <b>包含任意能被其他程序使用的代码</b></li>
</ul>

<pre class="example">
Cargo 对外部 crate 的运用是其真正闪光的地方
</pre>

<p>
使用 rand 编写代码之前，需要修改 Cargo.toml 文件， <b>引入一个 rand 依赖</b> 。现在打开这个文件并在底部的 <span class="underline">[dependencies]</span> 片段标题之下添加：
</p>

<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98f5ff;">dependencies</span>]

<span style="color: #4eee94;">rand</span> = <span style="color: #deb887;">"0.5.5"</span>
</pre>
</div>

<pre class="example">
      在 Cargo.toml 文件中，标题以及之后的内容属同一个片段，直到遇到下一个标题才开始新的片段
</pre>

<p>
<span class="underline">[dependencies]</span> 片段告诉 Cargo 本项目 <b>依赖了哪些外部 crate 及其版本</b> ：这里使用语义化版本 <span class="underline">0.5.5</span>  来指定 <span class="underline">rand</span> crate
</p>

<pre class="example">
Cargo 理解语义化版本（有时也称为 SemVer），这是一种定义版本号的标准

0.5.5 事实上是 ^0.5.5 的简写，它表示 “任何与 0.5.5 版本公有 API 相兼容的版本”
</pre>

<p>
现在，不修改任何代码，构建项目：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.6
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
  Downloaded libc v0.2.66
   Compiling libc v0.2.66
   Compiling rand_core v0.4.2
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 30.78s
</pre>
</div>

<p>
可能会出现不同的版本号（多亏了语义化版本，它们与代码是兼容的！），同时显示顺序也可能会有所不同
</p>

<pre class="example">
Cargo 从 registry 上获取所有包的最新版本信息，这是一份来自 Crates.io 的数据拷贝

Crates.io 是 Rust 生态环境中的开发者们向他人贡献 Rust 开源项目的地方
</pre>

<p>
在更新完 registry 后，Cargo 检查 [dependencies] 片段并下载缺失的 crate 
</p>

<pre class="example">
      本例中，虽然只声明了 rand 一个依赖，然而 Cargo 还是额外获取了 libc 和 rand_core 的拷贝，因为 rand 依赖 libc 来正常工作

      下载完成后，Rust 编译依赖，然后使用这些依赖编译项目
</pre>


<p>
如果不做任何修改，立刻再次运行 cargo build，则不会看到任何除了 Finished 行之外的输出。Cargo 知道它已经下载并编译了依赖，同时 Cargo.toml 文件也没有变动。Cargo 还知道代码也没有任何修改，所以它不会重新编译代码。因为无事可做，它简单的退出了。如果打开 src/main.rs 文件，做一些无关紧要的修改，保存并再次构建，则会出现两行输出：
</p>


<div class="org-src-container">
<pre class="src src-sh">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 2.53 secs
</pre>
</div>

<p>
这一行表示 Cargo 只针对 src/main.rs 文件的微小修改而更新构建。依赖没有变化，所以 Cargo 知道它可以复用已经为此下载并编译的代码。它只是重新构建了部分（项目）代码
</p>
</div>

<div id="outline-container-orgba1b6e6" class="outline-5">
<h5 id="orgba1b6e6">Cargo.lock 文件确保构建是可重现的</h5>
<div class="outline-text-5" id="text-orgba1b6e6">
<p>
Cargo 有一个机制来 <b>确保任何人在任何时候重新构建代码，都会产生相同的结果</b> ：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的
</p>

<pre class="example">
       例如，如果下周 rand crate 的 0.5.7 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷，这时会发生什么呢？
</pre>

<p>
Cargo.lock 文件。在第一次运行 cargo build 时创建，并放在 guessing_game 目录。当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 Cargo.lock 文件。当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得拥有了一个自动化的可重现的构建
</p>

<pre class="example">
       换句话说，项目会持续使用 0.5.6 直到你显式升级，多亏有了 Cargo.lock 文件
</pre>
</div>
</div>

<div id="outline-container-org467ff1f" class="outline-5">
<h5 id="org467ff1f">更新 crate 到一个新版本</h5>
<div class="outline-text-5" id="text-org467ff1f">
<p>
当 <b>确实</b> 需要升级 crate 时，Cargo 提供了另一个命令， <span class="underline">update</span> ：它会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本。如果成功了，Cargo 会把这些版本写入 Cargo.lock 文件
</p>

<pre class="example">
       不过 Cargo 默认只会寻找大于 0.5.6 而小于 0.6.0 的版本
</pre>
<p>
如果 rand crate 发布了两个新版本，0.5.7 和 0.6.0，在运行 cargo update 时会出现如下内容：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo update
    Updating crates.io index
    Updating rand v0.5.6 -&gt; v0.5.7
</pre>
</div>

<p>
如果想要使用 0.6.0 版本的 rand 或是任何 0.6.x 系列的版本，必须像这样手动更新 Cargo.toml 文件：
</p>

<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98f5ff;">dependencies</span>]

<span style="color: #4eee94;">rand</span> = <span style="color: #deb887;">"0.6.0"</span>
</pre>
</div>

<p>
下一次运行 cargo build 时，Cargo 会从 registry 更新可用的 crate，并根据指定的新版本重新计算
</p>
</div>
</div>
</div>

<div id="outline-container-org0056a56" class="outline-4">
<h4 id="org0056a56">生成一个随机数字</h4>
<div class="outline-text-4" id="text-org0056a56">
<p>
使用 rand，更新 src/main.rs : 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">rand</span>::<span style="color: #98f5ff;">Rng</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Guess the number!"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">secret_number</span> = <span style="color: #ffd700;">rand</span>::thread_rng().gen_range(1, 101);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"The secret number is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, secret_number);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Please input your guess."</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">guess</span> = <span style="color: #98f5ff;">String</span>::new();

    <span style="color: #ffd700;">io</span>::stdin().read_line(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> guess)
        .expect(<span style="color: #deb887;">"Failed to read line"</span>);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You guessed: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, guess);
}
</pre>
</div>

<p>
新增了一行 <span class="underline">use rand::Rng</span> ：Rng 是一个 <b>trait</b> ，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 <b>trait 必须在作用域中</b> 
</p>

<pre class="example">
注意：不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法。crate 的使用说明位于其文档中

Cargo 有一个很棒的功能是：运行 cargo doc --open 命令来构建所有本地依赖提供的文档，并在浏览器中打开

例如，假设你对 rand crate 中的其他功能感兴趣，你可以运行 cargo doc --open 并点击左侧导航栏中的 rand
</pre>

<p>
接下来，在中间还新增加了两行：
</p>
<ul class="org-ul">
<li><span class="underline">rand::thread_rng</span> 函数 <b>提供实际使用的随机数生成器</b> ：它位于 <span class="underline">当前执行线程的本地环境</span> 中，并从 <span class="underline">操作系统</span> 获取 <span class="underline">seed</span> 
<ul class="org-ul">
<li>调用随机数生成器的 <span class="underline">gen_range</span> 方法。这个方法由刚才引入到作用域的 <span class="underline">Rng::trait</span> 定义：
<ul class="org-ul">
<li>获取两个数字作为参数，并生成一个范围在两者之间的随机数</li>
<li>它包含下限但不包含上限，所以需要指定 1 和 101 来请求一个 1 和 100 之间的数</li>
</ul></li>
</ul></li>
<li>第二行就是打印出这个随机数字</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.95s
     Running <span style="color: #fa8072;">`target/debug/guessing_game`</span>
Guess the number!
The secret number is: 24
Please input your guess.
8
You guessed: 8
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5aabb56" class="outline-3">
<h3 id="org5aabb56">比较猜测的数字和秘密数字</h3>
<div class="outline-text-3" id="text-org5aabb56">
<p>
现在有了用户输入和一个随机数，可以比较它们：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">cmp</span>::<span style="color: #98f5ff;">Ordering</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">rand</span>::<span style="color: #98f5ff;">Rng</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">---snip---</span>

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You guessed: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, guess);

    <span style="color: #00bfff; font-weight: bold;">match</span> guess.cmp(&amp;secret_number) {
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Less</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too small!"</span>),
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Greater</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too big!"</span>),
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Equal</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You win!"</span>),
    }
}
</pre>
</div>

<p>
新代码的第一行是另一个 use，从标准库引入了一个叫做 <span class="underline">std::cmp::Ordering</span> 的类型。同 Result 一样， Ordering 也是一个 <b>枚举</b> ，不过它的成员是 <span class="underline">Less</span> 、 <span class="underline">Greater+</span> 和 <span class="underline">Equal</span> 。这是比较两个值时可能出现的三种结果
</p>

<p>
底部的五行新代码使用了 Ordering 类型：
</p>
<ul class="org-ul">
<li>cmp 方法用来比较两个值并可以在任何可比较的值上调用：
<ul class="org-ul">
<li>它获取一个 <b>被比较值的引用</b> ：这里是把 guess 与 secret_number 做比较</li>
<li>返回一个刚才通过 use 引入作用域的 <span class="underline">Ordering 枚举的成员</span></li>
</ul></li>
<li>使用一个 <b>match 表达式</b> ，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么</li>
</ul>
</div>
<div id="outline-container-org8cca9fe" class="outline-4">
<h4 id="org8cca9fe">模式匹配</h4>
<div class="outline-text-4" id="text-org8cca9fe">
<p>
一个 <span class="underline">match 表达式</span> 由 <span class="underline">分支</span> 构成
</p>
<ul class="org-ul">
<li>一个分支包含一个 <span class="underline">模式</span> 和 <b>表达式开头的值与分支模式</b> 相 <span class="underline">匹配</span> 时应该 <span class="underline">执行的代码</span></li>
<li>Rust 获取提供给 match 的值并挨个检查每个分支的模式</li>
<li>match 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并确保没有遗漏处理</li>
</ul>
<pre class="example">
假设用户猜了 50，这时随机生成的秘密数字是 38，比较 50 与 38 时，因为 50 比 38 要大，cmp 方法会返回 Ordering::Greater

Ordering::Greater 是 match 表达式得到的值：
1. 它检查第一个分支的模式，Ordering::Less 与 Ordering::Greater并不匹配，所以它忽略了这个分支的代码并来到下一个分支
2. 下一个分支的模式是 Ordering::Greater，正确匹配！这个分支关联的代码被执行，在屏幕打印出 Too big!

match 表达式就此终止，因为该场景下没有检查最后一个分支的必要
</pre>
</div>
</div>

<div id="outline-container-org36b11ab" class="outline-4">
<h4 id="org36b11ab">静态强类型</h4>
<div class="outline-text-4" id="text-org36b11ab">
<p>
然而上面的代码却不能通过编译：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo build
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:21:21
   |
21 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct <span style="color: #fa8072;">`std::string::String`</span>, found integer
   |
   = note: expected type <span style="color: #fa8072;">`&amp;std::string::String`</span>
              found type <span style="color: #fa8072;">`&amp;{integer}`</span>

error: aborting due to previous error

For more information about this error, try <span style="color: #fa8072;">`rustc --explain E0308`</span><span style="color: #f08080;">.</span>
error: could not compile <span style="color: #fa8072;">`guessing_game`</span><span style="color: #f08080;">.</span>

To learn more, run the command again with --verbose.
</pre>
</div>

<p>
错误的核心表明这里有 <b>不匹配的类型</b> 
</p>

<pre class="example">
Rust 有一个静态强类型系统，同时也有类型推断

当写出 let guess = String::new() 时，Rust 推断出 guess 应该是 String 类型，并不需要写出类型

另一方面，secret_number，是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 i32；32 位无符号数字 u32；64 位数字 i64 等等
Rust 默认使用 i32，所以它是 secret_number 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息

这里错误的原因在于 Rust 不会比较字符串类型和数字类型
</pre>

<p>
必须把从 <span class="underline">输入中读取到的String</span>  <b>转换</b> 为一个真正的 <span class="underline">数字类型</span> ，才好与秘密数字进行比较。这可以通过在 main 函数体中增加如下两行代码来实现：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">guess</span> = <span style="color: #98f5ff;">String</span>::new();

    <span style="color: #ffd700;">io</span>::stdin().read_line(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> guess)
        .expect(<span style="color: #deb887;">"Failed to read line"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">guess</span>: <span style="color: #98f5ff;">u32</span> = guess.trim().parse()
        .expect(<span style="color: #deb887;">"Please type a number!"</span>);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You guessed: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, guess);

    <span style="color: #00bfff; font-weight: bold;">match</span> guess.cmp(&amp;secret_number) {
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Less</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too small!"</span>),
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Greater</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too big!"</span>),
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Equal</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You win!"</span>),
    }
}
</pre>
</div>

<p>
这里创建了一个叫做 <span class="underline">guess</span> 的变量
</p>

<pre class="example">
      不过等等，不是已经有了一个叫做 guess 的变量了吗？
</pre>

<p>
确实如此，不过 Rust 允许用一个新值来 <b>隐藏</b> guess 之前的值
</p>

<pre class="example">
      这个功能常用在需要转换值类型之类的场景。它允许我们复用 guess 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类
</pre>

<p>
将 guess 绑定到 <span class="underline">guess.trim().parse()</span> 表达式上：
</p>
<ul class="org-ul">
<li><span class="underline">表达式中的 guess</span> 是包含输入的 <b>原始 String 类型</b></li>
<li>String 实例的 <span class="underline">trim</span> 方法会 <b>去除字符串开头和结尾的空白字符</b></li>
</ul>

<pre class="example">
u32 只能由数字字符转换，不过用户必须输入 enter 键才能让 read_line 返回，然而用户按下 enter 键时，会在字符串中增加一个换行符

例如，用户输入 5 并按下 enter，guess 看起来像这样：5\n。\n 代表 “换行”，回车键。trim 方法消除 \n，只留下 5
</pre>

<ul class="org-ul">
<li>字符串的 <span class="underline">parse</span> 方法 将 <b>字符串解析成数字</b> ： 
<ul class="org-ul">
<li>因为这个方法可以解析多种数字类型，因此 <b>需要告诉 Rust 具体的数字类型</b> ，这里通过 <span class="underline">let guess: u32</span> 指定
<ul class="org-ul">
<li>guess 后面的冒号 <span class="underline">:</span> 告诉 Rust 指定了 <span class="underline">变量的类型</span></li>
</ul></li>
</ul></li>
</ul>

<pre class="example">
Rust 有一些内建的数字类型；u32 是一个无符号的 32 位整型

对于不大的正整数来说，它是不错的类型

另外，程序中的 u32 注解以及与 secret_number 的比较，意味着 Rust 会推断出 secret_number 也是 u32 类型

现在可以使用相同类型比较两个值了
</pre>

<ul class="org-ul">
<li>parse 调用很容易产生错误：
<ul class="org-ul">
<li>例如，字符串中包含 <span class="underline">A👍%</span> ，就无法将其转换为一个数字</li>
<li>parse 方法返回一个 <span class="underline">Result</span> 类型，再次用 <span class="underline">expect</span> 方法处理即可：
<ul class="org-ul">
<li>如果 parse 不能从字符串生成一个数字，返回一个 Result 的 Err 成员时，expect 会使游戏崩溃并打印附带的信息</li>
<li>如果 parse 成功地将字符串转换为一个数字，它会返回 Result 的 Ok 成员，然后 expect 会返回 Ok 值中的数字</li>
</ul></li>
</ul></li>
</ul>

<p>
现在运行程序：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.08s
     Running <span style="color: #fa8072;">`target/debug/guessing_game`</span>
Guess the number!
The secret number is: 83
Please input your guess.
99
You guessed: 99
Too big!
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgecb5f53" class="outline-3">
<h3 id="orgecb5f53">使用循环来允许多次猜测</h3>
<div class="outline-text-3" id="text-orgecb5f53">
<pre class="example">
     现在游戏已经大体上能玩了，不过用户只能猜一次。增加一个循环来改变它吧！
</pre>
<p>
<span class="underline">loop</span>  关键字 <b>创建了一个无限循环</b> 。将其加入后，用户可以反复猜测：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"The secret number is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, secret_number);

<span style="color: #00bfff; font-weight: bold;">loop</span> {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Please input your guess."</span>);

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">match</span> guess.cmp(&amp;secret_number) {
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Less</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too small!"</span>),
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Greater</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too big!"</span>),
        <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Equal</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You win!"</span>),
    }
}
</pre>
</div>

<p>
这样就将提示用户猜测之后的所有内容放入了循环
</p>

<pre class="example">
     这里有一个新问题，因为程序忠实地执行了要求：永远地请求另一个猜测，用户好像无法退出啊！
</pre>

<p>
用户总能使用 <span class="underline">ctrl-c</span> 终止程序。还有另一个方法跳出无限循环，就是  parse：如果用户输入的答案不是一个数字，程序会崩溃
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.95s
     Running <span style="color: #fa8072;">`target/debug/guessing_game`</span>
Guess the number!
The secret number is: 39
Please input your guess.
12
You guessed: 12
Too small!
Please input your guess.
45
You guessed: 45
Too big!
Please input your guess.
39
You guessed: 39
You win!
Please input your guess.
<span style="color: #00bfff; font-weight: bold;">exit</span>
thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'Please type a number!: ParseIntError { kind: InvalidDigit }'</span>, src/libcore/result.rs:1165:5
note: run with <span style="color: #fa8072;">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace.
</pre>
</div>

<pre class="example">
     输入 exit 确实退出了程序，同时其他任何非数字输入也一样

     然而，这并不理想，我们想要当猜测正确的数字时游戏能自动退出
</pre>
</div>

<div id="outline-container-orgdf44210" class="outline-4">
<h4 id="orgdf44210">猜测正确后退出</h4>
<div class="outline-text-4" id="text-orgdf44210">
<p>
增加一个 <span class="underline">break</span> 语句，在用户猜对时退出游戏：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">match</span> guess.cmp(&amp;secret_number) {
    <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Less</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too small!"</span>),
    <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Greater</span> =&gt; <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Too big!"</span>),
    <span style="color: #98f5ff;">Ordering</span>::<span style="color: #98f5ff;">Equal</span> =&gt; {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You win!"</span>);
        <span style="color: #00bfff; font-weight: bold;">break</span>;
    }
}
</pre>
</div>

<p>
通过在 You win! 之后增加一行 break，用户猜对了神秘数字后会退出循环
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 1.10s
     Running <span style="color: #fa8072;">`target/debug/guessing_game`</span>
Guess the number!
The secret number is: 2
Please input your guess.
5
You guessed: 5
Too big!
Please input your guess.
1
You guessed: 1
Too small!
Please input your guess.
2
You guessed: 2
You win!
</pre>
</div>
</div>
</div>

<div id="outline-container-org443b9a7" class="outline-4">
<h4 id="org443b9a7">处理无效输入</h4>
<div class="outline-text-4" id="text-org443b9a7">
<p>
为了进一步改善游戏性，不要在用户输入非数字时崩溃，需要忽略非数字，让用户可以继续猜测。可以通过修改 guess 将 String 转化为 u32 那部分代码来实现：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #ffd700;">io</span>::stdin().read_line(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> guess)
    .expect(<span style="color: #deb887;">"Failed to read line"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">guess</span>: <span style="color: #98f5ff;">u32</span> = <span style="color: #00bfff; font-weight: bold;">match</span> guess.trim().parse() {
    <span style="color: #98f5ff;">Ok</span>(num) =&gt; num,
    <span style="color: #98f5ff;">Err</span>(_) =&gt; <span style="color: #00bfff; font-weight: bold;">continue</span>,
};

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"You guessed: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, guess);

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
</pre>
</div>

<p>
将 <span class="underline">expect</span> 调用换成 <span class="underline">match</span> 语句，是从遇到错误就崩溃转换到真正处理错误的惯用方法
</p>

<pre class="example">
parse 返回一个 Result 类型，而 Result 是一个拥有 Ok 或 Err 成员的枚举

这里使用的 match 表达式，和之前处理 cmp 方法返回 Ordering 时用的一样
</pre>

<ul class="org-ul">
<li>如果 parse 能够成功的将字符串转换为一个数字，它会返回一个包含结果数字的 Ok
<ul class="org-ul">
<li>这个 Ok 值与 match 第一个分支的模式相匹配，该分支对应的动作返回 Ok 值中的数字 num，最后如愿变成新创建的 guess 变量</li>
</ul></li>
<li>如果 parse 不能将字符串转换为一个数字，它会返回一个包含更多错误信息的 Err
<ul class="org-ul">
<li>Err 值不能匹配第一个 match 分支的 Ok(num) 模式，但是会匹配第二个分支的 <b>Err(_)</b> 模式： <b>_</b> 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息
<ul class="org-ul">
<li>程序会执行第二个分支的动作， <b>continue</b> 意味着 <b>进入 loop 的下一次循环</b> ，请求另一个猜测。这样程序就有效的忽略了 parse 可能遇到的所有错误！</li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling guessing_game v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 1.07s
     Running <span style="color: #fa8072;">`target/debug/guessing_game`</span>
Guess the number!
The secret number is: 32
Please input your guess.
<span style="color: #00bfff; font-weight: bold;">exit</span>
Please input your guess.
qqq
Please input your guess.
12
You guessed: 12
Too small!
Please input your guess.
40
You guessed: 40
Too big!
Please input your guess.
32
You guessed: 32
You win!
</pre>
</div>

<pre class="example">
      最后，还应该注释掉最开始的生成随机数字的打印语句 :-) 
</pre>
</div>
</div>
</div>

<div id="outline-container-org58c844d" class="outline-3">
<h3 id="org58c844d">总结</h3>
<div class="outline-text-3" id="text-org58c844d">
<pre class="example">
     这里介绍了 Rust 新概念：let、match、方法、关联函数、使用外部 crate 等等

     以后还会介绍rust最与众不同的一点是“它关于指针的所有权”
</pre>

<p>
<a href="concept.html">Next: 概念</a>
</p>

<p>
<a href="rust.html">Home: 目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
