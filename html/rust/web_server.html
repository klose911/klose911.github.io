<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Web服务器</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="advanced.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">Web服务器</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgad373e2">构建单线程 web server</a>
<ul>
<li><a href="#orgbb15e8f">监听 TCP 连接</a></li>
<li><a href="#orgc2b9523">读取请求</a>
<ul>
<li><a href="#org37f8e21">仔细观察 HTTP 请求</a></li>
</ul>
</li>
<li><a href="#orgc4f45f3">编写响应</a>
<ul>
<li><a href="#org99a5062">返回真正的 HTML</a></li>
</ul>
</li>
<li><a href="#orga79eeee">验证请求并有选择的进行响应</a></li>
<li><a href="#org57e0ef9">少量代码重构</a></li>
</ul>
</li>
<li><a href="#orge6dbd78">多线程 web server</a>
<ul>
<li><a href="#org2bc5dd1">在当前 server 实现中模拟慢请求</a></li>
<li><a href="#org375b5ca">使用线程池改善吞吐量</a>
<ul>
<li><a href="#org3392293">为每一个请求分配线程的代码结构</a></li>
<li><a href="#orgf826ac6">为有限数量的线程创建一个类似的接口</a></li>
<li><a href="#org0ca44a9">构建 ThreadPool 结构体</a></li>
<li><a href="#org838d9aa">在 new 中验证池中线程数量</a></li>
<li><a href="#org9384025">分配空间以储存线程</a></li>
<li><a href="#orge7f4b8e">Worker 结构体：负责从 ThreadPool 中将代码传递给线程</a></li>
<li><a href="#orged81a00">使用通道向线程发送请求</a></li>
<li><a href="#orgf40133c">实现 execute 方法</a>
<ul>
<li><a href="#orgfd7cf67">while let 陷阱</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org27f875c">优雅停机</a>
<ul>
<li><a href="#org8d3c7f2">为 ThreadPool 实现 Drop Trait</a></li>
<li><a href="#orgeffbb8b">向线程发送信号使其停止接收任务</a></li>
<li><a href="#org66ec4e0">最后测试</a></li>
</ul>
</li>
<li><a href="#org8d77012">总结</a></li>
</ul>
</div>
</div>
<p>
作为最后的项目，将要实现一个返回 “hello” 的 web server，它在浏览器中看起来就如下所示：
</p>


<div class="figure">
<p><img src="pic/trpl20-01.png" alt="trpl20-01.png" width="30%" /> 
</p>
</div>

<p>
如下是将怎样构建此 web server 的计划：
</p>
<ol class="org-ol">
<li>学习一些 TCP 与 HTTP 知识</li>
<li>在套接字socket上监听 TCP 请求</li>
<li>解析少量的 HTTP 请求</li>
<li>创建一个合适的 HTTP 响应</li>
<li>通过线程池改善 server 的吞吐量</li>
</ol>

<pre class="example">
不过在开始之前，需要提到一点细节：这里使用的方法并不是使用 Rust 构建 web server 最好的方法

crates.io 上有很多可用于生产环境的 crate，它们提供了比我们所要编写的更为完整的 web server 和线程池实现

然而，我们的目的在于学习自己编写一个基础的 HTTP server 和线程池，以便学习将来可能用到的 crate 背后的通用理念和技术

这里也展示了选择处理什么层次的抽象，并能够选择比其他语言可能或可用的层次更低的层次
</pre>
<div id="outline-container-orgad373e2" class="outline-2">
<h2 id="orgad373e2">构建单线程 web server</h2>
<div class="outline-text-2" id="text-orgad373e2">
<p>
首先创建一个可运行的单线程 web server，不过在开始之前，将快速了解一下构建 web server 所涉及到的协议
</p>

<pre class="example">
web server 中涉及到的两个主要协议是 超文本传输协议(HTTP)和 传输控制协议(TCP)。这两者都是 请求-响应协议，也就是说，有客户端来初始化请求，并有服务端监听请求并向客户端提供响应。请求与响应的内容由协议本身定义。

TCP 是一个底层协议，它描述了信息如何从一个 server 到另一个的细节，不过其并不指定信息是什么

HTTP 构建于 TCP 之上，它定义了请求和响应的内容

技术上讲可将 HTTP 用于其他协议之上，不过对于绝大部分情况，HTTP 通过 TCP 传输。将要做的就是处理 TCP 和 HTTP 请求与响应的原始字节数据
</pre>
</div>
<div id="outline-container-orgbb15e8f" class="outline-3">
<h3 id="orgbb15e8f">监听 TCP 连接</h3>
<div class="outline-text-3" id="text-orgbb15e8f">
<p>
我们的 web server 所需做的第一件事便是能够监听 TCP 连接。标准库提供了 <span class="underline">std::net</span> 模块处理这些功能。一如既往新建一个项目：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo new hello
     Created binary (application) <span style="color: #fa8072;">`hello`</span> project
$ cd hello
</pre>
</div>

<p>
在 src/main.rs 输入下面的代码作为开始。这段代码会在地址 127.0.0.1:7878 上监听传入的 TCP 流。当获取到传入的流，它会打印出 Connection established!：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">net</span>::<span style="color: #98f5ff;">TcpListener</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">listener</span> = <span style="color: #98f5ff;">TcpListener</span>::bind(<span style="color: #deb887;">"127.0.0.1:7878"</span>).unwrap();

    <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">stream</span> <span style="color: #00bfff; font-weight: bold;">in</span> listener.incoming() {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">stream</span> = stream.unwrap();

        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Connection established!"</span>);
    }
}
</pre>
</div>

<p>
<span class="underline">TcpListener</span> 用于 <b>监听</b> <span class="underline">TCP 连接</span> ，选择监听地址 <span class="underline">127.0.0.1:7878</span> 
</p>
<pre class="example">
     将这个地址拆开，冒号之前的部分是一个代表本机的 IP 地址

     而 7878 是端口。选择这个端口出于两个原因：通常 HTTP 接受这个端口而且 7878 在电话上打出来就是 "rust"
</pre>

<p>
在这个场景中 <span class="underline">bind</span> 函数类似于 new 函数，在这里它返回一个 <span class="underline">新的 TcpListener 实例</span> 
</p>
<pre class="example">
   这个函数叫做 bind 是因为，在网络领域，连接到监听端口被称为 “绑定到一个端口”
</pre>

<p>
bind 函数返回 <span class="underline">Result&lt;T, E&gt;</span> ，这表明 <b>绑定可能会失败</b> 。因为是出于学习目的来编写一个基础的 server，将不用关心处理这类错误，使用 <span class="underline">unwrap</span> 在出现这些情况时 <b>直接停止程序</b> 
</p>

<pre class="example">
     例如，连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口），所以如果不是管理员尝试连接 80 端口，则会绑定失败

     另一个例子是如果运行两个此程序的实例这样会有两个程序监听相同的端口，绑定会失败
</pre>

<p>
TcpListener 的 <span class="underline">incoming</span> 方法返回一个 <span class="underline">迭代器</span> ，它提供了 <b>一系列的流</b> （更准确的说是 TcpStream 类型的流）:
</p>
<ul class="org-ul">
<li><span class="underline">流</span> 代表一个客户端和服务端之间打开的连接</li>
<li><span class="underline">连接</span> 代表客户端连接服务端、服务端生成响应以及服务端关闭连接的全部请求 / 响应过程</li>
<li>TcpStream 允许读取它来查看客户端发送了什么，并可以编写响应</li>
<li>总体来说，这个 for 循环会依次处理每个连接并产生一系列的流供我们处理</li>
</ul>


<p>
目前为止，处理流的过程包含 unwrap 调用，如果出现任何错误会终止程序，如果没有任何错误，则打印出信息
</p>
<pre class="example">
     下一个示例将为成功的情况增加更多功能。当客户端连接到服务端时 incoming 方法返回错误是可能的，因为实际上没有遍历连接，而是遍历“连接尝试”

     连接可能会因为很多原因不能成功，大部分是操作系统相关的。例如，很多系统限制同时打开的连接数；新连接尝试产生错误，直到一些打开的连接关闭为止
</pre>

<p>
首先在终端执行 cargo run，接着在浏览器中加载 127.0.0.1:7878。浏览器会显示出看起来类似于“连接重置”的错误信息，因为 server 目前并没响应任何数据。但是如果观察终端，会发现当浏览器连接 server 时会打印出一系列的信息！
</p>

<div class="org-src-container">
<pre class="src src-sh">     Running <span style="color: #fa8072;">`target/debug/hello`</span>
Connection established!
Connection established!
Connection established!
</pre>
</div>

<pre class="example">
     有时会看到对于一次浏览器请求会打印出多条信息；这可能是因为浏览器在请求页面的同时还请求了其他资源，比如出现在浏览器 tab 标签中的 favicon.icon

     这也可能是因为浏览器尝试多次连接 server，因为 server 没有响应任何数据。当 stream 在循环的结尾离开作用域并被丢弃，其连接将被关闭，作为 drop 实现的一部分。浏览器有时通过重连来处理关闭的连接，因为这些问题可能是暂时的

     现在重要的是我们成功的处理了 TCP 连接！
</pre>
</div>
</div>
<div id="outline-container-orgc2b9523" class="outline-3">
<h3 id="orgc2b9523">读取请求</h3>
<div class="outline-text-3" id="text-orgc2b9523">
<p>
为了分离获取连接和接下来对连接的操作的相关内容，将开始一个新函数来处理连接。在这个新的 <span class="underline">handle_connection</span> 函数中，从 TCP 流中读取数据并打印出来以便观察浏览器发送过来的数据：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #ffd700;">prelude</span>::*;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">net</span>::<span style="color: #98f5ff;">TcpStream</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">net</span>::<span style="color: #98f5ff;">TcpListener</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">listener</span> = <span style="color: #98f5ff;">TcpListener</span>::bind(<span style="color: #deb887;">"127.0.0.1:7878"</span>).unwrap();

    <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">stream</span> <span style="color: #00bfff; font-weight: bold;">in</span> listener.incoming() {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">stream</span> = stream.unwrap();

        handle_connection(stream);
    }
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">handle_connection</span>(<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">stream</span>: <span style="color: #98f5ff;">TcpStream</span>) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">buffer</span> = [0; 512];

    stream.read(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> buffer).unwrap();

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Request: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #98f5ff;">String</span>::from_utf8_lossy(&amp;buffer[..]));
}
</pre>
</div>

<p>
这里将 <span class="underline">std::io::prelude</span> 引入作用域来获取读写流所需的特定 trait。在 main 函数的 for 循环中，相比获取到连接时打印信息，现在调用新的 handle_connection 函数并向其传递 stream
</p>
<ul class="org-ul">
<li>在 handle_connection 中， <span class="underline">stream</span> 参数是 <b>可变</b> 的</li>
</ul>
<pre class="example">
     这是因为 TcpStream 实例在内部记录了所返回的数据

     它可能读取了多于我们请求的数据并保存它们以备下一次请求数据，因此它需要是 mut 的因为其内部状态可能会改变

     通常认为 “读取” 不需要可变性，不过在这个例子中则需要 mut 关键字
</pre>
<ul class="org-ul">
<li>接下来，实际读取流。这里分两步进行：
<ul class="org-ul">
<li>在栈上声明一个 buffer 来存放读取到的数据，接着将缓冲区传递给 stream.read ，它会从 TcpStream 中读取字节并放入缓冲区中</li>
</ul></li>
</ul>
<pre class="example">
     这里创建了一个 512 字节的缓冲区，它足以存放基本请求的数据并满足本章的目的需要

     如果希望处理任意大小的请求，缓冲区管理将更为复杂，不过现在一切从简
</pre>
<ul class="org-ul">
<li>将缓冲区中的字节转换为字符串并打印出来。String::from_utf8_lossy 函数获取一个 &amp;[u8] 并产生一个 String</li>
</ul>
<pre class="example">
     函数名的 lossy 部分来源于当其遇到无效的 UTF-8 序列时的行为：它使用 �，U+FFFD REPLACEMENT CHARACTER，来代替无效序列

     可能会在缓冲区的剩余部分看到这些替代字符，因为他们没有被请求数据填满
</pre>

<p>
启动程序并再次在浏览器中发起请求。注意浏览器中仍然会出现错误页面，不过终端中程序的输出现在看起来像这样：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.42 secs
     Running <span style="color: #fa8072;">`target/debug/hello`</span>
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;<span style="color: #4eee94;">q</span>=0.9,*/*;<span style="color: #4eee94;">q</span>=0.8
Accept-Language: en-US,en;<span style="color: #4eee94;">q</span>=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;
</pre>
</div>

<pre class="example">
     根据使用的浏览器不同可能会出现稍微不同的数据

     现在打印出了请求数据，可以通过观察 Request: GET 之后的路径来解释为何会从浏览器得到多个连接

     如果重复的连接都是请求 /，就知道了浏览器尝试重复获取 / 因为它没有从程序得到响应
</pre>
</div>
<div id="outline-container-org37f8e21" class="outline-4">
<h4 id="org37f8e21">仔细观察 HTTP 请求</h4>
<div class="outline-text-4" id="text-org37f8e21">
<p>
HTTP 是一个基于文本的协议，同时一个请求有如下格式：
</p>
<pre class="example">
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</pre>

<ul class="org-ul">
<li>第一行叫做 <span class="underline">请求行</span> ，它存放了客户端请求了什么的信息
<ul class="org-ul">
<li>请求行的第一部分是 <span class="underline">所使用的 method</span> ，比如 GET 或 POST，这描述了客户端如何进行请求。这里客户端使用了 GET 请求</li>
<li>请求行接下来的部分是 /，它代表客户端请求的 <span class="underline">统一资源标识符</span> (URI)</li>
<li>接下来是 <span class="underline">客户端使用的HTTP版本</span> 这里是 HTTP/1.1</li>
<li>请求行最后以 <span class="underline">CRLF序列</span></li>
</ul></li>
</ul>
<pre class="example">
CRLF代表回车和换行，carriage return line feed，这是打字机时代的术语！

CRLF序列也可以写成\r\n，其中\r是回车符，\n是换行符。CRLF序列将请求行与其余请求数据分开

请注意，打印CRLF时，会看到一个新行，而不是\r\n
</pre>
<ul class="org-ul">
<li>从 Host: 开始的其余的行是 headers</li>
<li>最后 GET 请求没有 body</li>
</ul>

<pre class="example">
      如果希望的话，尝试用不同的浏览器发送请求，或请求不同的地址，比如 127.0.0.1:7878/test，来观察请求数据如何变化
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4f45f3" class="outline-3">
<h3 id="orgc4f45f3">编写响应</h3>
<div class="outline-text-3" id="text-orgc4f45f3">
<p>
现在将实现在客户端请求的响应中发送数据的功能。响应格式如下：
</p>

<pre class="example">
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</pre>

<ul class="org-ul">
<li>第一行叫做 <span class="underline">状态行</span> ：
<ul class="org-ul">
<li>响应的 <span class="underline">HTTP 版本</span></li>
<li>一个 <span class="underline">数字状态码</span> 用以总结请求的结果</li>
<li>一个 <span class="underline">描述之前状态码的文本原因</span></li>
<li>短语 <span class="underline">CRLF</span> 序列</li>
</ul></li>
<li>任意 <span class="underline">header</span> ，另一个 CRLF 序列</li>
<li>响应的 <span class="underline">body</span></li>
</ul>

<p>
下面是一个使用 HTTP 1.1 版本的响应例子，其状态码为 200，原因短语为 OK，没有 header，也没有 body：
</p>

<pre class="example">
HTTP/1.1 200 OK\r\n\r\n
</pre>

<p>
将这些文本写入流作为成功请求的响应！在 handle_connection 函数中，去掉打印请求数据的 println!，并替换：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">handle_connection</span>(<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">stream</span>: <span style="color: #98f5ff;">TcpStream</span>) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">buffer</span> = [0; 512];

    stream.read(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> buffer).unwrap();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">response</span> = <span style="color: #deb887;">"HTTP/1.1 200 OK\r\n\r\n"</span>;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</pre>
</div>

<ul class="org-ul">
<li>新代码中的第一行定义了变量 <span class="underline">response</span> 来 <b>存放</b> 将要 <span class="underline">返回的成功响应的数据</span></li>
<li>在 response 上调用 <span class="underline">as_bytes</span> ，因为 stream 的 <span class="underline">write</span> 方法获取一个 &amp;[u8] 并直接将这些 <span class="underline">字节</span> <b>发送</b> 给 <span class="underline">连接</span></li>
</ul>

<pre class="example">
     因为 write 操作可能会失败，所以像之前那样对任何错误结果使用 unwrap

     同理，在真实世界的应用中这里需要添加错误处理
</pre>
<ul class="org-ul">
<li><span class="underline">flush</span> 会 <b>等待</b> 并 <b>阻塞</b> 程序执行直到 <span class="underline">所有字节</span> 都被 <span class="underline">写入连接中</span> 
+TcpStream 包含一个内部缓冲区来最小化对底层操作系统的调用</li>
</ul>

<pre class="example">
     有了这些修改，运行代码并进行请求！

     不再向终端打印任何数据，所以不会再看到除了 Cargo 以外的任何输出

     不过当在浏览器中加载 127.0.0.1:7878 时，会得到一个空页面而不是错误！
</pre>
</div>

<div id="outline-container-org99a5062" class="outline-4">
<h4 id="org99a5062">返回真正的 HTML</h4>
<div class="outline-text-4" id="text-org99a5062">
<p>
在项目根目录创建一个新文件，hello.html 
</p>
<pre class="example">
    注意：不是在 src 目录！
</pre>
<p>
在此可以放入任何你期望的 HTML，下面展示了一个可能的文本：
</p>

<div class="org-src-container">
<pre class="src src-html"><span style="color: #deb887;">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color: #daa520; font-weight: bold;">html</span> <span style="color: #4eee94;">lang</span>=<span style="color: #deb887;">"en"</span>&gt;
  &lt;<span style="color: #daa520; font-weight: bold;">head</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">meta</span> <span style="color: #4eee94;">charset</span>=<span style="color: #deb887;">"utf-8"</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;">Hello!</span>&lt;/<span style="color: #daa520; font-weight: bold;">title</span>&gt;
  &lt;/<span style="color: #daa520; font-weight: bold;">head</span>&gt;
  &lt;<span style="color: #daa520; font-weight: bold;">body</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">h1</span>&gt;<span style="font-weight: bold; text-decoration: underline;">Hello!</span>&lt;/<span style="color: #daa520; font-weight: bold;">h1</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">p</span>&gt;Hi from Rust&lt;/<span style="color: #daa520; font-weight: bold;">p</span>&gt;
  &lt;/<span style="color: #daa520; font-weight: bold;">body</span>&gt;
&lt;/<span style="color: #daa520; font-weight: bold;">html</span>&gt;
</pre>
</div>

<p>
这是一个极小化的 HTML5 文档，它有一个标题和一小段文本。为了在 server 接受请求时返回它，修改 handle_connection 来读取 HTML 文件，将其加入到响应的 body 中，并发送：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fs;
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">handle_connection</span>(<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">stream</span>: <span style="color: #98f5ff;">TcpStream</span>) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">buffer</span> = [0; 512];
    stream.read(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> buffer).unwrap();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">contents</span> = <span style="color: #ffd700;">fs</span>::read_to_string(<span style="color: #deb887;">"hello.html"</span>).unwrap();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">response</span> = <span style="color: #f08080;">format!</span>(<span style="color: #deb887;">"HTTP/1.1 200 OK\r\n\r\n</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</pre>
</div>

<ul class="org-ul">
<li>在开头增加了一行来将标准库中的 File 引入作用域：打开和读取文件的代码应该看起来很熟悉</li>
<li>使用 format! 将文件内容加入到将要写入流的成功响应的 body 中</li>
</ul>

<p>
使用 cargo run 运行程序，重新测试后，应该会看到渲染出来的 HTML 文件！
</p>

<pre class="example">
      目前忽略了 buffer 中的请求数据并无条件的发送了 HTML 文件的内容

      这意味着如果尝试在浏览器中请求 127.0.0.1:7878/something-else 也会得到同样的 HTML 响应

      如此其作用是非常有限的，也不是大部分 server 所做的
</pre>
</div>
</div>
</div>

<div id="outline-container-orga79eeee" class="outline-3">
<h3 id="orga79eeee">验证请求并有选择的进行响应</h3>
<div class="outline-text-3" id="text-orga79eeee">
<p>
增加在返回 HTML 文件前检查浏览器是否请求 /，并在其请求任何其他内容时返回错误的功能。新代码接收到的请求的内容与已知的 / 请求的一部分做比较，并增加了 if 和 else 块来区别处理请求：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">handle_connection</span>(<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">stream</span>: <span style="color: #98f5ff;">TcpStream</span>) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">buffer</span> = [0; 512];
    stream.read(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> buffer).unwrap();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">get</span> = b<span style="color: #deb887;">"GET / HTTP/1.1\r\n"</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> buffer.starts_with(get) {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">contents</span> = <span style="color: #ffd700;">fs</span>::read_to_string(<span style="color: #deb887;">"hello.html"</span>).unwrap();

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">response</span> = <span style="color: #f08080;">format!</span>(<span style="color: #deb887;">"HTTP/1.1 200 OK\r\n\r\n</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20854;&#20182;&#35831;&#27714;</span>
    }
}
</pre>
</div>

<ul class="org-ul">
<li>首先，将与 / 请求相关的数据硬编码进变量 get
<ul class="org-ul">
<li>因为将原始字节读取进了缓冲区，所以在 get 的数据开头增加 <span class="underline">b""</span> 字节字符串语法将其转换为 <b>字节字符串</b></li>
</ul></li>
<li>检查 buffer 是否以 get 中的字节开头。如果是，这就是一个格式良好的 / 请求，也就是 if 块中期望处理的成功情况，并会返回 HTML 文件内容的代码</li>
<li>如果 buffer 不 以 get 中的字节开头，就说明接收的是其他请求，之后会在 else 块中增加代码来响应所有其他请求</li>
</ul>

<pre class="example">
     现在如果运行代码并请求 127.0.0.1:7878，就会得到 hello.html 中的 HTML

     如果进行任何其他请求，比如 127.0.0.1:7878/something-else，则会得到像前面运行那样的连接错误
</pre>
<p>
现在向else 块增加代码来返回一个带有 404 状态码的响应，这代表了所请求的内容没有找到。接着也会返回一个 HTML 向浏览器终端用户表明此意：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

} <span style="color: #00bfff; font-weight: bold;">else</span> {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">status_line</span> = <span style="color: #deb887;">"HTTP/1.1 404 NOT FOUND\r\n\r\n"</span>;
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">contents</span> = <span style="color: #ffd700;">fs</span>::read_to_string(<span style="color: #deb887;">"404.html"</span>).unwrap();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">response</span> = <span style="color: #f08080;">format!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}{}</span><span style="color: #deb887;">"</span>, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
} 
</pre>
</div>

<p>
这里，响应的状态行有状态码 404 和原因短语 NOT FOUND。仍然没有返回任何 header，而其 body 将是 404.html 文件中的 HTML。需要在 hello.html 同级目录创建 404.html 文件作为错误页面：
</p>

<div class="org-src-container">
<pre class="src src-html"><span style="color: #deb887;">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color: #daa520; font-weight: bold;">html</span> <span style="color: #4eee94;">lang</span>=<span style="color: #deb887;">"en"</span>&gt;
  &lt;<span style="color: #daa520; font-weight: bold;">head</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">meta</span> <span style="color: #4eee94;">charset</span>=<span style="color: #deb887;">"utf-8"</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;">Hello!</span>&lt;/<span style="color: #daa520; font-weight: bold;">title</span>&gt;
  &lt;/<span style="color: #daa520; font-weight: bold;">head</span>&gt;
  &lt;<span style="color: #daa520; font-weight: bold;">body</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">h1</span>&gt;<span style="font-weight: bold; text-decoration: underline;">Oops!</span>&lt;/<span style="color: #daa520; font-weight: bold;">h1</span>&gt;
    &lt;<span style="color: #daa520; font-weight: bold;">p</span>&gt;Sorry, I don't know what you're asking for.&lt;/<span style="color: #daa520; font-weight: bold;">p</span>&gt;
  &lt;/<span style="color: #daa520; font-weight: bold;">body</span>&gt;
&lt;/<span style="color: #daa520; font-weight: bold;">html</span>&gt;
</pre>
</div>

<pre class="example">
     有了这些修改，再次运行 server。请求 127.0.0.1:7878 应该会返回 hello.html 的内容

     而对于任何其他请求，比如 127.0.0.1:7878/foo，应该会返回 404.html 中的错误 HTML！
</pre>
</div>
</div>
<div id="outline-container-org57e0ef9" class="outline-3">
<h3 id="org57e0ef9">少量代码重构</h3>
<div class="outline-text-3" id="text-org57e0ef9">
<pre class="example">
     目前 if 和 else 块中的代码有很多的重复：他们都读取文件并将其内容写入流。唯一的区别是状态行和文件名

     为了使代码更为简明，将这些区别分别提取到一行 if 和 else 中，对状态行和文件名变量赋值；然后在读取文件和写入响应的代码中无条件的使用这些变量
</pre>
<p>
重构后取代了大段 if 和 else 块代码后的结果如下所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">handle_connection</span>(<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">stream</span>: <span style="color: #98f5ff;">TcpStream</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> (status_line, filename) = <span style="color: #00bfff; font-weight: bold;">if</span> buffer.starts_with(get) {
        (<span style="color: #deb887;">"HTTP/1.1 200 OK\r\n\r\n"</span>, <span style="color: #deb887;">"hello.html"</span>)
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        (<span style="color: #deb887;">"HTTP/1.1 404 NOT FOUND\r\n\r\n"</span>, <span style="color: #deb887;">"404.html"</span>)
    };

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">contents</span> = <span style="color: #ffd700;">fs</span>::read_to_string(filename).unwrap();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">response</span> = <span style="color: #f08080;">format!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}{}</span><span style="color: #deb887;">"</span>, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</pre>
</div>

<ul class="org-ul">
<li>现在 if 和 else 块所做的唯一的事就是在一个元组中返回合适的状态行和文件名的值；接着使用模式的 let 语句通过解构元组的两部分为 filename 和 header 赋值</li>
<li>之前读取文件和写入响应的冗余代码现在位于 if 和 else 块之外，并会使用变量 status_line 和 filename。这样更易于观察这两种情况真正有何不同，还意味着如果需要改变如何读取文件或写入响应时只需要更新一处的代码</li>
</ul>

<pre class="example">
     已经有了一个 40 行左右 Rust 代码的小而简单的 server，它对一个请求返回页面内容而对所有其他请求返回 404 响应

     目前 server 运行于单线程中，它一次只能处理一个请求

     接下来会模拟一些请求来看看这如何会成为一个问题，并进行修复以便 server 可以一次处理多个请求
</pre>
</div>
</div>
</div>


<div id="outline-container-orge6dbd78" class="outline-2">
<h2 id="orge6dbd78">多线程 web server</h2>
<div class="outline-text-2" id="text-orge6dbd78">
<pre class="example">
    目前 server 会依次处理每一个请求，意味着它在完成第一个连接的处理之前不会处理第二个连接

    如果 server 正接收越来越多的请求，这类串行操作会使性能越来越差

    如果一个请求花费很长时间来处理，随后而来的请求则不得不等待这个长请求结束，即便这些新请求可以很快就处理完
</pre>
<p>
需要修复这种情况，不过首先来实际尝试一下这个问题
</p>
</div>

<div id="outline-container-org2bc5dd1" class="outline-3">
<h3 id="org2bc5dd1">在当前 server 实现中模拟慢请求</h3>
<div class="outline-text-3" id="text-org2bc5dd1">
<p>
下面通过模拟慢响应实现了 /sleep 请求处理，它会使 server 在响应之前休眠五秒：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::thread;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">time</span>::<span style="color: #98f5ff;">Duration</span>;
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">handle_connection</span>(<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">stream</span>: <span style="color: #98f5ff;">TcpStream</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">get</span> = b<span style="color: #deb887;">"GET / HTTP/1.1\r\n"</span>;
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">sleep</span> = b<span style="color: #deb887;">"GET /sleep HTTP/1.1\r\n"</span>;

    <span style="color: #00bfff; font-weight: bold;">let</span> (status_line, filename) = <span style="color: #00bfff; font-weight: bold;">if</span> buffer.starts_with(get) {
        (<span style="color: #deb887;">"HTTP/1.1 200 OK\r\n\r\n"</span>, <span style="color: #deb887;">"hello.html"</span>)
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> buffer.starts_with(sleep) {
        <span style="color: #ffd700;">thread</span>::sleep(<span style="color: #98f5ff;">Duration</span>::from_secs(5));
        (<span style="color: #deb887;">"HTTP/1.1 200 OK\r\n\r\n"</span>, <span style="color: #deb887;">"hello.html"</span>)
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        (<span style="color: #deb887;">"HTTP/1.1 404 NOT FOUND\r\n\r\n"</span>, <span style="color: #deb887;">"404.html"</span>)
    };

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
这段代码有些凌乱，不过对于模拟的目的来说已经足够。这里创建了第二个请求 sleep，会识别其数据。在 if 块之后增加了一个 else if 来检查 /sleep 请求，当接收到这个请求时，在渲染成功 HTML 页面之前会先休眠五秒
</p>

<pre class="example">
   现在就可以真切的看出我们的 server 有多么的原始：真实的库将会以更简洁的方式处理多请求识别问题！
</pre>
<p>
使用 cargo run 启动 server，并接着打开两个浏览器窗口：一个请求 <a href="http://127.0.0.1:7878/">http://127.0.0.1:7878/</a> 而另一个请求 <a href="http://127.0.0.1:7878/sleep">http://127.0.0.1:7878/sleep</a> 。如果像之前一样多次请求 /，会发现响应的比较快速。不过如果请求 /sleep 之后在请求 /，就会看到 / 会等待直到 sleep 休眠完五秒之后才出现
</p>
<pre class="example">
   这里有多种办法来改变我们的 web server 使其避免所有请求都排在慢请求之后；将要实现的一个便是线程池
</pre>
</div>
</div>

<div id="outline-container-org375b5ca" class="outline-3">
<h3 id="org375b5ca">使用线程池改善吞吐量</h3>
<div class="outline-text-3" id="text-org375b5ca">
<p>
<span class="underline">线程池</span> 是一组 <span class="underline">预先分配</span> 的 <span class="underline">等待</span> 或 <span class="underline">准备</span> <b>处理任务</b> 的 <span class="underline">线程</span> ：
</p>
<ul class="org-ul">
<li>当程序收到一个新任务，线程池中的一个线程会被分配任务，这个线程会离开并处理任务
<ul class="org-ul">
<li>其余的线程则可用于处理在第一个线程处理任务的同时处理其他接收到的任务</li>
</ul></li>
<li>当第一个线程处理完任务时，它会返回空闲线程池中等待处理新任务</li>
<li>线程池允许我们并发处理连接，增加 server 的吞吐量</li>
</ul>

<pre class="example">
     我们会将池中线程限制为较少的数量，以防拒绝服务 Dos 攻击

     如果程序为每一个接收的请求都新建一个线程，某人向 server 发起千万级的请求时会耗尽服务器的资源并导致所有请求的处理都被终止
</pre>

<p>
不同于分配无限的线程，线程池中将有 <b>固定数量</b> 的等待线程：
</p>
<ul class="org-ul">
<li>当新进请求时，将请求发送到线程池中做处理</li>
<li>线程池会维护一个接收请求的队列。每一个线程会从队列中取出一个请求，处理请求，接着向对队列索取另一个请求</li>
<li>通过这种设计，则可以并发处理 N 个请求，其中 N 为线程数</li>
<li>如果每一个线程都在响应慢请求，之后的请求仍然会阻塞队列，不过相比之前增加了能处理的慢请求的数量</li>
</ul>

<pre class="example">
     这个设计仅仅是多种改善 web server 吞吐量的方法之一，其他可供探索的方法有 fork/join 模型和单线程异步 I/O 模型

     如果你对这个主题感兴趣，则可以阅读更多关于其他解决方案的内容并尝试用 Rust 实现他们，对于一个像 Rust 这样的底层语言，所有这些方法都是可能的
</pre>
<p>
在开始之前，先讨论一下线程池应用看起来怎样
</p>

<pre class="example">
     当尝试设计代码时，首先编写客户端接口确实有助于指导代码设计。以期望的调用方式来构建 API 代码的结构，接着在这个结构之内实现功能，而不是先实现功能再设计公有 API

     类似于前面使用的“测试驱动开发”。这里将要使用“编译器驱动开发”：将编写调用所期望的函数的代码，接着观察编译器错误告诉接下来需要修改什么使得代码可以工作
</pre>
</div>

<div id="outline-container-org3392293" class="outline-4">
<h4 id="org3392293">为每一个请求分配线程的代码结构</h4>
<div class="outline-text-4" id="text-org3392293">
<p>
首先，探索一下为每一个连接都创建一个线程的代码看起来如何
</p>

<pre class="example">
    这并不是最终方案，因为正如之前讲到的它会潜在的分配无限的线程，不过这是一个开始
</pre>

<p>
下面展示了 main 的改变，它在 for 循环中为每一个流分配了一个新线程进行处理：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">listener</span> = <span style="color: #98f5ff;">TcpListener</span>::bind(<span style="color: #deb887;">"127.0.0.1:7878"</span>).unwrap();

    <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">stream</span> <span style="color: #00bfff; font-weight: bold;">in</span> listener.incoming() {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">stream</span> = stream.unwrap();

        <span style="color: #ffd700;">thread</span>::spawn(|| {
            handle_connection(stream);
        });
    }
}
</pre>
</div>

<pre class="example">
      正如前面讲到的，thread::spawn 会创建一个新线程并在其中运行闭包中的代码

      如果运行这段代码并在在浏览器中加载 /sleep，接着在另两个浏览器标签页中加载 /，确实会发现 / 请求不必等待 /sleep 结束

      不过正如之前提到的，这最终会使系统崩溃因为无限制的创建新线程
</pre>
</div>
</div>

<div id="outline-container-orgf826ac6" class="outline-4">
<h4 id="orgf826ac6">为有限数量的线程创建一个类似的接口</h4>
<div class="outline-text-4" id="text-orgf826ac6">
<p>
现在期望线程池以类似且熟悉的方式工作，以便从线程切换到线程池并不会对使用该 API 的代码做出较大的修改。下面展示了希望用来替换 thread::spawn 的 ThreadPool 结构体的假想接口：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">listener</span> = <span style="color: #98f5ff;">TcpListener</span>::bind(<span style="color: #deb887;">"127.0.0.1:7878"</span>).unwrap();
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">pool</span> = <span style="color: #98f5ff;">ThreadPool</span>::new(4);

    <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">stream</span> <span style="color: #00bfff; font-weight: bold;">in</span> listener.incoming() {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">stream</span> = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
</pre>
</div>
<ul class="org-ul">
<li>使用 <span class="underline">ThreadPool::new</span> 来 <b>创建</b> 一个 <span class="underline">新的线程池</span> ，它有一个可配置的线程数的参数，在这里是4</li>
<li>在 for 循环中， <span class="underline">pool.execute</span> 有着类似 thread::spawn 的接口，它获取一个线程池运行于每一个流的闭包
<ul class="org-ul">
<li>pool.execute 需要实现为获取闭包并传递给池中的线程运行</li>
</ul></li>
</ul>

<pre class="example">
    这段代码还不能编译，不过通过尝试编译器会指导我们如何修复它
</pre>
</div>
</div>

<div id="outline-container-org0ca44a9" class="outline-4">
<h4 id="org0ca44a9">构建 ThreadPool 结构体</h4>
<div class="outline-text-4" id="text-org0ca44a9">
<p>
利用来自 cargo check 的编译器错误来驱动开发。下面是得到的第一个错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module <span style="color: #fa8072;">`ThreadPool`</span>
  --&gt; src\main.rs:10:16
   |
10 |     <span style="color: #f08080;">let</span> pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   <span style="color: #fa8072;">`ThreadPool`</span>

error: aborting due to previous error
</pre>
</div>

<pre class="example">
    好的，这告诉我们需要一个 ThreadPool 类型或模块，所以将构建一个
</pre>
<p>
ThreadPool 的实现会与 web server 的特定工作相独立，所以从 hello crate 切换到存放 ThreadPool 实现的新库 crate
</p>
<pre class="example">
    这也意味着可以在任何工作中使用这个单独的线程池库，而不仅仅是处理网络请求
</pre>
<p>
创建 src/lib.rs 文件，它包含了目前可用的最简单的 ThreadPool 定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ThreadPool</span>;
</pre>
</div>

<p>
接着创建一个新目录 <span class="underline">src/bin</span> ，并将二进制 crate 根文件从 <span class="underline">src/main.rs</span> 移动到 <span class="underline">src/bin/main.rs</span> 
</p>
<pre class="example">
      这使得库 crate 成为 hello 目录的主要 crate

      不过仍然可以使用 cargo run 运行 src/bin/main.rs 二进制文件
</pre>

<p>
移动了 main.rs 文件之后，修改 src/bin/main.rs 文件开头加入如下代码来引入库 crate 并将 ThreadPool 引入作用域：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">hello</span>::<span style="color: #98f5ff;">ThreadPool</span>;
</pre>
</div>

<p>
这仍然不能工作，再次尝试运行来得到下一个需要解决的错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no <span style="color: #00bfff; font-weight: bold;">function</span> <span style="color: #daa520; font-weight: bold;">or</span> associated item named <span style="color: #fa8072;">`new`</span> found for type
<span style="color: #fa8072;">`hello::ThreadPool`</span> <span style="color: #00bfff; font-weight: bold;">in</span> the current scope
 --&gt; src/bin/main.rs:13:16
   |
13 |     <span style="color: #f08080;">let</span> pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ <span style="color: #00bfff; font-weight: bold;">function</span> <span style="color: #daa520; font-weight: bold;">or</span> associated item not found<span style="color: #00bfff; font-weight: bold;"> in</span>
   <span style="color: #fa8072;">`hello::ThreadPool`</span>
</pre>
</div>

<pre class="example">
    这告诉我们下一步是为 ThreadPool 创建一个叫做 new 的关联函数
</pre>
<p>
我们知道 new 需要有一个参数可以接受 4，而且 new 应该返回 ThreadPool 实例。实现拥有此特征的最小化 new 函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ThreadPool</span>;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #98f5ff;">ThreadPool</span>
    }
}
</pre>
</div>

<pre class="example">
      这里选择 usize 作为 size 参数的类型，因为负的线程数没有意义
</pre>

<p>
再次编译检查这段代码：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: <span style="color: #fa8072;">`size`</span>
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">[warn(unused_variables)] on by default</span>
  = note: to avoid this warning, consider using <span style="color: #fa8072;">`_size`</span> instead

error[E0599]: no method named <span style="color: #fa8072;">`execute`</span> found for type <span style="color: #fa8072;">`hello::ThreadPool`</span> <span style="color: #00bfff; font-weight: bold;">in</span> the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</pre>
</div>

<pre class="example">
      现在有了一个警告和一个错误，暂时先忽略警告，发生错误是因为并没有 ThreadPool 上的 execute 方法

      这个方法应该有与 thread::spawn 类似的接口，同时将实现 execute 函数来获取传递的闭包并将其传递给池中的空闲线程执行

      回忆前面关于 “使用带有泛型和 Fn trait 的闭包” 部分，闭包作为参数时可以使用三个不同的 trait：Fn、FnMut 和 FnOnce，我们需要决定这里应该使用哪种闭包。
</pre>

<p>
最终需要实现的类似于标准库的 thread::spawn，所以先来观察 thread::spawn 的签名在其参数中使用了何种 bound。查看文档会发现：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">spawn</span>&lt;<span style="color: #98f5ff;">F</span>, <span style="color: #98f5ff;">T</span>&gt;(<span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">F</span>) -&gt; <span style="color: #98f5ff;">JoinHandl</span>`e&lt;<span style="color: #98f5ff;">T</span>&gt;
    <span style="color: #00bfff; font-weight: bold;">where</span>
        <span style="color: #4eee94;">F</span>: <span style="color: #98f5ff;">FnOnce</span>() -&gt; <span style="color: #98f5ff;">T</span> + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>,
        <span style="color: #4eee94;">T</span>: <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>
</pre>
</div>

<pre class="example">
F 是这里我们关心的参数；T 与返回值有关所以并不关心

考虑到 spawn 使用 FnOnce 作为 F 的 trait bound，这可能也是我们需要的，因为最终会将传递给 execute 的参数传给 spawn。因为处理请求的线程只会执行闭包一次，这也进一步确认了 FnOnce 是我们需要的 trait，这里符合 FnOnce 中 Once 的意思

F 还有 trait bound Send 和生命周期绑定 'static，这对我们的情况也是有意义的：需要 Send 来将闭包从一个线程转移到另一个线程，而 'static 是因为并不知道线程会执行多久

</pre>

<p>
现在可以定义一个使用带有这些 bound 的泛型参数 F 的 ThreadPool 的 execute 方法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">execute</span>&lt;<span style="color: #98f5ff;">F</span>&gt;(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">F</span>)
        <span style="color: #00bfff; font-weight: bold;">where</span>
            <span style="color: #4eee94;">F</span>: <span style="color: #98f5ff;">FnOnce</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>
    {

    }
}
</pre>
</div>

<pre class="example">
FnOnce trait 仍然需要之后的 ()，因为这里的 FnOnce 代表一个没有参数也没有返回值的闭包

正如函数的定义，返回值类型可以从签名中省略，不过即便没有参数也需要括号

这里再一次增加了 execute 方法的最小化实现：它没有做任何工作，只是尝试让代码能够编译
</pre>
<p>
再次进行检查：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: <span style="color: #fa8072;">`size`</span>
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">[warn(unused_variables)] on by default</span>
  = note: to avoid this warning, consider using <span style="color: #fa8072;">`_size`</span> instead

warning: unused variable: <span style="color: #fa8072;">`f`</span>
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using <span style="color: #fa8072;">`_f`</span> instead

</pre>
</div>

<p>
现在就只有警告了，这意味着能够编译了！
</p>

<pre class="example">
      注意：如果尝试 cargo run 运行程序并在浏览器中发起请求，仍会在浏览器中出现在本章开始时“连接重置”的错误，因为这个库实际上还没有调用传递给 execute 的闭包！

      一个你可能听说过的关于像 Haskell 和 Rust 这样有严格编译器的语言的说法是 “如果代码能够编译，它就能工作”

      这是一个提醒大家的好时机，实际上这并不是普适的。我们的项目可以编译，不过它完全没有做任何工作！

      如果构建一个真实且功能完整的项目，则需花费大量的时间来开始编写单元测试来检查代码能否编译“并且”拥有期望的行为
</pre>
</div>
</div>

<div id="outline-container-org838d9aa" class="outline-4">
<h4 id="org838d9aa">在 new 中验证池中线程数量</h4>
<div class="outline-text-4" id="text-org838d9aa">
<pre class="example">
      这里仍然存在警告是因为其并没有对 new 和 execute 的参数做任何操作。现在用期望的行为来实现这些函数

      以考虑 new 作为开始。之前选择使用无符号类型作为 size 参数的类型，因为线程数为负的线程池没有意义。然而，线程数为零的线程池同样没有意义，不过零是一个完全有效的 u32 值
</pre>

<p>
增加在返回 ThreadPool 实例之前检查 size 是否大于零的代码，并使用 assert! 宏在得到零时 panic：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #ffebcd;">/// &#21019;&#24314;&#32447;&#31243;&#27744;&#12290;</span>
    <span style="color: #ffebcd;">///</span>
    <span style="color: #ffebcd;">/// &#32447;&#31243;&#27744;&#20013;&#32447;&#31243;&#30340;&#25968;&#37327;&#12290;</span>
    <span style="color: #ffebcd;">///</span>
    <span style="color: #ffebcd;">/// # Panics</span>
    <span style="color: #ffebcd;">///</span>
    <span style="color: #ffebcd;">/// `new` &#20989;&#25968;&#22312; size &#20026; 0 &#26102;&#20250; panic&#12290;</span>
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #ffd700;">assert!</span>(size &gt; 0);

        <span style="color: #98f5ff;">ThreadPool</span>
    }

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<pre class="example">
      这里用文档注释为 ThreadPool 增加了一些文档

      注意：这里遵循了良好的文档实践并增加了一个部分来提示函数会 panic 的情况

      正如以前所讨论过的：尝试运行 cargo doc --open 并点击 ThreadPool 结构体来查看生成的 new 的文档看起来如何！
</pre>

<p>
相比像这里使用 assert! 宏，也可以让 new 像之前 I/O 项目中 Config::new 那样返回一个 Result：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">ThreadPool</span>, <span style="color: #98f5ff;">PoolCreationError</span>&gt; {
</pre>
</div>

<pre class="example">
      在这里选择创建一个没有任何线程的线程池，被认为是不可恢复的错误
</pre>
</div>
</div>

<div id="outline-container-org9384025" class="outline-4">
<h4 id="org9384025">分配空间以储存线程</h4>
<div class="outline-text-4" id="text-org9384025">
<p>
现在有了一个有效的线程池线程数，就可以实际创建这些线程并在返回之前将他们储存在 ThreadPool 结构体中。不过如何 “储存” 一个线程？再看看 thread::spawn 的签名：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">spawn</span>&lt;<span style="color: #98f5ff;">F</span>, <span style="color: #98f5ff;">T</span>&gt;(<span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">F</span>) -&gt; <span style="color: #98f5ff;">JoinHandle</span>&lt;<span style="color: #98f5ff;">T</span>&gt;
    <span style="color: #00bfff; font-weight: bold;">where</span>
        <span style="color: #4eee94;">F</span>: <span style="color: #98f5ff;">FnOnce</span>() -&gt; <span style="color: #98f5ff;">T</span> + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>,
        <span style="color: #4eee94;">T</span>: <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>
</pre>
</div>

<pre class="example">
spawn 返回 JoinHandle&lt;T&gt;，其中 T 是闭包返回的类型，尝试使用 JoinHandle 来看看会发生什么

在我们的情况中，传递给线程池的闭包会处理连接并不返回任何值，所以 T 将会是单元类型 ()
</pre>

<p>
现在改变了 ThreadPool 的定义来存放一个 thread::JoinHandle&lt;()&gt; 的 vector 实例，使用 size 容量来初始化，并设置一个 for 循环了来运行创建线程的代码，并返回包含这些线程的 ThreadPool 实例：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::thread;

<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #4eee94;">threads</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #ffd700;">thread</span>::<span style="color: #98f5ff;">JoinHandle</span>&lt;()&gt;&gt;,
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #ffd700;">assert!</span>(size &gt; 0);

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">threads</span> = <span style="color: #98f5ff;">Vec</span>::with_capacity(size);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">_</span> <span style="color: #00bfff; font-weight: bold;">in</span> 0..size {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">create some threads and store them in the vector</span>
        }

        <span style="color: #98f5ff;">ThreadPool</span> {
            threads
        }
    }

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<ul class="org-ul">
<li>将 std::thread 引入库 crate 的作用域，因为使用了 thread::JoinHandle 作为 ThreadPool 中 vector 元素的类型</li>
<li>在得到了有效的数量之后，ThreadPool 新建一个存放 size 个元素的 vector</li>
</ul>

<pre class="example">
      这里使用 with_capacity，它与 Vec::new 做了同样的工作，不过有一个重要的区别：它为 vector 预先分配空间

      已经知道了 vector 中需要 size 个元素，预先进行分配比仅仅 Vec::new 要稍微有效率一些，因为 Vec::new 随着插入元素而重新改变大小
</pre>

<p>
如果再次运行 cargo check，会看到一些警告，不过应该可以编译成功
</p>
</div>
</div>

<div id="outline-container-orge7f4b8e" class="outline-4">
<h4 id="orge7f4b8e">Worker 结构体：负责从 ThreadPool 中将代码传递给线程</h4>
<div class="outline-text-4" id="text-orge7f4b8e">
<pre class="example">
      前面 for 循环中留下了一个关于创建线程的注释。如何实际创建线程呢？这是一个难题

      标准库提供的创建线程的方法，thread::spawn，它期望获取一些一旦创建线程就应该执行的代码。然而，我们希望开始线程并使其等待稍后传递的代码

      标准库的线程实现并没有包含这么做的方法：我们必须自己实现
</pre>

<p>
将要实现的行为是创建线程并稍后发送代码，这会在 ThreadPool 和线程间引入一个新数据类型来管理这种新行为。这个数据结构称为 <span class="underline">Worker</span> 
</p>

<pre class="example">
      这是一个池实现中的常见概念

      想象一下在餐馆厨房工作的员工：员工等待来自客户的订单，他们负责接受这些订单并完成它们
</pre>
<p>
不同于在线程池中储存一个 JoinHandle&lt;()&gt; 实例的 vector，会储存 <span class="underline">Worker 结构体</span> 的实例：
</p>
<ul class="org-ul">
<li>每一个 Worker 会储存一个单独的 JoinHandle&lt;()&gt; 实例</li>
<li>接着会在 Worker 上实现一个方法，它会获取需要允许代码的闭包并将其发送给已经运行的线程执行</li>
<li>还会赋予每一个 worker id，这样就可以在日志和调试中区别线程池中的不同 worker</li>
</ul>

<p>
首先，做出如此创建 ThreadPool 时所需的修改。在通过如下方式设置完 Worker 之后，会实现向线程发送闭包的代码：
</p>
<ol class="org-ol">
<li><b>定义</b> <span class="underline">Worker 结构体</span> ：存放 <span class="underline">id</span> 和 <span class="underline">JoinHandle&lt;()&gt;</span></li>
<li><b>修改</b> ThreadPool： 存放一个 <span class="underline">Worker 实例</span> 的 <span class="underline">vector</span></li>
<li><b>定义</b> <span class="underline">Worker::new</span> 函数： <b>获取</b> 一个 <span class="underline">id 数字</span> 并 <b>返回</b> 一个带有 <span class="underline">id</span> 和用 <span class="underline">空闭包</span> 分配的线程的 <b>Worker 实例</b></li>
<li>在 <span class="underline">ThreadPool::new</span> 中：使用 for 循环计数生成 id，使用这个 id 新建 Worker，并储存进 vector 中</li>
</ol>


<p>
示例代码如下：
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::thread;

<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #4eee94;">workers</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">Worker</span>&gt;,
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #ffd700;">assert!</span>(size &gt; 0);

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">workers</span> = <span style="color: #98f5ff;">Vec</span>::with_capacity(size);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">id</span> <span style="color: #00bfff; font-weight: bold;">in</span> 0..size {
            workers.push(<span style="color: #98f5ff;">Worker</span>::new(id));
        }

        <span style="color: #98f5ff;">ThreadPool</span> {
            workers
        }
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>,
    <span style="color: #4eee94;">thread</span>: <span style="color: #ffd700;">thread</span>::<span style="color: #98f5ff;">JoinHandle</span>&lt;()&gt;,
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">Worker</span> {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">thread</span> = <span style="color: #ffd700;">thread</span>::spawn(|| {});

        <span style="color: #98f5ff;">Worker</span> {
            id,
            thread,
        }
    }
}
</pre>
</div>

<ul class="org-ul">
<li>这里将 ThreadPool 中字段名从 threads 改为 workers，因为它现在储存 Worker 而不是 JoinHandle&lt;()&gt;</li>
<li>使用 for 循环中的计数作为 Worker::new 的参数，并将每一个新建的 Worker 储存在叫做 workers 的 vector 中</li>
<li>Worker 结构体和其 new 函数是私有的，因为外部代码（比如 src/bin/main.rs 中的 server）并不需要知道关于 ThreadPool 中使用 Worker 结构体的实现细节</li>
<li>Worker::new 函数使用 id 参数并储存了使用一个 <span class="underline">空闭包</span> 创建的 JoinHandle&lt;()&gt;。</li>
</ul>

<pre class="example">
      这段代码能够编译并用指定给 ThreadPool::new 的参数创建储存了一系列的 Worker 实例，不过 仍然 没有处理 execute 中得到的闭包
</pre>
</div>
</div>
<div id="outline-container-orged81a00" class="outline-4">
<h4 id="orged81a00">使用通道向线程发送请求</h4>
<div class="outline-text-4" id="text-orged81a00">
<pre class="example">
      下一个需要解决的问题是传递给 thread::spawn 的闭包完全没有做任何工作

      目前，在 execute 方法中获得期望执行的闭包，不过在创建 ThreadPool 的过程中创建每一个 Worker 时需要向 thread::spawn 传递一个闭包

      我们希望刚创建的 Worker 结构体能够从 ThreadPool 的队列中获取需要执行的代码，并发送到线程中执行他们
</pre>


<p>
已经学习了 <span class="underline">通道</span> ：一个沟通两个线程的简单手段。这里通道将充当任务队列的作用，execute 将通过 ThreadPool 向其中线程正在寻找工作的 Worker 实例发送任务。如下是这个计划：
</p>
<ol class="org-ol">
<li><span class="underline">ThreadPool</span> 会 <b>创建</b> 一个 <span class="underline">通道</span> 并充当 <b>发送端</b></li>
<li>每个 <span class="underline">Worker</span> 将会充当 <span class="underline">通道</span> 的 <b>接收端</b></li>
<li>新建一个 <span class="underline">Job 结构体</span> 来 <b>存放</b> 用于向 <span class="underline">通道</span> 中 <b>发送的闭包</b></li>
<li><span class="underline">execute</span> 方法会在 <span class="underline">通道发送端</span> <b>发出</b> <span class="underline">期望执行的任务</span></li>
<li>在线程中， <span class="underline">Worker</span> 会 <b>遍历</b> <span class="underline">通道的接收端</span> 并 <b>执行</b> 任何 <span class="underline">接收到的任务</span></li>
</ol>

<p>
在 ThreadPool::new 中创建通道并让 ThreadPool 实例充当发送端开始，而Job 是将在通道中发出的类型，目前它是一个没有任何内容的结构体：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">sync</span>::mpsc;

<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #4eee94;">workers</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">Worker</span>&gt;,
    <span style="color: #4eee94;">sender</span>: <span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Sender</span>&lt;<span style="color: #98f5ff;">Job</span>&gt;,
}

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Job</span>;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #ffd700;">assert!</span>(size &gt; 0);

        <span style="color: #00bfff; font-weight: bold;">let</span> (sender, receiver) = <span style="color: #ffd700;">mpsc</span>::channel();

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">workers</span> = <span style="color: #98f5ff;">Vec</span>::with_capacity(size);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">id</span> <span style="color: #00bfff; font-weight: bold;">in</span> 0..size {
            workers.push(<span style="color: #98f5ff;">Worker</span>::new(id));
        }

        <span style="color: #98f5ff;">ThreadPool</span> {
            workers,
            sender,
        }
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<pre class="example">
      在 ThreadPool::new 中，新建了一个通道，并接着让线程池在接收端等待

      这段代码能够编译，不过仍有警告
</pre>

<p>
尝试在线程池 <span class="underline">创建</span> 每个 <span class="underline">worker</span> 时将 <span class="underline">通道的接收端</span> <b>传递</b> 给他们，所以将在闭包中引用 <span class="underline">receiver</span> 参数：
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #ffd700;">assert!</span>(size &gt; 0);

        <span style="color: #00bfff; font-weight: bold;">let</span> (sender, receiver) = <span style="color: #ffd700;">mpsc</span>::channel();

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">workers</span> = <span style="color: #98f5ff;">Vec</span>::with_capacity(size);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">id</span> <span style="color: #00bfff; font-weight: bold;">in</span> 0..size {
            workers.push(<span style="color: #98f5ff;">Worker</span>::new(id, receiver));
        }

        <span style="color: #98f5ff;">ThreadPool</span> {
            workers,
            sender,
        }
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>, <span style="color: #4eee94;">receiver</span>: <span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Receiver</span>&lt;<span style="color: #98f5ff;">Job</span>&gt;) -&gt; <span style="color: #98f5ff;">Worker</span> {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">thread</span> = <span style="color: #ffd700;">thread</span>::spawn(|| {
            receiver;
        });

        <span style="color: #98f5ff;">Worker</span> {
            id,
            thread,
        }
    }
}
</pre>
</div>

<pre class="example">
    这是一些小而直观的修改：将通道的接收端传递进了 Worker::new，并接着在闭包中使用它
</pre>
<p>
如果尝试 check 代码，会得到这个错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: <span style="color: #fa8072;">`receiver`</span>
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here<span style="color: #00bfff; font-weight: bold;"> in</span>
   previous iteration of loop
   |
   = note: move occurs because <span style="color: #fa8072;">`receiver`</span> has type
   <span style="color: #fa8072;">`std::sync::mpsc::Receiver&lt;Job&gt;`</span>, which does not implement the <span style="color: #fa8072;">`Copy`</span> trait
</pre>
</div>

<pre class="example">
这段代码尝试将 receiver 传递给多个 Worker 实例。这是不行的

Rust 所提供的通道实现是”多生产者，单消费者“的。这意味着不能简单的克隆通道的消费端来解决问题

即便可以，那也不是希望使用的技术：我们希望通过在所有的 worker 中共享单一 receiver，在线程间分发任务

另外，从通道队列中取出任务涉及到修改 receiver，所以这些线程需要一个能安全的共享和修改 receiver 的方式，否则可能导致竞争状态
</pre>

<p>
回忆一下曾经讨论的 <b>线程安全</b> <span class="underline">智能指针</span> ，为了在多个线程间共享所有权并允许线程修改其值，需要使用 <span class="underline">Arc&lt;Mutex&lt;T&gt;&gt;</span> ：
</p>
<ul class="org-ul">
<li>Arc 使得多个 worker 拥有接收端</li>
<li>Mutex 则确保一次只有一个 worker 能从接收端得到任务</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">sync</span>::<span style="color: #98f5ff;">Arc</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">sync</span>::<span style="color: #98f5ff;">Mutex</span>;
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">size</span>: <span style="color: #98f5ff;">usize</span>) -&gt; <span style="color: #98f5ff;">ThreadPool</span> {
        <span style="color: #ffd700;">assert!</span>(size &gt; 0);

        <span style="color: #00bfff; font-weight: bold;">let</span> (sender, receiver) = <span style="color: #ffd700;">mpsc</span>::channel();

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">receiver</span> = <span style="color: #98f5ff;">Arc</span>::new(<span style="color: #98f5ff;">Mutex</span>::new(receiver));

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">workers</span> = <span style="color: #98f5ff;">Vec</span>::with_capacity(size);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">id</span> <span style="color: #00bfff; font-weight: bold;">in</span> 0..size {
            workers.push(<span style="color: #98f5ff;">Worker</span>::new(id, <span style="color: #98f5ff;">Arc</span>::clone(&amp;receiver)));
        }

        <span style="color: #98f5ff;">ThreadPool</span> {
            workers,
            sender,
        }
    }

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>, <span style="color: #4eee94;">receiver</span>: <span style="color: #98f5ff;">Arc</span>&lt;<span style="color: #98f5ff;">Mutex</span>&lt;<span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Receiver</span>&lt;<span style="color: #98f5ff;">Job</span>&gt;&gt;&gt;) -&gt; <span style="color: #98f5ff;">Worker</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    }
}
</pre>
</div>

<pre class="example">
      在 ThreadPool::new 中，将通道的接收端放入一个 Arc 和一个 Mutex 中

      对于每一个新 worker，克隆 Arc 来增加引用计数，如此这些 worker 就可以共享接收端的所有权了
</pre>
</div>
</div>

<div id="outline-container-orgf40133c" class="outline-4">
<h4 id="orgf40133c">实现 execute 方法</h4>
<div class="outline-text-4" id="text-orgf40133c">
<p>
最后 <b>实现</b> <span class="underline">ThreadPool</span> 上的 <span class="underline">execute</span> 方法。同时也要修改 Job 结构体：它将不再是结构体，Job 将是一个有着 <span class="underline">execute</span> <b>接收</b> 到的 <span class="underline">闭包类型的 trait 对象</span> 的类型别名。类型别名允许将长的类型变短：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Job</span> = <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">FnOnce</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>&gt;;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">execute</span>&lt;<span style="color: #98f5ff;">F</span>&gt;(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">F</span>)
        <span style="color: #00bfff; font-weight: bold;">where</span>
            <span style="color: #4eee94;">F</span>: <span style="color: #98f5ff;">FnOnce</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>
    {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">Box</span>::new(f);

        <span style="color: #00bfff; font-weight: bold;">self</span>.sender.send(job).unwrap();
    }
}
</pre>
</div>

<p>
在使用 execute 得到的闭包新建 Job 实例之后，将这些任务从通道的发送端发出
</p>
<pre class="example">
      这里调用 send 上的 unwrap，因为发送可能会失败，这可能发生于例如停止了所有线程执行的情况，这意味着接收端停止接收新消息了。不过目前我们无法停止线程执行：只要线程池存在他们就会一直执行

      使用 unwrap 是因为知道失败不可能发生，即便编译器不这么认为
</pre>

<p>
不过到此事情还没有结束！在 worker 中，传递给 thread::spawn 的闭包仍然还只是 <b>引用</b> 了 <span class="underline">通道的接收端</span> 。相反需要闭包一直循环，向通道的接收端请求任务，并在得到任务时执行他们：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>, <span style="color: #4eee94;">receiver</span>: <span style="color: #98f5ff;">Arc</span>&lt;<span style="color: #98f5ff;">Mutex</span>&lt;<span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Receiver</span>&lt;<span style="color: #98f5ff;">Job</span>&gt;&gt;&gt;) -&gt; <span style="color: #98f5ff;">Worker</span> {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">thread</span> = <span style="color: #ffd700;">thread</span>::spawn(<span style="color: #00bfff; font-weight: bold;">move</span> || {
            <span style="color: #00bfff; font-weight: bold;">loop</span> {
                <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">job</span> = receiver.lock().unwrap().recv().unwrap();

                <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> got a job; executing."</span>, id);

                job();
            }
        });

        <span style="color: #98f5ff;">Worker</span> {
            id,
            thread,
        }
    }
}
</pre>
</div>

<ul class="org-ul">
<li>首先在 <span class="underline">receiver</span> 上调用了 <span class="underline">lock</span> 来获取 <b>互斥器</b></li>
<li>unwrap 在出现任何错误时 panic</li>
</ul>
<pre class="example">
      如果互斥器处于一种叫做”被污染“的状态时获取锁可能会失败，这可能发生于其他线程在持有锁时 panic 了且没有释放锁

      在这种情况下，调用 unwrap 使其 panic 是正确的行为

      请随意将 unwrap 改为包含有意义错误信息的 expect
</pre>
<ul class="org-ul">
<li>如果锁定了互斥器，接着调用 <span class="underline">recv</span> 从 <span class="underline">通道</span> 中 <b>接收</b> <span class="underline">Job</span></li>
<li>最后的 <span class="underline">unwrap</span> 也绕过了一些错误</li>
</ul>
<pre class="example">
    这可能发生于持有通道发送端的线程停止的情况，类似于如果接收端关闭时 send 方法如何返回 Err 一样
</pre>

<p>
调用 <span class="underline">recv</span> 会 <b>阻塞</b> <span class="underline">当前线程</span> ，所以如果还没有任务，其会等待直到有可用的任务。 <span class="underline">Mutex&lt;T&gt;</span>  <b>确保</b> <span class="underline">一次只有一个 Worker</span> 线程 <b>尝试</b> <span class="underline">请求任务</span> 。现在可以尝试运行下程序：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: <span style="color: #fa8072;">`workers`</span>
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">[warn(dead_code)] on by default</span>

warning: field is never used: <span style="color: #fa8072;">`id`</span>
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">[warn(dead_code)] on by default</span>

warning: field is never used: <span style="color: #fa8072;">`thread`</span>
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">[warn(dead_code)] on by default</span>

    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.99 secs
     Running <span style="color: #fa8072;">`target/debug/hello`</span>
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</pre>
</div>

<p>
成功了！现在有了一个可以异步执行连接的线程池！它绝不会创建超过四个线程，所以当 server 收到大量请求时系统也不会负担过重。如果请求 /sleep，server 也能够通过另外一个线程处理其他请求
</p>

<pre class="example">
      注意如果同时在多个浏览器窗口打开 /sleep，它们可能会彼此间隔地加载 5 秒，因为一些浏览器处于缓存的原因会顺序执行相同请求的多个实例

      这些限制并不是由于我们的 web server 造成的
</pre>
</div>

<div id="outline-container-orgfd7cf67" class="outline-5">
<h5 id="orgfd7cf67">while let 陷阱</h5>
<div class="outline-text-5" id="text-orgfd7cf67">
<p>
在学习了的 while let 循环之后，可能会好奇为何不能如此编写 worker 线程：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>, <span style="color: #4eee94;">receiver</span>: <span style="color: #98f5ff;">Arc</span>&lt;<span style="color: #98f5ff;">Mutex</span>&lt;<span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Receiver</span>&lt;<span style="color: #98f5ff;">Job</span>&gt;&gt;&gt;) -&gt; <span style="color: #98f5ff;">Worker</span> {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">thread</span> = <span style="color: #ffd700;">thread</span>::spawn(<span style="color: #00bfff; font-weight: bold;">move</span> || {
            <span style="color: #00bfff; font-weight: bold;">while</span> <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #98f5ff;">Ok</span>(job) = receiver.lock().unwrap().recv() {
                <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> got a job; executing."</span>, id);

                job();
            }
        });

        <span style="color: #98f5ff;">Worker</span> {
            id,
            thread,
        }
    }
}
</pre>
</div>

<p>
这段代码可以编译和运行，但是并不会产生所期望的线程行为：一个慢请求仍然会导致其他请求等待执行
</p>

<pre class="example">
       其原因有些微妙：Mutex 结构体没有公有 unlock 方法，因为锁的所有权依赖 lock 方法返回的 LockResult&lt;MutexGuard&lt;T&gt;&gt; 中 MutexGuard&lt;T&gt; 的生命周期，这允许借用检查器在编译时确保绝不会在没有持有锁的情况下访问由 Mutex 守护的资源

       不过如果没有认真的思考 MutexGuard&lt;T&gt; 的生命周期的话，也可能会导致比预期更久的持有锁

       因为 while 表达式中的值在整个块一直处于作用域中，job() 调用的过程中其仍然持有锁，这意味着其他 worker 不能接收任务！！！
</pre>

<p>
相反通过使用 <span class="underline">loop</span> 并在循环块之内而不是之外获取锁和任务，lock 方法返回的 MutexGuard 在 let job 语句结束之后立刻就被丢弃了。这确保了 <span class="underline">recv 调用过程</span> 中 <b>持有锁</b> ，而在 <span class="underline">job() 调用前</span> <b>锁就被释放</b> 了，这就 <b>允许</b> <span class="underline">并发处理多个请求</span> 了
</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org27f875c" class="outline-2">
<h2 id="org27f875c">优雅停机</h2>
<div class="outline-text-2" id="text-org27f875c">
<pre class="example">
    上面的代码如期通过使用线程池异步的响应请求，但有一些警告说 workers、id 和 thread 字段没有直接被使用，这提醒了我们并没有清理所有的内容

    当使用不那么优雅的 ctrl-c 终止主线程时，所有其他线程也会立刻停止，即便它们正处于处理请求的过程中
</pre>

<ol class="org-ol">
<li>现在要为 ThreadPool 实现 <span class="underline">Drop trait</span> 对 <span class="underline">线程池中的每一个线程</span> <b>调用</b> <span class="underline">join</span> ，这样这些线程将会执行完他们的请求</li>
<li>接着会为 ThreadPool 实现一个 <b>告诉</b> <span class="underline">线程</span> 他们应该 <b>停止接收</b> <span class="underline">新请求</span> 并结束的方式</li>
</ol>

<pre class="example">
    为了实践这些代码，修改 server 在优雅停机之前只接受两个请求
</pre>
</div>

<div id="outline-container-org8d3c7f2" class="outline-3">
<h3 id="org8d3c7f2">为 ThreadPool 实现 Drop Trait</h3>
<div class="outline-text-3" id="text-org8d3c7f2">
<p>
当线程池被丢弃时，应该 join 所有线程以确保他们完成其操作。下面展示了 Drop 实现的第一次尝试：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Drop</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">drop</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">worker</span> <span style="color: #00bfff; font-weight: bold;">in</span> &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>.workers {
            <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Shutting down worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</pre>
</div>

<p>
遍历线程池中的每个 workers，使用了 <span class="underline">&amp;mut</span> 因为 <span class="underline">self</span> 本身是一个 <b>可变引用</b> 而且也 <b>需要</b> 能够 <span class="underline">修改</span> worker
</p>
<ul class="org-ul">
<li>对于每一个线程，会打印出说明信息表明此特定 worker 正在关闭</li>
<li>接着在 worker 线程上调用 join
<ul class="org-ul">
<li>如果 join 调用失败，通过 unwrap 使得 panic 并进行不优雅的关闭</li>
</ul></li>
</ul>

<p>
但是尝试编译代码时得到的错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</pre>
</div>

<p>
这告诉我们并不能调用 join，因为 <b>只有</b> 每一个 <span class="underline">worker</span> 的 <span class="underline">可变借用</span> ，而 <span class="underline">join</span> <b>获取</b> 其 <span class="underline">参数的所有权</span>
</p>

<pre class="example">
     为了解决这个问题，需要一个方法将 thread 移动出拥有其所有权的 Worker 实例以便 join 可以消费这个线程

     办法是：如果 Worker 存放的是 Option&lt;thread::JoinHandle&lt;()&gt;，就可以在 Option 上调用 take 方法将值从 Some 成员中移动出来而对 None 成员不做处理

     换句话说，正在运行的 Worker 的 thread 将是 Some 成员值，而当需要清理 worker 时，将 Some 替换为 None，这样 worker 就没有可以运行的线程了
</pre>

<p>
为此需要更新 Worker 的定义为如下：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>,
    <span style="color: #4eee94;">thread</span>: <span style="color: #98f5ff;">Option</span>&lt;<span style="color: #ffd700;">thread</span>::<span style="color: #98f5ff;">JoinHandle</span>&lt;()&gt;&gt;,
}
</pre>
</div>

<p>
现在依靠编译器来找出其他需要修改的地方。check 代码会得到两个错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0599]: no method named <span style="color: #fa8072;">`join`</span> found for type
<span style="color: #fa8072;">`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`</span> <span style="color: #00bfff; font-weight: bold;">in</span> the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum <span style="color: #fa8072;">`std::option::Option`</span>, found struct
   <span style="color: #fa8072;">`std::thread::JoinHandle`</span>
   |             <span style="color: #f08080;">help</span>: try using a variant of the expected type: <span style="color: #fa8072;">`Some(thread)`</span>
   |
   = note: expected type <span style="color: #fa8072;">`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`</span>
              found type <span style="color: #fa8072;">`std::thread::JoinHandle&lt;_&gt;`</span>
</pre>
</div>

<p>
先修复第二个错误，它指向 Worker::new 结尾的代码；当新建 Worker 时需要将 thread 值封装进 Some。做出如下改变以修复问题：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>, <span style="color: #4eee94;">receiver</span>: <span style="color: #98f5ff;">Arc</span>&lt;<span style="color: #98f5ff;">Mutex</span>&lt;<span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Receiver</span>&lt;<span style="color: #98f5ff;">Job</span>&gt;&gt;&gt;) -&gt; <span style="color: #98f5ff;">Worker</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

        <span style="color: #98f5ff;">Worker</span> {
            id,
            <span style="color: #4eee94;">thread</span>: <span style="color: #98f5ff;">Some</span>(thread),
        }
    }
}
</pre>
</div>

<p>
第一个错误位于 Drop 实现中。之前提到过要调用 Option 上的 take 将 thread 移动出 worker。如下改变会修复问题：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Drop</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">drop</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">worker</span> <span style="color: #00bfff; font-weight: bold;">in</span> &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>.workers {
            <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Shutting down worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, worker.id);

            <span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #98f5ff;">Some</span>(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</pre>
</div>

<pre class="example">
Option 上的 take 方法会取出 Some 而留下 None

使用 if let 解构 Some 并得到线程，接着在线程上调用 join

如果 worker 的线程已然是 None，就知道此时这个 worker 已经清理了其线程所以无需做任何操作
</pre>
</div>
</div>

<div id="outline-container-orgeffbb8b" class="outline-3">
<h3 id="orgeffbb8b">向线程发送信号使其停止接收任务</h3>
<div class="outline-text-3" id="text-orgeffbb8b">
<pre class="example">
     有了所有这些修改，代码就能编译且没有任何警告。不过也有坏消息，这些代码还不能以我们期望的方式运行

     问题的关键在于 Worker 中分配的线程所运行的闭包中的逻辑：调用 join 并不会关闭线程，因为他们一直 loop 来寻找任务

     如果采用这个实现来尝试丢弃 ThreadPool ，则主线程会永远阻塞在等待第一个线程结束上
</pre>

<p>
为了修复这个问题，线程既监听是否有 Job 运行也要 <b>监听</b> 一个应该 <span class="underline">停止监听并退出无限循环</span> 的 <b>信号</b> 。所以通道将发送这个枚举的两个成员之一而不是 Job 实例： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">enum</span> <span style="color: #98f5ff;">Message</span> {
    <span style="color: #98f5ff;">NewJob</span>(<span style="color: #98f5ff;">Job</span>),
    <span style="color: #98f5ff;">Terminate</span>,
}
</pre>
</div>

<pre class="example">
Message 枚举要么是存放了线程需要运行的 Job 的 NewJob 成员，要么是会导致线程退出循环并终止的 Terminate 成员
</pre>

<p>
同时需要修改通道来使用 Message 类型值而不是 Job：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #4eee94;">workers</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">Worker</span>&gt;,
    <span style="color: #4eee94;">sender</span>: <span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Sender</span>&lt;<span style="color: #98f5ff;">Message</span>&gt;,
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">execute</span>&lt;<span style="color: #98f5ff;">F</span>&gt;(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">F</span>)
        <span style="color: #00bfff; font-weight: bold;">where</span>
            <span style="color: #4eee94;">F</span>: <span style="color: #98f5ff;">FnOnce</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>
    {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">job</span> = <span style="color: #98f5ff;">Box</span>::new(f);

        <span style="color: #00bfff; font-weight: bold;">self</span>.sender.send(<span style="color: #98f5ff;">Message</span>::<span style="color: #98f5ff;">NewJob</span>(job)).unwrap();
    }
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Worker</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">id</span>: <span style="color: #98f5ff;">usize</span>, <span style="color: #4eee94;">receiver</span>: <span style="color: #98f5ff;">Arc</span>&lt;<span style="color: #98f5ff;">Mutex</span>&lt;<span style="color: #ffd700;">mpsc</span>::<span style="color: #98f5ff;">Receiver</span>&lt;<span style="color: #98f5ff;">Message</span>&gt;&gt;&gt;) -&gt;
        <span style="color: #98f5ff;">Worker</span> {

        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">thread</span> = <span style="color: #ffd700;">thread</span>::spawn(<span style="color: #00bfff; font-weight: bold;">move</span> ||{
            <span style="color: #00bfff; font-weight: bold;">loop</span> {
                <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">message</span> = receiver.lock().unwrap().recv().unwrap();

                <span style="color: #00bfff; font-weight: bold;">match</span> message {
                    <span style="color: #98f5ff;">Message</span>::<span style="color: #98f5ff;">NewJob</span>(job) =&gt; {
                        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> got a job; executing."</span>, id);

                        job();
                    },
                    <span style="color: #98f5ff;">Message</span>::<span style="color: #98f5ff;">Terminate</span> =&gt; {
                        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> was told to terminate."</span>, id);

                        <span style="color: #00bfff; font-weight: bold;">break</span>;
                    },
                }
            }
        });

        <span style="color: #98f5ff;">Worker</span> {
            id,
            <span style="color: #4eee94;">thread</span>: <span style="color: #98f5ff;">Some</span>(thread),
        }
    }
}
</pre>
</div>

<pre class="example">
为了适用 Message 枚举需要将两个地方的 Job 修改为 Message：ThreadPool 的定义和 Worker::new 的签名

ThreadPool 的 execute 方法需要发送封装进 Message::NewJob 成员的任务

然后，在 Worker::new 中当从通道接收 Message 时，当获取到 NewJob成员会处理任务而收到 Terminate 成员则会退出循环
</pre>

<p>
通过这些修改，代码再次能够编译，不过还是会得到一个警告，因为并没有创建任何 Terminate 成员的消息。下面修改 Drop 实现来修复此问题：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Drop</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">ThreadPool</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">drop</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Sending terminate message to all workers."</span>);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">_</span> <span style="color: #00bfff; font-weight: bold;">in</span> &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>.workers {
            <span style="color: #00bfff; font-weight: bold;">self</span>.sender.send(<span style="color: #98f5ff;">Message</span>::<span style="color: #98f5ff;">Terminate</span>).unwrap();
        }

        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Shutting down all workers."</span>);

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">worker</span> <span style="color: #00bfff; font-weight: bold;">in</span> &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>.workers {
            <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Shutting down worker </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, worker.id);

            <span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #98f5ff;">Some</span>(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</pre>
</div>

<p>
现在遍历了 worker 两次：
</p>
<ul class="org-ul">
<li>一次向每个 worker 发送一个 Terminate 消息</li>
<li>一个调用每个 worker 线程上的 join</li>
</ul>

<p>
如果尝试在同一循环中发送消息并立即 join 线程，则无法保证当前迭代的 worker 是从通道收到终止消息的 worker：
</p>
<pre class="example">
       为了更好的理解为什么需要两个分开的循环，想象一下只有两个 worker 的场景

       如果在一个单独的循环中遍历每个 worker，在第一次迭代中向通道发出终止消息并对第一个 worker 线程调用 join。会一直等待第一个 worker 结束，不过它永远也不会结束因为第二个线程接收了终止消息

       死锁！
</pre>

<p>
为了避免此情况，首先在一个循环中向通道发出所有的 Terminate 消息，接着在另一个循环中 join 所有的线程。每个 worker 一旦收到终止消息即会停止从通道接收消息，意味着可以　 <b>确保如果发送同 worker 数相同的终止消息，在 join 之前每个线程都会收到一个终止消息</b> 
</p>
</div>
</div>

<div id="outline-container-org66ec4e0" class="outline-3">
<h3 id="org66ec4e0">最后测试</h3>
<div class="outline-text-3" id="text-org66ec4e0">
<p>
为了实践这些代码，修改 main 在优雅停机 server 之前只接受两个请求：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">listener</span> = <span style="color: #98f5ff;">TcpListener</span>::bind(<span style="color: #deb887;">"127.0.0.1:7878"</span>).unwrap();
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">pool</span> = <span style="color: #98f5ff;">ThreadPool</span>::new(4);

    <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">stream</span> <span style="color: #00bfff; font-weight: bold;">in</span> listener.incoming().take(2) {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">stream</span> = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Shutting down."</span>);
}
</pre>
</div>

<p>
take 方法定义于 Iterator trait，这里限制循环最多头 2 次。ThreadPool 会在 main 的结尾离开作用域，而且还会看到 drop 实现的运行 
</p>

<pre class="example">
     当然不会希望真实世界的 web server 只处理两次请求就停机了，这只是为了展示优雅停机和清理处于正常工作状态
</pre>

<p>
使用 cargo run 启动 server，并发起三个请求。第三个请求应该会失败，而终端的输出应该看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run 
   Compiling hello v0.1.0 (~/Documents/programming/html/klose911.github.io/src/rust/src/web_server/hello)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.52s
     Running <span style="color: #fa8072;">`target/debug/main`</span>
Worker 0 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 2 got a job; executing.
Worker 1 was told to terminate.
Worker 3 was told to terminate.
Worker 0 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Worker 2 was told to terminate.
Shutting down worker 3
</pre>
</div>

<p>
可能会出现不同顺序的 worker 和信息输出。可以从信息中看到服务是如何运行的：
</p>
<ol class="org-ol">
<li>worker 0 和 worker 2 获取了头两个请求</li>
<li>在第三个请求时，我们停止接收连接</li>
<li>当 ThreadPool 在 main 的结尾离开作用域时，其 Drop 实现开始工作，线程池通知所有线程终止</li>
<li>每个 worker 在收到终止消息时会打印出一个信息</li>
<li>接着线程池调用 join 来终止每一个 worker 线程</li>
</ol>

<pre class="example">
     这个特定的运行过程中一个有趣的地方在于： 向通道中发出终止消息，而在任何线程收到消息之前，就尝试 join worker 0 了。而worker 0 还没有收到终止消息，所以主线程阻塞直到 worker 0 结束

     与此同时，每一个线程都收到了终止消息。一旦 worker 0 结束，主线程就等待其他 worker 结束，此时他们都已经收到终止消息并能够停止了
</pre>

<p>
这里还有很多可以做的事！如果希望继续增强这个项目，如下是一些点子：
</p>
<ul class="org-ul">
<li>为 ThreadPool 和其公有方法增加更多文档</li>
<li>为库的功能增加测试</li>
<li>将 unwrap 调用改为更健壮的错误处理</li>
<li>使用 ThreadPool 进行其他不同于处理网络请求的任务</li>
<li>在 crates.io 上寻找一个线程池 crate 并使用它实现一个类似的 web server，将其 API 和鲁棒性与这里的实现做对比　</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8d77012" class="outline-2">
<h2 id="org8d77012">总结</h2>
<div class="outline-text-2" id="text-org8d77012">
<p>
恭喜！现在有了一个使用线程池异步响应请求的基础 web server，并且能对 server 执行优雅停机，它会清理线程池中的所有线程
</p>

<pre class="example">
    终于结束了这次 Rust 之旅，现在已经准备好出发并实现自己的 Rust 项目并帮助他人了

    请不要忘记 Rust 的社区，这里有其他 Rustaceans 正乐于帮助任何人迎接 Rust 之路上的任何挑战
</pre>

<p>
<a href="advanced.html">Previous：高级特性</a>
</p>

<p>
<a href="rust.html">Home: 目录</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
