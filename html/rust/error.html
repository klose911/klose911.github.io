<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>错误处理</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="collection.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">错误处理</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgab4a79c">panic! 与不可恢复的错误</a>
<ul>
<li><a href="#org086a06c">对应 panic 时的栈展开或终止</a></li>
<li><a href="#org2f48b61">panic! 宏</a></li>
<li><a href="#orga785541">使用 panic! 的 backtrace</a></li>
</ul>
</li>
<li><a href="#org6182f37">Result 与可恢复的错误</a>
<ul>
<li><a href="#orgc2493bd">匹配不同的错误</a></li>
<li><a href="#orgf203eef">失败时 panic 的简写：unwrap 和 expect</a></li>
<li><a href="#org74ec4eb">传播错误</a>
<ul>
<li><a href="#orgbd928ef">传播错误的简写：? 运算符</a></li>
<li><a href="#org761547f">? 运算符只可被用于返回 Result 的函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf1b9ec4">panic! 还是不 panic!</a>
<ul>
<li><a href="#org3ad6908">示例、代码原型和测试都非常适合 panic</a></li>
<li><a href="#orge4fd2b3">当我们比编译器知道更多的情况</a></li>
<li><a href="#org643d802">错误处理指导原则</a>
<ul>
<li><a href="#org362e8f3">创建自定义类型进行有效性验证</a></li>
</ul>
</li>
<li><a href="#org7f3eba7">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
Rust 对可靠性的执着也延伸到了错误处理

错误对于软件来说是不可避免的，所以 Rust 有很多特性来处理出现错误的情况

在很多情况下，Rust 要求你承认出错的可能性，并在编译代码之前就采取行动

这些要求使得程序更为健壮，它们确保了你会在将代码部署到生产环境之前就发现错误并正确地处理它们！
</pre>

<p>
Rust 将错误组合成两个主要类别：
</p>
<ul class="org-ul">
<li>可恢复错误：通常代表向 <span class="underline">用户报告</span> 错误和 <span class="underline">重试操作</span> 是合理的情况，比如未找到文件</li>
<li>不可恢复错误：不可恢复错误通常是 <span class="underline">bug</span> 的同义词，比如尝试访问超过数组结尾的位置</li>
</ul>

<pre class="example">
大部分语言并不区分这两类错误，并采用类似异常这样方式统一处理他们

Rust 并没有异常。相反，对于可恢复错误有 Result&lt;T, E&gt; 值，以及 panic!，它在遇到不可恢复错误时停止程序执行

这一章会首先介绍 panic! 调用，接着会讲到如何返回 Result&lt;T, E&gt;，还将探讨决定是尝试从错误中恢复还是停止执行时的注意事项
</pre>
<div id="outline-container-orgab4a79c" class="outline-2">
<h2 id="orgab4a79c">panic! 与不可恢复的错误</h2>
<div class="outline-text-2" id="text-orgab4a79c">
<p>
突然有一天，代码出问题了，而你对此束手无策。对于这种情况，Rust 有 <span class="underline">panic!宏</span> 。当执行这个宏时：
</p>
<ol class="org-ol">
<li>程序会打印出一个错误信息</li>
<li>展开并清理栈数据</li>
<li>退出</li>
</ol>

<pre class="example">
    出现这种情况的场景通常是检测到一些类型的 bug，而且程序员并不清楚该如何处理它
</pre>
</div>
<div id="outline-container-org086a06c" class="outline-3">
<h3 id="org086a06c">对应 panic 时的栈展开或终止</h3>
<div class="outline-text-3" id="text-org086a06c">
<p>
当出现 panic 时，程序默认会开始  <span class="underline">展开</span> ，这意味着 Rust 会 <span class="underline">回溯栈</span> 并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作
</p>

<p>
另一种选择是直接 <span class="underline">终止</span> ，这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理
</p>
<pre class="example">
     如果需要项目的最终二进制文件越小越好，panic 时通过在 Cargo.toml 的 [profile] 部分增加 panic = 'abort'，可以由展开切换为终止
</pre>
<p>
例如，如果想要在release模式中 panic 时直接终止：
</p>

<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98f5ff;">profile.release</span>]
<span style="color: #4eee94;">panic</span> = <span style="color: #deb887;">'abort'</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org2f48b61" class="outline-3">
<h3 id="org2f48b61">panic! 宏</h3>
<div class="outline-text-3" id="text-org2f48b61">
<p>
在一个简单的程序中调用 panic!：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"crash and burn"</span>);
}
</pre>
</div>
<p>
运行程序将会出现类似这样的输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling panic v0.1.0 (/mnt/c/Users/I514692/AppData/Roaming/Documents/programming/html/klose911.github.io/src/rust/src/error_handle/panic)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 2.39s
     Running <span style="color: #fa8072;">`target/debug/panic`</span>
thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'crash and burn'</span>, src/main.rs:2:5
note: run with <span style="color: #fa8072;">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace.
</pre>
</div>

<p>
这里包含 panic! 调用造成的错误信息：
</p>
<ul class="org-ul">
<li>显示了 panic 提供的信息</li>
<li>指明了源码中 panic 出现的位置：src/main.rs:2:5
<ul class="org-ul">
<li>src/main.rs 文件的第二行第五个字符</li>
</ul></li>
</ul>

<pre class="example">
     在这个例子中，被指明的那一行是代码的一部分，而且查看这一行的话就会发现 panic! 宏的调用

     在其他情况下，panic! 可能会出现在我们的代码所调用的代码中。错误信息报告的文件名和行号可能指向别人代码中的 panic! 宏调用，而不是我们代码中最终导致 panic! 的那一行

     这时候可以使用 panic! 被调用的函数的 backtrace 来寻找代码中出问题的地方
</pre>
</div>
</div>
<div id="outline-container-orga785541" class="outline-3">
<h3 id="orga785541">使用 panic! 的 backtrace</h3>
<div class="outline-text-3" id="text-orga785541">
<p>
看看另一个因为我们代码中的 bug 引起的别的库中 panic! 的例子，而不是直接的宏调用。下面是一个尝试通过索引访问 vector 中元素的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">v</span> = <span style="color: #ffd700;">vec!</span>[1, 2, 3];

    v[99];
}
</pre>
</div>

<p>
报错信息如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'index out of bounds: the len is 3 but the index is 99'</span>, /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/slice/mod.rs:2796:10
note: run with <span style="color: #fa8072;">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace.
</pre>
</div>

<pre class="example">
     这指向了一个不是自己编写的文件，libcore/slice/mod.rs。其为 Rust 源码中 slice 的实现

     这是当对 vector v 使用 [] 时 libcore/slice/mod.rs 中会执行的代码，也是真正出现 panic! 的地方
</pre>

<p>
接下来的几行提醒我们可以设置 <span class="underline">RUST_BACKTRACE</span>  环境变量来得到一个 backtrace： 这是一个执行到目前位置所有被调用的函数的列表
</p>

<pre class="example">
Rust 的 backtrace 跟其他语言中的一样：

阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地

这一行往上是你的代码所调用的代码；往下则是调用你的代码的代码

这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码
</pre>
<p>
将 RUST_BACKTRACE 环境变量设置为任何不是 0 的值来获取 backtrace 看看：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ <span style="color: #4eee94;">RUST_BACKTRACE</span>=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.00s
     Running <span style="color: #fa8072;">`target/debug/panic`</span>
thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'index out of bounds: the len is 3 but the index is 99'</span>, libcore/slice/mod.rs:2448:10
stack backtrace:
   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace
             at libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::print
             at libstd/sys_common/backtrace.rs:71
             at libstd/sys_common/backtrace.rs:59
   2: std::panicking::default_hook::{{closure}}
             at libstd/panicking.rs:211
   3: std::panicking::default_hook
             at libstd/panicking.rs:227
   4: &lt;std::panicking::begin_panic::PanicPayload&lt;A&gt; as core::panic::BoxMeUp&gt;::get
             at libstd/panicking.rs:476
   5: std::panicking::continue_panic_fmt
             at libstd/panicking.rs:390
   6: std::panicking::try::do_call
             at libstd/panicking.rs:325
   7: core::ptr::drop_in_place
             at libcore/panicking.rs:77
   8: core::ptr::drop_in_place
             at libcore/panicking.rs:59
   9: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at libcore/slice/mod.rs:2448
  10: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at libcore/slice/mod.rs:2316
  11: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at liballoc/vec.rs:1653
  12: panic::main
             at src/main.rs:4
  13: std::rt::lang_start::{{closure}}
             at libstd/rt.rs:74
  14: std::panicking::try::do_call
             at libstd/rt.rs:59
             at libstd/panicking.rs:310
  15: macho_symbol_search
             at libpanic_unwind/lib.rs:102
  16: std::alloc::default_alloc_error_hook
             at libstd/panicking.rs:289
             at libstd/panic.rs:392
             at libstd/rt.rs:58
  17: std::rt::lang_start
             at libstd/rt.rs:74
  18: panic::main
</pre>
</div>

<p>
这里有大量的输出：
</p>
<ul class="org-ul">
<li>实际看到的输出可能因 <span class="underline">不同的操作系统</span> 和 <span class="underline">Rust 版本</span> 而有所不同</li>
<li>为了获取带有这些信息的 backtrace，必须 <b>启用 debug</b>  标识
<ul class="org-ul">
<li>当 <b>不使用</b>  <span class="underline">&#x2013;release</span> 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用，就像这里一样</li>
</ul></li>
</ul>

<pre class="example">
     输出中，backtrace 的 12 行指向了我们项目中造成问题的行：src/main.rs 的第 4 行

     如果你不希望程序 panic，第一个提到我们编写的代码行的位置是你应该开始调查的，以便查明是什么值如何在这个地方引起了 panic

     在示例中，我们故意编写会 panic 的代码来演示如何使用 backtrace，修复这个 panic 的方法就是不要尝试在一个只包含三个项的 vector 中请求索引是 100 的元素

     当将来你的代码出现了 panic，你需要搞清楚在这特定的场景下代码中执行了什么操作和什么值导致了 panic，以及应当如何处理才能避免这个问题
</pre>
</div>
</div>
</div>
<div id="outline-container-org6182f37" class="outline-2">
<h2 id="org6182f37">Result 与可恢复的错误</h2>
<div class="outline-text-2" id="text-org6182f37">
<pre class="example">
    大部分错误并没有严重到需要程序完全停止执行。有时，一个函数会因为一个容易理解并做出反应的原因失败

    例如，如果因为打开一个并不存在的文件而失败，此时可能想要创建这个文件，而不是终止进程
</pre>

<p>
回忆一下 <span class="underline">Result</span> 枚举，它定义有如下两个成员， <span class="underline">Ok</span> 和 <span class="underline">Err</span> ： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">enum</span> <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">T</span>, <span style="color: #98f5ff;">E</span>&gt; {
    <span style="color: #98f5ff;">Ok</span>(<span style="color: #98f5ff;">T</span>),
    <span style="color: #98f5ff;">Err</span>(<span style="color: #98f5ff;">E</span>),
}
</pre>
</div>

<p>
<span class="underline">T</span> 和 <span class="underline">E</span> 是泛型类型参数；
</p>
<ul class="org-ul">
<li>T : <span class="underline">成功</span> 时返回的 <span class="underline">Ok</span> 成员中的 <span class="underline">数据的类型</span></li>
<li>E : <span class="underline">失败</span> 时返回的 <span class="underline">Err</span> 成员中的 <span class="underline">错误的类型</span></li>
</ul>

<pre class="example">
    因为 Result 有这些泛型类型参数，可以将 Result 类型和标准库中为其定义的函数用于很多不同的场景，这些情况中需要返回的成功值和失败值可能会各不相同
</pre>

<p>
调用一个返回 Result 的函数，因为它可能会失败：如下所示打开一个文件：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span>:<span style="color: #98f5ff;">u32</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>);
}
</pre>
</div>

<p>
试着编译下，会有下面的编译报错：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     <span style="color: #f08080;">let</span> f: u32 = File ::open(<span style="color: #deb887;">"hello.txt"</span>);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
<span style="color: #fa8072;">`std::result::Result`</span>
  |
  = note: expected type <span style="color: #fa8072;">`u32`</span>
             found type <span style="color: #fa8072;">`std::result::Result&lt;std::fs::File, std::io::Error&gt;`</span>
</pre>
</div>

<pre class="example">
这就告诉我们 File ::open 函数的返回值类型是 Result&lt;T, E&gt;

这里泛型参数 T 放入了成功值的类型 std::fs::File，它是一个文件句柄
E 被用在失败值上时 E 的类型是 std::io::Error

</pre>
<p>
这个返回值类型说明 File ::open 调用：
</p>
<ul class="org-ul">
<li>可能会成功并返回一个可以进行读写的文件句柄，变量 f 的值将会是一个包含文件句柄的 Ok 实例</li>
<li>这个函数也可能会失败，f 的值会是一个包含更多关于出现了何种错误信息的 Err 实例。例如：
<ul class="org-ul">
<li>文件可能并不存在</li>
<li>可能没有访问文件的权限</li>
</ul></li>
</ul>

<pre class="example">
File ::open 需要一个方式告诉我们是成功还是失败，并同时提供给我们文件句柄或错误信息

而这些信息正是 Result 枚举可以提供的

</pre>
<p>
根据 File ::open 返回值进行不同处理的逻辑。下面示例展示了一个使用基本工具处理 Result 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #00bfff; font-weight: bold;">match</span> f {
        <span style="color: #98f5ff;">Ok</span>(file) =&gt; file,
        <span style="color: #98f5ff;">Err</span>(error) =&gt; {
            <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"Problem opening the file: {:?}"</span>, error)
        },
    };
}
</pre>
</div>

<pre class="example">
    注意：与 Option 枚举一样，Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::
</pre>

<ul class="org-ul">
<li>当结果是 Ok 时，返回 Ok 成员中的 file 值，然后将这个文件句柄赋值给变量 f。match 之后，可以利用这个文件句柄来进行读写</li>
<li>match 的另一个分支处理从 File ::open 得到 Err 值的情况。在这种情况下，选择调用 panic! 宏。如果当前目录没有一个叫做 hello.txt 的文件，当运行这段代码时会看到如下来自 panic! 宏的输出：</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'Problem opening the file: Error { repr:</span>
<span style="color: #deb887;">Os { code: 2, message: "No such file or directory" } }'</span>, src/main.rs:9:12
</pre>
</div>
</div>
<div id="outline-container-orgc2493bd" class="outline-3">
<h3 id="orgc2493bd">匹配不同的错误</h3>
<div class="outline-text-3" id="text-orgc2493bd">
<pre class="example">
     上面的代码不管 File ::open 是因为什么原因失败都会 panic!

     真正希望的是对不同的错误原因采取不同的行为：
     如果 File ::open因为文件不存在而失败，希望创建这个文件并返回新文件的句柄

     如果 File ::open 因为任何其他原因失败，例如没有打开文件的权限，仍然希望像示例那样 panic!
</pre>

<p>
为 match 增加了另一个分支： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">ErrorKind</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #00bfff; font-weight: bold;">match</span> f {
        <span style="color: #98f5ff;">Ok</span>(file) =&gt; file,
        <span style="color: #98f5ff;">Err</span>(error) =&gt; <span style="color: #00bfff; font-weight: bold;">match</span> error.kind() {
            <span style="color: #98f5ff;">ErrorKind</span>::<span style="color: #98f5ff;">NotFound</span> =&gt; <span style="color: #00bfff; font-weight: bold;">match</span> <span style="color: #98f5ff;">File</span> ::create(<span style="color: #deb887;">"hello.txt"</span>) {
                <span style="color: #98f5ff;">Ok</span>(fc) =&gt; fc,
                <span style="color: #98f5ff;">Err</span>(e) =&gt; <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"Problem creating the file: {:?}"</span>, e),
            },
            other_error =&gt; <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"Problem opening the file: {:?}"</span>, other_error),
        },
    };
}
</pre>
</div>


<p>
File ::open 返回的 Err 成员中的值类型 <span class="underline">io::Error</span> ，它是一个标准库中提供的结构体：这个结构体有一个返回 <span class="underline">io::ErrorKind</span> 值的 <span class="underline">kind</span> 方法可供调用：
</p>
<ul class="org-ul">
<li>io::ErrorKind 是一个标准库提供的枚举，它的成员对应 <span class="underline">io</span> 操作可能导致的不同错误类型：
<ul class="org-ul">
<li>感兴趣的成员是 <span class="underline">ErrorKind::NotFound</span> ，它代表尝试 <b>打开的文件并不存在</b></li>
</ul></li>
</ul>

<pre class="example">
     希望在匹配守卫中检查的条件是 error.kind() 的返回值是 ErrorKind的 NotFound 成员

     如果是，则尝试通过 File ::create 创建文件
     然而因为 File ::create 也可能会失败，还需要增加一个内部 match 语句。当文件不能被打开，会打印出一个不同的错误信息

     外部 match 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic
</pre>

<p>
然而这里有很多的嵌套的 match 操作符，Result&lt;T, E&gt; 有很多接受 <span class="underline">闭包</span> 的方法，并采用 match 表达式实现。一个更老练的 Rustacean 可能会这么写：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">ErrorKind</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>).unwrap_or_else(|error| {
        <span style="color: #00bfff; font-weight: bold;">if</span> error.kind() == <span style="color: #98f5ff;">ErrorKind</span>::<span style="color: #98f5ff;">NotFound</span> {
            <span style="color: #98f5ff;">File</span> ::create(<span style="color: #deb887;">"hello.txt"</span>).unwrap_or_else(|error| {
                <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"Problem creating the file: {:?}"</span>, error);
            })
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
            <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"Problem opening the file: {:?}"</span>, error);
        }
    });
}

</pre>
</div>

<pre class="example">
     虽然这段代码和开始一样的行为，但比大量的 match 表达式且更容易阅读

     在处理错误时，还有很多这类方法可以消除大量嵌套的 match 表达式
</pre>
</div>
</div>

<div id="outline-container-orgf203eef" class="outline-3">
<h3 id="orgf203eef">失败时 panic 的简写：unwrap 和 expect</h3>
<div class="outline-text-3" id="text-orgf203eef">
<pre class="example">
match 能够胜任它的工作，不过它可能有点冗长并且不总是能很好的表明其意图
</pre>

<p>
Result&lt;T, E&gt; 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <span class="underline">unwrap</span> ：
</p>
<ul class="org-ul">
<li>如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值</li>
<li>如果 Result 是成员 Err，unwrap 会调用 panic!</li>
</ul>

<p>
这里是一个实践 unwrap 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>).unwrap();
}
</pre>
</div>

<p>
如果调用这段代码时不存在 hello.txt 文件，将会看到一个 unwrap 调用 panic! 时提供的错误信息：
</p>

<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'called `Result::unwrap()` on an `Err` value: Error {repr: Os { code: 2, message: "No such file or directory" } }'</span>,src/libcore/result.rs:906:4
</pre>
</div>

<p>
另一个类似于 unwrap 的方法 <span class="underline">expect</span> ，它还允许选择 <span class="underline">panic! 的错误信息</span> ： 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>).expect(<span style="color: #deb887;">"Failed to open hello.txt"</span>);
}
</pre>
</div>

<p>
expect 与 unwrap 的使用方式一样：返回文件句柄或调用 panic! 宏。expect 用来调用 panic! 的错误信息将会作为参数传递给 expect ，而不像unwrap 那样使用默认的 panic! 信息。它看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #deb887;">'main'</span> panicked at <span style="color: #deb887;">'Failed to open hello.txt: Error { repr: Os { code:2, message: "No such file or directory" } }'</span>, src/libcore/result.rs:906:4
</pre>
</div>

<pre class="example">
     这个错误信息以指定的文本开始，Failed to open hello.txt，将会更容易找到代码中的错误信息来自何处

     如果在多处使用 unwrap，则需要花更多的时间来分析到底是哪一个 unwrap 造成了 panic，因为所有的 unwrap 调用都打印相同的信息
</pre>
</div>
</div>

<div id="outline-container-org74ec4eb" class="outline-3">
<h3 id="org74ec4eb">传播错误</h3>
<div class="outline-text-3" id="text-org74ec4eb">
<p>
当编写一个实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让 <b>调用者知道这个错误</b> 并 <b>决定该如何处理</b> 。这被称为 <span class="underline">传播</span> 错误
</p>

<pre class="example">
     这样能更好的控制代码调用，因为比起实现代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误
</pre>

<p>
例如，下面的示例展示了一个从文件中读取用户名的函数。如果文件不存在或不能读取，这个函数会将这些错误返回给调用它的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Read</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">read_username_from_file</span>() -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">String</span>, <span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Error</span>&gt; {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">f</span> = <span style="color: #00bfff; font-weight: bold;">match</span> f {
        <span style="color: #98f5ff;">Ok</span>(file) =&gt; file,
        <span style="color: #98f5ff;">Err</span>(e) =&gt; <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #98f5ff;">Err</span>(e),
    };

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::new();

    <span style="color: #00bfff; font-weight: bold;">match</span> f.read_to_string(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s) {
        <span style="color: #98f5ff;">Ok</span>(_) =&gt; <span style="color: #98f5ff;">Ok</span>(s),
        <span style="color: #98f5ff;">Err</span>(e) =&gt; <span style="color: #98f5ff;">Err</span>(e),
    }
}
</pre>
</div>

<p>
这个函数的返回值： <span class="underline">Result&lt;String, io::Error&gt;</span> 。这意味着函数返回一个 <span class="underline">Result&lt;T, E&gt;</span> 类型的值，其中：
</p>
<ul class="org-ul">
<li>T 的具体类型是 String：如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含“从文件中读取到用户名”的 Ok 值</li>
<li>E 的具体类型是 io::Error：如果函数遇到任何错误，函数的调用者会收到一个 Err 值，它储存了一个包含更多这个问题相关信息的 io::Error 实例</li>
</ul>

<pre class="example">
     这里选择 io::Error 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：File ::open 函数和 read_to_string 方法
</pre>

<p>
函数体：
</p>
<ol class="org-ol">
<li>以 File ::open 函数开头</li>
<li>使用 match 处理返回值 Result
<ul class="org-ul">
<li>当 Err 时不再调用 panic!，而是提早返回并将 File ::open 返回的错误值作为函数的错误返回值传递给调用者</li>
<li>如果 File ::open 成功了，将文件句柄储存在变量 f 中并继续</li>
</ul></li>
<li>在变量 s 中创建了一个新 String</li>
<li>调用文件句柄 f 的 read_to_string 方法来将文件的内容读取到 s 中，read_to_string 方法也返回一个 Result 因为它也可能会失败：需要另一个 match 来处理这个 Result：
<ul class="org-ul">
<li>如果 read_to_string 成功了，那么这个函数就成功了，并返回文件中的用户名，它现在位于被封装进 Ok 的 s 中</li>
<li>如果read_to_string 失败了，则像之前处理 File ::open 的返回值的 match 那样返回错误值</li>
<li>并不需要显式的调用 return，因为这是函数的最后一个表达式</li>
</ul></li>
</ol>


<pre class="example">
调用这个函数的代码最终会得到一个包含用户名的 Ok 值，或者一个包含 io::Error 的 Err 值

然而我们无从得知调用者会如何处理这些值。如果他们得到了一个 Err 值，他们可能会选择：
1. panic! 并使程序崩溃
2. 使用一个默认的用户名
3. 从文件之外的地方寻找用户名
，，，

我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法
</pre>

<p>
这种传播错误的模式在 Rust 是如此的常见，以至于 Rust 提供了 <span class="underline">?</span> 问号运算符来使其更易于处理
</p>
</div>

<div id="outline-container-orgbd928ef" class="outline-4">
<h4 id="orgbd928ef">传播错误的简写：? 运算符</h4>
<div class="outline-text-4" id="text-orgbd928ef">
<p>
使用了 <span class="underline">?</span> 运算符来实现上面的功能：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Read</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">read_username_from_file</span>() -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">String</span>, <span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Error</span>&gt; {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>)<span style="color: #f08080; font-weight: bold;">?</span>;
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::new();
    f.read_to_string(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s)<span style="color: #f08080; font-weight: bold;">?</span>;
    <span style="color: #98f5ff;">Ok</span>(s)
}
</pre>
</div>

<p>
Result 值之后的 ? 于上面 match 表达式有着完全相同的工作方式：
</p>
<ul class="org-ul">
<li>如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将 <span class="underline">继续执行</span></li>
<li>如果值是 Err，Err 中的值将作为 <span class="underline">整个函数的返回值</span> ，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者</li>
</ul>


<pre class="example">
上面的示例中：

File ::open 调用结尾的 ? 将会把 Ok 中的值返回给变量 f
如果出现了错误，? 运算符会提早返回整个函数并将一些 Err 值传播给调用者

同理也适用于 read_to_string 调用结尾的 ?
</pre>

<p>
match 表达式与问号运算符所做的有一点不同： ? 运算符所使用的错误值被传递给了 from 函数，收到的错误类型被转换为定义为当前函数返回的错误类型
</p>

<pre class="example">
from 函数定义于标准库的 From trait 中，其用来将错误从一种类型转换为另一种类型

这在当一个函数返回一个错误类型来代表所有可能失败的方式时很有用：
即使其可能会因很多种原因失败。只要每一个错误类型都实现了 from 函数来定义如将其转换为返回的错误类型，? 运算符会自动处理这些转换
</pre>

<p>
? 运算符消除了大量样板代码并使得函数的实现更简单。甚至可以在 ? 之后直接使用 <span class="underline">链式</span> 方法调用来进一步缩短代码，如下所示： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Read</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">read_username_from_file</span>() -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">String</span>, <span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Error</span>&gt; {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::new();

    <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>)<span style="color: #f08080; font-weight: bold;">?</span>.read_to_string(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s)<span style="color: #f08080; font-weight: bold;">?</span>;

    <span style="color: #98f5ff;">Ok</span>(s)
}
</pre>
</div>

<pre class="example">
      在 s 中创建新的 String 被放到了函数开头；这一部分没有变化

      对 File ::open("hello.txt")? 的结果直接链式调用了 read_to_string，而不再创建变量 f

      当然仍然需要 read_to_string 调用结尾的 ?，而且当 File ::open 和 read_to_string 都成功没有失败时返回包含用户名 s 的 Ok 值

      其功能是一样的，不过这是一个与众不同且更符合工程学的写法
</pre>

<p>
甚至还有一个更短的写法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::io;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fs;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">read_username_from_file</span>() -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">String</span>, <span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Error</span>&gt; {
    <span style="color: #ffd700;">fs</span>::read_to_string(<span style="color: #deb887;">"hello.txt"</span>)
}
</pre>
</div>

<p>
将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 <span class="underline">fs::read_to_string</span> 的函数，它会打开文件、新建一个 String、读取文件的内容，并将内容放入 String，接着返回它
</p>
</div>
</div>

<div id="outline-container-org761547f" class="outline-4">
<h4 id="org761547f">? 运算符只可被用于返回 Result 的函数</h4>
<div class="outline-text-4" id="text-org761547f">
<p>
? 运算符可被用于返回值类型为 Result 的函数，因为他被定义为与示例中的 match 表达式有着完全相同的工作方式。match 的 <span class="underline">return Err(e)</span> 部分要求返回值类型是 <span class="underline">Result</span> ，所以函数的返回值必须是 Result 才能与这个 return 相兼容
</p>

<pre class="example">
    看看在 main 函数中使用 ? 运算符会发生什么?
</pre>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>)<span style="color: #f08080; font-weight: bold;">?</span>;
}
</pre>
</div>

<p>
当编译这些代码，会得到如下错误信息：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0277]: the <span style="color: #fa8072;">`?`</span> operator can only be used<span style="color: #00bfff; font-weight: bold;"> in</span> a <span style="color: #00bfff; font-weight: bold;">function</span> <span style="color: #daa520; font-weight: bold;">that</span> returns <span style="color: #fa8072;">`Result`</span> or <span style="color: #fa8072;">`Option`</span> (or another type that implements <span style="color: #fa8072;">`std:$</span>
<span style="color: #fa8072;">  --&gt; src/main.rs:43:13</span>
<span style="color: #fa8072;">   |</span>
<span style="color: #fa8072;">43 |     let f = File ::open("hello.txt")?;</span>
<span style="color: #fa8072;">   |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `</span>?<span style="color: #fa8072;">` operator in a function that returns `</span>()<span style="color: #fa8072;">`</span>
<span style="color: #fa8072;">   |</span>
<span style="color: #fa8072;">   = help: the trait `</span>std::ops::Try<span style="color: #fa8072;">` is not implemented for `</span>()<span style="color: #fa8072;">`</span>
<span style="color: #fa8072;">   = note: required by `</span>std::ops::Try::from_error<span style="color: #fa8072;">`</span>
</pre>
</div>

<p>
错误指出只能在返回 Result 或者其它实现了 std::ops::Try 的类型的函数中使用 ? 运算符。当期望在不返回 Result 的函数中调用其他返回 Result 的函数时使用 ? 的话，有两种方法修复这个问题：
</p>
<ol class="org-ol">
<li>将函数返回值类型修改为 Result&lt;T, E&gt;，如果没有其它限制阻止你这么做的话</li>
<li>通过合适的方法使用 match 或 Result 的方法之一来处理 Result&lt;T, E&gt;</li>
</ol>

<p>
main 函数是特殊的，其必须返回什么类型是有限制的。main 函数的一个有效的返回值是 ()，另一个有效的返回值是 <span class="underline">Result&lt;T, E&gt;</span> ，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">error</span>::<span style="color: #98f5ff;">Error</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">fs</span>::<span style="color: #98f5ff;">File</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() -&gt; <span style="color: #98f5ff;">Result</span>&lt;(), <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Error</span>&gt;&gt; {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span> = <span style="color: #98f5ff;">File</span> ::open(<span style="color: #deb887;">"hello.txt"</span>)<span style="color: #f08080; font-weight: bold;">?</span>;

    <span style="color: #98f5ff;">Ok</span>(())
}
</pre>
</div>

<pre class="example">
Box&lt;dyn Error&gt; 被称为 “trait 对象”，目前可以理解 Box&lt;dyn Error&gt; 为使用 ? 时 main 允许返回的 “任何类型的错误”
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf1b9ec4" class="outline-2">
<h2 id="orgf1b9ec4">panic! 还是不 panic!</h2>
<div class="outline-text-2" id="text-orgf1b9ec4">
<pre class="example">
  那么，该如何决定何时应该 panic! 以及何时应该返回 Result 呢？
</pre>
<ul class="org-ul">
<li>如果代码 panic，就没有恢复的可能。可以选择对任何错误场景都调用 panic!，不管是否有可能恢复</li>
</ul>
<pre class="example">
    不过这样就是你代替调用者决定了这是不可恢复的
</pre>
<ul class="org-ul">
<li>选择返回 Result 值的话，就将选择权交给了调用者，而不是代替他们做出决定。调用者可能会选择：
+以符合他们场景的方式尝试恢复
<ul class="org-ul">
<li>也可能干脆就认为 Err 是不可恢复的，所以他们也可能会调用 panic! 并将可恢复的错误变成了不可恢复的错误</li>
</ul></li>
</ul>

<pre class="example">
    因此返回 Result 是定义可能会失败的函数的一个好的默认选择
</pre>
</div>

<div id="outline-container-org3ad6908" class="outline-3">
<h3 id="org3ad6908">示例、代码原型和测试都非常适合 panic</h3>
<div class="outline-text-3" id="text-org3ad6908">
<p>
当编写一个 <span class="underline">示例</span> 来展示一些概念时，在拥有健壮的错误处理代码的同时也会使得 <span class="underline">例子不那么明确</span> 
</p>
<pre class="example">
     例如，调用一个类似 unwrap 这样可能 panic! 的方法可以被理解为一个你实际希望程序处理错误方式的占位符，它根据其余代码运行方式可能会各不相同
</pre>

<p>
类似地，在准备好决定如何处理错误之前，unwrap和expect方法在 <span class="underline">原型</span> 设计时非常方便
</p>
<pre class="example">
   当准备好让程序更加健壮时，它们会在代码中留下清晰的标记
</pre>

<p>
如果方法调用在 <span class="underline">测试</span> 中失败了，当然希望这个测试都失败，即便这个方法并不是需要测试的功能
</p>
<pre class="example">
   因为 panic! 是测试如何被标记为失败的，调用 unwrap 或 expect 就是应该发生的事情
</pre>
</div>
</div>

<div id="outline-container-orge4fd2b3" class="outline-3">
<h3 id="orge4fd2b3">当我们比编译器知道更多的情况</h3>
<div class="outline-text-3" id="text-orge4fd2b3">
<p>
当有一些其他的逻辑来确保 Result 会是 Ok 值时，调用 unwrap 也是合适的，虽然编译器无法理解这种逻辑。你仍然需要处理一个 Result 值：即使在你的特定情况下逻辑上是不可能的，你所调用的任何操作仍然有可能失败。如果通过人工检查代码来确保永远也不会出现 Err 值，那么调用 unwrap 也是完全可以接受的，这里是一个例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">net</span>::<span style="color: #98f5ff;">IpAddr</span>;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">home</span>: <span style="color: #98f5ff;">IpAddr</span> = <span style="color: #deb887;">"127.0.0.1"</span>.parse().unwrap();
</pre>
</div>

<pre class="example">
     通过解析一个硬编码的字符来创建一个 IpAddr 实例

     可以看出 127.0.0.1 是一个有效的 IP 地址，所以这里使用 unwrap 是可以接受的

     然而，拥有一个硬编码的有效的字符串也不能改变 parse 方法的返回值类型：它仍然是一个 Result 值，而编译器仍然就好像还是有可能出现 Err 成员，那样要求我们处理 Result，因为编译器还没有智能到可以识别出这个字符串总是一个有效的 IP 地址

     如果 IP 地址字符串来源于用户而不是硬编码进程序中的话，那么就 确实 有失败的可能性，这时就绝对需要我们以一种更健壮的方式处理 Result 了
</pre>
</div>
</div>

<div id="outline-container-org643d802" class="outline-3">
<h3 id="org643d802">错误处理指导原则</h3>
<div class="outline-text-3" id="text-org643d802">
<ul class="org-ul">
<li>在当有可能会导致 <b>有害状态</b> 的情况下建议使用 panic!</li>
</ul>
<pre class="example">
     有害状态是指当一些 假设 、 保证 、 协议 或 不可变性 被打破的状态

     例如无效的值、自相矛盾的值或者被传递了不存在的值 
</pre>
<p>
外加如下几种情况：
</p>
<ul class="org-ul">
<li>有害状态并不包含 <b>预期</b> 会偶尔发生的错误</li>
<li>之后的代码的运行 <b>依赖</b> 于处于这种有害状态</li>
<li>当没有可行的手段来将有害状态信息编码进所使用的类型中的情况</li>

<li>如果 <span class="underline">别人调用你的代码并传递了一个没有意义的值</span> ，最好的情况也许就是 panic! 并警告使用你的库的人他的代码中有 bug 以便他能在开发时就修复它</li>
<li>类似的，panic! 通常适合调用 <span class="underline">不能够控制的外部代码</span> 时，这时无法修复其返回的无效状态</li>
</ul>

<p>
然而当错误预期会出现时，返回 Result 仍要比调用 panic! 更为合适
</p>
<pre class="example">
     这样的例子包括解析器接收到错误数据，或者 HTTP 请求返回一个表明触发了限流的状态

     在这些例子中，应该通过返回 Result 来表明失败预期是可能的，这样将有害状态向上传播，调用者就可以决定该如何处理这个问题

     使用 panic! 来处理这些情况就不是最好的选择
</pre>

<p>
当代码对值进行操作时，应该首先验证值是有效的，并在其无效时 panic!
</p>

<pre class="example">
     这主要是出于安全的原因：尝试操作无效数据会暴露代码漏洞
     这就是标准库在尝试越界访问数组时会 panic! 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全隐患

     函数通常都遵循契约：他们的行为只有在输入满足特定条件时才能得到保证。当违反契约时 panic 是有道理的
     因为这通常代表调用方的 bug，而且这也不是那种你希望调用方必须处理的错误
     事实上也没有合理的方式来恢复调用方的代码：调用方的 程序员 需要修复其代码
     函数的契约，尤其是当违反它会造成 panic 的契约，应该在函数的 API 文档中得到解释
</pre>

<p>
然而在所有函数中都拥有许多错误检查是冗长而烦人的
</p>

<pre class="example">
幸运的是，可以利用 Rust 的类型系统（以及编译器的类型检查）为你进行很多检查

如果函数有一个特定类型的参数，可以在知晓编译器已经确保其拥有一个有效值的前提下进行你的代码逻辑。例如：
1. 如果你使用了一个不同于 Option 的类型，而且程序期望它是 有值 的并且不是 空值。你的代码无需处理 Some 和 None 这两种情况，它只会有一种情况就是绝对会有一个值，尝试向函数传递空值的代码甚至根本不能编译，所以你的函数在运行时没有必要判空
2. 使用像 u32 这样的无符号整型，也会确保它永远不为负
</pre>
</div>

<div id="outline-container-org362e8f3" class="outline-4">
<h4 id="org362e8f3">创建自定义类型进行有效性验证</h4>
<div class="outline-text-4" id="text-org362e8f3">
<p>
可以使用 Rust 类型系统的思想来进一步确保值的有效性，并尝试创建一个自定义类型以进行验证
</p>
<pre class="example">
      回忆一下开始的猜猜看游戏，代码要求用户猜测一个 1 到 100 之间的数字，在将其与秘密数字做比较之前我们从未验证用户的猜测是位于这两个数字之间的

      当时只是只验证它是否为正。在这种情况下，其影响并不是很严重：“Too high” 或 “Too low” 的输出仍然是正确的

      但是这是一个很好的引导用户得出有效猜测的辅助，例如当用户猜测一个超出范围的数字或者输入字母时采取不同的行为
</pre>

<p>
一种实现方式是将猜测解析成 i32 而不仅仅是 u32，来默许输入负数，接着检查数字是否在范围内：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">loop</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">guess</span>: <span style="color: #98f5ff;">i32</span> = <span style="color: #00bfff; font-weight: bold;">match</span> guess.trim().parse() {
        <span style="color: #98f5ff;">Ok</span>(num) =&gt; num,
        <span style="color: #98f5ff;">Err</span>(_) =&gt; <span style="color: #00bfff; font-weight: bold;">continue</span>,
    };

    <span style="color: #00bfff; font-weight: bold;">if</span> guess &lt; 1 || guess &gt; 100 {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"The secret number will be between 1 and 100."</span>);
        <span style="color: #00bfff; font-weight: bold;">continue</span>;
    }

    <span style="color: #00bfff; font-weight: bold;">match</span> guess.cmp(&amp;secret_number) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
if 表达式检查了值是否超出范围，告诉用户出了什么问题，并调用 continue 开始下一次循环，请求另一个猜测if 表达式之后，就可以在知道 guess 在 1 到 100 之间的情况下与秘密数字作比较了
</p>
<pre class="example">
      然而，这并不是一个理想的解决方案：

      程序只处理 1 到 100 之间的值是绝对不可取的，而且如果有很多函数都有这样的要求

      在每个函数中都有这样的检查将是非常冗余的（并可能潜在的影响性能）
</pre>

<p>
可以创建一个 <span class="underline">新类型</span> 来将 <b>验证</b> 放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全的在函数签名中使用新类型并相信他们接收到的值。下面示例展示了一个定义 <span class="underline">Guess 类型</span> 的方法，只有在 new 函数接收到 1 到 100 之间的值时才会创建 Guess 的实例：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Guess</span> {
    <span style="color: #4eee94;">value</span>: <span style="color: #98f5ff;">i32</span>,
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Guess</span> {
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">value</span>: <span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">Guess</span> {
        <span style="color: #00bfff; font-weight: bold;">if</span> value &lt; 1 || value &gt; 100 {
            <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"Guess value must be between 1 and 100, got {}."</span>, value);
        }

        <span style="color: #98f5ff;">Guess</span> {
            value
        }
    }

    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">value</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">i32</span> {
        <span style="color: #00bfff; font-weight: bold;">self</span>.value
    }
}
</pre>
</div>

<ol class="org-ol">
<li>定义了一个包含 <span class="underline">i32 类型</span> 字段 <span class="underline">value</span> 的结构体 <span class="underline">Guess</span> 。这里是 <b>储存猜测值</b> 的地方</li>
<li>在 Guess 上实现了一个叫做 <span class="underline">new</span> 的关联函数来 <b>创建 Guess 的实例</b> ：new 定义为接收一个 i32 类型的参数 value 并返回一个 Guess
<ul class="org-ul">
<li>new 函数中代码的测试确保了其值是在 1 到 100 之间的
<ul class="org-ul">
<li>如果 value 没有通过测试则调用 <span class="underline">panic!</span> ，这会警告调用这个函数的程序员有一个需要修改的 bug，因为创建一个 value 超出范围的 Guess 将会违反 Guess::new 所遵循的契约</li>
<li>如果 value 通过了测试：新建一个 Guess，其字段 value 将被设置为参数 value 的值，接着返回这个 Guess。</li>
</ul></li>
</ul></li>
<li>实现了一个借用了 self 的方法 <span class="underline">value</span> ，没有任何其他参数并返回一个 i32
<ul class="org-ul">
<li>这类方法有时被称为 getter，因为它的目的就是返回对应字段的数据</li>
<li>这样的公有方法是必要的，因为 Guess 结构体的 value 字段是私有的
<ul class="org-ul">
<li>私有的字段 value 是很重要的，这样使用 Guess 结构体的代码将不允许直接设置 value 的值</li>
<li>调用者 必须 使用 Guess::new 方法来创建一个 Guess 的实例</li>
<li>这就确保了不会存在一个 value 没有通过 Guess::new 函数的条件检查的 Guess</li>
</ul></li>
</ul></li>
</ol>

<pre class="example">
      如此获取一个参数并只返回 1 到 100 之间数字的函数就可以声明为获取或返回一个 Guess，而不是 i32，同时其函数体中也无需进行任何额外的检查
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f3eba7" class="outline-3">
<h3 id="org7f3eba7">总结</h3>
<div class="outline-text-3" id="text-org7f3eba7">
<p>
Rust 的错误处理功能被设计为帮助编写更加健壮的代码：
</p>
<ul class="org-ul">
<li>panic! 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理</li>
<li>Result 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 Result 来告诉代码调用者他需要处理潜在的成功或失败</li>
</ul>

<p>
在适当的场景使用 panic! 和 Result 将会使你的代码在面对不可避免的错误时显得更加可靠
</p>

<p>
<a href="generic.html">Next：泛型</a>
</p>

<p>
<a href="collection.html">Previous：集合</a>
</p>

<p>
<a href="rust.html">Home: 目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
