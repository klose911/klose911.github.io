<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>高阶内容</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="pattern.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">高阶内容</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5891fc5">不安全 Rust</a>
<ul>
<li><a href="#org67220db">不安全的超级力量</a></li>
<li><a href="#org92554f6">解引用裸指针</a></li>
<li><a href="#org01d54de">调用不安全函数或方法</a>
<ul>
<li><a href="#orge41854d">创建不安全代码的安全抽象</a></li>
<li><a href="#orgb5d4f41">使用 extern 函数调用外部代码</a>
<ul>
<li><a href="#org0eabe98">从其它语言调用 Rust 函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1cd1bdb">访问或修改可变静态变量</a></li>
<li><a href="#org5cc902a">实现不安全 trait</a></li>
<li><a href="#org55dcd9a">何时使用不安全代码</a></li>
</ul>
</li>
<li><a href="#orgf4216b1">高级 trait</a>
<ul>
<li><a href="#orga346ff6">关联类型</a></li>
<li><a href="#orgd3fba07">默认泛型类型参数和运算符重载</a></li>
<li><a href="#orgd5eaadb">完全限定语法与消歧义：调用相同名称的方法</a></li>
<li><a href="#org39f8414">父 trait</a></li>
<li><a href="#orgec599b9">newtype 模式</a></li>
</ul>
</li>
<li><a href="#orgc8e438c">高级类型</a>
<ul>
<li><a href="#org6cdbd83">为了类型安全和抽象而使用 newtype 模式</a></li>
<li><a href="#org63504d2">类型别名</a></li>
<li><a href="#org131a391">从不返回的 never type</a></li>
<li><a href="#org8782952">动态大小类型和 Sized trait</a></li>
</ul>
</li>
<li><a href="#org803b9e8">高级函数和闭包</a>
<ul>
<li><a href="#org934bc66">函数指针</a></li>
<li><a href="#org8bc492b">返回闭包</a></li>
</ul>
</li>
<li><a href="#org4b72435">宏</a>
<ul>
<li><a href="#org60eaeb1">宏和函数的区别</a></li>
<li><a href="#orge1dd60a">macro_rules! 定义宏</a></li>
<li><a href="#orge3d49b9">用于从属性生成代码的过程宏</a>
<ul>
<li><a href="#org0d1c5f9">编写自定义 derive 宏</a>
<ul>
<li><a href="#orgf8f0c30">新建过程宏creat</a></li>
<li><a href="#org994465d">定义宏函数</a></li>
<li><a href="#orga8f4c06">宏依赖</a></li>
<li><a href="#orged9339f">解析输入</a></li>
<li><a href="#orgd84d6b1">实现宏</a></li>
<li><a href="#orgfc83293">使用过程宏</a></li>
</ul>
</li>
<li><a href="#org2893e9f">类属性宏</a></li>
<li><a href="#org759cc21">类函数宏</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  现在已经学习了 Rust 编程语言中最常用的部分。接下来的功能在一些非常特定的场景下很有用处

  虽然很少会碰到它们，这会确保了解 Rust 提供的所有功能
</pre>
<p>
本章将涉及如下内容：
</p>
<ul class="org-ul">
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法，超父trait和 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
<li>宏：定义在编译时定义更多代码的方式</li>
</ul>
<div id="outline-container-org5891fc5" class="outline-2">
<h2 id="org5891fc5">不安全 Rust</h2>
<div class="outline-text-2" id="text-org5891fc5">
<p>
目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 <span class="underline">不安全 Rust</span> 。它与常规 Rust 代码无异，但是会提供额外的超级力量
</p>
<ul class="org-ul">
<li>不安全 Rust 之所以存在，是因为静态分析本质上是保守的</li>
</ul>
<pre class="example">
    当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些

    这必然意味着有时代码可能是合法的，但是 Rust 不这么认为！

    在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”

    这么做的缺点就是你只能靠自己了：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用
</pre>
<ul class="org-ul">
<li>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性</li>
</ul>
<pre class="example">
如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了

Rust 需要能够进行像直接与操作系统交互，甚至于编写自己的操作系统这样的底层系统编程！
</pre>

<p>
先看看不安全 Rust 能做什么，和怎么做
</p>
</div>
<div id="outline-container-org67220db" class="outline-3">
<h3 id="org67220db">不安全的超级力量</h3>
<div class="outline-text-3" id="text-org67220db">
<p>
可以通过 <span class="underline">unsafe</span> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有几类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超级力量。” 这些超级力量是：
</p>
<ol class="org-ol">
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
</ol>

<p>
有一点很重要，unsafe 并不会关闭 <span class="underline">借用检查器</span> 或禁用任何 <span class="underline">其他 Rust 安全检查</span> ：如果在不安全代码中使用引用，它仍会被检查
</p>

<pre class="example">
unsafe 关键字只是提供了那几个不会被编译器检查内存安全的功能

仍然能在不安全块中获得某种程度的安全
</pre>

<p>
再者，unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员将会确保 unsafe 块中的代码以有效的方式访问内存
</p>
<pre class="example">
     人是会犯错误的，错误总会发生

     不过通过要求这类操作必须位于标记为 unsafe 的块中，就能够知道任何与内存安全相关的错误必定位于 unsafe 块内

     保持 unsafe 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了
</pre>
<p>
为了尽可能隔离不安全代码，将 <span class="underline">不安全代码</span> <b>封装</b> 进一个 <span class="underline">安全的抽象</span> 并 <b>提供</b> <span class="underline">安全 API</span> 是一个好主意
</p>

<pre class="example">
     标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象

     这个技术防止了 unsafe 泄露到所有你或者用户希望使用由 unsafe 代码实现的功能的地方，因为使用其安全抽象是安全的
</pre>

<p>
接下来按顺序依次介绍上述几个超级力量，同时会看到一些提供不安全代码的安全接口的抽象
</p>
</div>
</div>
<div id="outline-container-org92554f6" class="outline-3">
<h3 id="org92554f6">解引用裸指针</h3>
<div class="outline-text-3" id="text-org92554f6">
<pre class="example">
   回到前面的 “悬垂引用” 部分，那里提到了编译器会确保引用总是有效的
</pre>
<p>
不安全 Rust 有两个被称为 <span class="underline">裸指针</span> 的类似于引用的新类型。和引用一样，裸指针是 <span class="underline">可变</span> 或 <span class="underline">不可变</span> 的，分别写作 <span class="underline">*const T</span> 和 <span class="underline">*mut T</span> 
</p>
<ul class="org-ul">
<li>这里的 <span class="underline">星号</span> 不是解引用运算符；它是 <b>类型名称</b> 的一部分</li>
<li>在裸指针的上下文中，不可变意味着 <span class="underline">指针解引用</span> 之后 <b>不能直接</b> <span class="underline">赋值</span></li>
</ul>

<p>
与引用和智能指针的区别在于，记住裸指针：
</p>
<ul class="org-ul">
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>

<pre class="example">
   通过去掉 Rust 强加的保证，可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用
</pre>
<p>
下面展示了如何从引用同时创建不可变和可变裸指针：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">num</span> = 5;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r1</span> = &amp;num <span style="color: #00bfff; font-weight: bold;">as</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">i32</span>;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r2</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> num <span style="color: #00bfff; font-weight: bold;">as</span> *<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #98f5ff;">i32</span>;
</pre>
</div>

<p>
注意：这里没有引入 unsafe 关键字。可以在 <span class="underline">安全代码</span> 中 <b>创建</b> 裸指针，只是 <b>不能</b> 在 <span class="underline">不安全块之外</span> <b>解引用</b> 裸指针
</p>

<pre class="example">
     这里使用 as 将不可变和可变引用强转为对应的裸指针类型

     因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设

</pre>
<p>
接下来创建一个不能确定其有效性的裸指针，下面展示了如何创建一个指向任意内存地址的裸指针
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">address</span> = 0x012345usize;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r</span> = address <span style="color: #00bfff; font-weight: bold;">as</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">i32</span>;
</pre>
</div>

<pre class="example">
     尝试使用任意内存是未定义行为：此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误

     通常没有好的理由编写这样的代码，不过却是可行的
</pre>

<p>
对裸指针使用解引用运算符 *，这需要一个 unsafe 块：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">num</span> = 5;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r1</span> = &amp;num <span style="color: #00bfff; font-weight: bold;">as</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">i32</span>;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r2</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> num <span style="color: #00bfff; font-weight: bold;">as</span> *<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #98f5ff;">i32</span>;

<span style="color: #ffff00;">unsafe</span> {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"r1 is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, *r1);
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"r2 is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, *r2);
}
</pre>
</div>

<pre class="example">
     创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值
</pre>
<p>
示例创建了同时指向相同内存位置 num 的裸指针 *const i32 和 *mut i32
</p>
<ul class="org-ul">
<li>如果尝试创建 num 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用</li>
<li>通过裸指针，就能够同时创建同一地址的可变指针和不可变指针</li>
<li>若通过 <span class="underline">可变指针</span> <b>修改</b> 数据，则可能造成 <span class="underline">数据竞争</span></li>
</ul>

<pre class="example">
     既然存在这么多的危险，为何还要使用裸指针呢？

     一个主要的应用场景便是调用 C 代码接口

     另一个场景是构建借用检查器无法理解的安全抽象
</pre>
</div>
</div>
<div id="outline-container-org01d54de" class="outline-3">
<h3 id="org01d54de">调用不安全函数或方法</h3>
<div class="outline-text-3" id="text-org01d54de">
<p>
不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <span class="underline">unsafe</span> 
</p>

<pre class="example">
     在此上下文中，关键字unsafe表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求

     通过在 unsafe 块中调用不安全函数，表明已经阅读过此函数的文档并对其是否满足函数自身的契约负责
</pre>

<p>
如下是一个没有做任何操作的不安全函数 dangerous 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffff00;">unsafe</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">dangerous</span>() {}

<span style="color: #ffff00;">unsafe</span> {
    dangerous();
}
</pre>
</div>

<p>
必须在一个单独的 unsafe 块中调用 dangerous 函数。如果尝试不使用 unsafe 块调用 dangerous，则会得到一个错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0133]: call to unsafe <span style="color: #00bfff; font-weight: bold;">function</span> <span style="color: #daa520; font-weight: bold;">requires</span> unsafe <span style="color: #00bfff; font-weight: bold;">function</span> <span style="color: #daa520; font-weight: bold;">or</span> block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe <span style="color: #00bfff; font-weight: bold;">function</span>
</pre>
</div>

<pre class="example">
     通过将 dangerous 调用插入 unsafe 块中，就向 Rust 保证了已经阅读过函数的文档，理解如何正确使用，并验证过其满足函数的契约
</pre>
<p>
不安全函数体也是有效的 unsafe 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 unsafe 块
</p>
</div>
<div id="outline-container-orge41854d" class="outline-4">
<h4 id="orge41854d">创建不安全代码的安全抽象</h4>
<div class="outline-text-4" id="text-orge41854d">
<p>
仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。作为一个例子，标准库中的函数，split_at_mut，它需要一些不安全代码，这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。split_at_mut 的用法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">v</span> = <span style="color: #ffd700;">vec!</span>[1, 2, 3, 4, 5, 6];

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> v[..];

<span style="color: #00bfff; font-weight: bold;">let</span> (a, b) = r.split_at_mut(3);

<span style="color: #ffd700;">assert_eq!</span>(a, &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [1, 2, 3]);
<span style="color: #ffd700;">assert_eq!</span>(b, &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [4, 5, 6]);
</pre>
</div>

<p>
这个函数无法只通过安全 Rust 实现。一个尝试可能看起来像示例，然而它不能编译。出于简单考虑，将 split_at_mut 实现为函数而不是方法，并只处理 i32 值而非泛型 T 的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">split_at_mut</span>(<span style="color: #4eee94;">slice</span>: &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [<span style="color: #98f5ff;">i32</span>], <span style="color: #4eee94;">mid</span>: <span style="color: #98f5ff;">usize</span>) -&gt; (&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [<span style="color: #98f5ff;">i32</span>], &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [<span style="color: #98f5ff;">i32</span>]) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = slice.len();

    <span style="color: #ffd700;">assert!</span>(mid &lt;= len);

    (&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> slice[..mid],
     &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> slice[mid..])
}
</pre>
</div>

<ol class="org-ol">
<li>此函数首先获取 slice 的长度</li>
<li>通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中：该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic</li>
<li>在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 mid 索引，另一个从 mid 直到原 slice 的结尾</li>
</ol>

<p>
如果尝试编译的，会得到一个错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0499]: cannot borrow <span style="color: #fa8072;">`*slice`</span> as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</pre>
</div>

<p>
Rust 的借用检查器不能理解要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次
</p>

<pre class="example">
      本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些

      当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了
</pre>
<p>
下面展示了如何使用 unsafe 块，裸指针和一些不安全函数调用来实现 split_at_mut：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::slice;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">split_at_mut</span>(<span style="color: #4eee94;">slice</span>: &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [<span style="color: #98f5ff;">i32</span>], <span style="color: #4eee94;">mid</span>: <span style="color: #98f5ff;">usize</span>) -&gt; (&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [<span style="color: #98f5ff;">i32</span>], &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> [<span style="color: #98f5ff;">i32</span>]) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = slice.len();
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">ptr</span> = slice.as_mut_ptr();

    <span style="color: #ffd700;">assert!</span>(mid &lt;= len);

    <span style="color: #ffff00;">unsafe</span> {
        (<span style="color: #ffd700;">slice</span>::from_raw_parts_mut(ptr, mid),
         <span style="color: #ffd700;">slice</span>::from_raw_parts_mut(ptr.offset(mid <span style="color: #00bfff; font-weight: bold;">as</span> <span style="color: #98f5ff;">isize</span>), len - mid))
    }
}
</pre>
</div>

<p>
slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 len 方法获取 slice 的长度，使用 <span class="underline">as_mut_ptr</span> 方法访问 <b>slice 的裸指针</b> 
</p>

<pre class="example">
    在这个例子中，因为有一个 i32 值的可变 slice，as_mut_ptr 返回一个 *mut i32 类型的裸指针，储存在 ptr 变量中
</pre>
<p>
保持索引 mid 位于 slice 中的断言。接着是不安全代码： <span class="underline">slice::from_raw_parts_mut</span>  函数获取一个裸指针和一个长度来 <b>创建</b> 一个 slice：
</p>
<ul class="org-ul">
<li>使用此函数从 ptr 中创建了一个有 mid 个项的 slice</li>
<li>在 ptr 上调用 offset 方法并使用 mid 作为参数来获取一个从 mid 开始的裸指针，使用这个裸指针并以 mid 之后项的数量为长度创建一个 slice</li>
</ul>

<pre class="example">
slice::from_raw_parts_mut 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的

裸指针上的 offset 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针

因此必须将 slice::from_raw_parts_mut 和 offset 放入 unsafe 块中以便能调用它们

通过观察代码，和增加 mid 必然小于等于 len 的断言，可以说 unsafe 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 unsafe 的恰当用法
</pre>

<p>
注意：无需将 split_at_mut 函数的结果标记为 unsafe，并可以在安全 Rust 中调用此函数。因为创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 unsafe 代码，其只从这个函数访问的数据中创建了有效的指针
</p>

<p>
与此相对，下面示例中的 slice::from_raw_parts_mut 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::slice;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">address</span> = 0x01234usize;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r</span> = address <span style="color: #00bfff; font-weight: bold;">as</span> *<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #98f5ff;">i32</span>;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span>: &amp;[<span style="color: #98f5ff;">i32</span>] = <span style="color: #ffff00;">unsafe</span> {
    <span style="color: #ffd700;">slice</span>::from_raw_parts_mut(r, 10000)
};
</pre>
</div>

<p>
并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 i32 值。试图使用臆测为有效的 slice 会导致未定义的行为
</p>
</div>
</div>
<div id="outline-container-orgb5d4f41" class="outline-4">
<h4 id="orgb5d4f41">使用 extern 函数调用外部代码</h4>
<div class="outline-text-4" id="text-orgb5d4f41">
<p>
有时 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字 <span class="underline">extern</span> ，有助于创建和使用外部函数接口。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。下面示例展示了如何集成 C 标准库中的 abs 函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #deb887;">"C"</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">abs</span>(<span style="color: #4eee94;">input</span>: <span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">i32</span>;
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #ffff00;">unsafe</span> {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Absolute value of -3 according to C: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, abs(-3));
    }
}
</pre>
</div>

<pre class="example">
extern 块中声明的函数在 Rust 代码中总是不安全的

因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任
</pre>

<p>
在 extern "C" 块中，列出了希望能够调用的另一个语言中的外部函数的签名和名称
</p>

<pre class="example">
"C" 部分定义了外部函数所使用的 应用程序接口(application binary interface，ABI) 

ABI 定义了如何在汇编语言层面调用此函数，"C" ABI 是最常见的，并遵循 C 编程语言的 ABI
</pre>
</div>

<div id="outline-container-org0eabe98" class="outline-5">
<h5 id="org0eabe98">从其它语言调用 Rust 函数</h5>
<div class="outline-text-5" id="text-org0eabe98">
<p>
也可以使用 extern 来创建一个允许其他语言调用 Rust 函数的接口。不同于 extern 块，就在 fn 关键字之前增加 extern 关键字并指定所用到的 ABI。还需增加 <span class="underline">#[no_mangle]</span> 注解来告诉 Rust 编译器不要 mangle 此函数的名称
</p>

<pre class="example">
Mangling 发生于当编译器将指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读

每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling
</pre>

<p>
在如下的例子中，一旦其编译为动态库并从 C 语言中链接，call_from_c 函数就能够在 C 代码中访问：
</p>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">#[no_mangle]</span>
<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #deb887;">"C"</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">call_from_c</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Just called a Rust function from C!"</span>);
}
</pre>
</div>
<p>
注意：extern 的使用无需 unsafe
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org1cd1bdb" class="outline-3">
<h3 id="org1cd1bdb">访问或修改可变静态变量</h3>
<div class="outline-text-3" id="text-org1cd1bdb">
<pre class="example">
     目前为止都尽量避免讨论 全局变量，Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的

     如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争
</pre>
<p>
全局变量在 Rust 中被称为 <span class="underline">静态</span> (static)变量。下面展示了一个拥有字符串 slice 值的静态变量的声明和应用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #4eee94;">HELLO_WORLD</span>: &amp;<span style="color: #98f5ff;">str</span> = <span style="color: #deb887;">"Hello, world!"</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"name is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #98f5ff;">HELLO_WORLD</span>);
}
</pre>
</div>

<p>
static 变量类似于开头讨论的常量。通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法，并 <b>必须</b> 标注 <span class="underline">变量的类型</span> ，在这个例子中是 &amp;'static str：
</p>
<ul class="org-ul">
<li>静态变量只能储存拥有 <span class="underline">'static</span> <b>生命周期的引用</b> ，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注</li>
<li>访问 <span class="underline">不可变</span> 静态变量是 <b>安全</b> 的</li>
</ul>

<p>
常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是：
</p>
<ul class="org-ul">
<li><span class="underline">静态变量</span> 中的值有一个 <b>固定的内存地址</b> ，使用这个值总是会访问相同的地址</li>
<li><span class="underline">常量</span> 则允许在任何被用到的时候 <b>复制</b> 其 <span class="underline">数据</span></li>
</ul>

<p>
常量与静态变量的另一个区别在于 <span class="underline">静态变量</span> 可以是 <b>可变</b> 的。 <span class="underline">访问</span> 和 <span class="underline">修改</span> <b>可变</b> <span class="underline">静态变量</span> 都是 <b>不安全</b> 的。下面展示了如何声明、访问和修改名为 COUNTER 的可变静态变量：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">COUNTER</span>: <span style="color: #98f5ff;">u32</span> = 0;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">add_to_count</span>(<span style="color: #4eee94;">inc</span>: <span style="color: #98f5ff;">u32</span>) {
    <span style="color: #ffff00;">unsafe</span> {
        <span style="color: #98f5ff;">COUNTER</span> += inc;
    }
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    add_to_count(3);

    <span style="color: #ffff00;">unsafe</span> {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"COUNTER: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #98f5ff;">COUNTER</span>);
    }
}
</pre>
</div>

<p>
就像常规变量一样，使用 mut 关键来指定可变性。任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。拥有多个线程访问 COUNTER 则可能导致数据竞争
</p>

<pre class="example">
     拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的

     任何可能的情况，请优先使用并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的
</pre>
</div>
</div>

<div id="outline-container-org5cc902a" class="outline-3">
<h3 id="org5cc902a">实现不安全 trait</h3>
<div class="outline-text-3" id="text-org5cc902a">
<p>
最后一个只能用在 unsafe 中的操作是实现不安全 trait。当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffff00;">unsafe</span> <span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Foo</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">methods go here</span>
}

<span style="color: #ffff00;">unsafe</span> <span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Foo</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">i32</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">method implementations go here</span>
}
</pre>
</div>

<p>
通过 unsafe impl，将保证编译器所不能验证的不变量
</p>

<pre class="example">
作为一个例子，回忆“使用 Sync 和 Send trait 的可扩展并发” 部分中的 Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们

如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe

Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 unsafe 表明
</pre>
</div>
</div>

<div id="outline-container-org55dcd9a" class="outline-3">
<h3 id="org55dcd9a">何时使用不安全代码</h3>
<div class="outline-text-3" id="text-org55dcd9a">
<p>
使用 unsafe 来进行这四个操作（超级力量）之一是没有问题的，甚至是不需要深思熟虑的
</p>

<pre class="example">
     不过使用 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全

     当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注使得在出现错误时易于追踪问题的源头
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf4216b1" class="outline-2">
<h2 id="orgf4216b1">高级 trait</h2>
<div class="outline-text-2" id="text-orgf4216b1">
<pre class="example">
    “trait：定义共享的行为” 部分，第一次涉及到了 trait，不过就像生命周期一样，并没有覆盖一些较为高级的细节

    现在更加了解 Rust 了，可以深入理解其本质了
</pre>
</div>

<div id="outline-container-orga346ff6" class="outline-3">
<h3 id="orga346ff6">关联类型</h3>
<div class="outline-text-3" id="text-orga346ff6">
<p>
<span class="underline">关联类型</span> 是一个将 <span class="underline">类型占位符</span> 与 <span class="underline">trait</span> 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么
</p>

<pre class="example">
     本章所描述的大部分内容都非常少见

     关联类型则比较适中；它们比本书其他的内容要少见，不过比本章中的很多内容要更常见
</pre>
<p>
一个带有关联类型的 trait 的例子是标准库提供的 Iterator trait。它有一个叫做 <span class="underline">Item</span> 的关联类型来替代遍历的值的类型：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Iterator</span> {
    <span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Item</span>;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">next</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">Option</span>&lt;<span style="color: #98f5ff;">Self</span>::<span style="color: #98f5ff;">Item</span>&gt;;
}
</pre>
</div>

<p>
Item 是一个占位类型，同时 next 方法定义表明它返回 Option&lt;Self::Item&gt; 类型的值。这个 trait 的实现者会指定 Item 的具体类型，然而不管实现者指定何种类型, next 方法都会返回一个包含了此具体类型值的 Option
</p>

<pre class="example">
     关联类型看起来像一个类似泛型的概念，因为它允许定义一个函数而不指定其可以处理的类型

     那么为什么要使用关联类型呢？
</pre>

<p>
通过一个前面出现过的 Counter 结构体上实现 Iterator trait 的例子来检视其中的区别。下面指定了 Item 的类型为 u32：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Iterator</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Counter</span> {
    <span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Item</span> = <span style="color: #98f5ff;">u32</span>;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">next</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">Option</span>&lt;<span style="color: #98f5ff;">Self</span>::<span style="color: #98f5ff;">Item</span>&gt; {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
</pre>
</div>

<p>
这类似于泛型。那么为什么 Iterator trait 不像下面那样定义呢？
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Iterator</span>&lt;<span style="color: #98f5ff;">T</span>&gt; {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">next</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">Option</span>&lt;<span style="color: #98f5ff;">T</span>&gt;;
}
</pre>
</div>

<pre class="example">
     区别在于当如上面那样使用泛型时，则不得不在每一个实现中标注类型，这是因为我们也可以实现为 Iterator&lt;String&gt; for Counter，或任何其他类型，这样就可以有多个 Counter 的 Iterator 的实现

     换句话说，当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型，接着当使用 Counter 的 next 方法时，必须提供类型注解来表明希望使用 Iterator 的哪一个实现

</pre>
<p>
通过关联类型，则无需标注类型因为不能多次实现这个 trait。对于使用关联类型的定义，只能选择一次 Item 会是什么类型，因为只能有一个 impl Iterator for Counter。当调用 Counter 的 next 时不必每次指定需要 u32 值的迭代器
</p>
</div>
</div>

<div id="outline-container-orgd3fba07" class="outline-3">
<h3 id="orgd3fba07">默认泛型类型参数和运算符重载</h3>
<div class="outline-text-3" id="text-orgd3fba07">
<p>
当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时使用 <span class="underline">&lt;PlaceholderType=ConcreteType&gt;</span> 
</p>

<pre class="example">
这种情况的一个非常好的例子是用于运算符重载，运算符重载：是指在特定情况下自定义运算符（比如 +）行为的操作

Rust 并不允许创建自定义运算符或重载任意运算符，不过 std::ops 中所列出的运算符和相应的 trait 可以通过实现运算符相关 trait 来重载
</pre>
<p>
例如，下面展示了如何在 <span class="underline">Point 结构体</span> 上实现 <span class="underline">Add trait</span> 来 <b>重载</b> <span class="underline">+ 运算符</span> ，这样就可以将两个 Point 实例相加了：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">ops</span>::<span style="color: #98f5ff;">Add</span>;

<span style="color: #ffd700;">#[derive(Debug, PartialEq)]</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Point</span> {
    <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">i32</span>,
    <span style="color: #4eee94;">y</span>: <span style="color: #98f5ff;">i32</span>,
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Add</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Point</span> {
    <span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Output</span> = <span style="color: #98f5ff;">Point</span>;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">add</span>(<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">other</span>: <span style="color: #98f5ff;">Point</span>) -&gt; <span style="color: #98f5ff;">Point</span> {
        <span style="color: #98f5ff;">Point</span> {
            <span style="color: #4eee94;">x</span>: <span style="color: #00bfff; font-weight: bold;">self</span>.x + other.x,
            <span style="color: #4eee94;">y</span>: <span style="color: #00bfff; font-weight: bold;">self</span>.y + other.y,
        }
    }
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #ffd700;">assert_eq!</span>(<span style="color: #98f5ff;">Point</span> { <span style="color: #4eee94;">x</span>: 1, <span style="color: #4eee94;">y</span>: 0 } + <span style="color: #98f5ff;">Point</span> { <span style="color: #4eee94;">x</span>: 2, <span style="color: #4eee94;">y</span>: 3 },
               <span style="color: #98f5ff;">Point</span> { <span style="color: #4eee94;">x</span>: 3, <span style="color: #4eee94;">y</span>: 3 });
}
</pre>
</div>

<p>
add 方法将两个 Point 实例的 x 值和 y 值分别相加来创建一个新的 Point。 <span class="underline">Add trait</span> 有一个叫做 <span class="underline">Output</span> 的 <b>关联类型</b> ，它用来决定 add 方法的返回值类型，这里默认泛型类型位于 Add trait 中。这里是其定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Add</span>&lt;RHS=Self&gt; {
    <span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Output</span>;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">add</span>(<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">rhs</span>: <span style="color: #98f5ff;">RHS</span>) -&gt; <span style="color: #98f5ff;">Self</span>::<span style="color: #98f5ff;">Output</span>;
}
</pre>
</div>

<p>
这看来应该很熟悉，这是一个带有一个方法和一个关联类型的 trait。比较陌生的部分是尖括号中的 <span class="underline">RHS=Self</span> ：这个语法叫做 <span class="underline">默认类型参数</span> 。RHS 是一个泛型类型参数，它用于定义 add 方法中的 rhs 参数
</p>

<pre class="example">
     如果实现 Add trait 时不指定 RHS 的具体类型，RHS 的类型将是默认的 Self 类型，也就是在其上实现 Add 的类型

     当为 Point 实现 Add 时，使用了默认的 RHS，因为希望将两个 Point 实例相加
</pre>
<p>
看看一个实现 Add trait 时希望自定义 RHS 类型而不是使用默认类型的例子。这里有两个存放不同单元值的结构体，Millimeters 和 Meters。希望能够将毫米值与米值相加，并让 Add 的实现正确处理转换。可以为 Millimeters 实现 Add 并以 Meters 作为 RHS：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">ops</span>::<span style="color: #98f5ff;">Add</span>;

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Millimeters</span>(<span style="color: #98f5ff;">u32</span>);
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Meters</span>(<span style="color: #98f5ff;">u32</span>);

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Add</span>&lt;<span style="color: #98f5ff;">Meters</span>&gt; <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Millimeters</span> {
    <span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Output</span> = <span style="color: #98f5ff;">Millimeters</span>;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">add</span>(<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">other</span>: <span style="color: #98f5ff;">Meters</span>) -&gt; <span style="color: #98f5ff;">Millimeters</span> {
        <span style="color: #98f5ff;">Millimeters</span>(<span style="color: #00bfff; font-weight: bold;">self</span>.0 + (other.0 * 1000))
    }
}
</pre>
</div>

<pre class="example">
     为了使 Millimeters 和 Meters 能够相加，指定 impl Add&lt;Meters&gt; 来设定 RHS 类型参数的值而不是使用默认的 Self
</pre>
<p>
默认参数类型主要用于如下两个方面：
</p>
<ol class="org-ol">
<li>扩展类型而不破坏现有代码</li>
<li>在大部分用户都不需要的特定情况进行自定义</li>
</ol>

<pre class="example">
     标准库的 Add trait 就是第二个目的：大部分时候你会将两个相似的类型相加，不过它提供了自定义额外行为的能力。在 Add trait 定义中使用默认类型参数意味着大部分时候无需指定额外的参数。换句话说，一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了

     第一个目的是相似的，但过程是反过来的：如果需要为现有 trait 增加类型参数，为其提供一个默认类型将允许在不破坏现有实现代码的基础上扩展 trait 的功能
</pre>
</div>
</div>

<div id="outline-container-orgd5eaadb" class="outline-3">
<h3 id="orgd5eaadb">完全限定语法与消歧义：调用相同名称的方法</h3>
<div class="outline-text-3" id="text-orgd5eaadb">
<pre class="example">
Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait

甚至直接在类型上实现开始已经有的同名方法也是可能的！
</pre>
<p>
不过，当调用这些同名方法时，需要告诉 Rust 希望使用哪一个。下面定义了 trait Pilot 和 Wizard 都拥有方法 fly。接着在一个本身已经实现了名为 fly 方法的类型 Human 上实现这两个 trait。每一个 fly 方法都进行了不同的操作：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Pilot</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fly</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>);
}

<span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Wizard</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fly</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>);
}

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Human</span>;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Pilot</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Human</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fly</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"This is your captain speaking."</span>);
    }
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Wizard</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Human</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fly</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Up!"</span>);
    }
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Human</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fly</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"*waving arms furiously*"</span>);
    }
}
</pre>
</div>

<p>
当调用 Human 实例的 fly 时，编译器默认调用直接是现在类型上的方法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">person</span> = <span style="color: #98f5ff;">Human</span>;
    person.fly();
}
</pre>
</div>

<pre class="example">
   运行这段代码会打印出 *waving arms furiously*，这表明 Rust 调用了直接实现在 Human 上的 fly 方法
</pre>
<p>
为了能够调用 Pilot trait 或 Wizard trait 的 fly 方法，需要使用更明显的语法以便能指定指的是哪个 fly 方法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">person</span> = <span style="color: #98f5ff;">Human</span>;
    <span style="color: #98f5ff;">Pilot</span>::fly(&amp;person);
    <span style="color: #98f5ff;">Wizard</span>::fly(&amp;person);
    person.fly();
}
</pre>
</div>

<p>
在方法名前指定 trait 名向 Rust 澄清了希望调用哪个 fly 实现。也可以选择写成 Human::fly(&amp;person)，这等同于示例 19-18 中的 person.fly()，不过如果无需消歧义的话这么写就有点长了。运行这段代码会打印出：
</p>

<div class="org-src-container">
<pre class="src src-sh">This is your captain speaking.
Up!
*waving arms furiously*
</pre>
</div>

<pre class="example">
   因为 fly 方法获取一个 self 参数，如果有两个 类型 都实现了同一 trait，Rust 可以根据 self 的类型计算出应该使用哪一个 trait 实现
</pre>

<p>
然而，关联函数是 trait 的一部分，但没有 self 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出期望的是哪一个类型，除非使用 <span class="underline">完全限定语法</span> 。例如，下面的 Animal trait 来说，它有关联函数 baby_name，结构体 Dog 实现了 Animal，同时有关联函数 baby_name 直接定义于 Dog 之上：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Animal</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">baby_name</span>() -&gt; <span style="color: #98f5ff;">String</span>;
}

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Dog</span>;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Dog</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">baby_name</span>() -&gt; <span style="color: #98f5ff;">String</span> {
        <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"Spot"</span>)
    }
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Animal</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Dog</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">baby_name</span>() -&gt; <span style="color: #98f5ff;">String</span> {
        <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"puppy"</span>)
    }
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"A baby dog is called a </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #98f5ff;">Dog</span>::baby_name());
}
</pre>
</div>

<pre class="example">
这段代码用于一个动物收容所，他们将所有的小狗起名为 Spot，这实现为定义于 Dog 之上的关联函数 baby_name

Dog 类型还实现了 Animal trait，它描述了所有动物的共有的特征。小狗被称为 puppy，这表现为 Dog 的 Animal trait 实现中与 Animal trait 相关联的函数 baby_name
</pre>

<p>
在 main 调用了 Dog::baby_name 函数，它直接调用了定义于 Dog 之上的关联函数。这段代码会打印出：
</p>

<div class="org-src-container">
<pre class="src src-sh">A baby dog is called a Spot
</pre>
</div>

<p>
这并不是我们需要的。希望调用的是 Dog 上 Animal trait 实现那部分的 baby_name 函数，这样能够打印出 A baby dog is called a puppy。前面用到的技术在这并不管用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"A baby dog is called a </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #98f5ff;">Animal</span>::baby_name());
}
</pre>
</div>

<p>
会得到一个编译错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0283]: type annotations required: cannot resolve <span style="color: #fa8072;">`_: Animal`</span>
  --&gt; src/main.rs:20:43
   |
20 |     println!(<span style="color: #deb887;">"A baby dog is called a {}"</span>, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by <span style="color: #fa8072;">`Animal::baby_name`</span>
</pre>
</div>

<pre class="example">
     因为 Animal::baby_name 是关联函数而不是方法，因此它没有 self 参数，Rust 无法计算出所需的是哪一个 Animal::baby_name 实现
</pre>

<p>
为了消歧义并告诉 Rust 希望使用的是 Dog 的 Animal 实现，需要使用 <span class="underline">完全限定语法</span> ，这是调用函数时最为明确的方式：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"A baby dog is called a </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, &lt;<span style="color: #98f5ff;">Dog</span> <span style="color: #00bfff; font-weight: bold;">as</span> <span style="color: #98f5ff;">Animal</span>&gt;::baby_name());
}
</pre>
</div>

<p>
在尖括号中向 Rust 提供了类型注解，并通过在此函数调用中将 Dog 类型当作 Animal 对待，来指定希望调用的是 Dog 上 Animal trait 实现中的 baby_name 函数。现在这段代码会打印出期望的数据：
</p>

<div class="org-src-container">
<pre class="src src-sh">A baby dog is called a puppy
</pre>
</div>

<p>
通常，完全限定语法定义为：
</p>
<pre class="example">
&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</pre>

<p>
对于关联函数，其没有一个 receiver，故只会有其他参数的列表
</p>

<pre class="example">
     可以选择在任何函数或方法调用处使用完全限定语法。然而，允许省略任何 Rust 能够从程序中的其他信息中计算出的部分

     只有当存在多个同名实现而 Rust 需要帮助以便知道我们希望调用哪个实现时，才需要使用这个较为冗长的语法
</pre>
</div>
</div>

<div id="outline-container-org39f8414" class="outline-3">
<h3 id="org39f8414">父 trait</h3>
<div class="outline-text-3" id="text-org39f8414">
<pre class="example">
     有时可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现

     这个所需的 trait 是实现的 trait 的 父 trait(supertrait)
</pre>
<p>
例如希望创建一个带有 outline_print 方法的 trait OutlinePrint，它会打印出带有星号框的值。也就是说，如果 Point 实现了 Display 并返回 (x, y)，调用以 1 作为 x 和 3 作为 y 的 Point 实例的 outline_print 会显示如下：
</p>

<pre class="example">
**********
*        *
* (1, 3) *
*        *
**********
</pre>

<p>
在 outline_print 的实现中，因为希望能够使用 Display trait 的功能，则需要说明 OutlinePrint 只能用于同时也实现了 Display 并提供了 OutlinePrint 需要的功能的类型。可以通过在 trait 定义中指定 OutlinePrint: Display 来做到这一点。这类似于为 trait 增加 trait bound。下面示例展示了一个 OutlinePrint trait 的实现：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fmt;

<span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #4eee94;">OutlinePrint</span>: <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Display</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">outline_print</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>) {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">output</span> = <span style="color: #00bfff; font-weight: bold;">self</span>.to_string();
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = output.len();
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #deb887;">"*"</span>.repeat(len + 4));
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"*</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">*"</span>, <span style="color: #deb887;">" "</span>.repeat(len + 2));
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"* </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> *"</span>, output);
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"*</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">*"</span>, <span style="color: #deb887;">" "</span>.repeat(len + 2));
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #deb887;">"*"</span>.repeat(len + 4));
    }
}
</pre>
</div>

<pre class="example">
     因为指定了 OutlinePrint 需要 Display trait，则可以在 outline_print 中使用 to_string， 其会为任何实现 Display 的类型自动实现

     如果不在 trait 名后增加 : Display 并尝试在 outline_print 中使用 to_string，则会得到一个错误说在当前作用域中没有找到用于 &amp;Self 类型的方法 to_string
</pre>
<p>
如果尝试在一个没有实现 Display 的类型上实现 OutlinePrint ：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Point</span> {
    <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">i32</span>,
    <span style="color: #4eee94;">y</span>: <span style="color: #98f5ff;">i32</span>,
}

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">OutlinePrint</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Point</span> {}
</pre>
</div>

<p>
一旦在 Point 上实现 Display 并满足 OutlinePrint 要求的限制，比如这样：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fmt;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Display</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Point</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fmt</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">f</span>: &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Formatter</span>) -&gt; <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Result</span> {
        <span style="color: #f08080;">write!</span>(f, <span style="color: #deb887;">"(</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">)"</span>, <span style="color: #00bfff; font-weight: bold;">self</span>.x, <span style="color: #00bfff; font-weight: bold;">self</span>.y)
    }
}
</pre>
</div>

<p>
那么在 Point 上实现 OutlinePrint trait 将能成功编译，并可以在 Point 实例上调用 outline_print 来显示位于星号框中的点的值：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">point</span> = <span style="color: #98f5ff;">Point</span> { <span style="color: #4eee94;">x</span>: 1, <span style="color: #4eee94;">y</span>: 3 };
    point.outline_print();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgec599b9" class="outline-3">
<h3 id="orgec599b9">newtype 模式</h3>
<div class="outline-text-3" id="text-orgec599b9">
<pre class="example">
前面“为类型实现 trait” 部分，提到了孤儿规则，它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait

一个绕开这个限制的方法是使用 newtype 模式，它涉及到在一个元组结构体，中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait

Newtype 是一个源自Haskell 编程语言的概念，使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了

</pre>
<p>
例如，如果想要在 Vec&lt;T&gt; 上实现 Display，而孤儿规则阻止直接这么做，因为 Display trait 和 Vec&lt;T&gt; 都定义于我们的 crate 之外。可以创建一个包含 Vec&lt;T&gt; 实例的 Wrapper 结构体，接着可以在 Wrapper 上实现 Display 并使用 Vec&lt;T&gt; 的值：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fmt;

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Wrapper</span>(<span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt;);

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Display</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Wrapper</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">fmt</span>(&amp;<span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">f</span>: &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Formatter</span>) -&gt; <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Result</span> {
        <span style="color: #f08080;">write!</span>(f, <span style="color: #deb887;">"[</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">]"</span>, <span style="color: #00bfff; font-weight: bold;">self</span>.0.join(<span style="color: #deb887;">", "</span>))
    }
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">w</span> = <span style="color: #98f5ff;">Wrapper</span>(<span style="color: #ffd700;">vec!</span>[<span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>), <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"world"</span>)]);
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"w = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, w);
}
</pre>
</div>

<p>
Display 的实现使用 self.0 来访问其内部的 Vec&lt;T&gt;，因为 Wrapper 是元组结构体而 Vec&lt;T&gt; 是结构体总位于索引 0 的项，接着就可以使用 Wrapper 中 Display 的功能了
</p>

<pre class="example">
     因为 Wrapper 是一个新类型，它没有定义于其值之上的方法；必须直接在 Wrapper 上实现 Vec&lt;T&gt; 的所有方法，这样就可以代理到self.0 上。这允许完全像 Vec&lt;T&gt; 那样对待 Wrapper

     如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 Deref trait，并返回其内部类型是一种解决方案

     如果不希望封装类型拥有所有内部类型的方法，比如为了“限制封装类型的行为”，则必须只自行实现所需的方法
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc8e438c" class="outline-2">
<h2 id="orgc8e438c">高级类型</h2>
<div class="outline-text-2" id="text-orgc8e438c">
<p>
Rust 的类型系统有一些曾经提到但没有讨论过的功能:
</p>
<ol class="org-ol">
<li>从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始</li>
<li>接着会转向类型别名，一个类似于 newtype 但有着稍微不同的语义的功能</li>
<li>还会讨论 ! 类型和动态大小类型</li>
</ol>
</div>

<div id="outline-container-org6cdbd83" class="outline-3">
<h3 id="org6cdbd83">为了类型安全和抽象而使用 newtype 模式</h3>
<div class="outline-text-3" id="text-org6cdbd83">
<p>
newtype 模式可以用于一些其他还未讨论的功能，包括静态的 <b>确保</b> <span class="underline">某值不被混淆</span> ，和用来 <b>表示</b> <span class="underline">一个值的单元</span>
</p>
<pre class="example">
     实际上前面中已经有一个这样的例子：Millimeters 和 Meters 结构体都在 newtype 中封装了 u32 值

     如果编写了一个有 Millimeters 类型参数的函数，不小心使用 Meters 或普通的 u32 值来调用该函数的程序是不能编译的
</pre>

<p>
另一个 newtype 模式的应用在于 <b>抽象</b> 掉一些 <span class="underline">类型的实现细节</span> 
</p>
<pre class="example">
   例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能
</pre>

<p>
newtype 也可以 <b>隐藏</b> 其 <span class="underline">内部的泛型类型</span> 
</p>

<pre class="example">
例如，可以提供一个封装了 HashMap&lt;i32, String&gt; 的 People 类型，用来储存人名以及相应的 ID

使用 People 的代码只需与提供的公有 API 交互即可，比如向 People 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 i32 ID 赋予了这个名字了

newtype 模式是一种实现 “封装隐藏了实现细节” 部分所讨论的隐藏实现细节的封装的轻量级方法
</pre>
</div>
</div>

<div id="outline-container-org63504d2" class="outline-3">
<h3 id="org63504d2">类型别名</h3>
<div class="outline-text-3" id="text-org63504d2">
<p>
连同 newtype 模式，Rust 还提供了声明 <b>类型别名</b> 的能力，使用 <span class="underline">type</span> 关键字来给予现有类型另一个名字。例如，可以像这样创建 i32 的别名 Kilometers：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Kilometers</span> = <span style="color: #98f5ff;">i32</span>;
</pre>
</div>

<p>
这意味着 Kilometers 是 i32 的 <b>同义词</b> 不同于前面创建的 Millimeters 和 Meters 类型。Kilometers 不是一个新的、单独的类型。Kilometers 类型的值将被完全当作 i32 类型值来对待：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Kilometers</span> = <span style="color: #98f5ff;">i32</span>;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">i32</span> = 5;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">y</span>: <span style="color: #98f5ff;">Kilometers</span> = 5;

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"x + y = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, x + y);
</pre>
</div>

<pre class="example">
     因为 Kilometers 是 i32 的别名，他们是同一类型，可以将 i32 与 Kilometers 相加，也可以将 Kilometers 传递给获取 i32 参数的函数

     但通过这种手段无法获得上一部分讨论的 newtype 模式所提供的类型检查的好处
</pre>

<p>
类型别名的主要用途是 <b>减少重复</b> 。例如，可能会有这样很长的类型：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Fn</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>&gt;
</pre>
</div>

<p>
在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。想象一下全是如此代码的项目：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Fn</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>&gt; = <span style="color: #98f5ff;">Box</span>::new(|| <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"hi"</span>));

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">takes_long_type</span>(<span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Fn</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>&gt;) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">returns_long_type</span>() -&gt; <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Fn</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>&gt; {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
类型别名通过减少项目中重复代码的数量来使其更加易于控制。这里为这个冗长的类型引入了一个叫做 Thunk 的别名，这样就可以将所有使用这个类型的地方替换为更短的 Thunk：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Thunk</span> = <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Fn</span>() + <span style="color: #98f5ff;">Send</span> + '<span style="color: #00bfff; font-weight: bold;">static</span>&gt;;

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">Thunk</span> = <span style="color: #98f5ff;">Box</span>::new(|| <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"hi"</span>));

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">takes_long_type</span>(<span style="color: #4eee94;">f</span>: <span style="color: #98f5ff;">Thunk</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">returns_long_type</span>() -&gt; <span style="color: #98f5ff;">Thunk</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<pre class="example">
     这样就读写起来就容易多了！

     为类型别名选择一个好名字也可以帮助表达意图（单词 thunk 表示会在之后被计算的代码，所以这是一个存放闭包的合适的名字）
</pre>

<p>
类型别名也经常与 <span class="underline">Result&lt;T, E&gt;</span> 结合使用来减少重复。考虑一下标准库中的 std::io 模块。I/O 操作通常会返回一个 Result&lt;T, E&gt;，因为这些操作可能会失败。标准库中的 std::io::Error 结构体代表了所有可能的 I/O 错误。std::io 中大部分函数会返回 Result&lt;T, E&gt;，其中 E 是 std::io::Error，比如 Write trait 中的这些函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Error</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fmt;

<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Write</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">write</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">buf</span>: &amp;[<span style="color: #98f5ff;">u8</span>]) -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">usize</span>, <span style="color: #98f5ff;">Error</span>&gt;;
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">flush</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">Result</span>&lt;(), <span style="color: #98f5ff;">Error</span>&gt;;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">write_all</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">buf</span>: &amp;[<span style="color: #98f5ff;">u8</span>]) -&gt; <span style="color: #98f5ff;">Result</span>&lt;(), <span style="color: #98f5ff;">Error</span>&gt;;
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">write_fmt</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">fmt</span>: <span style="color: #ffd700;">fmt</span>::<span style="color: #98f5ff;">Arguments</span>) -&gt; <span style="color: #98f5ff;">Result</span>&lt;(), <span style="color: #98f5ff;">Error</span>&gt;;
}
</pre>
</div>

<p>
这里出现了很多的 Result&lt;&#x2026;, Error&gt;。为此，std::io 有这个类型别名声明：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">T</span>&gt; = <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">result</span>::<span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">T</span>, <span style="color: #ffd700;">std</span>::<span style="color: #ffd700;">io</span>::<span style="color: #98f5ff;">Error</span>&gt;;
</pre>
</div>

<p>
因为这位于 std::io 中，可用的完全限定的别名是 std::io::Result&lt;T&gt;。Write trait 中的函数最终看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">Write</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">write</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">buf</span>: &amp;[<span style="color: #98f5ff;">u8</span>]) -&gt; <span style="color: #98f5ff;">Result</span>&lt;<span style="color: #98f5ff;">usize</span>&gt;;
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">flush</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">Result</span>&lt;()&gt;;

    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">write_all</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">buf</span>: &amp;[<span style="color: #98f5ff;">u8</span>]) -&gt; <span style="color: #98f5ff;">Result</span>&lt;()&gt;;
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">write_fmt</span>(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #00bfff; font-weight: bold;">self</span>, <span style="color: #4eee94;">fmt</span>: <span style="color: #98f5ff;">Arguments</span>) -&gt; <span style="color: #98f5ff;">Result</span>&lt;()&gt;;
}
</pre>
</div>

<pre class="example">
类型别名在两个方面有帮助：

1. 易于编写 并 在整个 std::io 中提供了一致的接口
2. 因为这是一个别名，它只是另一个 Result&lt;T, E&gt;，这意味着可以在其上使用 Result&lt;T, E&gt; 的任何方法，以及像 ? 这样的特殊语法
</pre>
</div>
</div>

<div id="outline-container-org131a391" class="outline-3">
<h3 id="org131a391">从不返回的 never type</h3>
<div class="outline-text-3" id="text-org131a391">
<p>
Rust 有一个叫做 <span class="underline">!</span> 的特殊类型。在类型理论术语中，它被称为 empty type，因为它没有值。我们更倾向于称之为 <span class="underline">never type</span> 。这个名字描述了它的作用：在 <b>函数从不返回的时候充当返回值</b> 。例如：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">bar</span>() -&gt; ! {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
函数 bar 从不返回，而从不返回的函数被称为 <span class="underline">发散函数</span> 。不能创建 ! 类型的值，所以 bar 也不可能返回值。不过一个不能创建值的类型有什么用呢？回想一下以前示例的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">guess</span>: <span style="color: #98f5ff;">u32</span> = <span style="color: #00bfff; font-weight: bold;">match</span> guess.trim().parse() {
    <span style="color: #98f5ff;">Ok</span>(num) =&gt; num,
    <span style="color: #98f5ff;">Err</span>(_) =&gt; <span style="color: #00bfff; font-weight: bold;">continue</span>,
};
</pre>
</div>

<p>
当时我们忽略了代码中的一些细节。后来学习了 match 的分支必须返回相同的类型。如下代码不能工作：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">guess</span> = <span style="color: #00bfff; font-weight: bold;">match</span> guess.trim().parse() {
    <span style="color: #98f5ff;">Ok</span>(_) =&gt; 5,
    <span style="color: #98f5ff;">Err</span>(_) =&gt; <span style="color: #deb887;">"hello"</span>,
}
</pre>
</div>

<pre class="example">
这里的 guess 必须既是整型 也是 字符串，而 Rust 要求 guess 只能是一个类型

那么 continue 返回了什么呢？为什么开头的示例中会允许一个分支返回 u32 而另一个分支却以 continue 结束呢？

continue 的值是 !。也就是说，当 Rust 要计算 guess 的类型时，它查看这两个分支。前者是 u32 值，而后者是 ! 值。因为 ! 并没有一个值，Rust 决定 guess 的类型是 u32。

描述 ! 的行为的正式方式是 never type 可以强转为任何其他类型。允许 match 的分支以 continue 结束是因为 continue 并不真正返回一个值；相反它把控制权交回上层循环，所以在 Err 的情况，事实上并未对 guess 赋值
</pre>

<p>
never type 的另一个用途是 <span class="underline">panic!</span> 。还记得 Option&lt;T&gt; 上的 unwrap 函数吗？它产生一个值或 panic。这里是它的定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">impl</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">Option</span>&lt;<span style="color: #98f5ff;">T</span>&gt; {
    <span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">unwrap</span>(<span style="color: #00bfff; font-weight: bold;">self</span>) -&gt; <span style="color: #98f5ff;">T</span> {
        <span style="color: #00bfff; font-weight: bold;">match</span> <span style="color: #00bfff; font-weight: bold;">self</span> {
            <span style="color: #98f5ff;">Some</span>(val) =&gt; val,
            <span style="color: #98f5ff;">None</span> =&gt; <span style="color: #ffd700;">panic!</span>(<span style="color: #deb887;">"called `Option::unwrap()` on a `None` value"</span>),
        }
    }
}
</pre>
</div>

<pre class="example">
这里与前面的 match 发生了相同的情况：

Rust 知道 val 是 T 类型，panic! 是 ! 类型，所以整个 match 表达式的结果是 T 类型。这能工作是因为 panic! 并不产生一个值；它会终止程序

对于 None 的情况，unwrap 并不返回一个值，所以这些代码是有效
</pre>

<p>
最后一个有着 ! 类型的表达式是 <span class="underline">loop</span> ：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #f08080;">print!</span>(<span style="color: #deb887;">"forever "</span>);

<span style="color: #00bfff; font-weight: bold;">loop</span> {
    <span style="color: #f08080;">print!</span>(<span style="color: #deb887;">"and ever "</span>);
}
</pre>
</div>

<pre class="example">
     这里，循环永远也不结束，所以此表达式的值是 !

     但是如果引入 break 这就不为真了，因为循环在执行到 break 后就会终止
</pre>
</div>
</div>

<div id="outline-container-org8782952" class="outline-3">
<h3 id="org8782952">动态大小类型和 Sized trait</h3>
<div class="outline-text-3" id="text-org8782952">
<pre class="example">
     因为 Rust 需要知道例如应该为特定类型的值分配多少空间

     这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 动态大小类型的概念

     这有时被称为 “DST” 或 “unsized types”，这些类型允许处理只有在运行时才知道大小的类型
</pre>
<p>
一个贯穿本书都在使用的动态大小类型的细节： <b>str</b> 。没错，不是 <span class="underline">&amp;str</span> ，而是 str 本身。str 是一个 DST；直到运行时都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着 <b>不能创建 str 类型的变量</b> ，也 <b>不能获取 str 类型的参数</b> 。考虑一下这些代码，他们不能工作：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span>: <span style="color: #98f5ff;">str</span> = <span style="color: #deb887;">"Hello there!"</span>;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s2</span>: <span style="color: #98f5ff;">str</span> = <span style="color: #deb887;">"How's it going?"</span>;
</pre>
</div>

<pre class="example">
Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存

如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。

那么该怎么办？ 答案是 s1 和 s2 的类型是 &amp;str 而不是 str
</pre>

<p>
所以虽然 &amp;T 是一个储存了 T 所在的内存位置的单个值，&amp;str 则是 两个 值：str 的地址和其长度。这样，&amp;str 就有了一个在编译时可以知道的大小：它是 usize 长度的两倍。也就是说，我们总是知道 &amp;str 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则： <b>必须将动态大小类型的值置于某种指针之后</b> 
</p>

<pre class="example">
     可以将 str 与所有类型的指针结合：比如 Box&lt;str&gt; 或 Rc&lt;str&gt;

     事实上，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型

     在“为使用不同类型的值而设计的 trait 对象” 部分，提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 &amp;Trait 或 Box&lt;Trait&gt;（Rc&lt;Trait&gt; 也可以）
</pre>

<p>
为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 <span class="underline">Sized trait</span> 。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust <b>隐式的为每一个泛型函数增加了 Sized bound</b> 。也就是说，对于如下泛型函数定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">generic</span>&lt;<span style="color: #98f5ff;">T</span>&gt;(<span style="color: #4eee94;">t</span>: <span style="color: #98f5ff;">T</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
实际上被当作如下处理：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">generic</span>&lt;<span style="color: #4eee94;">T</span>: <span style="color: #98f5ff;">Sized</span>&gt;(<span style="color: #4eee94;">t</span>: <span style="color: #98f5ff;">T</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">generic</span>&lt;<span style="color: #4eee94;">T</span>: <span style="color: #f08080; font-weight: bold;">?</span><span style="color: #98f5ff;">Sized</span>&gt;(<span style="color: #4eee94;">t</span>: &amp;<span style="color: #98f5ff;">T</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}
</pre>
</div>

<p>
<span class="underline">?Sized</span> trait bound 与 Sized 相对；也就是说，它可以解释为 <b>T 可能是也可能不是 Sized 的</b>
</p>

<pre class="example">
     这个语法只能用于 Sized ，而不能用于其他 trait

     另外注意将 t 参数的类型从 T 变为了 &amp;T：因为其类型可能不是 Sized 的，所以需要将其置于某种指针之后，在这个例子中选择了引用。
</pre>
</div>
</div>
</div>

<div id="outline-container-org803b9e8" class="outline-2">
<h2 id="org803b9e8">高级函数和闭包</h2>
<div class="outline-text-2" id="text-org803b9e8">
</div>
<div id="outline-container-org934bc66" class="outline-3">
<h3 id="org934bc66">函数指针</h3>
<div class="outline-text-3" id="text-org934bc66">
<pre class="example">
     前面已经讨论过了如何向函数传递闭包，也可以向函数传递常规函数

     这在希望传递已经定义的函数而不是重新定义闭包作为参数是很有用
</pre>
<p>
通过函数指针允许使用函数作为另一个函数的参数。函数的类型是 fn 被称为 <b>函数指针</b> 。指定参数为函数指针的语法类似于闭包，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">add_one</span>(<span style="color: #4eee94;">x</span>: <span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">i32</span> {
    x + 1
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">do_twice</span>(<span style="color: #4eee94;">f</span>: <span style="color: #00bfff; font-weight: bold;">fn</span>(<span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">i32</span>, <span style="color: #4eee94;">arg</span>: <span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">i32</span> {
    f(arg) + f(arg)
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">answer</span> = do_twice(add_one, 5);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"The answer is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, answer);
}
</pre>
</div>

<pre class="example">
这会打印出 The answer is: 12

do_twice 中的 f 被指定为一个接受一个 i32 参数并返回 i32 的 fn。接着就可以在 do_twice 函数体中调用 f。在 main 中，可以将函数名 add_one 作为第一个参数传递给 do_twice

注意： 不要把 fn 和 Fn 闭包 trait 相混淆！ 不同于闭包，fn 是一个类型而不是一个 trait，所以直接指定 fn 作为参数而不是声明一个带有 Fn 作为 trait bound 的泛型参数

</pre>
<p>
函数指针 <b>实现</b> 了所有三个闭包 trait（ <span class="underline">Fn</span> 、 <span class="underline">FnMut</span> 和 <span class="underline">FnOnce</span> ），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 trait 的函数，这样它就能接受函数或闭包作为参数
</p>


<pre class="example">
一个只期望接受 fn 而不接受闭包的情况的例子是与不存在闭包的外部代码交互时：

C 语言的函数可以接受函数作为参数，但 C 语言没有闭包
</pre>
<p>
作为一个既可以使用内联定义的闭包又可以使用命名函数的例子，看看一个 map 的应用。使用 map 函数将一个数字 vector 转换为一个字符串 vector，就可以使用闭包，比如这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">list_of_numbers</span> = <span style="color: #ffd700;">vec!</span>[1, 2, 3];
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">list_of_strings</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
</pre>
</div>
<p>
或者可以将函数作为 map 的参数来代替闭包，像是这样：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">list_of_numbers</span> = <span style="color: #ffd700;">vec!</span>[1, 2, 3];
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">list_of_strings</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = list_of_numbers
    .iter()
    .map(<span style="color: #98f5ff;">ToString</span>::to_string)
    .collect();
</pre>
</div>

<pre class="example">
     注意：这里必须使用 “高级 trait” 部分讲到的完全限定语法，因为存在多个叫做 to_string 的函数

     这里使用了定义于 ToString trait 的 to_string 函数，标准库为所有实现了 Display 的类型实现了这个 trait
</pre>

<p>
另一个实用的模式暴露了 <span class="underline">元组结构体</span> 和元组结构体 <span class="underline">枚举成员</span> 的 <b>实现细节</b> ：
</p>
<ul class="org-ul">
<li>这些项使用 <span class="underline">()</span> 作为初始化语法，这看起来就像 <b>函数调用</b> ，同时它们确实被实现为返回由参数构造的实例的函数</li>
<li>它们也被称为 <span class="underline">实现了闭包 trait</span> 的 <b>函数指针</b> ，并可以采用类似如下的方式调用：</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">enum</span> <span style="color: #98f5ff;">Status</span> {
    <span style="color: #98f5ff;">Value</span>(<span style="color: #98f5ff;">u32</span>),
    <span style="color: #98f5ff;">Stop</span>,
}

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">list_of_statuses</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">Status</span>&gt; =
    (0u32..20)
    .map(<span style="color: #98f5ff;">Status</span>::<span style="color: #98f5ff;">Value</span>)
    .collect();
</pre>
</div>
<p>
这里创建了 Status::Value 实例，它通过 map 把0~20范围的每一个 u32 值调用 Status::Value 的初始化函数
</p>

<pre class="example">
     一些人倾向于函数风格，一些人喜欢闭包

     这两种形式最终都会产生同样的代码，所以请使用对你来说更明白的形式吧
</pre>
</div>
</div>

<div id="outline-container-org8bc492b" class="outline-3">
<h3 id="org8bc492b">返回闭包</h3>
<div class="outline-text-3" id="text-org8bc492b">
<pre class="example">
     闭包表现为 trait，这意味着不能直接返回闭包

     对于大部分需要返回 trait 的情况，可以使用实现了期望返回的 trait 的具体类型来替代函数的返回值
</pre>
<p>
但是不能直接返回闭包，因为他们没有一个可返回的具体类型。也就是说不允许使用函数指针 fn 作为返回值类型，例如下面这段代码尝试直接返回闭包，它并不能编译：　
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">returns_closure</span>() -&gt; <span style="color: #98f5ff;">Fn</span>(<span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">i32</span> {
    |x| x + 1
}
</pre>
</div>

<p>
编译器给出的错误是：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0277]: the trait bound <span style="color: #fa8072;">`std::ops::Fn(i32) -&gt; i32 + 'static:</span>
<span style="color: #fa8072;">std::marker::Sized`</span> is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ <span style="color: #fa8072;">`std::ops::Fn(i32) -&gt; i32 + 'static`</span>
  does not have a constant size known at compile-time
  |
  = help: the trait <span style="color: #fa8072;">`std::marker::Sized`</span> is not implemented for
  <span style="color: #fa8072;">`std::ops::Fn(i32) -&gt; i32 + 'static`</span>
  = note: the return type of a <span style="color: #00bfff; font-weight: bold;">function</span> <span style="color: #daa520; font-weight: bold;">must</span> have a statically known size
</pre>
</div>

<p>
错误又一次指向了 Sized trait！Rust 并不知道需要多少空间来储存闭包。在上一部分见过这种情况的解决办法，可以使用 trait 对象：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">returns_closure</span>() -&gt; <span style="color: #98f5ff;">Box</span>&lt;<span style="color: #00bfff; font-weight: bold;">dyn</span> <span style="color: #98f5ff;">Fn</span>(<span style="color: #98f5ff;">i32</span>) -&gt; <span style="color: #98f5ff;">i32</span>&gt; {
    <span style="color: #98f5ff;">Box</span>::new(|x| x + 1)
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"call return closure: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, returns_closure()(5));
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4b72435" class="outline-2">
<h2 id="org4b72435">宏</h2>
<div class="outline-text-2" id="text-org4b72435">
<pre class="example">
    在本书中已经使用过像 println! 这样的宏了，不过还没完全探索什么是宏以及它是如何工作的
</pre>
<p>
宏指的是 Rust 中一系列的功能： 
</p>
<ul class="org-ul">
<li><span class="underline">声明宏</span> : 使用 <span class="underline">macro_rules!</span></li>
<li><span class="underline">过程宏</span> ：
<ul class="org-ul">
<li><span class="underline">自定义 #[derive] 宏</span> ：在 <span class="underline">结构体</span> 和 <span class="underline">枚举</span> 上指定 <b>通过 derive 属性</b> 添加的 <span class="underline">代码</span></li>
<li><span class="underline">类属性宏</span> ：定义可用于 <b>任意项的自定义属性</b></li>
<li><span class="underline">类函数宏</span> ：看起来像函数不过作用于 <b>作为参数传递的 token</b></li>
</ul></li>
</ul>

<p>
接下来会依次讨论每一种宏，不过首要的是，为什么已经有了函数还需要宏呢？
</p>
</div>

<div id="outline-container-org60eaeb1" class="outline-3">
<h3 id="org60eaeb1">宏和函数的区别</h3>
<div class="outline-text-3" id="text-org60eaeb1">
<p>
从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 <span class="underline">元编程</span> 
</p>
<pre class="example">
     在附录 C 中会探讨 derive 属性，其生成各种 trait 的实现

     在本书中使用过 println! 宏和 vec! 宏

     所有的这些宏以 “展开” 的方式来生成比所手写出的更多的代码
</pre>

<p>
元编程对于 <b>减少</b> 大量编写和维护的 <b>代码</b> 是非常有用的，它也扮演了函数的角色。但宏有一些函数所没有的附加能力
</p>
<ul class="org-ul">
<li>一个 <span class="underline">函数</span> 标签必须 <b>声明</b> 函数 <span class="underline">参数个数</span> 和 <span class="underline">类型</span> ，宏只接受一个 <b>可变参数</b></li>
</ul>
<pre class="example">
   用一个参数调用 println!("hello") 或用两个参数调用 println!("hello {}", name)
</pre>
<ul class="org-ul">
<li>宏可以在 <span class="underline">编译器翻译代码前</span> <b>展开</b></li>
</ul>
<pre class="example">
     例如，宏可以在一个给定类型上实现 trait

     而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现
</pre>

<p>
实现一个宏而不是函数的消极面是 <b>宏定义要比函数定义更复杂</b> 
</p>
<pre class="example">
     因为正在编写生成 Rust 代码的 Rust 代码

     由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护
</pre>

<p>
宏和函数的最后一个重要的区别是：在 <span class="underline">调用宏之前</span> 必须 <b>定义</b> 并将其 <b>引入作用域</b> ，而函数则可以在任何地方定义和调用
</p>
</div>
</div>

<div id="outline-container-orge1dd60a" class="outline-3">
<h3 id="orge1dd60a">macro_rules! 定义宏</h3>
<div class="outline-text-3" id="text-orge1dd60a">
<p>
Rust 最常用的宏形式是 <span class="underline">声明宏</span> 。它们有时也被称为 <span class="underline">macro_rules! 宏</span> 或者就是 <span class="underline">macros</span> 。其核心概念是，声明宏允许编写一些类似 Rust <span class="underline">match 表达式</span> 的代码
</p>

<pre class="example">
match 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码
</pre>

<p>
宏也将一个 <span class="underline">值</span> 和 <span class="underline">包含相关代码的模式</span> 进行比较：
</p>
<ul class="org-ul">
<li>值：传递给宏的 <span class="underline">Rust 源代码字面值</span></li>
<li>模式：用于和传递给宏的源代码进行比较，同时 <span class="underline">每个模式的相关代码</span> 则用于 <b>替换</b> <span class="underline">传递给宏的代码</span></li>
<li>所有这一切都发生于 <span class="underline">编译</span> 时</li>
</ul>

<p>
Rust 使用 macro_rules! 来定义宏。先通过 vec! 宏来探索如何使用 macro_rules! 结构。例如可以用三个整数创建一个 vector：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">v</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">u32</span>&gt; = <span style="color: #ffd700;">vec!</span>[1, 2, 3];
</pre>
</div>

<pre class="example">
     也可以使用 vec! 宏来构造两个整数的 vector 或五个字符串 slice 的 vector

     但却无法使用函数做相同的事情，因为无法预先知道参数值的数量和类型
</pre>

<p>
下面展示了一个 vec! 稍微简化的定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">#[macro_export]</span>
<span style="color: #ffd700;">macro_rules!</span> vec {
    ( $( <span style="color: #4eee94;">$x</span>:expr ),* ) =&gt; {
        {
            <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">temp_vec</span> = <span style="color: #98f5ff;">Vec</span>::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</pre>
</div>

<pre class="example">
     注意：标准库中实际定义的 vec! 包括预分配适当量的内存的代码。这部分为代码优化，为了让示例简化，此处并没有包含在内
</pre>
<ul class="org-ul">
<li>无论何时导入定义了宏的包， <span class="underline">#[macro_export] 注解</span> 说明宏应该是 <b>可用</b> 的。 如果没有该注解，这个宏不能被引入作用域</li>
<li>接着使用 <span class="underline">macro_rules!</span> 和 <span class="underline">宏名称</span> 开始宏 <b>定义</b> ，且所定义的宏并 <b>不带</b> 感叹号。名字后跟 <span class="underline">大括号</span> 表示宏 <b>定义体</b> ，在该例中宏名称是 vec</li>
<li>vec! 宏的结构和 match 表达式的结构类似。此处有一个单边模式 <span class="underline">( $( $x:expr ),* )</span> ，后跟 <span class="underline">=&gt;</span> 以及和 <span class="underline">模式相关的代码块</span> 。如果模式匹配，该相关代码块将被执行。假设这是这个宏中唯一的模式，则只有这一种有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。
<ul class="org-ul">
<li>一对 <span class="underline">()</span> 包含了 <b>全部模式</b> 。接下来是后跟一对括号的美元符号 <span class="underline">$()</span> ，其通过 <span class="underline">替代代码</span> <b>捕获</b> 了 <span class="underline">符合括号内模式的值</span> 。$() 内则是 <span class="underline">$x:expr</span> ，其匹配 Rust 的 <b>任意表达式</b> 或 <b>给定 $x 名字的表达式</b></li>
<li>$() 之后的 <span class="underline">逗号</span> 说明一个 <b>逗号分隔符</b> 可以有选择的 <b>出现</b> 代码之后，这段代码与在 $() 中所捕获的代码相匹配</li>
<li>紧随逗号之后的 <span class="underline">*</span> 说明该模式 <b>匹配</b> <span class="underline">零个</span> 或 <span class="underline">多个</span> * 之前的任何模式</li>
</ul></li>
</ul>
<pre class="example">
     宏定义中有效模式语法和在上一章提及的模式语法是不同的，因为宏模式所匹配的是 Rust 代码结构而不是值

     当以 vec![1, 2, 3]; 调用宏时，$x 模式与三个表达式 1、2 和 3 进行了三次匹配
</pre>

<p>
现在来看看这个出现在与此单边模式相关的代码块中的模式：
</p>
<ul class="org-ul">
<li>在 <span class="underline">$()*</span> 部分中所生成的 temp_vec.push() 为在匹配到模式中的 <span class="underline">$()</span> 每一部分而生成</li>
<li>$x 由每个与之相匹配的表达式所替换</li>
</ul>

<p>
所以当 vec![1, 2, 3]; 调用该宏时，替换该宏调用所生成的代码会是下面这样：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">temp_vec</span> = <span style="color: #98f5ff;">Vec</span>::new();
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#19979;&#38754;&#19977;&#34892;&#23601;&#26159;$x&#34987;&#23454;&#38469;&#35843;&#29992;&#20013;&#30340;&#26367;&#25442;&#30340;&#20195;&#30721;</span>
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</pre>
</div>

<p>
这样就已经定义了一个宏，其可以接收任意数量和类型的参数，同时可以生成能够创建包含指定元素的 vector 的代码
</p>

<pre class="example">
macro_rules! 中有一些奇怪的地方。会有第二种采用 macro 关键字的声明宏，其工作方式类似但修复了这些极端情况。在此之后，macro_rules! 实际上就过时了

同时鉴于大多数 Rust 程序员“使用”宏而非“编写”宏的事实，此处不再深入探讨 macro_rules!
</pre>
</div>
</div>
<div id="outline-container-orge3d49b9" class="outline-3">
<h3 id="orge3d49b9">用于从属性生成代码的过程宏</h3>
<div class="outline-text-3" id="text-orge3d49b9">
<p>
第二种形式的宏被称为 <span class="underline">过程宏</span> ，因为它们更像函数（一种过程类型）
</p>
<pre class="example">
     过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出

     不是像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码
</pre>
<p>
有三种类型的过程宏，它们的工作方式都类似:
</p>
<ol class="org-ol">
<li>自定义 derive</li>
<li>类属性</li>
<li>类函数</li>
</ol>

<p>
当创建过程宏时，其定义必须位于一种特殊类型的属于它们自己的 crate 中
</p>
<pre class="example">
   这么做出于复杂的技术原因，将来希望能够消除这些限制
</pre>

<p>
使用这些宏需采用类似下面所示的代码形式，其中 <span class="underline">some_attribute</span> 是一个使用特定宏的 <b>占位符</b> 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">proc_macro</span>;

<span style="color: #ffd700;">#[some_attribute]</span>
<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">some_name</span>(<span style="color: #4eee94;">input</span>: <span style="color: #98f5ff;">TokenStream</span>) -&gt; <span style="color: #98f5ff;">TokenStream</span> {
}
</pre>
</div>
<p>
上面的过程宏包含一个函数，这个函数接受一个 TokenStream 作为输入并产生一个 TokenStream 作为输出。这也就是宏的核心：宏所处理的源代码组成了输入 TokenStream，同时宏生成的代码是输出 TokenStream：
</p>
<ul class="org-ul">
<li>函数上有一个属性；这个属性表明过程宏的类型</li>
<li>在同一 crate 中可以有多种的过程宏</li>
</ul>
<pre class="example">
     这也是其得名的原因：“过程” 是 “函数” 的同义词

     那么为何不叫 “函数宏” 呢？因为有一个过程宏是 “类函数” 的，叫成函数会产生混乱
</pre>
</div>

<div id="outline-container-org0d1c5f9" class="outline-4">
<h4 id="org0d1c5f9">编写自定义 derive 宏</h4>
<div class="outline-text-4" id="text-org0d1c5f9">
<p>
创建一个 hello_macro crate，其包含名为 HelloMacro 的 trait 和关联函数 hello_macro。不同于让 crate 的用户为其每一个类型实现 HelloMacro trait，将会提供一个过程式宏以便用户可以使用 #[derive(HelloMacro)] 注解他们的类型来得到 hello_macro 函数的默认实现。该默认实现会打印 Hello, Macro! My name is TypeName!，其中 TypeName 为定义了 trait 的类型名。换言之，会创建一个 crate，使程序员能够写类似下面的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">hello_macro</span>::<span style="color: #98f5ff;">HelloMacro</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">hello_macro_derive</span>::<span style="color: #98f5ff;">HelloMacro</span>;

<span style="color: #ffd700;">#[derive(HelloMacro)]</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Pancakes</span>;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #98f5ff;">Pancakes</span>::hello_macro();
}
</pre>
</div>
<p>
运行该代码将会打印 "Hello, Macro! My name is Pancakes!" 首先像下面这样新建一个库 crate：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo new hello_macro --lib
</pre>
</div>
<p>
接下来定义 HelloMacro trait 以及其关联函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">trait</span> <span style="color: #98f5ff;">HelloMacro</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">hello_macro</span>();
}
</pre>
</div>

<p>
此时，crate 用户可以实现该 trait 以达到其期望的功能，像这样：
</p>
<div class="org-src-container">
<pre class="src src-rust">
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">hello_macro</span>::<span style="color: #98f5ff;">HelloMacro</span>;

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Pancakes</span>;

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">HelloMacro</span> <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #98f5ff;">Pancakes</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">hello_macro</span>() {
        <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Hello, Macro! My name is Pancakes!"</span>);
    }
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #98f5ff;">Pancakes</span>::hello_macro();
}
</pre>
</div>

<pre class="example">
      然而，需要为每一个想使用 hello_macro 的类型编写实现的代码块。我们希望为其节约这些工作

      另外，也无法为 hello_macro 函数提供一个能够打印实现了该 trait 的类型的名字的默认实现：Rust 没有反射的能力，因此其无法在运行时获取类型名

      所以我们需要一个在运行时生成代码的宏
</pre>
</div>

<div id="outline-container-orgf8f0c30" class="outline-5">
<h5 id="orgf8f0c30">新建过程宏creat</h5>
<div class="outline-text-5" id="text-orgf8f0c30">
<p>
下一步是定义过程式宏：
</p>
<pre class="example">
       构造 crate 和其中宏的惯例如下：对于一个 foo 的包来说，一个自定义的派生过程宏的包被称为 foo_derive 

       到目前为止过程式宏必须在其自己的 crate 内，该限制最终可能被取消
</pre>

<p>
在 hello_macro 项目中新建名为 hello_macro_derive 的包：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo new hello_macro_derive --lib
</pre>
</div>

<pre class="example">
       由于两个 crate 紧密相关，因此在 hello_macro 包的目录下创建过程式宏的 crate

       如果改变在 hello_macro 中定义的 trait ，同时也必须改变在 hello_macro_derive 中实现的过程式宏

       这两个包需要分别发布，编程人员如果使用这些包，则需要同时添加这两个依赖并将其引入作用域

       也可以只用 hello_macro 包而将 hello_macro_derive 作为一个依赖，并重新导出过程式宏的代码，但这里组织项目的方式使编程人员使用 hello_macro 成为可能，即使他们无需 derive 的功能
</pre>

<p>
需要将 hello_macro_derive 声明为一个过程宏的 crate。同时也需要 syn 和 quote crate 中的功能，正如注释中所说，需要将其加到依赖中。为 hello_macro_derive 将下面的代码加入到 Cargo.toml 文件中：
</p>

<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98f5ff;">lib</span>]
<span style="color: #4eee94;">proc-macro</span> = <span style="color: #ffd700;">true</span>

[<span style="color: #98f5ff;">dependencies</span>]
<span style="color: #4eee94;">syn</span> = <span style="color: #deb887;">"0.14.4"</span>
<span style="color: #4eee94;">quote</span> = <span style="color: #deb887;">"0.6.3"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org994465d" class="outline-5">
<h5 id="org994465d">定义宏函数</h5>
<div class="outline-text-5" id="text-org994465d">
<p>
为定义一个过程式宏，请将下面代码放在 hello_macro_derive crate 的 src/lib.rs 文件里面
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #00bfff; font-weight: bold;">crate</span> proc_macro;

<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #00bfff; font-weight: bold;">crate</span>::<span style="color: #ffd700;">proc_macro</span>::<span style="color: #98f5ff;">TokenStream</span>;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">quote</span>::quote;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">syn</span>;

<span style="color: #ffd700;">#[proc_macro_derive(HelloMacro)]</span>
<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">hello_macro_derive</span>(<span style="color: #4eee94;">input</span>: <span style="color: #98f5ff;">TokenStream</span>) -&gt; <span style="color: #98f5ff;">TokenStream</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26500;&#24314; Rust &#20195;&#30721;&#25152;&#20195;&#34920;&#30340;&#35821;&#27861;&#26641;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#20415;&#21487;&#20197;&#36827;&#34892;&#25805;&#20316;</span>
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">ast</span> = <span style="color: #ffd700;">syn</span>::parse(input).unwrap();

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26500;&#24314; trait &#23454;&#29616;</span>
    impl_hello_macro(&amp;ast)
}
</pre>
</div>

<pre class="example">
hello_macro_derive 函数中代码分割的方式，它负责解析 TokenStream，而 impl_hello_macro 函数则负责转换语法树：这让编写一个过程式宏更加方便

外部函数中的代码（在这里是 hello_macro_derive）几乎在所有你能看到或创建的过程宏 crate 中都一样

内部函数（在这里是 impl_hello_macro）的函数体中所指定的代码则依过程宏的目的而各有不同
</pre>

<p>
当用户在 <span class="underline">一个类型</span> 上 <b>指定</b> <span class="underline">#[derive(HelloMacro)]</span> 时， <span class="underline">hello_macro_derive 函数</span> 将会被 <b>调用</b> 
</p>
<pre class="example">
     原因在于已经使用 proc_macro_derive 及其指定名称对 hello_macro_derive 函数进行了注解：HelloMacro ，其匹配到 trait 名，这是大多数过程宏遵循的习惯
</pre>
</div>
</div>

<div id="outline-container-orga8f4c06" class="outline-5">
<h5 id="orga8f4c06">宏依赖</h5>
<div class="outline-text-5" id="text-orga8f4c06">
<p>
现在，已经引入了三个新的 crate： <span class="underline">proc_macro</span> 、 <span class="underline">syn</span> 和 <span class="underline">quote</span> ：
</p>
<ul class="org-ul">
<li>Rust 自带 proc_macro crate，因此无需将其加到 Cargo.toml 文件的依赖中。proc_macro crate 是 <b>编译器用来读取和操作</b> 我们 Rust 代码的 API</li>
<li>syn crate 将 <span class="underline">字符串中的 Rust 代码</span> <b>解析</b> 成为一个 <span class="underline">可以操作的数据结构</span></li>
<li>quote 则将 <span class="underline">syn 解析的数据结构</span> 反过来 <b>传入</b> 到 <span class="underline">Rust 代码</span> 中</li>
</ul>

<pre class="example">
     这些 crate 让解析任何所要处理的 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作
</pre>
</div>
</div>

<div id="outline-container-orged9339f" class="outline-5">
<h5 id="orged9339f">解析输入</h5>
<div class="outline-text-5" id="text-orged9339f">
<p>
hello_macro_derive 函数首先将来自 TokenStream 的 input 转换为一个可以解释和操作的数据结构。这正是 syn 派上用场的地方。syn 中的 <span class="underline">parse_derive_input 函数</span> 获取一个 TokenStream 并返回一个表示解析出 Rust 代码的 DeriveInput 结构体。下面展示了从字符串 struct Pancakes; 中解析出来的 DeriveInput 结构体的相关部分：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #98f5ff;">DeriveInput</span> {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

    <span style="color: #4eee94;">ident</span>: <span style="color: #98f5ff;">Ident</span> {
        <span style="color: #4eee94;">ident</span>: <span style="color: #deb887;">"Pancakes"</span>,
        <span style="color: #4eee94;">span</span>: #0 bytes(95..103)
    },
    <span style="color: #4eee94;">data</span>: <span style="color: #98f5ff;">Struct</span>(
        <span style="color: #98f5ff;">DataStruct</span> {
            <span style="color: #4eee94;">struct_token</span>: <span style="color: #98f5ff;">Struct</span>,
            <span style="color: #4eee94;">fields</span>: <span style="color: #98f5ff;">Unit</span>,
            <span style="color: #4eee94;">semi_token</span>: <span style="color: #98f5ff;">Some</span>(
                <span style="color: #98f5ff;">Semi</span>
            )
        }
    )
}
</pre>
</div>

<pre class="example">
       该结构体的字段展示了解析的 Rust 代码是一个类单元结构体，其 ident（ identifier，表示名字）为 Pancakes

       该结构体里面有更多字段描述了所有类型的 Rust 代码，查阅 syn 中 DeriveInput 的文档 以获取更多信息
</pre>
<ul class="org-ul">
<li>此时，尚未定义 impl_hello_macro 函数，但在此之前，注意其输出也是 TokenStream。所返回的 TokenStream 会被加到我们的 crate 用户所写的代码中，因此，当用户编译他们的 crate 时，他们会获取到所提供的额外功能</li>
<li>当调用 parse_derive_input 或 parse 失败时。在错误时 panic 对过程宏来说是必须的，因为 proc_macro_derive 函数必须返回 TokenStream 而不是 Result，以此来符合过程宏的 API</li>
</ul>

<pre class="example">
       这里选择用 unwrap 来简化了这个例子

       在生产代码中，则应该通过 panic! 或 expect 来提供关于发生何种错误的更加明确的错误信息
</pre>
</div>
</div>

<div id="outline-container-orgd84d6b1" class="outline-5">
<h5 id="orgd84d6b1">实现宏</h5>
<div class="outline-text-5" id="text-orgd84d6b1">
<p>
现在有了将注解的 Rust 代码从 TokenStream 转换为 DeriveInput 实例的代码，来创建在注解类型上实现 HelloMacro trait 的代码，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">impl_hello_macro</span>(<span style="color: #4eee94;">ast</span>: &amp;<span style="color: #ffd700;">syn</span>::<span style="color: #98f5ff;">DeriveInput</span>) -&gt; <span style="color: #98f5ff;">TokenStream</span> {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">name</span> = &amp;ast.ident;
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">gen</span> = <span style="color: #ffd700;">quote!</span> {
        <span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">HelloMacro</span> <span style="color: #00bfff; font-weight: bold;">for</span> #name {
            <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">hello_macro</span>() {
                <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Hello, Macro! My name is </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, <span style="color: #ffd700;">stringify!</span>(#name));
            }
        }
    };
    gen.into()
}
</pre>
</div>
<p>
首先得到一个包含以 <span class="underline">ast.ident</span> 作为 <b>注解类型名字</b> （标识符）的 Ident 结构体实例
</p>
<pre class="example">
       前面的结构体表明当 impl_hello_macro 函数运行时 ident 字段的值是 "Pancakes"

       因此，这里 name 变量会包含一个 Ident 结构体的实例，当打印时，会是字符串 "Pancakes"
</pre>
<p>
<span class="underline">quote! 宏</span> 使得可以 <b>编写</b> <span class="underline">希望返回的 Rust 代码</span> ：
</p>
<ul class="org-ul">
<li>quote! 宏执行的直接结果并不是编译器所期望的并需要转换为 TokenStream。为此需要调用 <span class="underline">into</span> 方法：
<ul class="org-ul">
<li>它会 <b>消费</b> 这个 <span class="underline">中间表示</span> IR</li>
<li><b>返回</b> 所需的 <span class="underline">TokenStream 类型值</span></li>
</ul></li>
</ul>

<pre class="example">
       这个宏也提供了一些非常酷的模板机制；

       可以写 #name ，然后 quote! 会以名为 name 的变量值来替换它。甚至可以做一些类似常用宏那样的重复代码的工作
</pre>
<p>
这里期望我们的过程式宏能够为通过 #name 获取到的用户注解类型生成 HelloMacro trait 的实现。该 trait 的实现有一个函数 hello_macro ，其函数体包括了期望提供的功能：打印 Hello, Macro! My name is 和注解的类型名
</p>

<pre class="example">
此处所使用的 stringify! 为 Rust 内置宏。其接收一个 Rust 表达式，如 1 + 2 ， 然后在编译时将表达式转换为一个字符串常量，如 "1 + 2"

这与 format! 或 println! 是不同的，它计算表达式并将结果转换为 String

有一种可能的情况是，所输入的 #name 可能是一个需要打印的表达式，因此我们用 stringify!

stringify! 编译时也保留了一份将 #name 转换为字符串之后的内存分配
</pre>
</div>
</div>

<div id="outline-container-orgfc83293" class="outline-5">
<h5 id="orgfc83293">使用过程宏</h5>
<div class="outline-text-5" id="text-orgfc83293">
<pre class="example">
     此时，cargo build 应该都能成功编译 hello_macro 和 hello_macro_derive 
</pre>
<p>
现在将这些 crate 连接到最开头的代码中来看看过程宏的行为。首先新建一个二进制项目pancakes: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo new pancakes 
</pre>
</div>

<p>
将 hello_macro 和 hello_macro_derive 作为依赖加到 pancakes 包的 Cargo.toml 文件中去。如果没有将 hello_macro 和 hello_macro_derive 的版本发布到 crates.io 上，则可以像下面这样将其指定为 path 依赖：
</p>
<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98f5ff;">dependencies</span>]
<span style="color: #4eee94;">hello_macro</span> = { path = <span style="color: #deb887;">"../hello_macro"</span> }
<span style="color: #4eee94;">hello_macro_derive</span> = { path = <span style="color: #deb887;">"../hello_macro/hello_macro_derive"</span> }
</pre>
</div>

<p>
测试：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
</pre>
</div>

<p>
应该打印：
</p>

<div class="org-src-container">
<pre class="src src-sh">Hello, Macro! My name is Pancakes!
</pre>
</div>
<p>
其包含了该过程宏中 HelloMacro trait 的实现，而无需 pancakes crate 实现它，因为 <span class="underline">#[derive(HelloMacro)]</span> <b>增加</b> 了该 <span class="underline">trait 实现</span> 
</p>
</div>
</div>
</div>

<div id="outline-container-org2893e9f" class="outline-4">
<h4 id="org2893e9f">类属性宏</h4>
<div class="outline-text-4" id="text-org2893e9f">
<p>
类属性宏与自定义派生宏相似，不同于为 derive 属性生成代码，它们允许你 <b>创建</b> <span class="underline">新的属性</span> 。它们也更为灵活：
</p>
<ul class="org-ul">
<li>derive 只能用于 <span class="underline">结构体</span> 和 <span class="underline">枚举</span></li>
<li>属性还可以用于其它的项，比如函数</li>
</ul>

<p>
作为一个使用类属性宏的例子，可以创建一个名为 <span class="underline">route 的属性</span> 用于 <b>注解</b> <span class="underline">web 应用程序框架</span> 的函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">#[route(GET, </span><span style="color: #deb887;">"/"</span><span style="color: #ffd700;">)]</span>
<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">index</span>() {
</pre>
</div>

<p>
#[route] 属性将由框架本身定义为一个过程宏。其宏定义的函数签名看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">#[proc_macro_attribute]</span>
<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">route</span>(<span style="color: #4eee94;">attr</span>: <span style="color: #98f5ff;">TokenStream</span>, <span style="color: #4eee94;">item</span>: <span style="color: #98f5ff;">TokenStream</span>) -&gt; <span style="color: #98f5ff;">TokenStream</span> {
</pre>
</div>
<p>
这里有两个 TokenStream 类型的参数：
</p>
<ul class="org-ul">
<li>第一个用于属性内容本身，也就是 GET, "/" 部分</li>
<li>第二个是属性所标记的项，在本例中，是 fn index() {} 和剩下的函数体</li>
</ul>

<pre class="example">
    除此之外，类属性宏与自定义派生宏工作方式一致：创建 proc-macro crate 类型的 crate 并实现希望生成代码的函数！
</pre>
</div>
</div>

<div id="outline-container-org759cc21" class="outline-4">
<h4 id="org759cc21">类函数宏</h4>
<div class="outline-text-4" id="text-org759cc21">
<p>
类函数宏定义看起来像 <span class="underline">函数调用的宏</span> ：
</p>

<pre class="example">
      类似于 macro_rules!，它们比函数更灵活；例如，可以接受未知数量的参数

      然而 macro_rules! 宏只能使用之前 “使用 macro_rules! 的声明宏用于通用元编程” 介绍的类匹配的语法定义

      类函数宏获取 TokenStream 参数，其定义使用 Rust 代码操纵 TokenStream，就像另两种过程宏一样
</pre>

<p>
一个类函数宏例子是可以像这样被调用的 sql! 宏：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">sql</span> = <span style="color: #ffd700;">sql!</span>(<span style="color: #98f5ff;">SELECT</span> * <span style="color: #98f5ff;">FROM</span> posts <span style="color: #98f5ff;">WHERE</span> id=1);
</pre>
</div>

<p>
这个宏会解析其中的 SQL 语句并检查其是否是句法正确的，这是比 macro_rules! 可以做到的更为复杂的处理。sql! 宏应该被定义为如此：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffd700;">#[proc_macro]</span>
<span style="color: #00bfff; font-weight: bold;">pub</span> <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">sql</span>(<span style="color: #4eee94;">input</span>: <span style="color: #98f5ff;">TokenStream</span>) -&gt; <span style="color: #98f5ff;">TokenStream</span> {
</pre>
</div>

<p>
这类似于自定义派生宏的签名：获取括号中的 token，并返回希望生成的代码
</p>

<p>
<a href="web_server.html">Next:最后实践web服务器</a>
</p>

<p>
<a href="pattern.html">Previous:模式匹配</a>
</p>

<p>
<a href="rust.html">Home: 目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
