<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>所有权</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="concept.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">所有权</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org282b1a7">概念</a>
<ul>
<li><a href="#org20c84d3">栈和堆</a></li>
<li><a href="#orgb46b3f9">所有权规则</a></li>
<li><a href="#org4492b33">变量作用域</a>
<ul>
<li><a href="#org145b825">String 类型</a></li>
<li><a href="#org3f2c33a">内存与分配</a>
<ul>
<li><a href="#orge7c5e7e">变量与数据交互的方式（一）：移动</a></li>
<li><a href="#org0349f53">变量与数据交互的方式（二）：克隆</a></li>
<li><a href="#org91615b8">只在栈上的数据：拷贝</a></li>
</ul>
</li>
<li><a href="#org9930369">所有权与函数</a></li>
<li><a href="#org6ac7894">返回值与作用域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf8bccb0">引用与借用</a>
<ul>
<li><a href="#orgef8e6bd">可变引用</a></li>
<li><a href="#org7effd38">悬垂引用</a></li>
<li><a href="#org7c3cd69">引用规则</a></li>
</ul>
</li>
<li><a href="#orgc68adbc">slice</a>
<ul>
<li><a href="#orgb4277a7">字符串 slice</a>
<ul>
<li><a href="#org917c68d">字符串字面值就是 slice</a></li>
<li><a href="#org975166a">字符串 slice 作为参数</a></li>
</ul>
</li>
<li><a href="#org8e08e6e">其他类型的 slice</a></li>
<li><a href="#org42f033e">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  所有权是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收即可保障内存安全

  因此，理解 Rust 中所有权如何工作是十分重要的

  本章将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据
</pre>
<div id="outline-container-org282b1a7" class="outline-2">
<h2 id="org282b1a7">概念</h2>
<div class="outline-text-2" id="text-org282b1a7">
<p>
所有运行的程序都必须管理其使用计算机内存的方式：
</p>
<ul class="org-ul">
<li>一些语言中具有 <span class="underline">垃圾回收</span> 机制，在程序运行时不断地寻找不再使用的内存</li>
<li>在另一些语言中，程序员必须亲自 <span class="underline">分配</span> 和 <span class="underline">释放</span> 内存</li>
<li>Rust 则选择了第三种方式：通过 <span class="underline">所有权</span> 系统管理内存
<ul class="org-ul">
<li><span class="underline">编译器</span> 在 <span class="underline">编译</span> 时会根据一系列的 <span class="underline">规则</span> 进行 <b>检查</b></li>
<li>在运行时，所有权系统的任何功能都不会减慢程序</li>
</ul></li>
</ul>

<pre class="example">
    因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应
    好消息是随着对 Rust 和所有权系统的规则越来越有经验，就越能自然地编写出安全和高效的代码。持之以恒！

    当理解了所有权，将有一个坚实的基础来理解那些使 Rust 独特的功能

    在这节中，将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：“字符串”
</pre>
</div>

<div id="outline-container-org20c84d3" class="outline-3">
<h3 id="org20c84d3">栈和堆</h3>
<div class="outline-text-3" id="text-org20c84d3">
<pre class="example">
     在很多语言中，并不需要经常考虑到栈与堆

     不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择
     会在稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释
</pre>

<p>
<span class="underline">栈</span> 和 <span class="underline">堆</span> 都是代码在运行时 <span class="underline">可供使用的内存</span> ，但是它们的 <b>结构不同</b> ：
</p>
<ul class="org-ul">
<li>栈以 <span class="underline">放入值的顺序</span> <b>存储</b> 值并以 <span class="underline">相反顺序</span> <b>取出</b> 值。这也被称作 <span class="underline">后进先出</span> 
<ul class="org-ul">
<li>增加数据叫做 <span class="underline">进栈</span></li>
<li>移出数据叫做 <span class="underline">出栈</span></li>
</ul></li>
</ul>
<pre class="example">
     想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走

     不能从中间也不能从底部增加或拿走盘子！
</pre>
<ul class="org-ul">
<li>栈中的所有数据都必须占用已知且固定的大小。在 <span class="underline">编译</span> 时 <b>大小未知</b> 或 <b>大小可能变化</b> 的数据，要改为存储在 <span class="underline">堆</span> 上
<ul class="org-ul">
<li>堆是 <b>缺乏组织</b> 的：当向堆 <span class="underline">放入</span> 数据时，要 <b>请求</b> 一定大小的 <b>空间</b> ， <span class="underline">操作系统</span> 在 <span class="underline">堆的某处</span> 找到一块 <span class="underline">足够大的空位</span> ，把它 <b>标记为已使用</b> ，并 <b>返回</b> 一个表示 <span class="underline">该位置地址的指针</span>
<ul class="org-ul">
<li>这个过程称作 <span class="underline">在堆上分配内存</span> ，有时简称为 <span class="underline">分配</span></li>
<li>将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，可以将指针存储在栈上，不过当需要实际数据时，必须访问指针</li>
</ul></li>
</ul></li>
</ul>

<pre class="example">
     想象一下去餐馆就座吃饭

     当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去

     如果有人来迟了，他们也可以通过询问来找到你们坐在哪
</pre>

<p>
<span class="underline">访问堆</span> 上的数据比 <span class="underline">访问栈</span> 上的数据 <b>慢</b> ，因为必须通过 <span class="underline">指针</span> 来访问，现代处理器在内存中跳转越少就越快
</p>

<pre class="example">
     继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜
     在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢

     出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作

     另外，在堆上分配大量的空间也可能消耗时间
</pre>


<ul class="org-ul">
<li>当调用一个函数时， <span class="underline">传递给函数的值</span> （包括可能指向堆上数据的指针）和 <span class="underline">函数的局部变量</span> 被 <b>压入栈</b> 中</li>
<li>当函数结束时，这些值被 <b>移出栈</b></li>
</ul>

<pre class="example">
     跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的

     一旦理解了所有权，就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作
</pre>
</div>
</div>

<div id="outline-container-orgb46b3f9" class="outline-3">
<h3 id="orgb46b3f9">所有权规则</h3>
<div class="outline-text-3" id="text-orgb46b3f9">
<p>
首先，看一下所有权的规则。后面通过举例说明时，请谨记这些规则：
</p>
<ol class="org-ol">
<li>Rust 中的 <span class="underline">每一个值</span> 都有一个被称为其 <span class="underline">所有者</span> 的 <b>变量</b></li>
<li><span class="underline">值</span> <b>有且只有一个</b> <span class="underline">所有者</span></li>
<li>当 <span class="underline">所有者</span> （变量） <b>离开</b> 作用域，这个 <span class="underline">值</span> 将被 <b>丢弃</b></li>
</ol>
</div>
</div>

<div id="outline-container-org4492b33" class="outline-3">
<h3 id="org4492b33">变量作用域</h3>
<div class="outline-text-3" id="text-org4492b33">
<p>
在所有权的第一个例子中，看看一些变量的 <span class="underline">作用域</span> 。作用域是一个 <span class="underline">项</span> 在 <span class="underline">程序</span> 中 <b>有效</b> 的范围。假设有这样一个变量：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #deb887;">"hello"</span>;
</pre>
</div>

<p>
变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从 <span class="underline">声明的点</span> 开始直到 <span class="underline">当前作用域0结束</span> 时都是 <b>有效的</b> 。下面注释标明了变量 s 在何处是有效的：
</p>

<div class="org-src-container">
<pre class="src src-rust">{                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s &#22312;&#36825;&#37324;&#26080;&#25928;, &#23427;&#23578;&#26410;&#22768;&#26126;</span>
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #deb887;">"hello"</span>;   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20174;&#27492;&#22788;&#36215;&#65292;s &#26159;&#26377;&#25928;&#30340;</span>

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992; s</span>
} 
</pre>
</div>

<p>
换句话说，这里有 <b>两个</b> 重要的 <span class="underline">时间点</span> ：
</p>
<ul class="org-ul">
<li>当 s <span class="underline">进入</span> 作用域 时，它就是有效的</li>
<li>这一直持续到它 <span class="underline">离开</span> 作用域 为止</li>
</ul>

<pre class="example">
     目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的

     现在在此基础上介绍 String 类型
</pre>
</div>

<div id="outline-container-org145b825" class="outline-4">
<h4 id="org145b825">String 类型</h4>
<div class="outline-text-4" id="text-org145b825">
<pre class="example">
      这里使用 String 作为例子，并专注于 String 与所有权相关的部分，这些方面也同样适用于标准库提供的或自己创建的其他复杂数据类型

      我们已经见过字符串字面值，字符串值被硬编码进程序里。字符串字面值是很方便的，不过他们并不适合使用文本的每一种场景，原因之一就是他们是不可变的
      另一个原因是并不是所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢
</pre>
<p>
为此，Rust 有第二个字符串类型， <span class="underline">String</span> 。这个类型被 <b>分配到堆</b> 上，所以能够存储在编译时未知大小的文本。可以使用 <span class="underline">from</span> 函数基于字符串字面值来创建 String，如下：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);
</pre>
</div>

<pre class="example">
      这两个冒号 :: 是运算符，允许将特定的 from 函数置于 String 类型的命名空间下，而不需要使用类似 string_from 这样的名字
</pre>

<p>
<b>可以</b> 修改此类字符串：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

s.push_str(<span style="color: #deb887;">", world!"</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">push_str() &#22312;&#23383;&#31526;&#20018;&#21518;&#36861;&#21152;&#23383;&#38754;&#20540;</span>

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, s); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#25171;&#21360; `hello, world!`</span>
</pre>
</div>

<pre class="example">
      那么这里有什么区别呢？为什么 String 可变而字面值却不行呢？

      区别在于两个类型对内存的处理上
</pre>
</div>
</div>

<div id="outline-container-org3f2c33a" class="outline-4">
<h4 id="org3f2c33a">内存与分配</h4>
<div class="outline-text-4" id="text-org3f2c33a">
<pre class="example">
      就字符串字面值来说，在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中

      这使得字符串字面值快速且高效，不过这些特性都只得益于字符串字面值的不可变性

      不幸的是，不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变
</pre>

<p>
对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
</p>
<ul class="org-ul">
<li>必须在运行时向操作系统请求内存</li>
<li>需要一个当处理完 String 时将内存返回给操作系统的方法</li>
</ul>

<pre class="example">
      第一部分由我们完成：当调用 String::from 时，它的实现中请求其所需的内存

      这在编程语言中是非常通用的
</pre>

<pre class="example">
      然而，第二部分实现起来就各有区别了。在有垃圾回收的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它

      没有 GC 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样
      从历史的角度上说正确处理内存回收曾经是一个困难的编程问题
      如果忘记回收了会浪费内存
      如果过早回收了，将会出现无效变量
      如果重复回收，这也是个 bug

      需要精确的为一个 allocate 配对一个 free ！
</pre>

<p>
Rust 采取了一个不同的策略： <b>内存在拥有它的变量离开作用域后就被自动释放</b> 。下面是作用域例子的一个使用 String 而不是字符串字面值的版本：
</p>

<div class="org-src-container">
<pre class="src src-rust">{
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20174;&#27492;&#22788;&#36215;&#65292;s &#26159;&#26377;&#25928;&#30340;</span>

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992; s</span>
}                                  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27492;&#20316;&#29992;&#22495;&#24050;&#32467;&#26463;&#65292;</span>
                                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s &#19981;&#20877;&#26377;&#25928;</span>
</pre>
</div>

<p>
这是一个将 String 需要的内存返回给操作系统的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 会 <b>调用</b> 一个特殊的函数。这个函数叫做 <span class="underline">drop</span> ，在这里 String 的作者可以放置释放内存的代码。Rust <b>在结尾的 } 处自动调用 drop</b> 
</p>

<pre class="example">
      注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化

      如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生

      这个模式对编写 Rust 代码的方式有着深远的影响
      现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时
</pre>
</div>

<div id="outline-container-orge7c5e7e" class="outline-5">
<h5 id="orge7c5e7e">变量与数据交互的方式（一）：移动</h5>
<div class="outline-text-5" id="text-orge7c5e7e">
<p>
Rust 中的多个变量可以采用一种独特的方式与同一数据交互。下面是中一个使用整型的例子：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">x</span> = 5;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">y</span> = x;
</pre>
</div>

<pre class="example">
大致可以猜到这在干什么：

“将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”
现在有了两个变量，x 和 y，都等于 5。这也正是事实上发生了的

因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中
</pre>

<p>
现在看看这个 String 版本：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s2</span> = s1;
</pre>
</div>

<pre class="example">
       这看起来与上面的代码非常类似，所以可能会假设他们的运行方式也是类似的：
       也就是说，第二行可能会生成一个 s1 的拷贝并绑定到 s2 上

       不过，事实上并不完全是这样
</pre>

<p>
看看下图以了解 String 的底层会发生什么。String 由三部分组成：
</p>
<ul class="org-ul">
<li>如图左侧所示，这一组数据 <b>存储在栈</b> 上：
<ul class="org-ul">
<li>一个指向 <span class="underline">存放字符串内容内存</span> 的指针</li>
<li>一个 <span class="underline">长度</span></li>
<li>和一个 <span class="underline">容量</span></li>
</ul></li>
<li><p>
右侧则是 <b>堆上存放内容</b> 的内存部分
</p>


<div class="figure">
<p><object type="image/svg+xml" data="pic/trpl04-01.svg" class="org-svg" width="10%">
Sorry, your browser does not support SVG.</object> 
</p>
</div></li>
</ul>

<pre class="example">
       长度表示 String 的内容当前使用了多少字节的内存
       容量是 String 从操作系统总共获取了多少字节的内存

       长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量
</pre>

<p>
当将 s1 赋值给 s2，String 的数据被复制了，这意味着从 <span class="underline">栈上</span>  <b>拷贝</b> 了它的 <span class="underline">指针</span> 、 <span class="underline">长度</span> 和 <span class="underline">容量</span> 。并 <b>没有复制</b> 指针指向的 <span class="underline">堆上数据</span> 。换句话说，内存中数据的表现如图所示：
</p>


<div class="figure">
<p><object type="image/svg+xml" data="pic/trpl04-02.svg" class="org-svg" width="10%">
Sorry, your browser does not support SVG.</object> 
</p>
</div>

<p>
这个表现形式看起来 并不像图 4-3 中的那样，如果 Rust 也 <b>拷贝</b> 了 <span class="underline">堆上的数据</span> ，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 s2 = s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响
</p>


<div class="figure">
<p><object type="image/svg+xml" data="pic/trpl04-03.svg" class="org-svg" width="10%">
Sorry, your browser does not support SVG.</object> 
</p>
</div>


<pre class="example">
       之前提到过当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存，不过图 4-2 展示了两个数据指针指向了同一位置

       这就有了一个问题：当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做“二次释放”的错误，也是之前提到过的内存安全性 bug 之一

       两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞
</pre>

<p>
为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。 <b>与其尝试拷贝被分配的内存，Rust 则认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西</b> 。看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s2</span> = s1;

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, world!"</span>, s1);
</pre>
</div>

<p>
将会得到一个类似如下的错误，因为 Rust <b>禁止使用无效的引用</b> ：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0382]: use of moved value: <span style="color: #fa8072;">`s1`</span>
 --&gt; src/main.rs:5:28
  |
3 |     <span style="color: #f08080;">let</span> s2 = s1;
  |         -- value moved here
4 |
5 |     println!(<span style="color: #deb887;">"{}, world!"</span>, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because <span style="color: #fa8072;">`s1`</span> has type <span style="color: #fa8072;">`std::string::String`</span>, which does
  not implement the <span style="color: #fa8072;">`Copy`</span> trait
</pre>
</div>

<pre class="example">
       如果在其他语言中听说过术语 浅拷贝 和 深拷贝 ，那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝
</pre>
<p>
不过因为 Rust  <b>同时使第一个变量无效了</b> ，这个操作被称为 <span class="underline">移动</span> ，而不是浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中。那么具体发生了什么，如图 4-4 所示：
</p>


<div class="figure">
<p><object type="image/svg+xml" data="pic/trpl04-04.svg" class="org-svg" width="10%">
Sorry, your browser does not support SVG.</object> 
</p>
</div>


<p>
这样就解决了的问题：因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕
</p>

<pre class="example">
       另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”

       因此，任何“自动的”复制可以被认为对运行时性能影响较小
</pre>
</div>
</div>

<div id="outline-container-org0349f53" class="outline-5">
<h5 id="org0349f53">变量与数据交互的方式（二）：克隆</h5>
<div class="outline-text-5" id="text-org0349f53">
<p>
如果确实需要 <b>深度复制</b> String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <span class="underline">clone</span> 的通用函数，这是一个实际使用 clone 方法的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s2</span> = s1.clone();

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"s1 = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, s2 = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, s1, s2);
</pre>
</div>

<p>
这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据 <b>确实</b> 被复制了
</p>

<pre class="example">
       当出现 clone 调用时，就知道一些特定的代码被执行而且这些代码可能相当消耗资源

       很容易察觉到一些不寻常的事情正在发生
</pre>
</div>
</div>

<div id="outline-container-org91615b8" class="outline-5">
<h5 id="org91615b8">只在栈上的数据：拷贝</h5>
<div class="outline-text-5" id="text-org91615b8">
<p>
这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的，他们是示例 4-2 中的一部分：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">x</span> = 5;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">y</span> = x;

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"x = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, y = </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, x, y);
</pre>
</div>

<pre class="example">
       但这段代码似乎与刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中

       原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效
       换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，可以不用管它
</pre>

<p>
Rust 有一个叫做 <span class="underline">Copy trait</span> 的 <b>特殊注解</b> ，可以用在类似整型这样的存储在栈上的类型上。如果一个类型拥有 Copy trait， <b>一个旧的变量在将其赋值给其他变量后仍然可用</b> 
</p>
<pre class="example">
Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait

如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误

要学习如何为你的类型增加 Copy 注解，请阅读附录 C 中的 “可派生的 trait”
</pre>

<p>
作为一个通用的规则， <b>任何简单标量值的组合</b> 可以是 Copy 的， <b>不需要分配内存或某种形式资源</b> 的类型是 Copy 的。如下是一些 Copy 的类型：
</p>
<ul class="org-ul">
<li>所有 <span class="underline">整数</span> 类型，比如 u32</li>
<li><span class="underline">布尔</span> 类型 bool，它的值是 true 和 false</li>
<li>所有 <span class="underline">浮点数</span> 类型，比如 f64</li>
<li><span class="underline">字符</span> 类型，char</li>
<li><span class="underline">元组</span> ， <b>当且仅当其包含的类型</b> 也都是 Copy 的时候
<ul class="org-ul">
<li>比如，(i32, i32) 是 Copy 的</li>
<li>但 <span class="underline">(i32, String)</span> 就不是</li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org9930369" class="outline-4">
<h4 id="org9930369">所有权与函数</h4>
<div class="outline-text-4" id="text-org9930369">
<p>
将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会 <span class="underline">移动</span> 或者 <span class="underline">复制</span> ，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s &#36827;&#20837;&#20316;&#29992;&#22495;</span>

    takes_ownership(s);             <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s &#30340;&#20540;&#31227;&#21160;&#21040;&#20989;&#25968;&#37324; ...</span>
                                    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">... &#25152;&#20197;&#21040;&#36825;&#37324;&#19981;&#20877;&#26377;&#25928;</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">x</span> = 5;                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">x &#36827;&#20837;&#20316;&#29992;&#22495;</span>

    makes_copy(x);                  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">x &#24212;&#35813;&#31227;&#21160;&#20989;&#25968;&#37324;&#65292;</span>
                                    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20294; i32 &#26159; Copy &#30340;&#65292;&#25152;&#20197;&#22312;&#21518;&#38754;&#21487;&#32487;&#32493;&#20351;&#29992; x</span>

} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;, x &#20808;&#31227;&#20986;&#20102;&#20316;&#29992;&#22495;&#65292;&#28982;&#21518;&#26159; s&#12290;&#20294;&#22240;&#20026; s &#30340;&#20540;&#24050;&#34987;&#31227;&#36208;&#65292;</span>
  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25152;&#20197;&#19981;&#20250;&#26377;&#29305;&#27530;&#25805;&#20316;</span>

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">takes_ownership</span>(<span style="color: #4eee94;">some_string</span>: <span style="color: #98f5ff;">String</span>) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">some_string &#36827;&#20837;&#20316;&#29992;&#22495;</span>
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, some_string);
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#65292;some_string &#31227;&#20986;&#20316;&#29992;&#22495;&#24182;&#35843;&#29992; `drop` &#26041;&#27861;&#12290;&#21344;&#29992;&#30340;&#20869;&#23384;&#34987;&#37322;&#25918;</span>

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">makes_copy</span>(<span style="color: #4eee94;">some_integer</span>: <span style="color: #98f5ff;">i32</span>) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">some_integer &#36827;&#20837;&#20316;&#29992;&#22495;</span>
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, some_integer);
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#65292;some_integer &#31227;&#20986;&#20316;&#29992;&#22495;&#12290;&#19981;&#20250;&#26377;&#29305;&#27530;&#25805;&#20316;</span>
</pre>
</div>

<p>
当尝试在调用 <span class="underline">takes_ownership</span> 后使用 <span class="underline">s</span> 时，Rust 会抛出一个 <b>编译时错误</b> 
</p>

<pre class="example">
      这些静态检查使我们免于犯错

      试试在 main 函数中添加使用 s 和 x 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做
</pre>
</div>
</div>

<div id="outline-container-org6ac7894" class="outline-4">
<h4 id="org6ac7894">返回值与作用域</h4>
<div class="outline-text-4" id="text-org6ac7894">
<p>
返回值也可以转移所有权。示例 4-4 与示例 4-3 一样带有类似的注释：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = gives_ownership();         <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">gives_ownership &#23558;&#36820;&#22238;&#20540;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31227;&#32473; s1</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s2</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);     <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s2 &#36827;&#20837;&#20316;&#29992;&#22495;</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s3</span> = takes_and_gives_back(s2);  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s2 &#34987;&#31227;&#21160;&#21040;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">takes_and_gives_back &#20013;, </span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23427;&#20063;&#23558;&#36820;&#22238;&#20540;&#31227;&#32473; s3</span>
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;, s3 &#31227;&#20986;&#20316;&#29992;&#22495;&#24182;&#34987;&#20002;&#24323;&#12290;s2 &#20063;&#31227;&#20986;&#20316;&#29992;&#22495;&#65292;&#20294;&#24050;&#34987;&#31227;&#36208;&#65292;</span>
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25152;&#20197;&#20160;&#20040;&#20063;&#19981;&#20250;&#21457;&#29983;&#12290;s1 &#31227;&#20986;&#20316;&#29992;&#22495;&#24182;&#34987;&#20002;&#24323;</span>

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">gives_ownership</span>() -&gt; <span style="color: #98f5ff;">String</span> {             <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">gives_ownership &#23558;&#36820;&#22238;&#20540;&#31227;&#21160;&#32473;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35843;&#29992;&#23427;&#30340;&#20989;&#25968;</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">some_string</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">some_string &#36827;&#20837;&#20316;&#29992;&#22495;.</span>

    some_string                              <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238; some_string &#24182;&#31227;&#20986;&#32473;&#35843;&#29992;&#30340;&#20989;&#25968;</span>
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">takes_and_gives_back &#23558;&#20256;&#20837;&#23383;&#31526;&#20018;&#24182;&#36820;&#22238;&#35813;&#20540;</span>
<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">takes_and_gives_back</span>(<span style="color: #4eee94;">a_string</span>: <span style="color: #98f5ff;">String</span>) -&gt; <span style="color: #98f5ff;">String</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">a_string &#36827;&#20837;&#20316;&#29992;&#22495;</span>

    a_string  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238; a_string &#24182;&#31227;&#20986;&#32473;&#35843;&#29992;&#30340;&#20989;&#25968;</span>
}
</pre>
</div>


<p>
变量的所有权总是遵循相同的模式：
</p>
<ul class="org-ul">
<li><b>将值赋给另一个变量时移动它</b></li>
<li>当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有</li>
</ul>

<pre class="example">
      在每一个函数中都获取所有权并接着返回所有权有些啰嗦

      如果想要函数使用一个值但不获取所有权该怎么办呢？如果还要接着使用它的话，每次都传进去再返回来就有点烦人了

      除此之外，也可能想返回函数体中产生的一些数据
</pre>

<p>
可以使用 <span class="underline">元组</span> 来返回多个值（其中包含想要接着使用的变量，比如下面calculte_length中的参数s），如下面示例所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> (s2, len) = calculate_length(s1);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"The length of '</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">' is </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">."</span>, s2, len);
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">calculate_length</span>(<span style="color: #4eee94;">s</span>: <span style="color: #98f5ff;">String</span>) -&gt; (<span style="color: #98f5ff;">String</span>, <span style="color: #98f5ff;">usize</span>) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">length</span> = s.len(); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">len() &#36820;&#22238;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230;</span>

    (s, length)
}
</pre>
</div>

<pre class="example">
      但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个功能，叫做“引用“
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf8bccb0" class="outline-2">
<h2 id="orgf8bccb0">引用与借用</h2>
<div class="outline-text-2" id="text-orgf8bccb0">
<pre class="example">
    上面实例中的元组代码有这样一个问题：
    必须将 String 返回给调用函数，以便在调用 calculate_length 后仍能使用 String，因为 String 被移动到了 calculate_length 内
</pre>

<p>
下面是如何定义并使用一个（新的）calculate_length 函数，它以一个 <b>对象的引用</b> 作为参数而不是 <span class="underline">获取值的所有权</span> ：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = calculate_length(&amp;s1);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"The length of '</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">' is </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">."</span>, s1, len);
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">calculate_length</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; <span style="color: #98f5ff;">usize</span> {
    s.len()
}
</pre>
</div>

<p>
注意：
</p>
<ul class="org-ul">
<li>变量声明和函数返回值中的所有元组代码都消失了</li>
<li>在函数定义中，获取 <b>&amp;String</b> 而不是 <span class="underline">String</span> 
<ul class="org-ul">
<li>传递 <b>&amp;s1</b> 给 calculate_length</li>
</ul></li>
</ul>

<p>
这里的 <span class="underline">&amp;</span> 符号就是 <b>引用</b> ，它们 <b>允许使用值</b> 但 <b>不获取其所有权</b> 。下图展示了一张示意图：
</p>


<div class="figure">
<p><object type="image/svg+xml" data="pic/trpl04-05.svg" class="org-svg" width="10%">
Sorry, your browser does not support SVG.</object> 
</p>
</div>

<pre class="example">
    注意：与使用 &amp; 引用相反的操作是 解引用，它使用解引用运算符 '*' 
</pre>

<p>
仔细看看这个函数调用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s1</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = calculate_length(&amp;s1);
</pre>
</div>

<pre class="example">
&amp;s1 语法创建了一个”指向值s1的引用“，但是并不拥有它

因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃
</pre>

<p>
同理， <span class="underline">函数签名</span> 使用 <span class="underline">&amp;</span> 来表明 <span class="underline">参数s的类型</span> 是一个 <b>引用</b> ： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">calculate_length</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; <span style="color: #98f5ff;">usize</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s &#26159;&#23545; String &#30340;&#24341;&#29992;</span>
    s.len()
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#65292;s &#31163;&#24320;&#20102;&#20316;&#29992;&#22495;&#12290;&#20294;&#22240;&#20026;&#23427;&#24182;&#19981;&#25317;&#26377;&#24341;&#29992;&#20540;&#30340;&#25152;&#26377;&#26435;&#65292;</span>
  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25152;&#20197;&#20160;&#20040;&#20063;&#19981;&#20250;&#21457;&#29983;</span>
</pre>
</div>

<pre class="example">
”变量s有效的作用域“ 与 ”函数参数的作用域“一样，不过当引用离开作用域后并不丢弃它指向的数据，因为没有所有权

当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权
</pre>

<p>
将 <span class="underline">获取引用</span> 作为 <span class="underline">函数参数</span> 称为 <b>借用</b> 
</p>
<pre class="example">
    正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，但当你使用完毕，必须还回去
</pre>

<p>
如果尝试修改借用的变量呢？
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

    change(&amp;s);
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">change</span>(<span style="color: #4eee94;">some_string</span>: &amp;<span style="color: #98f5ff;">String</span>) {
    some_string.push_str(<span style="color: #deb887;">", world"</span>);
}
</pre>
</div>

<p>
编译时会报错：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run 
   Compiling change_reference v0.1.0 (/home/klose/Documents/programming/html/klose911.github.io/src/rust/src/ownership/change_reference)
error[E0596]: cannot borrow <span style="color: #fa8072;">`*some_string`</span> as mutable, as it is behind a <span style="color: #fa8072;">`&amp;`</span> reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: <span style="color: #fa8072;">`&amp;mut std::string::String`</span>
8 |     some_string.push_str(<span style="color: #deb887;">", world"</span>);
  |     ^^^^^^^^^^^ <span style="color: #fa8072;">`some_string`</span> is a <span style="color: #fa8072;">`&amp;`</span> reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try <span style="color: #fa8072;">`rustc --explain E0596`</span><span style="color: #f08080;">.</span>
error: Could not compile <span style="color: #fa8072;">`change_reference`</span><span style="color: #f08080;">.</span>

To learn more, run the command again with --verbose.
</pre>
</div>

<p>
正如变量默认是不可变的，引用也一样。 <b>默认不允许修改引用的值</b> 
</p>
</div>

<div id="outline-container-orgef8e6bd" class="outline-3">
<h3 id="orgef8e6bd">可变引用</h3>
<div class="outline-text-3" id="text-orgef8e6bd">
<p>
通过一个小调整就能修复上面示例代码中的错误：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

    change(&amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s);
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">change</span>(<span style="color: #4eee94;">some_string</span>: &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #98f5ff;">String</span>) {
    some_string.push_str(<span style="color: #deb887;">", world"</span>);
}
</pre>
</div>

<ol class="org-ol">
<li>必须将 <span class="underline">s</span> 改为 <b>mut</b></li>
<li>必须 <b>创建</b> 一个 <b>可变引用</b> <span class="underline">&amp;mut s</span></li>
<li><b>接受</b> 一个 <b>可变引用</b> <span class="underline">some_string: &amp;mut String</span></li>
</ol>

<p>
不过可变引用有一个很大的 <span class="underline">限制</span> ：在 <span class="underline">特定作用域</span> 中的 <span class="underline">特定数据</span> <b>有且只有</b> <span class="underline">一个可变引用</span> 。这些代码会失败：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r1</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s;
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r2</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s;

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, r1, r2);
</pre>
</div>

<p>
错误如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run 
   Compiling multiple_mutable_references v0.1.0 (/home/klose/Documents/programming/html/klose911.github.io/src/rust/src/ownership/multiple_mutable_references)
error[E0499]: cannot borrow <span style="color: #fa8072;">`s`</span> as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     <span style="color: #f08080;">let</span> r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     <span style="color: #f08080;">let</span> r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(<span style="color: #deb887;">"{}, {}"</span>, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try <span style="color: #fa8072;">`rustc --explain E0499`</span><span style="color: #f08080;">.</span>
error: Could not compile <span style="color: #fa8072;">`multiple_mutable_references`</span><span style="color: #f08080;">.</span>

To learn more, run the command again with --verbose.
</pre>
</div>

<pre class="example">
     这个限制允许可变性，不过是以一种受限制的方式允许

     新 Rustacean 们经常与此作斗争，因为大部分语言中变量任何时候都是可变的
</pre>

<p>
这个限制的好处是Rust可以在 <b>编译时就避免数据竞争</b> 。 <span class="underline">数据竞争</span> 类似于竞态条件，它可由这三个行为造成：
</p>
<ol class="org-ol">
<li><b>两个或更多</b> <span class="underline">指针</span> <b>同时访问</b> <span class="underline">同一数据</span></li>
<li><b>至少有一个</b> <span class="underline">指针</span> 被用来 <b>写入数据</b></li>
<li><b>没有</b> <b>同步数据访问</b> 的 <span class="underline">机制</span></li>
</ol>

<pre class="example">
数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复

Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码
</pre>

<p>
可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <b>同时</b> 拥有： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

{
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r1</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s;

} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">r1 &#22312;&#36825;&#37324;&#31163;&#24320;&#20102;&#20316;&#29992;&#22495;&#65292;&#25152;&#20197;&#25105;&#20204;&#23436;&#20840;&#21487;&#20197;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#24341;&#29992;</span>

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r2</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s;
</pre>
</div>

<p>
类似的规则也存在于 <b>同时使用</b> <span class="underline">可变</span> 与 <span class="underline">不可变</span> 引用中。这些代码会导致一个错误：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r1</span> = &amp;s; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#38382;&#39064;</span>
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r2</span> = &amp;s; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#38382;&#39064;</span>
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r3</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22823;&#38382;&#39064;</span>

<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">, and </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, r1, r2, r3);
</pre>
</div>

<p>
编译报错如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run 
   Compiling both_mut_immut_references v0.1.0 (/home/klose/Documents/programming/html/klose911.github.io/src/rust/src/ownership/both_mut_immut_references)
error[E0502]: cannot borrow <span style="color: #fa8072;">`s`</span> as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     <span style="color: #f08080;">let</span> r1 = &amp;s; // &#27809;&#38382;&#39064;
  |              -- immutable borrow occurs here
5 |     <span style="color: #f08080;">let</span> r2 = &amp;s; // &#27809;&#38382;&#39064;
6 |     <span style="color: #f08080;">let</span> r3 = &amp;mut s; // &#22823;&#38382;&#39064;
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(<span style="color: #deb887;">"{}, {}, and {}"</span>, r1, r2, r3);
  |                                -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try <span style="color: #fa8072;">`rustc --explain E0502`</span><span style="color: #f08080;">.</span>
error: Could not compile <span style="color: #fa8072;">`both_mut_immut_references`</span><span style="color: #f08080;">.</span>

To learn more, run the command again with --verbose.
</pre>
</div>

<pre class="example">
     不能在拥有不可变引用的同时拥有可变引用，不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了

     然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据
</pre>

<p>
注意：一个 <span class="underline">引用的作用域</span> 从 <b>声明的地方</b> 开始一直持续到 <b>最后一次使用</b> 为止。例如，因为最后一次使用不可变引用在声明可变引用之前，所以如下代码是可以编译的：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r1</span> = &amp;s; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#38382;&#39064;</span>
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r2</span> = &amp;s; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#38382;&#39064;</span>
<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;"> and </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, r1, r2);
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27492;&#20301;&#32622;&#20043;&#21518; r1 &#21644; r2 &#19981;&#20877;&#20351;&#29992;</span>

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">r3</span> = &amp;<span style="color: #00bfff; font-weight: bold;">mut</span> s; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27809;&#38382;&#39064;</span>
<span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, r3);
</pre>
</div>
<p>
<span class="underline">不可变引用</span> r1 和 r2 的作用域在 <span class="underline">println!</span> <b>最后一次使用</b> 之后 <b>结束</b> ，这也是 <b>创建</b> <span class="underline">可变引用</span> r3 的地方。它们的作用域没有重叠，所以代码是可以编译的
</p>

<pre class="example">
     尽管这些错误有时使人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在

     这样就不必去跟踪为何数据并不是想象中的那样
</pre>
</div>
</div>

<div id="outline-container-org7effd38" class="outline-3">
<h3 id="org7effd38">悬垂引用</h3>
<div class="outline-text-3" id="text-org7effd38">
<p>
在具有指针的语言中，很容易通过 <b>释放内存</b> 时 <b>保留指向它的指针</b> 而错误地生成一个 <span class="underline">悬垂指针</span> 
</p>
<pre class="example">
     所谓悬垂指针是其指向的内存可能已经被分配给其它持有者，在C语言里这也被称为”野指针“
</pre>

<p>
相比之下，在 Rust 中 <span class="underline">编译器</span> <b>确保</b> <span class="underline">引用</span> <b>永远也不会</b> 变成 <span class="underline">悬垂</span> 状态： <b>当拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域</b> 。试着创建一个悬垂引用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">reference_to_nothing</span> = dangle();
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">dangle</span>() -&gt; &amp;<span style="color: #98f5ff;">String</span> {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

    &amp;s
}
</pre>
</div>

<p>
编译报错：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo run 
   Compiling dangling_reference v0.1.0 (/home/klose/Documents/programming/html/klose911.github.io/src/rust/src/ownership/dangling_reference)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ help: consider giving it a <span style="color: #deb887;">'static lifetime: `&amp;'</span>static<span style="color: #fa8072;">`</span>
<span style="color: #fa8072;">  |</span>
<span style="color: #fa8072;">  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from</span>

<span style="color: #fa8072;">error: aborting due to previous error</span>

<span style="color: #fa8072;">For more information about this error, try `</span>rustc --explain E0106<span style="color: #fa8072;">`.</span>
<span style="color: #fa8072;">error: Could not compile `</span>dangling_reference<span style="color: #fa8072;">`.</span>

<span style="color: #fa8072;">To learn more, run the command again with --verbose.</span>
</pre>
</div>

<pre class="example">
错误信息引用了一个还未介绍的功能：生命周期

不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息：
this function's return type contains a borrowed value, but there is no value for it to be borrowed from 
</pre>

<p>
仔细看看 dangle 代码的每一步到底发生了什么：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">dangle</span>() -&gt; &amp;<span style="color: #98f5ff;">String</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">dangle &#36820;&#22238;&#19968;&#20010;&#23383;&#31526;&#20018;&#30340;&#24341;&#29992;</span>

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">s &#26159;&#19968;&#20010;&#26032;&#23383;&#31526;&#20018;</span>

    &amp;s <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238;&#23383;&#31526;&#20018; s &#30340;&#24341;&#29992;</span>
} <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324; s &#31163;&#24320;&#20316;&#29992;&#22495;&#24182;&#34987;&#20002;&#24323;&#12290;&#20854;&#20869;&#23384;&#34987;&#37322;&#25918;&#12290;</span>
  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21361;&#38505;&#65281;</span>
</pre>
</div>

<pre class="example">
因为 s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放
当尝试返回它的引用，这意味着这个引用会指向一个无效的 String

Rust 不会允许这么做！
</pre>

<p>
这里的解决方法是直接返回 String：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">dangle</span>() -&gt; <span style="color: #98f5ff;">String</span> { 

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>); 

    s 
} 
</pre>
</div>

<p>
这样就没有任何错误了。所有权被移动出去，所以没有值被释放
</p>
</div>
</div>

<div id="outline-container-org7c3cd69" class="outline-3">
<h3 id="org7c3cd69">引用规则</h3>
<div class="outline-text-3" id="text-org7c3cd69">
<p>
概括一下之前对引用的讨论：
</p>
<ul class="org-ul">
<li>在 <b>任意</b> 给定时间，要么 <span class="underline">只能有</span> <b>一个可变</b> 引用，要么 <span class="underline">只能有</span> <b>多个不可变</b> 引用</li>
<li><span class="underline">引用</span> 必须 <b>总是有效</b> 的</li>
</ul>

<pre class="example">
   接下来看一下另外一种不拥有”所有权“的数据类型：slice 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc68adbc" class="outline-2">
<h2 id="orgc68adbc">slice</h2>
<div class="outline-text-2" id="text-orgc68adbc">
<p>
slice 允许 <b>引用</b> <span class="underline">集合</span> 中一段 <b>连续的</b> <span class="underline">元素序列</span> ，而不用引用整个集合
</p>

<pre class="example">
    这里有一个编程小习题：

    编写一个函数，该函数接收一个字符串，并返回在该字符串中找到的第一个单词
    如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串
</pre>

<p>
先考虑一下这个函数的签名：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">first_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; <span style="color: #f08080; font-weight: bold;">?</span>
</pre>
</div>

<pre class="example">
first_word 函数有一个参数 &amp;String，因为我们不需要所有权，所以这没有问题

不过应该返回什么呢？
</pre>
<p>
并没有一个真正获取 <b>部分</b> 字符串的办法。不过，可以返回 <span class="underline">单词结尾的索引</span> 。试试下面的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">first_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; <span style="color: #98f5ff;">usize</span> {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">bytes</span> = s.as_bytes();

    <span style="color: #00bfff; font-weight: bold;">for</span> (i, &amp;item) <span style="color: #00bfff; font-weight: bold;">in</span> bytes.iter().enumerate() {
        <span style="color: #00bfff; font-weight: bold;">if</span> item == b<span style="color: #deb887;">' '</span> {
            <span style="color: #00bfff; font-weight: bold;">return</span> i;
        }
    }

    s.len()
}
</pre>
</div>

<p>
因为需要逐个元素的检查String中的值是否为空格，需要用 <span class="underline">as_bytes</span> 方法将String转化为 <span class="underline">字节数组</span> ： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">bytes</span> = s.as_bytes();
</pre>
</div>

<p>
接下来，使用 <span class="underline">iter</span> 方法在字节数组上创建一个 <b>迭代器</b> ： 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">for</span> (i, &amp;item) <span style="color: #00bfff; font-weight: bold;">in</span> bytes.iter().enumerate() {
</pre>
</div>

<pre class="example">
现在，只需知道 iter 方法返回集合中的每一个元素，而 enumerate 包装了 iter 的结果，将这些元素作为元组的一部分来返回
enumerate 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用

这比自己计算索引要方便一些。
</pre>

<p>
因为 <span class="underline">enumerate</span> 方法返回一个元组，可以使用 <span class="underline">模式</span> 来 <b>解构</b> ，就像Rust中其他任何地方所做的一样
</p>

<pre class="example">
    所以在 for 循环中，指定了一个模式，其中元组中的 i 是索引而元组中的 &amp;item 是单个字节

    因为从 .iter().enumerate() 中获取了“集合元素的引用”，所以模式中使用了 &amp; 
</pre>

<p>
在for循环中，通过字节的字面值语法来寻找代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 <span class="underline">s.len()</span> 返回字符串的长度：
</p>

<div class="org-src-container">
<pre class="src src-rust">    <span style="color: #00bfff; font-weight: bold;">if</span> item == b<span style="color: #deb887;">' '</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> i;
    }
}

s.len()
</pre>
</div>

<pre class="example">
    现在有了一个找到字符串中第一个单词结尾索引的方法，不过这有一个问题

    虽然返回了一个独立的 usize，不过它只在 &amp;String 的上下文中才是一个有意义的数字
    换句话说，因为它是一个与 String 相分离的值，无法保证将来它仍然有效
</pre>

<p>
考虑下面first_word的使用例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello world"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">word</span> = first_word(&amp;s); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">word &#30340;&#20540;&#20026; 5</span>

    s.clear(); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#28165;&#31354;&#20102;&#23383;&#31526;&#20018;&#65292;&#20351;&#20854;&#31561;&#20110; ""</span>

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">word &#22312;&#27492;&#22788;&#30340;&#20540;&#20173;&#28982;&#26159; 5&#65292;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20294;&#26159;&#27809;&#26377;&#26356;&#22810;&#30340;&#23383;&#31526;&#20018;&#35753;&#25105;&#20204;&#21487;&#20197;&#26377;&#25928;&#22320;&#24212;&#29992;&#25968;&#20540; 5&#12290;word &#30340;&#20540;&#29616;&#22312;&#23436;&#20840;&#26080;&#25928;&#65281;</span>
}
</pre>
</div>

<pre class="example">
    这个程序编译时没有任何错误，而且在调用 s.clear() 之后使用 word 也不会出错
    因为 word 与 s 状态完全没有联系，所以 word 仍然包含值 5

    可以尝试用值 5 来提取变量 s 的第一个单词，不过这是有 bug 的，因为在将 5 保存到 word 之后 s 的内容已经改变
    这样就不得不时刻担心 word 的索引与 s 中的数据不再同步，这很啰嗦且易出错！
</pre>

<p>
如果编写这么一个 <span class="underline">second_word</span> 函数的话，管理索引这件事将更加容易出问题。它的签名看起来像这样：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">second_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; (<span style="color: #98f5ff;">usize</span>, <span style="color: #98f5ff;">usize</span>) {
</pre>
</div>

<pre class="example">
    这要跟踪一个开始索引 和 一个结尾索引，同时有了更多从数据的某个特定状态计算而来的值，但都完全没有与这个状态相关联

    现在有三个飘忽不定的不相关变量需要保持同步！
</pre>

<p>
幸运的是，Rust 为这个问题提供了一个解决方法： <span class="underline">字符串 slice</span> 
</p>
</div>

<div id="outline-container-orgb4277a7" class="outline-3">
<h3 id="orgb4277a7">字符串 slice</h3>
<div class="outline-text-3" id="text-orgb4277a7">
<p>
<span class="underline">字符串 slice</span> 是 <span class="underline">String</span> 中 <b>一部分值的引用</b> ，它看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello world"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">hello</span> = &amp;s[0..5];
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">world</span> = &amp;s[6..11];
</pre>
</div>

<pre class="example">
     这类似于引用整个 String 不过带有额外的 [0..5] 部分

     它不是对整个 String 的引用，而是对部分 String 的引用
</pre>

<p>
使用一个由中括号中的 <span class="underline">[starting_index..ending_index]</span> 指定的 <span class="underline">range</span> 创建一个 <b>slice</b> ，其中：
</p>
<ul class="org-ul">
<li>starting_index 是 slice 的 <b>第一个位置</b></li>
<li>ending_index 则是 slice <b>最后一个位置的后一个值</b></li>
<li>在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度对应于 ending_index 减去 starting_index 的值</li>
</ul>

<pre class="example">
     所以对于 let world = &amp;s[6..11]; 的情况，world 将是一个包含指向 s 第 7 个字节（索引从 0 开始）的指针和长度值 5 的 slice
</pre>

<p>
下图展示了一个图例：
</p>


<div class="figure">
<p><object type="image/svg+xml" data="pic/trpl04-06.svg" class="org-svg" width="10%">
Sorry, your browser does not support SVG.</object> 
</p>
</div>

<p>
对于 Rust 的 <span class="underline">..</span> range 语法，如果想要从 <span class="underline">第一个索引</span> （0）开始，可以 <b>不写两个点号之前的值</b> 。换句话说，如下两个语句是相同的：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;s[0..2];
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;s[..2];
</pre>
</div>

<p>
依此类推，如果 slice 包含 String 的 <span class="underline">最后一个字节</span> ，也可以 <b>舍弃尾部的数字</b> 。这意味着如下也是相同的：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = s.len();

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;s[3..len];
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;s[3..];
</pre>
</div>

<p>
也可以同时舍弃这两个值来获取整个字符串的 slice。所以如下亦是相同的：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello"</span>);

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">len</span> = s.len();

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;s[0..len];
<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;s[..];
</pre>
</div>

<pre class="example">
     注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内
     如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出

     出于介绍字符串 slice 的目的，本部分假设只使用 ASCII 字符集； 以后会更加全面的讨论 UTF-8 处理问题
</pre>

<p>
现在重写 first_word 来返回一个 slice。 <b>字符串 slice</b> 的 <span class="underline">类型声明</span> 写作 <b>&amp;str</b> ： 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">first_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; &amp;<span style="color: #98f5ff;">str</span> {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">bytes</span> = s.as_bytes();

    <span style="color: #00bfff; font-weight: bold;">for</span> (i, &amp;item) <span style="color: #00bfff; font-weight: bold;">in</span> bytes.iter().enumerate() {
        <span style="color: #00bfff; font-weight: bold;">if</span> item == b<span style="color: #deb887;">' '</span> {
            <span style="color: #00bfff; font-weight: bold;">return</span> &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</pre>
</div>

<p>
现在当调用 first_word 时，会返回与底层数据关联的单个值。这个值由一个 <span class="underline">slice 开始位置的引用</span> 和 <span class="underline">slice 中元素的数量</span> 组成
</p>
<pre class="example">
     使用跟开始相同的方式获取单词结尾的索引，通过寻找第一个出现的空格
     当找到一个空格，返回一个字符串 slice，它使用字符串的开始和空格的索引作为开始和结束的索引
</pre>

<p>
second_word 函数也可以改为返回一个 slice：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">second_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; &amp;<span style="color: #98f5ff;">str</span> {
</pre>
</div>

<pre class="example">
现在有了一个不易混淆且直观的 API 了，因为编译器会确保指向 String 的引用持续有效

还记得那个获取第一个单词结尾的索引后，接着就清除了字符串导致索引就无效的 bug 吗？
那些代码在逻辑上是不正确的，但却没有显示任何直接的错误，问题会在之后尝试对空字符串使用第一个单词的索引时出现

slice 就不可能出现这种 bug 并更早的报出问题了
</pre>

<p>
使用 slice 版本的 first_word 会抛出一个编译时错误：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #00bfff; font-weight: bold;">mut</span> <span style="color: #4eee94;">s</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello world"</span>);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">word</span> = first_word(&amp;s);

    s.clear(); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38169;&#35823;!</span>

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"the first word is: </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, word);
}
</pre>
</div>

<p>
这里是编译错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0502]: cannot borrow <span style="color: #fa8072;">`s`</span> as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     <span style="color: #f08080;">let</span> word = first_word(&amp;s);
  |                           -- immutable borrow occurs here
5 | 
6 |     s.clear(); // &#38169;&#35823;!
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(<span style="color: #deb887;">"the first word is: {}"</span>, word);
  |                                       ---- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try <span style="color: #fa8072;">`rustc --explain E0502`</span><span style="color: #f08080;">.</span>
error: Could not compile <span style="color: #fa8072;">`string_slice`</span><span style="color: #f08080;">.</span>

To learn more, run the command again with --verbose.
</pre>
</div>

<p>
回忆一下借用规则， <b>当拥有某值的不可变引用时，就不能再获取一个可变引用</b> 
</p>

<pre class="example">
因为 clear 需要清空 String，它尝试获取一个可变引用
Rust不允许这样做，所以编译失败

Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！
</pre>
</div>

<div id="outline-container-org917c68d" class="outline-4">
<h4 id="org917c68d">字符串字面值就是 slice</h4>
<div class="outline-text-4" id="text-org917c68d">
<pre class="example">
      还记得讲到过字符串字面值被储存在二进制文件中吗
</pre>
<p>
现在知道 slice 了，就可以正确的理解字符串字面值了：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">s</span> = <span style="color: #deb887;">"Hello, world!"</span>;
</pre>
</div>

<p>
这里 s 的类型是 <span class="underline">&amp;str</span> ：一个 <b>指向</b> <span class="underline">二进制程序</span> <b>特定位置</b> 的 <span class="underline">slice</span>
</p>

<pre class="example">
      这也就是为什么字符串字面值是不可变的：&amp;str 是一个不可变引用
</pre>
</div>
</div>

<div id="outline-container-org975166a" class="outline-4">
<h4 id="org975166a">字符串 slice 作为参数</h4>
<div class="outline-text-4" id="text-org975166a">
<p>
在知道了能够获取字面值和 String 的 slice 后，对 first_word 做了改进，这是它的签名：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">first_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">String</span>) -&gt; &amp;<span style="color: #98f5ff;">str</span> {
</pre>
</div>
<p>
而更有经验的 Rustacean 会编写出下面的签名，因为它使得可以对 <span class="underline">String</span> 值和 <span class="underline">&amp;str</span> 值使用相同的函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">first_word</span>(<span style="color: #4eee94;">s</span>: &amp;<span style="color: #98f5ff;">str</span>) -&gt; &amp;<span style="color: #98f5ff;">str</span> {
</pre>
</div>

<p>
如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">my_string</span> = <span style="color: #98f5ff;">String</span>::from(<span style="color: #deb887;">"hello world"</span>);

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">first_word &#20013;&#20256;&#20837; `String` &#30340; slice</span>
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">word</span> = first_word(&amp;my_string[..]);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">my_string_literal</span> = <span style="color: #deb887;">"hello world"</span>;

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">first_word &#20013;&#20256;&#20837;&#23383;&#31526;&#20018;&#23383;&#38754;&#20540;&#30340; slice</span>
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">word</span> = first_word(&amp;my_string_literal[..]);

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22240;&#20026;&#23383;&#31526;&#20018;&#23383;&#38754;&#20540; **&#23601;&#26159;** &#23383;&#31526;&#20018; slice&#65292;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#26679;&#20889;&#20063;&#21487;&#20197;&#65292;&#21363;&#19981;&#20351;&#29992; slice &#35821;&#27861;&#65281;</span>
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">word</span> = first_word(my_string_literal);
}
</pre>
</div>

<pre class="example">
      定义一个获取字符串 slice 而不是 String 引用的函数使得 API 更加通用并且不会丢失任何功能
</pre>
</div>
</div>
</div>


<div id="outline-container-org8e08e6e" class="outline-3">
<h3 id="org8e08e6e">其他类型的 slice</h3>
<div class="outline-text-3" id="text-org8e08e6e">
<pre class="example">
     字符串 slice，正如你想象的那样，是针对字符串的
</pre>
<p>
不过也有更通用的 slice 类型。考虑一下这个数组：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">a</span> = [1, 2, 3, 4, 5];
</pre>
</div>

<p>
就跟想要获取字符串的一部分那样，也会想要引用数组的一部分。可以这样做：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">a</span> = [1, 2, 3, 4, 5];

<span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">slice</span> = &amp;a[1..3];
</pre>
</div>

<p>
这个 slice 的类型是 <span class="underline">&amp;[i32]</span> ：它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度
</p>

<pre class="example">
     可以对其他所有集合使用这类 slice
</pre>
</div>
</div>

<div id="outline-container-org42f033e" class="outline-3">
<h3 id="org42f033e">总结</h3>
<div class="outline-text-3" id="text-org42f033e">
<p>
<span class="underline">所有权</span> 、 <span class="underline">借用</span> 和  <span class="underline">slice</span> 这些概念让 Rust 程序在 <b>编译时确保内存安全</b> 
</p>

<pre class="example">
Rust 语言提供了跟其他系统编程语言相同的方式来控制使用的内存
但”拥有数据所有者“在 ”离开作用域“ 后 ”自动清除其数据“ 的功能意味着：无须额外编写和调试相关的控制代码

所有权系统影响了 Rust 中很多其他部分的工作方式
</pre>

<p>
<a href="struct.html">Next: 结构体</a>
</p>

<p>
<a href="concept.html">Previous: 概念</a>
</p>

<p>
<a href="rust.html">Home: 目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
