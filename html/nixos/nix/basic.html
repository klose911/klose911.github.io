<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>快速入门</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="nix.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">快速入门</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4516dd6">交互模式</a></li>
<li><a href="#org39f77d8">即时计算</a>
<ul>
<li><a href="#org1e2679a">匿名集合</a></li>
<li><a href="#org4c6921a">惰性求值</a></li>
</ul>
</li>
<li><a href="#orgcdee9b5">文件求值</a>
<ul>
<li><a href="#org50cc77e">立即求值</a>
<ul>
<li><a href="#org0176625">echo 命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9983158">代码风格</a>
<ul>
<li><a href="#org780e3c7">格式化</a></li>
</ul>
</li>
<li><a href="#org057a115">当心空格</a></li>
<li><a href="#org06bdf46">名称和值</a></li>
<li><a href="#orgcdb6895">属性集</a>
<ul>
<li><a href="#org68df0c2">递归属性集</a></li>
</ul>
</li>
<li><a href="#org0e2e80a">let 绑定</a>
<ul>
<li><a href="#orgf192e09">作用域</a></li>
</ul>
</li>
<li><a href="#org6035678">属性访问</a>
<ul>
<li><a href="#orge4fad25">with 表达式</a></li>
<li><a href="#org6aef6a0">inherit 表达式</a></li>
</ul>
</li>
<li><a href="#orgcffa73e">字符串插值</a></li>
<li><a href="#orgf2c8597">路径类型</a>
<ul>
<li><a href="#org764d202">检索路径</a></li>
</ul>
</li>
<li><a href="#orgdf71a2d">字符串</a>
<ul>
<li><a href="#orgc788ea4">多行字符串</a></li>
</ul>
</li>
<li><a href="#org6edcc3b">函数</a>
<ul>
<li><a href="#org652dfbd">高阶函数</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4516dd6" class="outline-2">
<h2 id="org4516dd6">交互模式</h2>
<div class="outline-text-2" id="text-org4516dd6">
<p>
以下交互式教程需要使用 <span class="underline">nix repl</span> 命令调出交互命令模式：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ nix repl
Welcome to Nix 2.5.1. Type :? for help.
</pre>
</div>

<p>
它有点像用于调试 JavaScript 的控制台或 Python 的交互模式
</p>

<div class="org-src-container">
<pre class="src src-sh">nix-repl&gt; 1 + 2  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36755;&#20837;&#34920;&#36798;&#24335;</span>
3  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36755;&#20986;&#32467;&#26524;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org39f77d8" class="outline-2">
<h2 id="org39f77d8">即时计算</h2>
<div class="outline-text-2" id="text-org39f77d8">
<div class="org-src-container">
<pre class="src src-sh">nix-repl&gt; { a.b.c = 1; }
{ a = { ... }; }
</pre>
</div>

<pre class="example" id="orgd4e610c">
在上面的例子中，我们输入了一个匿名集合，而这个匿名集合包含 a 集合 
</pre>
</div>

<div id="outline-container-org1e2679a" class="outline-3">
<h3 id="org1e2679a">匿名集合</h3>
<div class="outline-text-3" id="text-org1e2679a">
<p>
匿名集合是没有分配名称的集合，与之对立的是命名集合，例如 <span class="underline">foo = { bar };</span> 
</p>
<pre class="example" id="orgccff643">
a 集合中的值并没有被这个匿名集合直接依赖

自然顶级以下的集合不会被立刻求值，占位的变成了 ... 
</pre>

<p>
在下面这个例子，将显式声明 qux 的直接依赖：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">foo</span> = { <span style="color: #eedd82;">bar.qux</span> = 1; };
  <span style="color: #eedd82;">lax</span> = foo.bar.qux;
<span style="color: #00ffff;">in</span>
lax  <span style="color: #ff4500;"># &#25105;&#20204;&#38656;&#35201; lax&#65292;lax &#38656;&#35201; foo.bar.qux</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c6921a" class="outline-3">
<h3 id="org4c6921a">惰性求值</h3>
<div class="outline-text-3" id="text-org4c6921a">
<p>
Nix语言的求值是 <b>惰性的</b> ，这意味着 <b>表达式不会在被绑定到变量后立即求值，而是在该值 <span class="underline">被使用</span> 时才求值</b> 
</p>

<p>
可以输入 <span class="underline">:p</span> 启用 <b>即刻求值</b> ，所有表达式都将被立刻求值：
</p>

<div class="org-src-container">
<pre class="src src-sh">nix-repl&gt; :p { a.b.c = 1; }
{ a = { b = { c = 1; }; }; }
</pre>
</div>

<p>
注意：
</p>
<ul class="org-ul">
<li><span class="underline">:p</span> 参数 <b>只能</b> 在 <span class="underline">交互</span> 模式使用</li>
<li>输入 <span class="underline">:q</span> 可以 <b>退出</b> 交互模式</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcdee9b5" class="outline-2">
<h2 id="orgcdee9b5">文件求值</h2>
<div class="outline-text-2" id="text-orgcdee9b5">
<p>
使用 <span class="underline">nix-instantiate &#x2013;eval</span> 对 <span class="underline">nix 文件</span> 中存在的 <span class="underline">表达式</span> 进行 <b>求值</b> ：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b0c4de;">echo</span> 1 + 2 &gt; file.nix  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#35813;&#21629;&#20196;&#20250;&#24448; file.nix &#20013;&#20889;&#20837; 1 + 2</span>
nix-instantiate --eval file.nix  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25991;&#20214;&#27714;&#20540;</span>
3  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#36755;&#20986;&#32467;&#26524;</span>
</pre>
</div>
</div>

<div id="outline-container-org50cc77e" class="outline-3">
<h3 id="org50cc77e">立即求值</h3>
<div class="outline-text-3" id="text-org50cc77e">
<p>
在文件求值的情景下可以通过在命令行添加 <span class="underline">&#x2013;strict</span> 参数来启用立即求值：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b0c4de;">echo</span> <span style="color: #ffa07a;">"{ a.b.c = 1; }"</span> &gt; file.nix
nix-instantiate --eval --strict file.nix
{ a = { b = { c = 1; }; }; }
</pre>
</div>
</div>

<div id="outline-container-org0176625" class="outline-4">
<h4 id="org0176625">echo 命令</h4>
<div class="outline-text-4" id="text-org0176625">
<p>
echo 是 Linux 中最常见的命令之一，主要作用是输出文本，追加文本，返回输出
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org9983158" class="outline-2">
<h2 id="org9983158">代码风格</h2>
<div class="outline-text-2" id="text-org9983158">
<p>
好的代码风格会让程序员身心愉悦，同时也增加了代码可维护性
</p>
</div>


<div id="outline-container-org780e3c7" class="outline-3">
<h3 id="org780e3c7">格式化</h3>
<div class="outline-text-3" id="text-org780e3c7">
<p>
<span class="underline">Alejandra</span> 是一个新兴的 Nix 代码格式化工具，使用 Rust 编写
</p>
</div>
</div>
</div>


<div id="outline-container-org057a115" class="outline-2">
<h2 id="org057a115">当心空格</h2>
<div class="outline-text-2" id="text-org057a115">
<p>
空格用于分隔 <b>词法标记</b> <span class="underline">Lexical tokens</span> ，在一些场景是必要的，不然会无法区分关键字
</p>

<pre class="example" id="org359be73">
在许多中文资料中，混淆了 Lexical，Syntax 和 Grammar 三者的概念：

Lexical（词法）：是指语言中单词的意义、形态和用法等方面的规则。词法规则定义了单词的基本形态和语法功能，例如名词、动词、形容词等。同时，它还规定了一些特殊单词的用法，例如冠词、介词、连词等

Syntax（句法）：是指语言中标记（Token）之间的组合方式，以及这种组合方式所遵循的规则。通俗点说，语法规定了单词应该如何排列、组合成句子，以及这些句子之间的联系方式

Grammar（语法）：是指语言中的规则体系，包括了语法规则、语义规则和语用规则等。它涉及到语言的整个结构和组成方式，而不仅仅是句子的构成
</pre>

<p>
下面的两种示例是等价的：
</p>
<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">x</span> = 1;
  <span style="color: #eedd82;">y</span> = 2;
<span style="color: #00ffff;">in</span>
x + y
</pre>
</div>

<p>
显然，下面的可读性比上面的差很多：
</p>
<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span>=1;<span style="color: #eedd82;">y</span>=2;<span style="color: #00ffff;">in</span> x+y
</pre>
</div>
</div>
</div>

<div id="outline-container-org06bdf46" class="outline-2">
<h2 id="org06bdf46">名称和值</h2>
<div class="outline-text-2" id="text-org06bdf46">
<p>
<span class="underline">原始数据类型</span> ， <span class="underline">列表</span> ， <span class="underline">属性集</span> 与 <span class="underline">函数</span> 都可以被当作 <b>值</b> ，可以使用 <span class="underline">=</span> 为名称 <b>绑定</b> 值，然后用 <span class="underline">分号</span> <b>分隔</b> <span class="underline">赋值</span> 语句：
</p>


<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">foo</span> = <span style="color: #ffa07a;">"I am a fool"</span>;
  <span style="color: #eedd82;">bar</span> = <span style="color: #ffa07a;">"I am at the bar"</span>;
<span style="color: #00ffff;">in</span>
foo + bar
</pre>
</div>
<p>
名称不等同常见编程语言中的变量，因为它 <b>一旦定义就无法修改</b> 。在概念上，它们更多地是形成了一种 <span class="underline">绑定</span> 关系：
</p>
<ul class="org-ul">
<li><p>
一个值可以被多个名称绑定，一个名称只能绑定一个值
</p>
<pre class="example" id="org106fb80">
这种赋值没有副作用

传统的赋值会改变变量的状态，Nix 语言中的变量一旦赋值无法改变
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orgcdb6895" class="outline-2">
<h2 id="orgcdb6895">属性集</h2>
<div class="outline-text-2" id="text-orgcdb6895">
<pre class="example" id="orgabcbcdf">
还记得我们在上面提到的集合吗？

其实它真正的名字是属性集，没有过早引入属性集的概念是为了方便读者渐进式地理解
</pre>

<p>
<b>属性集</b> 就是 <b>装载若干对名称与值的集合</b> ：
</p>
<ul class="org-ul">
<li>集合内的 <span class="underline">名称</span> 被称为这个集合的 <b>属性</b></li>
<li><p>
集合内中由 <span class="underline">名称和值</span> 组成的对则被称为该属性的 <b>元素</b>
</p>

<div class="org-src-container">
<pre class="src src-nix">{
  <span style="color: #eedd82;">string</span> = <span style="color: #ffa07a;">"hello"</span>;
  <span style="color: #eedd82;">integer</span> = 1;
  <span style="color: #eedd82;">float</span> = 3.141;
  <span style="color: #eedd82;">bool</span> = <span style="color: #b0c4de;">true</span>;
  <span style="color: #b0c4de;">null</span> = <span style="color: #b0c4de;">null</span>;
  <span style="color: #eedd82;">list</span> = [ 1 <span style="color: #ffa07a;">"two"</span> <span style="color: #b0c4de;">false</span> ];
  <span style="color: #eedd82;">attribute-set</span> = {
    <span style="color: #eedd82;">a</span> = <span style="color: #ffa07a;">"hello"</span>;
    <span style="color: #eedd82;">b</span> = 2;
    <span style="color: #eedd82;">c</span> = 2.718;
    <span style="color: #eedd82;">d</span> = <span style="color: #b0c4de;">false</span>;
  };  <span style="color: #ff4500;"># &#26631;&#20934; json &#19981;&#25903;&#25345;&#27880;&#37322;</span>
}
</pre>
</div>

<p>
可能觉得莫名的像 json，下面是 json 的示例：
</p>
<div class="org-src-container">
<pre class="src src-js">{
    <span style="color: #ffa07a;">"string"</span>: <span style="color: #ffa07a;">"hello"</span>,
    <span style="color: #ffa07a;">"integer"</span>: 1,
    <span style="color: #ffa07a;">"float"</span>: 3.141,
    <span style="color: #ffa07a;">"bool"</span>: <span style="color: #7fffd4;">true</span>,
    <span style="color: #ffa07a;">"null"</span>: <span style="color: #7fffd4;">null</span>,
    <span style="color: #ffa07a;">"list"</span>: [1, <span style="color: #ffa07a;">"two"</span>, <span style="color: #7fffd4;">false</span>],
    <span style="color: #ffa07a;">"object"</span>: {
        <span style="color: #ffa07a;">"a"</span>: <span style="color: #ffa07a;">"hello"</span>,
        <span style="color: #ffa07a;">"b"</span>: 1,
        <span style="color: #ffa07a;">"c"</span>: 2.718,
        <span style="color: #ffa07a;">"d"</span>: <span style="color: #7fffd4;">false</span>
    }
}
</pre>
</div>

<p>
注意：
</p></li>
<li>属性不需要添加引号</li>
<li>列表是用空格分隔的</li>
</ul>
</div>
<div id="outline-container-org68df0c2" class="outline-3">
<h3 id="org68df0c2">递归属性集</h3>
<div class="outline-text-3" id="text-org68df0c2">
<p>
当属性集内的属性需要访问该集合的另一个属性时，应当使用 <b>递归属性集</b> ：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">rec</span> {
  <span style="color: #eedd82;">one</span> = 1;
  <span style="color: #eedd82;">two</span> = one + 1;  <span style="color: #ff4500;"># &#30452;&#25509;&#20381;&#36182;&#20110; one</span>
  <span style="color: #eedd82;">three</span> = two + 1; <span style="color: #ff4500;"># &#30452;&#25509;&#20381;&#36182;&#20110; two&#65292;&#38388;&#25509;&#20381;&#36182;&#20110; one</span>
}
</pre>
</div>

<p>
输出如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">{ one = 1; three = 3; two = 2; }
</pre>
</div>


<pre class="example" id="org6a60665">
元素的声明顺序并不决定元素在属性集中的排布顺序

属性集中的元素排布顺序是由求值顺序决定的，优先被求值的被放在了前面
</pre>
</div>
</div>
</div>
<div id="outline-container-org0e2e80a" class="outline-2">
<h2 id="org0e2e80a">let 绑定</h2>
<div class="outline-text-2" id="text-org0e2e80a">
<p>
一个完整的 let 绑定有两个部分：
</p>
<ol class="org-ol">
<li>let: 绑定名称与值</li>
<li>in: 使用名称</li>
</ol>

<p>
在 let 与 in 之间的语句中，可以声明需要被复用的名称，并将其与值绑定。它们可以在 <span class="underline">in 之后的表达式</span> 中发挥作用：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">b</span> = a + 1;
  <span style="color: #eedd82;">a</span> = 1;
<span style="color: #00ffff;">in</span>
a + b
</pre>
</div>

<p>
引用到 a 的地方有两处，它们都会将 a <b>替换</b> 成值来计算或赋值，类似于常量
</p>

<pre class="example" id="org3d51a88">
不需要关心名称的声明顺序，不会出现名称未定义的情况
</pre>

<p>
<b>in 后面只能跟随一个表达式，并且 let 绑定的名称只在该表达式是有效的</b> ，这里演示一个列表：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">b</span> = a + 1;
  <span style="color: #eedd82;">c</span> = a + b;
  <span style="color: #eedd82;">a</span> = 1;
<span style="color: #00ffff;">in</span>
[ a b c ]
</pre>
</div>

<p>
输出的值为：
</p>
<div class="org-src-container">
<pre class="src src-sh">[ 1 2 3 ]
</pre>
</div>
</div>
<div id="outline-container-orgf192e09" class="outline-3">
<h3 id="orgf192e09">作用域</h3>
<div class="outline-text-3" id="text-orgf192e09">
<p>
let 绑定是有 <b>作用域</b> 的，绑定的名称只能在作用域使用，或者说每个 let 绑定的名称 <b>只能在该表达式内</b> 使用：
</p>

<div class="org-src-container">
<pre class="src src-nix">{
  <span style="color: #eedd82;">a</span> = <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = 1; <span style="color: #00ffff;">in</span> x;
  <span style="color: #eedd82;">b</span> = x;
}
</pre>
</div>

<p>
x 未定义：
</p>

<div class="org-src-container">
<pre class="src src-sh">error: undefined variable <span style="color: #ffa07a;">'x'</span>

at &#171;string&#187;:3:7:

2|   a = let x = 1; <span style="color: #00ffff;">in</span> x;
                       3|   b = x;
                         |       ^
                         4| }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6035678" class="outline-2">
<h2 id="org6035678">属性访问</h2>
<div class="outline-text-2" id="text-org6035678">
<p>
使用 <span class="underline">.</span> 访问属性：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">attrset</span> = { <span style="color: #eedd82;">x</span> = 1; };
<span style="color: #00ffff;">in</span>
attrset.x
</pre>
</div>

<p>
访问嵌套的属性也是同样的方式：
</p>
<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">attrset</span> = { <span style="color: #eedd82;">a</span> = { <span style="color: #eedd82;">b</span> = { <span style="color: #eedd82;">c</span> = 1; }; }; };
<span style="color: #00ffff;">in</span>
attrset.a.b.c
</pre>
</div>

<p>
当然，就像如何访问属性一样，也可以用 . 直接赋值它：
</p>
<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">a.b.c</span> = 1;
<span style="color: #00ffff;">in</span>
a.b.c
</pre>
</div>
</div>
<div id="outline-container-orge4fad25" class="outline-3">
<h3 id="orge4fad25">with 表达式</h3>
<div class="outline-text-3" id="text-orge4fad25">
<p>
with 表达式可以让人少写几次属性集的名称，是个语法糖：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">a</span> = {
    <span style="color: #eedd82;">x</span> = 1;
    <span style="color: #eedd82;">y</span> = 2;
    <span style="color: #eedd82;">z</span> = 3;
  };
<span style="color: #00ffff;">in</span>
<span style="color: #00ffff;">with</span> a; [ x y z ]  <span style="color: #ff4500;"># &#31561;&#20215; [ a.x a.y a.z ]</span>
</pre>
</div>

<p>
作用域被限制到了 <span class="underline">分号后面的第一个表达式</span> 内：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">a</span> = {
    <span style="color: #eedd82;">x</span> = 1;
    <span style="color: #eedd82;">y</span> = 2;
    <span style="color: #eedd82;">z</span> = 3;
  };
<span style="color: #00ffff;">in</span>
{
  <span style="color: #eedd82;">b</span> = <span style="color: #00ffff;">with</span> a; [ x y z ];
  <span style="color: #eedd82;">c</span> = x;  <span style="color: #ff4500;"># a.x</span>
} 
</pre>
</div>

<p>
x 未定义：
</p>
<div class="org-src-container">
<pre class="src src-sh">error: undefined variable <span style="color: #ffa07a;">'x'</span>

at &#171;string&#187;:10:11:

9|       b = with a; [ x y z ];
10|       c = x;  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">a.x</span>
                     |           ^
                     11|     }
</pre>
</div>
</div>
</div>
<div id="outline-container-org6aef6a0" class="outline-3">
<h3 id="org6aef6a0">inherit 表达式</h3>
<div class="outline-text-3" id="text-org6aef6a0">
<p>
inherit 本意就是继承，可以使用它完成 <b>一对命名相同的名称和属性之间的赋值</b> ：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">x</span> = 1;
  <span style="color: #eedd82;">y</span> = 2;
<span style="color: #00ffff;">in</span>
{
  <span style="color: #00ffff;">inherit</span> x y;
}
</pre>
</div>

<p>
没有这个语法糖，可能得这样写：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">x</span> = 1;
  <span style="color: #eedd82;">y</span> = 2;
<span style="color: #00ffff;">in</span>
{
  <span style="color: #eedd82;">x</span> = x;
  <span style="color: #eedd82;">y</span> = y;
}
</pre>
</div>

<p>
加上括号，就直接从属性集继承名称：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">a</span> = { <span style="color: #eedd82;">x</span> = 1; <span style="color: #eedd82;">y</span> = 2; };
<span style="color: #00ffff;">in</span>
{
  <span style="color: #00ffff;">inherit</span> (a) x y;
}
</pre>
</div>

<p>
inherit 同样可以在 let 表达式中使用：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #00ffff;">inherit</span> ({ <span style="color: #eedd82;">x</span> = 1; <span style="color: #eedd82;">y</span> = 2; }) x y;
<span style="color: #00ffff;">in</span>
[ x y ]
</pre>
</div>

<p>
等价于：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">x</span> = { <span style="color: #eedd82;">x</span> = 1; <span style="color: #eedd82;">y</span> = 2; }.x;
  <span style="color: #eedd82;">y</span> = { <span style="color: #eedd82;">x</span> = 1; <span style="color: #eedd82;">y</span> = 2; }.y;
<span style="color: #00ffff;">in</span>
[ x y ]
</pre>
</div>

<pre class="example" id="org96970da">
变相的将特定属性带到了全局作用域，实现了更方便的解构出名称的方法
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcffa73e" class="outline-2">
<h2 id="orgcffa73e">字符串插值</h2>
<div class="outline-text-2" id="text-orgcffa73e">
<p>
各大流行语言均已支持，使用 <span class="underline">${ &#x2026; }</span> 可以 <b>插入</b> 名称的值：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">name</span> = <span style="color: #ffa07a;">"Nix"</span>;
<span style="color: #00ffff;">in</span>
<span style="color: #ffa07a;">"hello </span><span style="color: #7fffd4;">${</span>name<span style="color: #7fffd4;">}</span>"
</pre>
</div>

<p>
输出为：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #ffa07a;">"hello Nix"</span>
</pre>
</div>

<p>
字符串插值语法 <b>只支持字符串类型</b> ，所以引入的名称的值必须是字符串，或是可以转换为字符串的类型：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">x</span> = 1;
<span style="color: #00ffff;">in</span>
<span style="color: #ffa07a;">"</span><span style="color: #7fffd4;">${</span>x<span style="color: #7fffd4;">}</span><span style="color: #ffa07a;"> + </span><span style="color: #7fffd4;">${</span>x<span style="color: #7fffd4;">}</span><span style="color: #ffa07a;"> = </span><span style="color: #7fffd4;">${</span>x + x<span style="color: #7fffd4;">}</span>"
</pre>
</div>

<p>
因为是数字类型，所以报错：
</p>

<div class="org-src-container">
<pre class="src src-sh">error: cannot coerce an integer to a string

at &#171;string&#187;:4:2:

3| <span style="color: #00ffff;">in</span>
4| <span style="color: #ffa07a;">"${x} + ${x} = ${x + x}"</span>
                 |  ^
                 5|
</pre>
</div>

<p>
字符串插值是可以 <span class="underline">被嵌套</span> 的：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">a</span> = <span style="color: #ffa07a;">"no"</span>;
<span style="color: #00ffff;">in</span>
<span style="color: #ffa07a;">"</span><span style="color: #7fffd4;">${</span>a + <span style="color: #ffa07a;">" </span><span style="color: #7fffd4;">${</span>a + <span style="color: #ffa07a;">" </span><span style="color: #7fffd4;">${</span>a<span style="color: #7fffd4;">}</span>"<span style="color: #7fffd4;">}</span>"<span style="color: #7fffd4;">}</span>"
</pre>
</div>

<p>
输出为：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #ffa07a;">"no no no"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf2c8597" class="outline-2">
<h2 id="orgf2c8597">路径类型</h2>
<div class="outline-text-2" id="text-orgf2c8597">
<p>
<b>路径</b> 在 Nix 语言中不是字符串类型，而是一种 <b>独立的</b> <span class="underline">类型</span> ，以下是一些路径的示例：
</p>

<div class="org-src-container">
<pre class="src src-sh">./relative  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#24403;&#21069;&#25991;&#20214;&#22841;&#19979; relative &#25991;&#20214;&#65288;&#22841;&#65289;&#30340;&#30456;&#23545;&#36335;&#24452;</span>
/current/directory/absolute  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#32477;&#23545;&#36335;&#24452;&#65292;&#20174;&#26681;&#30446;&#24405;&#24320;&#22987;&#25351;&#23450;</span>
../  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#24403;&#21069;&#30446;&#24405;&#30340;&#19978;&#32423;&#30446;&#24405;</span>
../../  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#24403;&#21069;&#30446;&#24405;&#30340;&#19978;&#32423;&#30340;&#19978;&#32423;&#30446;&#24405;</span>
./  <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#24403;&#21069;&#30446;&#24405;</span>
</pre>
</div>
</div>

<div id="outline-container-org764d202" class="outline-3">
<h3 id="org764d202">检索路径</h3>
<div class="outline-text-3" id="text-org764d202">
<pre class="example" id="org1bc09fc">
这又被称为“尖括号语法”
</pre>

<p>
<b>检索路径</b> 是通过 <span class="underline">系统变量</span> 来 <b>获取</b> <span class="underline">路径</span> 的语法，由 <span class="underline">一对尖括号</span> 组成：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #7fffd4;">&lt;nixpkgs&gt;</span>
</pre>
</div>

<p>
这个时候 <span class="underline">&lt;nixpkgs&gt;</span> 实际上一个依赖了系统变量中为 <span class="underline">$NIX_PATH</span> 的路径值：
</p>

<div class="org-src-container">
<pre class="src src-sh">/nix/var/nix/profiles/per-user/root/channels/nixos
</pre>
</div>

<p>
建议： <b>避免</b> 使用检索路径来指定其它相对路径，比如下面的例子：
</p>
<div class="org-src-container">
<pre class="src src-nix">&lt;<span style="color: #7fffd4;">nixpkgs/lib</span>&gt;
</pre>
</div>

<p>
这是一种 <b>污染</b> ，因为这样指定相对路径会让配置与环境产生联系
</p>

<pre class="example" id="orgf6973cc">
配置文件应该尽量保留纯函数式的特性，即输出只与输入有关，纯函数不应该与外界产生任何联系
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf71a2d" class="outline-2">
<h2 id="orgdf71a2d">字符串</h2>
<div class="outline-text-2" id="text-orgdf71a2d">
</div>
<div id="outline-container-orgc788ea4" class="outline-3">
<h3 id="orgc788ea4">多行字符串</h3>
<div class="outline-text-3" id="text-orgc788ea4">
<p>
Nix 中被 <b>两对单引号</b> <span class="underline">''</span> 引用的内容即为多行字符串：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #ffa07a;">''</span>
<span style="color: #ffa07a;">multi</span>
<span style="color: #ffa07a;">line</span>
<span style="color: #ffa07a;">string</span>
<span style="color: #ffa07a;">''</span>
</pre>
</div>

<p>
等价于：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #ffa07a;">"multi\nline\nstring"</span>
</pre>
</div>

<p>
Nix 的多行字符串存在特殊行为，Nix 会智能地去除掉开头的缩进，这在其他语言中是不常见的：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #ffa07a;">''</span>
<span style="color: #ffa07a;">  one</span>
<span style="color: #ffa07a;">   two</span>
<span style="color: #ffa07a;">    three</span>
<span style="color: #ffa07a;">''</span>
</pre>
</div>

<p>
等价于：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #ffa07a;">"one\n two\n  three\n"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6edcc3b" class="outline-2">
<h2 id="org6edcc3b">函数</h2>
<div class="outline-text-2" id="text-org6edcc3b">
<p>
函数在 Nix 语言中是人上人，先来声明一个 匿名函数 <span class="underline">Lambda</span> ：
</p>

<div class="org-src-container">
<pre class="src src-nix">x: x + 1

<span style="color: #ff4500;">#  </span><span style="color: #ff4500;">&#171;lambda @ &#171;string&#187;:1:1&#187;</span>
</pre>
</div>
<ul class="org-ul">
<li>引号左边是函数 <span class="underline">参数</span></li>
<li>引号右边跟随一个 <span class="underline">空格</span> ，随即是 <span class="underline">函数体</span></li>
</ul>

<p>
Nix 支持多重参数（柯里化函数）：
</p>

<div class="org-src-container">
<pre class="src src-nix">x: y: x + y

  <span style="color: #ff4500;">#&#171;lambda @ &#171;string&#187;:1:1&#187;</span>
</pre>
</div>

<p>
参数当然可以是 <span class="underline">属性集</span> 类型：
</p>

<div class="org-src-container">
<pre class="src src-nix">{ a, b }: a + b

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#171;lambda @ &#171;string&#187;:1:1&#187;</span>
</pre>
</div>

<p>
为函数指定 <span class="underline">默认</span> 参数，在缺省该参数赋值的情况下，它就是默认值：
</p>
<div class="org-src-container">
<pre class="src src-nix">{ a, b ? 0 }: a + b
</pre>
</div>

<p>
允许传入额外的属性：
</p>

<div class="org-src-container">
<pre class="src src-nix">{ a, b, ...}: a + b  <span style="color: #ff4500;"># &#26126;&#30830;&#20256;&#20837;&#30340;&#23646;&#24615;&#26377; a &#21644; b&#65292;&#20256;&#20837;&#39069;&#22806;&#30340;&#23646;&#24615;&#23558;&#34987;&#24573;&#30053;</span>
{ a, b, ...}: a + b + c  <span style="color: #ff4500;"># &#21363;&#20351;&#20256;&#20837;&#30340;&#23646;&#24615;&#26377; c&#65292;&#19968;&#26679;&#19981;&#20250;&#21442;&#19982;&#35745;&#31639;&#65292;&#36825;&#37324;&#20250;&#25253;&#38169; </span>

<span style="color: #ff4500;">#  </span><span style="color: #ff4500;">error: undefined variable 'c'</span>

 <span style="color: #ff4500;">#      at &#171;string&#187;:1:23:</span>

  <span style="color: #ff4500;">#          1| { a, b, ...}: a + b + c</span>
   <span style="color: #ff4500;">#          |                       ^</span>
</pre>
</div>

<p>
为额外的参数 <b>绑定</b> 到参数集，然后调用：
</p>

<div class="org-src-container">
<pre class="src src-nix">args@{ a, b, ... }: a + b + args.c
{ a, b, ... }@args: a + b + args.c  <span style="color: #ff4500;"># &#20063;&#21487;&#20197;&#26159;&#36825;&#26679;</span>
</pre>
</div>

<p>
为函数命名：
</p>

<div class="org-src-container">
<pre class="src src-nix"><span style="color: #00ffff;">let</span>
  <span style="color: #eedd82;">f</span> = x: x + 1;
<span style="color: #00ffff;">in</span>
  f
</pre>
</div>

<p>
调用函数，并使用函数构建新属性集：
</p>
<div class="org-src-container">
<pre class="src src-nix"><span style="color: #eedd82;">concat</span> = { a, b }: a + b  <span style="color: #ff4500;"># &#31561;&#20215;&#20110; concat = x: x.a + x.b</span>
concat { <span style="color: #eedd82;">a</span> = <span style="color: #ffa07a;">"Hello "</span>; <span style="color: #eedd82;">b</span> = <span style="color: #ffa07a;">"NixOS"</span>; }
</pre>
</div>

<p>
输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">Hello NixOS
</pre>
</div>

<p>
由于函数与参数使用空格分隔，所以可以使用 <span class="underline">括号</span> 将函数体与参数分开：
</p>

<div class="org-src-container">
<pre class="src src-nix">(x: x + 1) 1  <span style="color: #ff4500;"># &#21521;&#35813; Lambda &#20989;&#25968;&#20256;&#20837;&#21442;&#25968; 1</span>

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">2 </span>
</pre>
</div>
</div>
<div id="outline-container-org652dfbd" class="outline-3">
<h3 id="org652dfbd">高阶函数</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
