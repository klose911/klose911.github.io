<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>TCP：传输控制协议</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="bootp.html"> UP </a>
 |
 <a accesskey="H" href="tii.html"> HOME </a>
</div><div id="content">
<h1 class="title">TCP：传输控制协议</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">TCP 协议</a>
<ul>
<li><a href="#sec-1-1">服务</a>
<ul>
<li><a href="#sec-1-1-1">面向连接</a></li>
<li><a href="#sec-1-1-2">可靠性</a></li>
<li><a href="#sec-1-1-3">字节流</a></li>
</ul>
</li>
<li><a href="#sec-1-2">首部</a>
<ul>
<li><a href="#sec-1-2-1">端口号字段</a></li>
<li><a href="#sec-1-2-2">序号字段</a></li>
<li><a href="#sec-1-2-3">确认序号字段</a></li>
<li><a href="#sec-1-2-4">首部长度</a></li>
<li><a href="#sec-1-2-5">标志位字段</a>
<ul>
<li><a href="#sec-1-2-5-1">紧急方式</a></li>
</ul>
</li>
<li><a href="#sec-1-2-6">窗口大小字段</a>
<ul>
<li><a href="#sec-1-2-6-1">滑动窗口</a></li>
</ul>
</li>
<li><a href="#sec-1-2-7">检验和字段</a></li>
<li><a href="#sec-1-2-8">选项字段</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章将介绍TCP为应用层提供的服务，以及TCP首部中的各个字段。随后的几章在了解TCP的工作过程中将对这些字段作详细介绍：
</p>
<ul class="org-ul">
<li>描述如何建立和终止一个TCP连接
</li>
<li>了解正常的数据传输过程：
<ul class="org-ul">
<li>交互使用（远程登录）
</li>
<li>批量数据传送（文件传输）
</li>
</ul>
</li>
<li>提供TCP超时及重传的技术细节
<ul class="org-ul">
<li>介绍两种其他的定时器
</li>
</ul>
</li>
<li>概述TCP新的特性以及TCP的性能
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">TCP 协议</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">服务</h3>
<div class="outline-text-3" id="text-1-1">
<p>
尽管TCP和UDP都使用相同的网络层( <b>IP</b> )，TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">面向连接</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁
</p>

<p>
在一个TCP连接中，仅有两方进行彼此通信。以前介绍的 <b>广播和多播不能用于TCP</b> 
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">可靠性</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
TCP通过下列方式来提供可靠性：
</p>
<ol class="org-ol">
<li>应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段( <b>segement</b> )
</li>
<li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段
</li>
<li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将 <b>推迟几分之一秒</b>
</li>
<li>TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）
</li>
<li>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。 <b>如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层</b>
</li>
<li>既然IP数据报会发生重复， <b>TCP的接收端必须丢弃重复的数据</b> 
</li>
<li>TCP还能 <b>提供流量控制</b> 。TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">字节流</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端。
</p>

<p>
TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层解释
</p>

<pre class="example">
这种对字节流的处理方式与Unix操作系统对文件的处理方式很相似

Unix的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理

对Unix的内核来说，它无法区分一个二进制文件与一个文本文件
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">首部</h3>
<div class="outline-text-3" id="text-1-2">
<p>
TCP数据被封装在一个IP数据报中，如图17-1所示：
</p>


<div class="figure">
<p><img src="pic/ip-tcp-headers.png" alt="ip-tcp-headers.png" width="70%" />
</p>
</div>

<p>
图17-2显示TCP首部的数据格式。如果不计 <b>选项</b> 字段，它通常是20个字节：
</p>


<div class="figure">
<p><img src="pic/tcp-header.png" alt="tcp-header.png" width="70%" />
</p>
</div>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">端口号字段</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
每个TCP段都包含 <b>源端和目的端的端口号</b> ，用于寻找发端和收端应用进程。这两个值加上 <b>IP首部中的源端IP地址和目的端IP地址</b> 唯一确定一个TCP连接
</p>

<p>
有时，一个IP地址和一个端口号也称为一个socket。这个术语出现在最早的TCP规范(RFC793)中，后来它也作为表示伯克利版的编程接口。插口对包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组可唯一确定互联网络中每个TCP连接的双方
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">序号字段</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
序号用来 <b>标识从TCP发端向TCP收端发送的数据字节流</b> ，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 <b>TCP用序号对每个字节进行计数</b> 
</p>

<pre class="example">
    序号是32bit的无符号数，序号到达2^32-1后又从0开始
    
    当建立一个新的连接时，SYN标志变1
    
    序号字段包含由这个主机选择的该连接的初始序号ISN
    
    该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">确认序号字段</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此， <b>确认序号应当是上次已成功收到数据字节序号加1</b> 
</p>

<pre class="example">
    只有ACK标志为1时确认序号字段才有效
    
    发送ACK无需任何代价，因为32bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。
    
    因此一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1
</pre>

<p>
TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号
</p>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">首部长度</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
首部长度给出首部中32bit字的数目：
</p>

<pre class="example">
    需要这个值是因为任选字段的长度是可变的
    
    这个字段占4bit，因此TCP最多有60字节的首部
    
    没有任选字段，正常的长度是20字节
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">标志位字段</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
在TCP首部中有6个标志比特。它们中的多个可同时被设置为1：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> TCP首部标志位</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标志位</td>
<td class="left">描述</td>
</tr>

<tr>
<td class="left">URG</td>
<td class="left">紧急指针有效</td>
</tr>

<tr>
<td class="left">ACK</td>
<td class="left">确认序号有效</td>
</tr>

<tr>
<td class="left">PSH</td>
<td class="left">接收方应该尽快把这个报文段发给应用层</td>
</tr>

<tr>
<td class="left">RST</td>
<td class="left">重建连接</td>
</tr>

<tr>
<td class="left">SYN</td>
<td class="left">同步序号用来建立连接</td>
</tr>

<tr>
<td class="left">FIN</td>
<td class="left">发送端完成任务</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-1-2-5-1" class="outline-5">
<h5 id="sec-1-2-5-1">紧急方式</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<p>
只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号
</p>

<p>
TCP的紧急方式是发送端向另一端发送紧急数据的一种方式
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">窗口大小字段</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
TCP的流量控制由 <b>连接的每一端通过声明的窗口大小</b> 来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是 <b>接收端正期望接收的字节</b> 
</p>

<pre class="example">
    窗口大小是一个16 bit字段，因而窗口大小最大为65535字节
</pre>
</div>

<div id="outline-container-sec-1-2-6-1" class="outline-5">
<h5 id="sec-1-2-6-1">滑动窗口</h5>
<div class="outline-text-5" id="text-1-2-6-1">
<p>
TCP可以表述为 <b>一个没有选择确认或否认的滑动窗口协议</b> ：
</p>

<ul class="org-ul">
<li>缺少选择确认是因为TCP首部中的确认序号表示发方已成功收到字节，但还不包含确认序号所指的字节，当前还无法对数据流中选定的部分进行确认：
</li>
</ul>

<pre class="example">
例如，如果1～1024字节已经成功收到，下一报文段中包含序号从2049～3072的字节

然而收端并不能确认这个新的报文段，它所能做的就是发回一个确认序号为1025的ACK
</pre>

<ul class="org-ul">
<li>同样也无法对一个报文段进行否认：
</li>
</ul>

<pre class="example">
例如，如果收到包含1025～2048字节的报文段，但它的检验和错，TCP接收端所能做的就是发回一个确认序号为1025的ACK
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7">检验和字段</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证
</p>

<p>
TCP检验和的计算和UDP检验和的计算相似，使用如前所述的一个伪首部
</p>
</div>
</div>


<div id="outline-container-sec-1-2-8" class="outline-4">
<h4 id="sec-1-2-8">选项字段</h4>
<div class="outline-text-4" id="text-1-2-8">
<p>
最常见的可选字段是 <b>最长报文大小</b> ，又称为MSS。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段
</p>

<p>
同样TCP报文段中的数据部分是可选的：
</p>
<ul class="org-ul">
<li>一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据
</li>
<li>在处理超时的许多情况中，也会发送不带任何数据的报文段
</li>
</ul>

<p>
<a href="tcp-connection.html">Next：TCP 连接的建立和终止</a>
</p>

<p>
<a href="bootp.html">Previous：BOOTP 引导程序协议</a>
</p>

<p>
<a href="tii.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
