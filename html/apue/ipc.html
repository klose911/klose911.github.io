<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程间通信</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="daemon.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">进程间通信</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org6c844ca">管道</a>
<ul>
<li><a href="#orge8b5e8c">pipe函数</a>
<ul>
<li><a href="#org5ea31b2">实例：创建管道</a></li>
<li><a href="#orgb7ee184">实例：分页展示文件</a></li>
<li><a href="#org2a6624e">实例：父子进程同步</a></li>
</ul>
</li>
<li><a href="#org11d9ee3">popen和pclose函数</a>
<ul>
<li><a href="#org0f28e71">cmdstring</a></li>
<li><a href="#orga4b77f9">使用popen实现分页读取文件</a></li>
<li><a href="#orgd3f9e21">实现popen和pclose函数</a></li>
<li><a href="#orgd331135">用popen变换输入</a></li>
</ul>
</li>
<li><a href="#org47939cf">协同进程</a>
<ul>
<li><a href="#org490667e">对两个数求和的简单过滤</a>
<ul>
<li><a href="#org639fa44">使用标准IO改写add2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf4281a9">FIFO</a>
<ul>
<li><a href="#org169d951">mkfifo函数</a></li>
<li><a href="#orgb04fdd5">FIFO文件</a></li>
<li><a href="#org8a35715">FIFO用途</a>
<ul>
<li><a href="#org91eeaaa">复制输出流</a></li>
<li><a href="#org0e6749b">简单客户-服务器通信</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org337df82">系统V IPC</a>
<ul>
<li><a href="#org5daf1a1">相似特征</a>
<ul>
<li><a href="#org3a6482c">标识符和关键字</a>
<ul>
<li><a href="#orgda7eb86">客户机和服务器使用同一IPC结构</a></li>
<li><a href="#org18d3e40">创建IPC结构</a></li>
</ul>
</li>
<li><a href="#org63e22f2">权限结构</a>
<ul>
<li><a href="#orgb48b38c">mode字段</a></li>
</ul>
</li>
<li><a href="#org9f4e6d8">资源限制</a></li>
<li><a href="#orga73ff4c">优点和缺点</a>
<ul>
<li><a href="#orgb612dd1">系统V IPC的缺点</a></li>
<li><a href="#org6354038">IPC的优点</a></li>
<li><a href="#org1471129">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb3aec5e">消息队列</a>
<ul>
<li><a href="#org774c1ff">msqid_ds结构</a></li>
<li><a href="#org0f9fb4e">资源限制</a></li>
<li><a href="#orgb4eebda">msgget函数</a></li>
<li><a href="#orgf850e94">msgctl函数</a>
<ul>
<li><a href="#orgfb635ac">cmd参数</a></li>
</ul>
</li>
<li><a href="#orgdcc6e53">msgsnd函数</a>
<ul>
<li><a href="#orgca8ed73">ptr指针</a></li>
<li><a href="#orgd66aa4b">flag标记</a></li>
</ul>
</li>
<li><a href="#org3fcde4a">msgrcv函数</a>
<ul>
<li><a href="#org40bdebe">type参数</a></li>
</ul>
</li>
<li><a href="#org1853260">实例</a></li>
</ul>
</li>
<li><a href="#orgdc4c516">信号量</a>
<ul>
<li><a href="#org8b2d17d">实现</a></li>
<li><a href="#org9bb3938">semid_ds结构</a></li>
<li><a href="#org9c973ae">资源限制</a></li>
<li><a href="#org98cfb2a">semget函数</a></li>
<li><a href="#org62429ab">semctl函数</a>
<ul>
<li><a href="#org4e17128">cmd参数</a></li>
</ul>
</li>
<li><a href="#org6fd7980">semop函数</a>
<ul>
<li><a href="#orgb2402ea">semoarray参数</a></li>
<li><a href="#org52cb8f5">exit时的信号量调整</a></li>
</ul>
</li>
<li><a href="#org93d9dad">实例</a></li>
<li><a href="#org309b047">信号量 VS 文件锁</a></li>
</ul>
</li>
<li><a href="#orgcf4d37a">共享内存</a>
<ul>
<li><a href="#org902bcd7">shmid_ds结构</a></li>
<li><a href="#orgccff110">资源限制</a></li>
<li><a href="#orga090675">shmget函数</a></li>
<li><a href="#orgcac8c77">shmctl函数</a>
<ul>
<li><a href="#org66a590a">cmd参数</a></li>
</ul>
</li>
<li><a href="#org4239445">shmat函数</a></li>
<li><a href="#orge694ed7">shmdt函数</a></li>
<li><a href="#org9f4b2e1">打印不同类型的数据所存放的位置</a></li>
<li><a href="#org54542f6">/dev/zero的存储映射</a>
<ul>
<li><a href="#org367076e">匿名存储映射</a></li>
<li><a href="#org33bfb44">共享存储 VS mmap</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org69df744">客户机-服务器模型</a>
<ul>
<li><a href="#org3ad86da">单向管道</a></li>
<li><a href="#orgf8240a9">FIFO</a></li>
<li><a href="#org8fe11bd">消息队列</a>
<ul>
<li><a href="#org8929ca3">实现</a></li>
<li><a href="#orgb880d23">缺陷</a>
<ul>
<li><a href="#orgcc046be">安全措施</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9d4a616">总结</a></li>
</ul>
</div>
</div>
<pre class="example" id="orgd37377c">
第8章说明了进程控制原语并且观察了如何调用多个进程

但是这些进程之间交换信息的唯一方法是经由fork或exec传送打开文件，或通过文件系统

本章将说明进程之间相互通信的其他技术IPC

</pre>
<p>
UNIX <span class="underline">IPC</span> 已经是而且继续是各种 <b>进程通信方式</b> 的统称，其中极少能在所有UNIX的实现中进行移植。下表列出了不同实现所支持的不同形式的IPC：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> UNIX IPC</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">IPC类型</td>
<td class="org-left">POSIX.1</td>
<td class="org-left">XPG3</td>
<td class="org-left">V7</td>
<td class="org-left">SVR2</td>
<td class="org-left">SVR3.2</td>
<td class="org-left">SVR4</td>
<td class="org-left">4.3BSD</td>
<td class="org-left">4.3+BSD</td>
</tr>

<tr>
<td class="org-left">管道(半双工)</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">FIFO(命令管道)</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流管道(全双工)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">命令流管道</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">消息队列</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">信号量</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">共享内存</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">套接口</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
正如上表所示，不管哪一种UNIX实现，都可依靠的唯一一种IPC是 <b>半双工的管道</b> 
</p>

<pre class="example" id="org69a5d4c">
表中前7种IPC通常限于同一台主机的各个进程间的IPC

最后两种：套接口和流，则支持不同主机上各个进程间IPC

虽然中间三种形式的IPC(消息队列、信号量以及共享存储器)在表中说明为只受到系统V的支持
但是在大多数制造商所支持的，从伯克利UNIX导出的UNIX系统中(例如，SunOS以及Ultrix)已经添加了这三种形式的IPC
</pre>

<p>
本章将讨论经典的IPC：
</p>
<ul class="org-ul">
<li>管道</li>
<li>FIFO</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
</ul>


<div id="outline-container-org6c844ca" class="outline-2">
<h2 id="org6c844ca">管道</h2>
<div class="outline-text-2" id="text-org6c844ca">
<p>
<b>管道</b> 是UNIX IPC的最老形式，有两种限制; 
</p>
<ol class="org-ol">
<li><span class="underline">半双工</span> ： <b>数据只能在 <span class="underline">一个方向</span> 上流动</b></li>
<li>只能在具有 <b>公共祖先</b> 的 <span class="underline">进程之间</span> 使用：通常一个 <span class="underline">管道</span> 由一个 <span class="underline">进程创建</span> ，然后该进程调用 <span class="underline">fork</span> ，此后 <b>父、子进程之间就可应用该管道</b></li>
</ol>

<pre class="example" id="org4dde1d8">
尽管有这两种限制，半双工管道仍是最常用的IPC形式

并且所有UNIX系统都提供此种通信机制
</pre>
</div>
<div id="outline-container-orge8b5e8c" class="outline-3">
<h3 id="orge8b5e8c">pipe函数</h3>
<div class="outline-text-3" id="text-orge8b5e8c">
<p>
<span class="underline">pipe</span> 函数： <b>创建</b> 管道
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#31649;&#36947;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * filedes: &#25991;&#20214;&#25551;&#36848;&#31526;&#25968;&#32452;&#65292;filedes[0]&#20026;&#35835;&#32780;&#25171;&#24320;&#65292;filedes[1]&#20026;&#20889;&#32780;&#25171;&#24320;&#65292;filedes[1]&#30340;&#36755;&#20986;&#26159;filedes[0]&#30340;&#36755;&#20837;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pipe</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>[2]);
</pre>
</div>
<p>
参数 <span class="underline">filedes数组返回</span> 两个文件描述符：
</p>
<ul class="org-ul">
<li><span class="underline">filedes[0]</span> ：为 <b>读</b> 而打开</li>
<li><span class="underline">filedes[1]</span> ：为 <b>写</b> 而打开</li>
<li><span class="underline">filedes[1]的输出</span> 正好是 <span class="underline">filedes[0]的输入</span></li>
</ul>

<pre class="example" id="orge4c5711">
有两种方法来描绘一个管道：

左半图显示了 管道的两端 在 一个进程 中 相互连接

右半图则说明 数据 通过 内核 在 管道 中 流动 
</pre>


<div id="orgdb88389" class="figure">
<p><img src="pic/pipe.jpg" alt="pipe.jpg" width="90%" /> 
</p>
</div>

<pre class="example" id="org58a06a1">
fstat函数对管道的每一端都返回一个FIFO类型的文件描述符，可以用S_ISFIFO宏来测试管道
</pre>

<p>
单个进程中的管道几乎没有任何用处。通常 <span class="underline">调用pipe的进程</span> 接着 <b>调用fork</b> ，这样就创建了从 <span class="underline">父进程到子进程</span> 或 <span class="underline">反之的IPC通道</span> 。下图显示了这种情况：
</p>

<div id="orge8ffcf4" class="figure">
<p><img src="pic/pipe-fork.jpg" alt="pipe-fork.jpg" width="70%" /> 
</p>
</div>

<pre class="example" id="org57219bf">
fork之后做什么取决于我们想要有的数据流的方向
</pre>

<p>
对于从 <span class="underline">父进程</span> 到 <span class="underline">子进程</span> 的管道：
</p>
<ul class="org-ul">
<li><span class="underline">父进程</span> <b>关闭</b>  <span class="underline">管道的读端</span> (fd[0])</li>
<li><span class="underline">子进程</span> 则 <b>关闭</b> <span class="underline">写端</span> (fd[1])。下图显示了描述符的最后安排：</li>
</ul>

<div id="orged2855c" class="figure">
<p><img src="pic/pipe-fork-close.jpg" alt="pipe-fork-close.jpg" width="70%" /> 
</p>
</div>

<p>
当管道的一端被关闭后，下列规则起作用：
</p>
<ul class="org-ul">
<li>当 <span class="underline">读</span> 一个 <b>写端已被关闭</b> 的管道时：在所有数据都被读取后， <span class="underline">read</span> 返回 <span class="underline">0</span> ，以指示 <b>达到了文件结束处</b></li>
</ul>
<pre class="example" id="orge86a2ba">
从技术方面考虑，管道的写端还有进程时，就不会产生文件的结束

可以复制一个管道的描述符，使得有多个进程具有写打开文件描述符

但是，通常一个管道只有一个读进程，一个写进程
</pre>
<ul class="org-ul">
<li>如果 <span class="underline">写</span> 一个 <b>读端已被关闭</b> 的管道：则产生信号 <span class="underline">SIGPIPE</span>
<ul class="org-ul">
<li>如果 <span class="underline">忽略</span> 该信号或者 <span class="underline">捕捉</span> 该信号并从其处理程序返回，则 <b>write出错返回</b> ，errno设置为 <span class="underline">EPIPE</span></li>
</ul></li>
</ul>


<pre class="example" id="orge142df3">
注意：在写管道时，常数PIPE_BUF规定了内核中管道缓存器的大小

如果对管道进行write调用，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或FIFO)的write操作穿插进行

但是若有多个进程同时写一个管道(FIFO)，而且某个或某些进程要求写的字节数超过PIPE_BUF字节数，则数据可能会与其他写操作的数据相穿插
</pre>
</div>

<div id="outline-container-org5ea31b2" class="outline-4">
<h4 id="org5ea31b2">实例：创建管道</h4>
<div class="outline-text-4" id="text-org5ea31b2">
<p>
创建了一个从 <span class="underline">父进程</span> 到 <span class="underline">子进程</span> 的 <b>管道</b> ，并且父进程经由该管道向子进程传送数据：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>[2];
        <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

        <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(fd) &lt; 0)
                err_sys(<span style="color: #deb887;">"pipe error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
                err_sys(<span style="color: #deb887;">"fork error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                close(fd[0]);<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">close read tunnel of pipe in parent process</span>
                <span style="color: #00bfff; font-weight: bold;">if</span>(write(fd[1], <span style="color: #deb887;">"hello world\n"</span>, 12) &lt; 0)
                        err_sys(<span style="color: #deb887;">"write to pipe error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> {                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                close(fd[1]); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">close write tunnel of pipe in child process</span>
                n = read(fd[0], line, MAXLINE);
                <span style="color: #00bfff; font-weight: bold;">if</span>(write(STDOUT_FILENO, line, n) &lt; 0)
                        err_sys(<span style="color: #deb887;">"write to console error"</span>);
        }

        exit(0);
}
</pre>
</div>
<pre class="example" id="org80e3f7d">
上面程序对管道描述符调用read和write

更为普遍的是将管道描述符复制为 “标准输入”和“标准输出”

在此之后通常子进程调用'exec'，执行另一个程序
该程序从标准输入(已创建的管道)或将数据写至其标准输出(管道)
</pre>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/pipe1

hello world
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb7ee184" class="outline-4">
<h4 id="orgb7ee184">实例：分页展示文件</h4>
<div class="outline-text-4" id="text-orgb7ee184">
<pre class="example" id="org4c279dc">
下面程序的功能是每次一页显示已产生的输出

已经有很多UNIX公用程序具有分页功能，因此无需再构造一个新的分页程序，而是调用用户最喜爱的分页程序
</pre>
<p>
为了 <b>避免</b> 先将 <span class="underline">所有数据写到一个临时文件</span> 中，然后再调用系统中的有关程序显示该文件，将 <span class="underline">输出</span> 通过 <b>管道</b> 直接送到 <span class="underline">分页程序</span> ：
</p>
<ol class="org-ol">
<li>创建一个 <span class="underline">管道</span></li>
<li>创建一个 <span class="underline">子进程</span></li>
<li>使 <span class="underline">子进程的标准输入</span> 成为 <b>管道的读端</b></li>
<li><p>
<span class="underline">exec</span> 用户喜爱的 <span class="underline">分页程序</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DEF_PAGER</span>   <span style="color: #deb887;">"/usr/bin/less"</span>     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">default pager program</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>[2];
        <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
        <span style="color: #98f5ff;">char</span>    *<span style="color: #4eee94;">pager</span>, *<span style="color: #4eee94;">argv0</span>;
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];
        <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fp</span>;

        <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 2)
                err_quit(<span style="color: #deb887;">"usage: a.out &lt;pathname&gt;"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fopen(argv[1], <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
                err_sys(<span style="color: #deb887;">"can't open %s"</span>, argv[1]);
        <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(fd) &lt; 0)
                err_sys(<span style="color: #deb887;">"pipe error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
                err_sys(<span style="color: #deb887;">"fork error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {                               <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                close(fd[0]);       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close read end</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent copies argv[1] to pipe</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, fp) != <span style="color: #ffd700;">NULL</span>) {
                        n = strlen(line);
                        <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd[1], line, n) != n)
                                err_sys(<span style="color: #deb887;">"write error to pipe"</span>);
                }
                <span style="color: #00bfff; font-weight: bold;">if</span> (ferror(fp))
                        err_sys(<span style="color: #deb887;">"fgets error"</span>);

                close(fd[1]);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close write end of pipe for reader</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

                <span style="color: #00bfff; font-weight: bold;">if</span> (waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) &lt; 0)
                        err_sys(<span style="color: #deb887;">"waitpid error"</span>);
                exit(0);
        } <span style="color: #00bfff; font-weight: bold;">else</span> {                                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                close(fd[1]);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close write end</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">if</span> (fd[0] != STDIN_FILENO) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">standard input descriptor point to fd[0]</span>
                        <span style="color: #00bfff; font-weight: bold;">if</span> (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)
                                err_sys(<span style="color: #deb887;">"dup2 error to stdin"</span>);
                        close(fd[0]);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">don't need this after dup2</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                }

                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">get arguments for execl()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">if</span> ((pager = getenv(<span style="color: #deb887;">"PAGER"</span>)) == <span style="color: #ffd700;">NULL</span>)
                        pager = DEF_PAGER;
                <span style="color: #00bfff; font-weight: bold;">if</span> ((argv0 = strrchr(pager, <span style="color: #deb887;">'/'</span>)) != <span style="color: #ffd700;">NULL</span>)
                        argv0++;        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">step past rightmost slash</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">else</span>
                        argv0 = pager;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">no slash in pager</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

                <span style="color: #00bfff; font-weight: bold;">if</span> (execl(pager, argv0, (<span style="color: #98f5ff;">char</span> *)0) &lt; 0)
                        err_sys(<span style="color: #deb887;">"execl error for %s"</span>, pager);
        }
        exit(0);
}
</pre>
</div></li>
</ol>

<pre class="example" id="org76630e2">
在调用fork之前先创建一个管道

fork之后父进程关闭其读端

子进程关闭其写端

子进程然后调用dup2，使其标准输入指向管道的读端

当执行分页程序时，其标准输入将是管道的读端
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/most2 Makefile

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">Makefile.in generated by automake 1.15 from Makefile.am.</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">Makefile.  Generated from Makefile.in by configure.</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">Copyright (C) 1994-2014 Free Software Foundation, Inc.</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">This Makefile.in is free software; the Free Software Foundation</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">gives unlimited permission to copy and/or distribute it,</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">with or without modifications, as long as this notice is preserved.</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">This program is distributed in the hope that it will be useful,</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">but WITHOUT ANY WARRANTY, to the extent permitted by law; without</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">even the implied warranty of MERCHANTABILITY or FITNESS FOR A</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">PARTICULAR PURPOSE.</span>



am__is_gnu_make = { <span style="color: #deb887;">\</span>
  <span style="color: #00bfff; font-weight: bold;">if </span><span style="color: #f08080;">test</span> -z <span style="color: #deb887;">'$(</span><span style="color: #fa8072;">MAKELEVEL</span><span style="color: #deb887;">)'</span>; <span style="color: #00bfff; font-weight: bold;">then</span> <span style="color: #deb887;">\</span>
    false; <span style="color: #deb887;">\</span>
  <span style="color: #00bfff; font-weight: bold;">elif </span><span style="color: #f08080;">test</span> -n <span style="color: #deb887;">'$(</span><span style="color: #fa8072;">MAKE_HOST</span><span style="color: #deb887;">)'</span>; <span style="color: #00bfff; font-weight: bold;">then</span> <span style="color: #deb887;">\</span>
    true; <span style="color: #deb887;">\</span>
  <span style="color: #00bfff; font-weight: bold;">elif </span><span style="color: #f08080;">test</span> -n <span style="color: #deb887;">'$(</span><span style="color: #fa8072;">MAKE_VERSION</span><span style="color: #deb887;">)'</span> &amp;&amp; <span style="color: #f08080;">test</span> -n <span style="color: #deb887;">'$(</span><span style="color: #fa8072;">CURDIR</span><span style="color: #deb887;">)'</span>; <span style="color: #00bfff; font-weight: bold;">then</span> <span style="color: #deb887;">\</span>
: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20998;&#39029;&#24320;&#22987;</span>
</pre>
</div>

<p>
将一个描述符复制到另一个时，在子进程中，fd[0]复制到标准输入
</p>

<pre class="example" id="org32b52ca">
注意：该描述符fd[0]的值不允许已经是所希望的值

如果fd[0]已经是标准输入，并且先调用dup2，然后调用close则将关闭此进程中只有该单个描述符所代表的标准输入

在本程序中，如果shell没有打开标准输入，那么程序开始处的fopen应已使用描述符0，也就是最小未使用的描述符，所以fd[0]决不会等于标准输入

尽管如此，只要先调用dup2，然后调用close以复制一个描述符到另一个，作为一种保护性的编程措施，总是先将两个描述符进行比较
</pre>
<p>
先使用 <span class="underline">环境变量PAGER</span> 获得 <b>用户分页程序名称</b> 
</p>

<pre class="example" id="orgf34db38">
如果操作没有成功，则使用系统默认值。这是环境变量的常见用法
</pre>
</div>
</div>

<div id="outline-container-org2a6624e" class="outline-4">
<h4 id="org2a6624e">实例：父子进程同步</h4>
<div class="outline-text-4" id="text-org2a6624e">
<pre class="example" id="org5c667d0">
以前使用信号实现了TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD
</pre>
<p>
下面则是一个使用 <span class="underline">管道</span> 的实现：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span>  <span style="color: #4eee94;">pfd1</span>[2], <span style="color: #4eee94;">pfd2</span>[2];

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_WAIT</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(pfd1) &lt; 0 || pipe(pfd2) &lt; 0)
                err_sys(<span style="color: #deb887;">"pipe error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_PARENT</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>)
{
        <span style="color: #00bfff; font-weight: bold;">if</span> (write(pfd2[1], <span style="color: #deb887;">"c"</span>, 1) != 1)
                err_sys(<span style="color: #deb887;">"write error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">WAIT_PARENT</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">c</span>;

        <span style="color: #00bfff; font-weight: bold;">if</span> (read(pfd1[0], &amp;c, 1) != 1)
                err_sys(<span style="color: #deb887;">"read error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> (c != <span style="color: #deb887;">'p'</span>)
                err_quit(<span style="color: #deb887;">"WAIT_PARENT: incorrect data"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_CHILD</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>)
{
        <span style="color: #00bfff; font-weight: bold;">if</span> (write(pfd1[1], <span style="color: #deb887;">"p"</span>, 1) != 1)
                err_sys(<span style="color: #deb887;">"write error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">WAIT_CHILD</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">c</span>;

        <span style="color: #00bfff; font-weight: bold;">if</span> (read(pfd2[0], &amp;c, 1) != 1)
                err_sys(<span style="color: #deb887;">"read error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> (c != <span style="color: #deb887;">'c'</span>)
                err_quit(<span style="color: #deb887;">"WAIT_CHILD: incorrect data"</span>);
}
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">TELL_WAIT</span> : 在 <span class="underline">fork之前</span> <b>创建</b> 了 <span class="underline">两个管道</span>  <span class="underline">pfd1[2]</span> ,  <span class="underline">pfd2[2]</span></li>
<li><span class="underline">TELL_CHILD</span> : 父进程向 <span class="underline">pfd1[1]</span> <b>写</b> 一个字符 <span class="underline">P</span></li>
<li><span class="underline">WAIT_PARENT</span> : 子进程从 <span class="underline">pfd1[0]</span>  <b>读</b> 一个字符， <b>没有读到字符时阻塞</b> (睡眠等待)</li>
<li><span class="underline">TELL_PARENT</span> : 子进程向 <span class="underline">pfd2[1]</span>  <b>写</b> 一个字符 <span class="underline">C</span></li>
<li><p>
<span class="underline">WAIT_CHILD</span> : 父进程从 <span class="underline">pfd2[0]</span>  <b>读</b> 一个字符， <b>没有读到字符时阻塞</b> (睡眠等待)
</p>


<div id="org0eb09d7" class="figure">
<p><img src="pic/pipe-tell-wait.jpg" alt="pipe-tell-wait.jpg" width="70%" /> 
</p>
</div></li>
</ul>

<pre class="example" id="org032224d">
注意：每一个管道都有一个额外的读取进程，这没有关系

也就是说除了"子进程"从pfd1[0]读取，父进程也有上一个管道的读端
因为父进程并没有执行对该管道的读操作，所以这不会产生任何影响
</pre>
</div>
</div>
</div>

<div id="outline-container-org11d9ee3" class="outline-3">
<h3 id="org11d9ee3">popen和pclose函数</h3>
<div class="outline-text-3" id="text-org11d9ee3">
<pre class="example" id="org8c20a21">
常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其发送输入

标准I/O库为实现这些操作提供了两个函数popen和pclose
</pre>

<p>
<span class="underline">popen</span> 实现的操作是：
</p>
<ol class="org-ol">
<li><span class="underline">创建</span> 一个 <span class="underline">管道</span></li>
<li><span class="underline">fork</span> 一个 <span class="underline">子进程</span></li>
<li><span class="underline">关闭</span> 管道的 <span class="underline">不使用端</span></li>
<li><span class="underline">exec</span> 一个 <span class="underline">shell</span> 以 <b>执行命令</b></li>
<li><b>等待</b> <span class="underline">命令终止</span></li>
</ol>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#19968;&#20010;&#23376;&#36827;&#31243;&#65292;&#29992;&#20110;&#25191;&#34892;&#25351;&#23450;&#30340;shell&#21629;&#20196;</span>
<span style="color: #ffebcd;"> * &#21487;&#20197;&#23558;&#27492;&#23376;&#36827;&#31243;&#30340;&#26631;&#20934;&#36755;&#20837;&#25110;&#26631;&#20934;&#36755;&#20986;&#20026;&#31649;&#36947;&#65292;&#35813;&#31649;&#36947;&#30340;&#21478;&#19968;&#31471;&#20026;&#35843;&#29992;&#36827;&#31243;&#20013;&#36820;&#22238;&#30340;&#31649;&#36947;&#25991;&#20214;&#27969;&#25351;&#38024;&#25152;&#24341;&#29992;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * cmdstring : &#35201;&#25191;&#34892;&#30340;shell&#21629;&#20196;</span>
<span style="color: #ffebcd;"> * type : &#20026;"r"&#26102;&#65292;&#23376;&#36827;&#31243;&#25152;&#25191;&#34892;&#21629;&#20196;&#30340;&#26631;&#20934;&#36755;&#20986;&#20026;&#31649;&#36947;&#30340;&#36755;&#20837;&#31471;&#65292;&#35813;&#31649;&#36947;&#30340;&#36755;&#20986;&#31471;&#20026;popen&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> *           &#20026;"w"&#26102;&#65292;&#23376;&#36827;&#31243;&#25191;&#34892;&#30340;&#21629;&#20196;&#30340;&#26631;&#20934;&#36755;&#20837;&#20026;&#31649;&#36947;&#30340;&#36755;&#20986;&#31471;&#65292;&#35813;&#31649;&#36947;&#30340;&#36755;&#20837;&#31471;&#20026;popen&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return : &#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">popen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>);
</pre>
</div>
<p>
函数 <span class="underline">popen</span> 先执行 <span class="underline">fork</span> ，然后调用 <span class="underline">exec</span> 以执行 <span class="underline">cmdstring</span> ，并且返回一个 <span class="underline">标准I/O文件指针</span> ：
</p>
<ul class="org-ul">
<li>如果type是 <span class="underline">r</span> ：则 <span class="underline">文件指针</span> 连接到 <b>cmdstring的标准输出</b></li>
<li>如果type是 <span class="underline">w</span> : 则 <span class="underline">文件指针</span> 连接到 <b>cmdstring的标准输入</b></li>
</ul>

<div id="org187b8a0" class="figure">
<p><img src="pic/popen.jpg" alt="popen.jpg" width="90%" /> 
</p>
</div>

<p>
<span class="underline">pclose</span> 函数： <b>关闭</b> 标准I/O流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20851;&#38381;popen&#25171;&#24320;&#30340;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp : popen&#25171;&#24320;&#30340;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return : cmdstring&#30340;&#32456;&#27490;&#29366;&#24577;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pclose</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
<span class="underline">pclose</span> 函数会 <b>等待命令执行结束</b> ，然后返回 <span class="underline">shell的终止状态</span> 
</p>
<ul class="org-ul">
<li>如果 <span class="underline">shell不能被执行</span> ，则pclose返回的终止状态与shell执行 <span class="underline">exit(127)</span> 一样</li>
</ul>
</div>

<div id="outline-container-org0f28e71" class="outline-4">
<h4 id="org0f28e71">cmdstring</h4>
<div class="outline-text-4" id="text-org0f28e71">
<p>
cmdstring由 <span class="underline">Bourne shell</span> 以下列方式执行：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ sh -c cmdstring
</pre>
</div>
<p>
这表示shell将扩展 <b>cmdstring中的任何特殊字符</b> 。例如可以使用：
</p>
<div class="org-src-container">
<pre class="src src-C">fp = popen(<span style="color: #deb887;">"ls *.c"</span>, <span style="color: #deb887;">"r"</span>);
</pre>
</div>
<p>
或者
</p>
<div class="org-src-container">
<pre class="src src-C">fp = popen(<span style="color: #deb887;">"cmd 2&gt;&amp;1"</span>, <span style="color: #deb887;">"w"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4b77f9" class="outline-4">
<h4 id="orga4b77f9">使用popen实现分页读取文件</h4>
<div class="outline-text-4" id="text-orga4b77f9">
<p>
shell命令 <span class="underline">${PAGER:-more}</span> 的意思是：如果shell变量 <span class="underline">PAGER</span> <b>已经定义，且其值非空，则使用其值</b> ，否则使用字符串 <span class="underline">more</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PAGER</span>   <span style="color: #deb887;">"${PAGER:-more}"</span> <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">environment variable, or default</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];
        <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fpin</span>, *<span style="color: #4eee94;">fpout</span>;

        <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 2)
                err_quit(<span style="color: #deb887;">"usage: a.out &lt;pathname&gt;"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> ((fpin = fopen(argv[1], <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
                err_sys(<span style="color: #deb887;">"can't open %s"</span>, argv[1]);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((fpout = popen(PAGER, <span style="color: #deb887;">"w"</span>)) == <span style="color: #ffd700;">NULL</span>)
                err_sys(<span style="color: #deb887;">"popen error"</span>);

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">copy argv[1] to pager</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, fpin) != <span style="color: #ffd700;">NULL</span>) {
                <span style="color: #00bfff; font-weight: bold;">if</span> (fputs(line, fpout) == EOF)
                        err_sys(<span style="color: #deb887;">"fputs error to pipe"</span>);
        }
        <span style="color: #00bfff; font-weight: bold;">if</span> (ferror(fpin))
                err_sys(<span style="color: #deb887;">"fgets error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> (pclose(fpout) == -1)
                err_sys(<span style="color: #deb887;">"pclose error"</span>);

        exit(0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd3f9e21" class="outline-4">
<h4 id="orgd3f9e21">实现popen和pclose函数</h4>
<div class="outline-text-4" id="text-orgd3f9e21">
<p>
实现popen和pclose函数需要考虑很多细节：
</p>
<ul class="org-ul">
<li>每次调用 <span class="underline">popen</span> 时，应当 <b>记住</b> 所 <span class="underline">创建的子进程的进程ID</span> ，以及其 <span class="underline">文件描述符</span> 或 <span class="underline">FILE指针</span> 
<ul class="org-ul">
<li>在 <span class="underline">数组childpid</span> 中 <b>保存</b> <span class="underline">子进程ID</span> ，并用 <span class="underline">文件描述符</span> 作为其 <b>下标</b></li>
</ul></li>
<li>当以 <span class="underline">FILE指针</span> 作为参数调用 <span class="underline">pclose</span> 时，
<ul class="org-ul">
<li>调用标准I/O函数 <span class="underline">fileno</span> 以得到 <span class="underline">文件描述符</span></li>
<li>取得 <span class="underline">子进程ID</span></li>
<li>调用 <span class="underline">waitpid</span></li>
</ul></li>
<li>因为一个进程可能 <b>调用 <span class="underline">popen</span> 多次</b> ，所以在 <b>动态分配</b> <span class="underline">childpid数组</span> 时(第一次调用popen时)，其 <span class="underline">长度</span> 必须容纳与 <b>文件描述符数相同的进程数</b></li>
</ul>

<pre class="example" id="org705a0ad">
根据POSIX要求子进程必须从头逐个检查childpid数组的各元素，关闭仍旧打开的任一描述符

因为“fork的子进程”可能继承了“父进程以前popen所形成的管道”
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;"> * Pointer to array allocated at run-time.</span>
<span style="color: #5f9ea0; font-style: italic;"> */</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">pid_t</span> *<span style="color: #4eee94;">childpid</span> = <span style="color: #ffd700;">NULL</span>;

<span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;"> * From our open_max(), {Prog openmax}.</span>
<span style="color: #5f9ea0; font-style: italic;"> */</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">maxfd</span>;

<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">popen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">i</span>;
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">pfd</span>[2];
        <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
        <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fp</span>;

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">only allow "r" or "w"</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> ((type[0] != <span style="color: #deb887;">'r'</span> &amp;&amp; type[0] != <span style="color: #deb887;">'w'</span>) || type[1] != 0) {
                errno = EINVAL;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">required by POSIX</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
        }

        <span style="color: #00bfff; font-weight: bold;">if</span> (childpid == <span style="color: #ffd700;">NULL</span>) {     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">first time through</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">allocate zeroed out array for child pids</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                maxfd = open_max();
                <span style="color: #00bfff; font-weight: bold;">if</span> ((childpid = calloc(maxfd, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(pid_t))) == <span style="color: #ffd700;">NULL</span>)
                        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
        }

        <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(pfd) &lt; 0)
                <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">errno set by pipe()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

        <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
                <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">errno set by fork()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) {                          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">if</span> (*type == <span style="color: #deb887;">'r'</span>) {
                        close(pfd[0]);
                        <span style="color: #00bfff; font-weight: bold;">if</span> (pfd[1] != STDOUT_FILENO) {
                                dup2(pfd[1], STDOUT_FILENO);
                                close(pfd[1]);
                        }
                } <span style="color: #00bfff; font-weight: bold;">else</span> {
                        close(pfd[1]);
                        <span style="color: #00bfff; font-weight: bold;">if</span> (pfd[0] != STDIN_FILENO) {
                                dup2(pfd[0], STDIN_FILENO);
                                close(pfd[0]);
                        }
                }

                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close all descriptors in childpid[]</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">for</span> (i = 0; i &lt; maxfd; i++)
                        <span style="color: #00bfff; font-weight: bold;">if</span> (childpid[i] &gt; 0)
                                close(i);

                execl(<span style="color: #deb887;">"/bin/sh"</span>, <span style="color: #deb887;">"sh"</span>, <span style="color: #deb887;">"-c"</span>, cmdstring, (<span style="color: #98f5ff;">char</span> *)0);
                _exit(127);
        }

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent continues...</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (*type == <span style="color: #deb887;">'r'</span>) {
                close(pfd[1]);
                <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fdopen(pfd[0], type)) == <span style="color: #ffd700;">NULL</span>)
                        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
                close(pfd[0]);
                <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fdopen(pfd[1], type)) == <span style="color: #ffd700;">NULL</span>)
                        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
        }

        childpid[fileno(fp)] = pid; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">remember child pid for this fd</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">return</span>(fp);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pclose</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">stat</span>;
        <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;

        <span style="color: #00bfff; font-weight: bold;">if</span> (childpid == <span style="color: #ffd700;">NULL</span>) {
                errno = EINVAL;
                <span style="color: #00bfff; font-weight: bold;">return</span>(-1);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">popen() has never been called</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        }

        fd = fileno(fp);
        <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = childpid[fd]) == 0) {
                errno = EINVAL;
                <span style="color: #00bfff; font-weight: bold;">return</span>(-1);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">fp wasn't opened by popen()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        }

        childpid[fd] = <span style="color: #ffd700;">NULL</span>;
        <span style="color: #00bfff; font-weight: bold;">if</span> (fclose(fp) == EOF)
                <span style="color: #00bfff; font-weight: bold;">return</span>(-1);

        <span style="color: #00bfff; font-weight: bold;">while</span> (waitpid(pid, &amp;stat, 0) &lt; 0)
                <span style="color: #00bfff; font-weight: bold;">if</span> (errno != EINTR)
                        <span style="color: #00bfff; font-weight: bold;">return</span>(-1); <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">error other than EINTR from waitpid()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

        <span style="color: #00bfff; font-weight: bold;">return</span>(stat);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">return child's termination status</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
}
</pre>
</div>

<pre class="example" id="org67863d9">
若pclose的调用者已经为信号SIGCHLD设置了一个信号处理程序，则waitpid将返回一个EINTR

因为允许调用者捕捉此信号(或者任何其他可能中断waitpid调用的信号)，所以当waitpid被一个捕捉到的信号中断时，那就必须再次调用waitpid
</pre>
</div>
</div>

<div id="outline-container-orgd331135" class="outline-4">
<h4 id="orgd331135">用popen变换输入</h4>
<div class="outline-text-4" id="text-orgd331135">
<pre class="example" id="org4eacff8">
考虑一个应用程序，它向标准输出写一个提示，然后从标准输入读1行

使用popen可以在应用程序和输入之间插入一个程序以对输入进行变换处理
</pre>

<p>
下图显示了进程的安排：
</p>

<div id="org50382a7" class="figure">
<p><img src="pic/filter-input.jpg" alt="filter-input.jpg" width="70%" /> 
</p>
</div>

<p>
下面是一个简单的过滤程序，它只是将 <span class="underline">输入</span> <b>复制</b> 到 <span class="underline">输出</span> ，在复制时将任一 <b>大写字符变换为小写字符</b> 。在 <span class="underline">写了一行</span> 之后，对 <span class="underline">标准输出</span> 进行了 <b>刷新</b> (用 <span class="underline">fflush</span> )：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;ctype.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">c</span>;

        <span style="color: #00bfff; font-weight: bold;">while</span> ((c = getchar()) != EOF) {
                <span style="color: #00bfff; font-weight: bold;">if</span> (isupper(c))
                        c = tolower(c);
                <span style="color: #00bfff; font-weight: bold;">if</span> (putchar(c) == EOF)
                        err_sys(<span style="color: #deb887;">"output error"</span>);
                <span style="color: #00bfff; font-weight: bold;">if</span> (c == <span style="color: #deb887;">'\n'</span>)
                        fflush(stdout);
        }
        exit(0);
}
</pre>
</div>
<p>
对该过滤程序进行编译，其可执行目标代码存放在文件 <span class="underline">myuclc</span> 中。在下面程序中通过 <span class="underline">popen</span> 调用 <span class="underline">myuclc</span> 完成对 <b>输入的过滤</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fpin</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fpin = popen(<span style="color: #deb887;">"myuclc"</span>, <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
        err_sys(<span style="color: #deb887;">"popen error"</span>);
    <span style="color: #00bfff; font-weight: bold;">for</span> ( ; ; ) {
        fputs(<span style="color: #deb887;">"prompt&gt; "</span>, stdout);
        fflush(stdout);
        <span style="color: #00bfff; font-weight: bold;">if</span> (fgets(line, MAXLINE, fpin) == <span style="color: #ffd700;">NULL</span>) <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">read from pipe</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        <span style="color: #00bfff; font-weight: bold;">if</span> (fputs(line, stdout) == EOF)
            err_sys(<span style="color: #deb887;">"fputs error to pipe"</span>);
    }
    <span style="color: #00bfff; font-weight: bold;">if</span> (pclose(fpin) == -1)
        err_sys(<span style="color: #deb887;">"pclose error"</span>);
    putchar(<span style="color: #deb887;">'\n'</span>);
    exit(0);
}
</pre>
</div>
<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/popen1 
prompt&gt; HELLO WORLD
hello world
prompt&gt; ^C
</pre>
</div>

<pre class="example" id="orgf914f7e">
因为标准输出通常是按行进行缓存的

而提示并不包含新行符，所以在写了提示之后，需要调用fflush
</pre>
</div>
</div>
</div>

<div id="outline-container-org47939cf" class="outline-3">
<h3 id="org47939cf">协同进程</h3>
<div class="outline-text-3" id="text-org47939cf">
<p>
UNIX过滤程序从 <span class="underline">标准输入</span> <b>读取数据</b> ，对其进行 <b>适当处理</b> 后 <b>写到</b> <span class="underline">标准输出</span> 。 <span class="underline">几个过滤进程</span> 通常在 <span class="underline">shell管道命令</span> 中 <b>线性地连接</b> 。当 <span class="underline">同一个程序</span> <b>产生</b> <span class="underline">某个过滤程序的输入</span> ，同时又 <b>读取</b> <span class="underline">该过滤程序的输出</span> 时，则该 <span class="underline">过滤程序</span> 就成为 <b>协同进程</b> 
</p>

<pre class="example" id="org0c4eb19">
协同进程通常在“shell的后台运行”，其标准输入和标准输出通过管道连接到另一个程序

虽然要求初始化一个协同进程，并将其输入和输出连接到另一个进程的shell语法是十分奇特的，但是协同进程的工作方式在C程序中也是非常有用的
</pre>

<p>
进程先 <b>创建</b> <span class="underline">两个管道</span> ， <span class="underline">协同进程的标准输入</span> 和 <span class="underline">协同进程的标准输出</span> 。下图显示了这种安排：
</p>

<div id="org597b2ca" class="figure">
<p><img src="pic/coprocess.jpg" alt="coprocess.jpg" width="90%" /> 
</p>
</div>

<ul class="org-ul">
<li><span class="underline">popen</span> 提供连接到 <span class="underline">另一个进程</span> 的 <span class="underline">标准输入</span> 或 <span class="underline">标准输出</span> 的一个单行管道</li>
<li><span class="underline">协同进程</span> 产生连接到另一个进程的两个单行管道</li>
</ul>
</div>

<div id="outline-container-org490667e" class="outline-4">
<h4 id="org490667e">对两个数求和的简单过滤</h4>
<div class="outline-text-4" id="text-org490667e">
<p>
下面程序从标准输入读两个数，计算它们的和，然后将结果写至标准输出:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>, <span style="color: #4eee94;">int1</span>, <span style="color: #4eee94;">int2</span>;
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

        <span style="color: #00bfff; font-weight: bold;">while</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &gt; 0) {
                line[n] = 0;        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">null terminate</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">if</span> (sscanf(line, <span style="color: #deb887;">"%d%d"</span>, &amp;int1, &amp;int2) == 2) {
                        sprintf(line, <span style="color: #deb887;">"%d\n"</span>, int1 + int2);
                        n = strlen(line);
                        <span style="color: #00bfff; font-weight: bold;">if</span> (write(STDOUT_FILENO, line, n) != n)
                                err_sys(<span style="color: #deb887;">"write error"</span>);
                } <span style="color: #00bfff; font-weight: bold;">else</span> {
                        <span style="color: #00bfff; font-weight: bold;">if</span> (write(STDOUT_FILENO, <span style="color: #deb887;">"invalid args\n"</span>, 13) != 13)
                                err_sys(<span style="color: #deb887;">"write error"</span>);
                }
        }
        exit(0);
}
</pre>
</div>

<ul class="org-ul">
<li>从 <span class="underline">标准输入</span> <b>读入</b> 两个数之后调用 <span class="underline">add2</span> 协同进程</li>
<li>从 <span class="underline">协同进程送来的值</span> 则 <b>写到</b> 其 <span class="underline">标准输出</span></li>
<li>在协同程序中 <b>创建</b> 了 <span class="underline">两个管道</span>
<ul class="org-ul">
<li>一个用做协同进程的标准输入</li>
<li>另一个则用做它的标准输出</li>
</ul></li>
<li>父、子进程各自关闭它们不需使用的端口</li>
<li><p>
在调用execl之前， <span class="underline">子进程</span>  调用 <span class="underline">dup2</span> 使 <span class="underline">管道描述符</span> 移至其 <span class="underline">标准输入</span> 和 <span class="underline">标准输出</span> ： 
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_pipe</span>(<span style="color: #98f5ff;">int</span>);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">our signal handler</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>, <span style="color: #4eee94;">fd1</span>[2], <span style="color: #4eee94;">fd2</span>[2];
        <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
        <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

        <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGPIPE, sig_pipe) == SIG_ERR)
                err_sys(<span style="color: #deb887;">"signal error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(fd1) &lt; 0 || pipe(fd2) &lt; 0)
                err_sys(<span style="color: #deb887;">"pipe error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
                err_sys(<span style="color: #deb887;">"fork error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {                           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                close(fd1[0]);
                close(fd2[1]);

                <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>) {
                        n = strlen(line);
                        <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd1[1], line, n) != n)
                                err_sys(<span style="color: #deb887;">"write error to pipe"</span>);
                        <span style="color: #00bfff; font-weight: bold;">if</span> ((n = read(fd2[0], line, MAXLINE)) &lt; 0)
                                err_sys(<span style="color: #deb887;">"read error from pipe"</span>);
                        <span style="color: #00bfff; font-weight: bold;">if</span> (n == 0) {
                                err_msg(<span style="color: #deb887;">"child closed pipe"</span>);
                                <span style="color: #00bfff; font-weight: bold;">break</span>;
                        }
                        line[n] = 0;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">null terminate</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                        <span style="color: #00bfff; font-weight: bold;">if</span> (fputs(line, stdout) == EOF)
                                err_sys(<span style="color: #deb887;">"fputs error"</span>);
                }

                <span style="color: #00bfff; font-weight: bold;">if</span> (ferror(stdin))
                        err_sys(<span style="color: #deb887;">"fgets error on stdin"</span>);
                exit(0);
        } <span style="color: #00bfff; font-weight: bold;">else</span> {                                    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                close(fd1[1]);
                close(fd2[0]);
                <span style="color: #00bfff; font-weight: bold;">if</span> (fd1[0] != STDIN_FILENO) {
                        <span style="color: #00bfff; font-weight: bold;">if</span> (dup2(fd1[0], STDIN_FILENO) != STDIN_FILENO)
                                err_sys(<span style="color: #deb887;">"dup2 error to stdin"</span>);
                        close(fd1[0]);
                }

                <span style="color: #00bfff; font-weight: bold;">if</span> (fd2[1] != STDOUT_FILENO) {
                        <span style="color: #00bfff; font-weight: bold;">if</span> (dup2(fd2[1], STDOUT_FILENO) != STDOUT_FILENO)
                                err_sys(<span style="color: #deb887;">"dup2 error to stdout"</span>);
                        close(fd2[1]);
                }
                <span style="color: #00bfff; font-weight: bold;">if</span> (execl(<span style="color: #deb887;">"./add2"</span>, <span style="color: #deb887;">"add2"</span>, (<span style="color: #98f5ff;">char</span> *)0) &lt; 0)
                        err_sys(<span style="color: #deb887;">"execl error"</span>);
        }
        exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_pipe</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
        printf(<span style="color: #deb887;">"SIGPIPE caught\n"</span>);
        exit(1);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./pipe4  
1
invalid args
2 3
5
4 5
SIGPIPE caught
</pre>
</div></li>
</ul>

<pre class="example" id="org47c33f0">
当pipe4进程正等待输入时杀死add2协同进程

然后输入两个数，进行写操作时，由于该管道无读进程，于是调用信号处理函数sig_pipe
</pre>
</div>
<div id="outline-container-org639fa44" class="outline-5">
<h5 id="org639fa44">使用标准IO改写add2</h5>
<div class="outline-text-5" id="text-org639fa44">
<p>
在协同进程add2中，使用了 <span class="underline">UNIX的I/O</span> :read和write。现在使用 <b>标准I/O</b> 改写该协同进程：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">int1</span>, <span style="color: #4eee94;">int2</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>) {
        <span style="color: #00bfff; font-weight: bold;">if</span> (sscanf(line, <span style="color: #deb887;">"%d%d"</span>, &amp;int1, &amp;int2) == 2) {
            <span style="color: #00bfff; font-weight: bold;">if</span> (printf(<span style="color: #deb887;">"%d\n"</span>, int1 + int2) == EOF)
                err_sys(<span style="color: #deb887;">"printf error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (printf(<span style="color: #deb887;">"invalid args\n"</span>) == EOF)
                err_sys(<span style="color: #deb887;">"printf error"</span>);
        }
    }
    exit(0);
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./spipe4 
1 2 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#27515;&#38145;</span>
</pre>
</div>

<pre class="example" id="org3842cf2">
若pipe4调用此新的协同进程，则它不再工作，问题出在系统默认的标准I/O缓存机制上：

当add2stdio被调用时，对标准输入的第一个fgets引起标准I/O库分配一个缓存，并选择缓存的类型
因为标准输入是个管道，所以isatty为假，于是标准I/O库由系统默认是全缓存的，对标准输出也有同样的处理

当add2stdio从其标准输入读取而发生堵塞时，pipe4从管道读时也发生堵塞，于是产生了死锁
</pre>

<p>
对将要执行的这样一个协同进程可以设置buf，可以在add2stdio程序的while循环之前加上如下代码:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">if</span> (setvbuf(stdin, <span style="color: #ffd700;">NULL</span>, _IOLBF, 0) != 0)
        err_sys(<span style="color: #deb887;">"setvbuf error"</span>);

<span style="color: #00bfff; font-weight: bold;">if</span> (setvbuf(stdout, <span style="color: #ffd700;">NULL</span>, _IOLBF, 0)!= 0)
        err_sys(<span style="color: #deb887;">"setvbuf error"</span>);
</pre>
</div>
<p>
这使得当 <b>有一行可用时fgets即返回</b> ，并使得 <b>当输出一新行符</b> 时，printf即执行 <b>fflush操作</b> 
</p>

<pre class="example" id="org8423bba">
这种设置往往要求对协同进程进程代码修改，但在使用一个第三方的协同进程时不一定可以满足

更一般解决方法是使被调用的协同进程认为它的标准输入和输出被连接到一个“伪终端”

这使得协同进程中的标准I/O例程对这两个I/O流进行行缓存
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf4281a9" class="outline-3">
<h3 id="orgf4281a9">FIFO</h3>
<div class="outline-text-3" id="text-orgf4281a9">
<pre class="example" id="org2f8cfb6">
管道只能由相关进程使用，它们共同的祖先进程创建了管道
</pre>
<p>
<span class="underline">FIFO</span> 被称为 <b>命名管道</b> ，通过FIFO不相关的进程也能交换数据
</p>
</div>

<div id="outline-container-org169d951" class="outline-4">
<h4 id="org169d951">mkfifo函数</h4>
<div class="outline-text-4" id="text-org169d951">
<pre class="example" id="org1f09c09">
曾经提及FIFO是一种文件类型

而stat结构的成员st_mode的编码指明文件是否是FIFO类型，并且可以用S_ISFIFO宏对此进行测试
</pre>

<p>
<span class="underline">mkfifo</span> 函数： 创建命名管道
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/stat.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#21629;&#21517;&#31649;&#36947;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pathname: &#31649;&#36947;&#25991;&#20214;&#21517;</span>
<span style="color: #ffebcd;"> * mode: &#21487;&#36873;&#25321;&#21442;&#25968;&#65292;&#24403;oflag&#21253;&#21547;O_CREAT&#30340;&#26102;&#20505;&#65292;&#34920;&#31034;&#21019;&#24314;&#25991;&#20214;&#30340;&#26435;&#38480;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">mkfifo</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #98f5ff;">mode_t</span> <span style="color: #4eee94;">mode</span>);
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">mode</span> 参数：规格说明与open函数中的mode相同
<ul class="org-ul">
<li>FIFO文件的用户和组的所有权与前面文件和目录中所描述的相同</li>
</ul></li>
</ul>

<pre class="example" id="org5349448">
mkinfo 类似于创建文件，事实上FIFO的路径名存在于文件系统中
</pre>
</div>
</div>

<div id="outline-container-orgb04fdd5" class="outline-4">
<h4 id="orgb04fdd5">FIFO文件</h4>
<div class="outline-text-4" id="text-orgb04fdd5">
<pre class="example" id="org239fdff">
一旦已经用mkfifo创建了一个FIFO，就可用open打开它

实际上，一般的文件I/O函数close、read、write、unlink等都可用于FIFO
</pre>
<ul class="org-ul">
<li>在一般情况： 
<ul class="org-ul">
<li><span class="underline">只读打开</span> 要 <b>阻塞</b> 到某个 <span class="underline">其他进程为写打开</span> 此FIFO</li>
<li><span class="underline">为写而打开</span> 一个FIFO要 <b>阻塞</b> 到某个 <span class="underline">其他进程为读</span> 而打开它</li>
</ul></li>
<li>指定了 <b>非阻塞</b> 标志 <span class="underline">O_NONBLOCK</span> 
<ul class="org-ul">
<li><span class="underline">只读打开</span> <b>立即返回</b></li>
<li><b>没有进程已经为读</b> 而打开一个FIFO，那么 <span class="underline">只写打开</span> 将 <b>出错返回</b> ，其errno是 <span class="underline">ENXIO</span></li>
</ul></li>
<li>如果 <span class="underline">写</span> 一个尚 <b>无进程为读</b> 而打开的FIFO，则产生信号 <span class="underline">SIGPIPE</span></li>
<li>若某个FIFO的 <span class="underline">最后一个写进程</span> <b>关闭</b> 了该FIFO，则将为该FIFO的 <span class="underline">读进程</span> 产生一个 <span class="underline">文件结束标志</span></li>
</ul>
<pre class="example" id="orgbe81c6c">
一个给定的FIFO有多个写进程是常见的，这就意味着如果不希望多个进程所写的数据互相穿插，则需考虑原子写操作

正如对于管道一样，常数PIPE_BUF说明了可被原子写到FIFO的最大数据量
</pre>
</div>
</div>
<div id="outline-container-org8a35715" class="outline-4">
<h4 id="org8a35715">FIFO用途</h4>
<div class="outline-text-4" id="text-org8a35715">
<pre class="example" id="org1def1eb">
1.  shell命令使用命名管道将数据从一条管道线传送到另一条，为此无需创建中间临时文件

2. 用于客户机-服务器应用程序中，以在客户机和服务器之间传递数据
</pre>
</div>

<div id="outline-container-org91eeaaa" class="outline-5">
<h5 id="org91eeaaa">复制输出流</h5>
<div class="outline-text-5" id="text-org91eeaaa">
<pre class="example" id="orge859f51">
FIFO可被用于复制串行管道命令之间的输出流，于是也就不需要写数据到中间磁盘文件中，类似于使用管道以避免中间磁盘文件

但是管道只能用于进程间的线性连接，而FIFO因为具有名字，所以它可用于非线性连接
</pre>

<p>
考虑这样一个操作过程，它需要对一个 <span class="underline">经过过滤的输入流</span> 同时进行 <b>两次处理</b> 。图14-9表示了这种安排：
</p>

<div id="org4e896a9" class="figure">
<p><img src="pic/fifo-two-handler.jpg" alt="fifo-two-handler.jpg" width="60%" /> 
</p>
</div>

<p>
使用FIFO以及UNIX程序tee(1)：将其 <span class="underline">标准输入</span> 同时复制到其 <span class="underline">标准输出</span> 以及其命令行中包含的 <span class="underline">命名文件</span> 中：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mkfifo fifo1 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#31649;&#36947;&#25991;&#20214;fifo1</span>
$ prog3 &lt; fifo1 &amp; <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21518;&#21488;&#21551;&#21160;prog3&#31561;&#24453;fifo1&#30340;&#36755;&#20986;</span>
$ prog1 &lt; infile | tee fifo1 | prog2 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;progl, &#29992;tee&#23558;&#20854;&#36755;&#20986;&#21457;&#36865;&#21040;fifo1&#21644;prog2</span>
</pre>
</div>
<ol class="org-ol">
<li>创建命名管道 <span class="underline">fifo1</span></li>
<li>后台起动prog3，它 <b>从fifo1读数据</b></li>
<li>起动prog1</li>
<li>用 <span class="underline">tee</span> 将其 <span class="underline">输出</span> <b>发送</b> 到 <span class="underline">fifo1</span> 和 <span class="underline">prog2</span></li>
</ol>

<p>
图14-10显示了有关安排：
</p>

<div id="org2f9a0e0" class="figure">
<p><img src="pic/fifo-tee.jpg" alt="fifo-tee.jpg" width="60%" />  
</p>
</div>

<pre class="example" id="orgea3ad8c">
这样就可以无需使用临时文件
</pre>
</div>
</div>

<div id="outline-container-org0e6749b" class="outline-5">
<h5 id="org0e6749b">简单客户-服务器通信</h5>
<div class="outline-text-5" id="text-org0e6749b">
<pre class="example" id="orgde9d407">
FIFO的另一个应用是在客户机和服务器之间传送数据
</pre>

<p>
如果有一个服务器，它与很多客户机有关，每个 <span class="underline">客户机</span> 都可将其请求写到一个该服务器创建的 <span class="underline">众所周知的FIFO</span> 中。
</p>
<pre class="example" id="org98fca4f">
所有需与服务器联系的客户机都知道该FIFO的路径名

因为对于该FIFO有多个写进程，客户机发送给服务器的请求其长度要小于PIPE_BUF字节，这样就能避免客户机各次写之间的穿插
</pre>

<p>
图14-11显示了这种安排：
</p>

<div id="orgc0581fa" class="figure">
<p><img src="pic/fifo-client-send-request.jpg" alt="fifo-client-send-request.jpg" width="60%" />  
</p>
</div>

<pre class="example" id="orgb5fdca4">
这种类型的客户机-服务器通信中使用FIFO的问题是：服务器如何将回答送回各个客户机

不能使用单个FIFO，因为服务器会发出对各个客户机请求的响应
而请求者却不可能知道什么时候去读才能恰恰得到对它的响应
</pre>

<p>
一种解决方法是 <span class="underline">每个客户机</span> 都在其 <span class="underline">请求中</span> <b>发送</b> 其 <span class="underline">进程ID</span> 。然后 <span class="underline">服务器</span> 为 <b>每个客户机</b> 创建一个FIFO，所使用的路径名是以客户机的进程ID为基础的
</p>
<ul class="org-ul">
<li><p>
例如，服务器可以用名字/tmp/serv1.XXXXX创建FIFO，其中XXXXX被替换成客户机的进程ID。图14-12显示了这种安排：
</p>

<div id="org8ffa020" class="figure">
<p><img src="pic/fifo-client-server.jpg" alt="fifo-client-server.jpg" width="60%" />  
</p>
</div></li>
</ul>

<pre class="example" id="orgf31215e">
这种安排可以工作，但也有一些不足之处：

服务器不能判断一个客户机是否崩溃终止，这就使得客户机专用的FIFO会遗留在文件系统中

服务器必须捕捉SIGPIPE信号，因为客户机在发送一个请求后没有读取响应就可能终止，于是留下一个有写进程(服务器)而无读进程的客户机专用FIFO
</pre>

<p>
按照图14-12中的安排，如果服务器以 <b>只读方式</b> 打开 <span class="underline">众所周知的FIFO</span> (因为它只需读该FIFO)，则 <span class="underline">每次客户机数</span> 从 <span class="underline">1</span> 变成 <b>0</b> ， 服务器就将在FIFO中读到一个 <b>文件结束</b> 标记
</p>

<pre class="example" id="orgd2accfb">
为使服务器免于处理这种情况，一种常见的技巧是使服务器以读-写方式打开该FIFO
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org337df82" class="outline-2">
<h2 id="org337df82">系统V IPC</h2>
<div class="outline-text-2" id="text-org337df82">
<ul class="org-ul">
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
</ul>
</div>

<div id="outline-container-org5daf1a1" class="outline-3">
<h3 id="org5daf1a1">相似特征</h3>
<div class="outline-text-3" id="text-org5daf1a1">
</div>
<div id="outline-container-org3a6482c" class="outline-4">
<h4 id="org3a6482c">标识符和关键字</h4>
<div class="outline-text-4" id="text-org3a6482c">
<p>
每个 <span class="underline">内核</span> 中的 <b>IPC结构</b> (消息队列、信号量或共享存储段)都用一个 <span class="underline">非负整数</span> 的 <b>标识符</b> 加以引用
</p>
<pre class="example" id="orge249e05">
例如，为了对一个消息队列发送或取消息，只需知道其队列标识符

与文件描述符不同，IPC标识符不是small integer

当一个IPC结构被创建，以后又被删除时，与这种结构相关的标识符连续加1，直至达到一个整型数的最大正值，然后又回转到0

即使在IPC结构被删除后也记住该值，每次使用此结构时则增1，该值被称为“槽使用顺序号”
</pre>

<p>
无论何时创建IPC结构，都应指定一个 <span class="underline">关键字</span> ，关键字的数据类型由系统规定为 <b>key_t</b> ，通常在头文件 <span class="underline">&lt;sys/types.h&gt;</span> 中被规定为 <b>长整型</b> 
</p>

<pre class="example" id="org4e2f18d">
关键字由 内核 变换成 标识符
</pre>
</div>

<div id="outline-container-orgda7eb86" class="outline-5">
<h5 id="orgda7eb86">客户机和服务器使用同一IPC结构</h5>
<div class="outline-text-5" id="text-orgda7eb86">
<p>
有多种方法使客户机和服务器在同一IPC结构上会合：
</p>
<ul class="org-ul">
<li><span class="underline">服务器</span> 可以指定关键字 <b>IPC_PRIVATE</b> 创建一个新IPC结构，将返回的 <span class="underline">标识符</span> <b>存放</b> 在某处(例如一个文件)以便 <b>客户机取用</b> 
<ul class="org-ul">
<li>关键字 <span class="underline">IPC_PRIVATE</span> 保证 <b>服务器创建一个新IPC结构</b></li>
</ul></li>
</ul>

<pre class="example" id="org548e78f">
缺点： 服务器要将整型标识符写到文件中，然后客户机在此后又要读文件取得此标识符
</pre>

<pre class="example" id="orgedbc331">
IPC_PRIVATE关键字也可用于父、子关系进程

父进程指定IPC_PRIVATE创建一个新IPC结构，所返回的标识符在fork后可由子进程使用

子进程可将此标识符作为exec函数的一个参数传给一个新程序
</pre>

<ul class="org-ul">
<li>在一个 <b>公用头文件</b> 中定义一个客户机和服务器都认可的关键字。然后 <span class="underline">服务器</span> <b>指定此关键字</b> 创建一个新的IPC结构</li>
</ul>

<pre class="example" id="orgf0c643d">
问题是该关键字可能已与一个IPC结构相结合，在此情况下，get函数(msgget、semget或shmget)出错返回

服务器必须处理这一错误，删除已存在的IPC结构，然后试着再创建它
</pre>

<ul class="org-ul">
<li>客户机和服务器认同一个 <b>路径名</b> 和 <b>课题ID</b> (课题ID是0~255之间的字符值)，然后调用函数 <span class="underline">ftok</span> 将这两个值变换为一个 <b>关键字</b> ，下面就和第二种做法类似</li>
</ul>

<pre class="example" id="orgd3d4802">
ftok提供的唯一服务就是由一个路径名和课题ID产生一个关键字

因为一般来说，客户机和服务器至少共享一个头文件，所以一个比较简单的方法是避免使用ftok

而只是在该头文件中存放一个大家都知道的关键字
</pre>
</div>
</div>

<div id="outline-container-org18d3e40" class="outline-5">
<h5 id="org18d3e40">创建IPC结构</h5>
<div class="outline-text-5" id="text-org18d3e40">
<p>
三个get函数( <span class="underline">msgget</span> 、 <span class="underline">semget</span> 和 <span class="underline">shmget</span> )都有两个类似的参数 <b>key</b> 和一个整型的 <b>flag</b> 。如若满足下列条件，则 <b>创建一个新的</b> IPC结构(通常由服务器创建)：
</p>
<ol class="org-ol">
<li><span class="underline">key</span> 是 <b>IPC_PRIVATE</b></li>
<li><span class="underline">key</span> 当前 <b>未与特定类型的IPC结构</b> 相结合， <span class="underline">flag</span> 中指定了 <b>IPC_CREAT</b> 位。</li>
</ol>

<pre class="example" id="org4e170a3">
注意，为了访问一个现存队列，决不能指定IPC_PRIVATE作为关键字
因为这是一个特殊的键值，它总是用于创建一个新队列

为了访问一个用IPC_PRIVATE关键字创建的现存队列，一定要知道与该队列相结合的标识符，并且不应指定IPC_CREAT
因为在其他IPC调用中(例如msgsnd、msgrcv)必须使用该标识符
</pre>

<p>
如果希望创建一个新的IPC结构，保证不是引用具有同一标识符的一个现行IPC结构，那么必须在 <span class="underline">flag</span> 中同时指定 <b>IPC_CREAT</b> 和 <b>IPC_EXCL</b> 位。这样做了以后，如果 <span class="underline">IPC结构已经存在</span> 就会 <b>造成出错</b> ，返回 <span class="underline">EEXIST</span> 
</p>

<pre class="example" id="orgf483edc">
这与指定了O_CREAT和O_EXCL标志的open相类似
</pre>
</div>
</div>
</div>

<div id="outline-container-org63e22f2" class="outline-4">
<h4 id="org63e22f2">权限结构</h4>
<div class="outline-text-4" id="text-org63e22f2">
<p>
系统V IPC为每一个IPC结构设置了一个 <span class="underline">ipc_perm</span> 结构。该结构规定了 <b>许可权</b> 和 <b>所有者</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Data structure used to pass permission information to IPC operations.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span>
{
        <span style="color: #98f5ff;">__key_t</span> <span style="color: #4eee94;">__key</span>;                      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Key.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">__uid_t</span> <span style="color: #4eee94;">uid</span>;                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Owner's user ID.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">__gid_t</span> <span style="color: #4eee94;">gid</span>;                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Owner's group ID.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">__uid_t</span> <span style="color: #4eee94;">cuid</span>;                       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Creator's user ID.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">__gid_t</span> <span style="color: #4eee94;">cgid</span>;                       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Creator's group ID.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mode</span>;            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Read/write permission.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__pad1</span>;
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__seq</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Sequence number.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__pad2</span>;
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__unused1</span>;
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__unused2</span>;
};
</pre>
</div>
<p>
在创建IPC结构时，除 <span class="underline">seq以外</span> 的所有字段都 <b>赋初值</b> ：
</p>
<ul class="org-ul">
<li>可以调用 <span class="underline">msgctl</span> 、 <span class="underline">semctl</span> 或 <span class="underline">shmctl</span> 修改uid、gid和mode字段</li>
<li>为了改变这些值， <span class="underline">调用进程</span> 必须是 <b>IPC结构的创建者</b> 或 <b>超级用户</b></li>
</ul>

<pre class="example" id="org1ae6ec3">
更改这些字段类似于对文件调用chown和chmod    
</pre>
</div>

<div id="outline-container-orgb48b38c" class="outline-5">
<h5 id="orgb48b38c">mode字段</h5>
<div class="outline-text-5" id="text-orgb48b38c">
<p>
<span class="underline">mode</span> 字段的值类似于 <span class="underline">文件权限</span> 的，但是对于 <b>任何IPC结构都不存在 <span class="underline">执行</span> 许可权</b> 。下表中对每种IPC说明了6种许可权：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 系统V IPC权限</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">权限</td>
<td class="org-left">消息队列</td>
<td class="org-left">信号量</td>
<td class="org-left">共享内存</td>
</tr>

<tr>
<td class="org-left">用户读</td>
<td class="org-left">MSG_R</td>
<td class="org-left">SEM_R</td>
<td class="org-left">SHM_R</td>
</tr>

<tr>
<td class="org-left">用户写(更改)</td>
<td class="org-left">MSG_W</td>
<td class="org-left">SEM_A</td>
<td class="org-left">SHM_W</td>
</tr>

<tr>
<td class="org-left">组读</td>
<td class="org-left">MSG_R &gt;&gt; 3</td>
<td class="org-left">SEM_R &gt;&gt; 3</td>
<td class="org-left">SHM_R &gt;&gt; 3</td>
</tr>

<tr>
<td class="org-left">组写(更改)</td>
<td class="org-left">MSG_W &gt;&gt; 3</td>
<td class="org-left">SEM_A &gt;&gt; 3</td>
<td class="org-left">SHM_W &gt;&gt; 3</td>
</tr>

<tr>
<td class="org-left">其他读</td>
<td class="org-left">MSG_R &gt;&gt; 6</td>
<td class="org-left">SEM_R &gt;&gt; 6</td>
<td class="org-left">SHM_R &gt;&gt; 6</td>
</tr>

<tr>
<td class="org-left">其他写(更改)</td>
<td class="org-left">MSG_W &gt;&gt; 6</td>
<td class="org-left">SEM_A &gt;&gt; 6</td>
<td class="org-left">SHM_R &gt;&gt; 6</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org9f4e6d8" class="outline-4">
<h4 id="org9f4e6d8">资源限制</h4>
<div class="outline-text-4" id="text-org9f4e6d8">
<p>
三种形式的系统VIPC都有可能会遇到的资源限制
</p>
</div>
</div>

<div id="outline-container-orga73ff4c" class="outline-4">
<h4 id="orga73ff4c">优点和缺点</h4>
<div class="outline-text-4" id="text-orga73ff4c">
</div>
<div id="outline-container-orgb612dd1" class="outline-5">
<h5 id="orgb612dd1">系统V IPC的缺点</h5>
<div class="outline-text-5" id="text-orgb612dd1">
<ul class="org-ul">
<li>IPC结构是在系统范围内起作用的， <b>没有访问计数</b> 
<ul class="org-ul">
<li>如果创建了一个消息队列，在该队列中放入了几条消息，然后终止，但是 <b>该消息队列及其内容并不被删除</b> 。它们余留在系统中直至：
<ul class="org-ul">
<li>由某个进程调用 <span class="underline">msgrcv</span> 或 <span class="underline">msgctl</span> 读消息或删除消息队列</li>
<li>某个进程执行 <span class="underline">ipcrm</span> (1)命令删除消息队列</li>
<li>由正在再 <span class="underline">起动</span> 的系统删除消息队列</li>
</ul></li>
</ul></li>
</ul>

<pre class="example" id="orge633f8f">
与管道pipe相比，那么当最后一个访问管道的进程终止时，管道就被完全地删除了

对于FIFO而言虽然当最后一个引用FIFO的进程终止时其名字仍保留在系统中，直至显式地删除它，但是留在FIFO中的数据却在此时全部删除
</pre>
<ul class="org-ul">
<li>这些IPC结构并 <b>不按名字</b> 为 <span class="underline">文件系统</span> 所知
<ul class="org-ul">
<li>不能用以前的函数来存取它们或修改它们的特性，为了支持它们不得不 <b>增加了十多个全新的系统调用</b> (msgget、semop、shmat等)
<ul class="org-ul">
<li>不能用ls命令见到它们</li>
<li>不能用rm命令删除它们</li>
<li>不能用chmod命令更改它们的存取权</li>
<li>不得不增加了全新的命令ipcs和ipcrm</li>
</ul></li>
<li>这些IPC <span class="underline">不使用文件描述符</span> ，所以 <b>不能对它们使用多路转接I/O</b> 函数：select和poll
<ul class="org-ul">
<li>这就使得一次使用多个IPC结构，以及用文件或设备I/O来使用IPC结构很难做到</li>
</ul></li>
</ul></li>
</ul>

<pre class="example" id="org0367879">
没有某种形式的忙-等待循环，就不能使一个服务器等待一个消息放在两个消息队列的任一一个中
</pre>
</div>
</div>

<div id="outline-container-org6354038" class="outline-5">
<h5 id="org6354038">IPC的优点</h5>
<div class="outline-text-5" id="text-org6354038">
<ul class="org-ul">
<li>避免 <b>多次</b> <span class="underline">open</span> ,  <span class="underline">write</span> ,  <span class="underline">close</span> 调用</li>
<li><span class="underline">可靠的</span></li>
<li>流是 <span class="underline">受到控制</span> 的</li>
<li>面向 <span class="underline">记录</span></li>
<li>支持 <span class="underline">非先进先出</span></li>
</ul>
</div>
</div>

<div id="outline-container-org1471129" class="outline-5">
<h5 id="org1471129">总结</h5>
<div class="outline-text-5" id="text-org1471129">
<p>
下表对不同形式的IPC的某些特征进行了比较：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 不同形式IPC之间特征的比较</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">类型</td>
<td class="org-left">无连接</td>
<td class="org-left">可靠</td>
<td class="org-left">流控制</td>
<td class="org-left">记录</td>
<td class="org-left">消息类型或优先权</td>
</tr>

<tr>
<td class="org-left">消息队列</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">流</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">UNIX流套接字</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">UNIX数据套接字</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">FIFO</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
</tr>
</tbody>
</table>


<p>
<span class="underline">无连接</span> 指的是无需先调用某种形式的open，就能发送消息的能力
</p>
<pre class="example" id="org49e40a6">
正如前述因为需要有某种技术以获得队列标识符，所以并不认为消息队列具有无连接特性
</pre>

<p>
因为所有这些形式的IPC都限制用在单主机上，所以它们都是 <span class="underline">可靠的</span> 
</p>

<pre class="example" id="orgd87029c">
当消息通过网络传送时，丢失消息的可能性就要加以考虑
</pre>

<p>
<span class="underline">流控制</span> 的意思是：
</p>
<ul class="org-ul">
<li>如果 <span class="underline">系统资源</span> <b>短缺</b> (缓存)或者如果 <span class="underline">接收进程</span> <b>不能再接收</b> 更多消息，则 <span class="underline">发送进程</span> 就要 <b>睡眠</b></li>
<li>当 <span class="underline">流控制条件</span> <b>消失</b> 时， <span class="underline">发送进程</span> 应自动地被 <b>唤醒</b></li>
</ul>

<pre class="example" id="org2351a29">
表中没有表示的一个特征是：

IPC设施能否自动地为每个客户机自动地创建一个到服务器的唯一连接

实际上流以及UNIX流套接口可以提供这种能力
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb3aec5e" class="outline-3">
<h3 id="orgb3aec5e">消息队列</h3>
<div class="outline-text-3" id="text-orgb3aec5e">
<p>
<span class="underline">消息队列</span> 是 <b>消息的链表</b> ，存放在 <span class="underline">内核</span> 中并由 <span class="underline">消息队列标识符</span> 标识。因此可以将称消息队列为 <span class="underline">队列</span> ，其标识符为 <span class="underline">队列ID</span> 
</p>

<ul class="org-ul">
<li><span class="underline">msgget</span> 函数： <b>创建</b> 一个 <span class="underline">新</span> 队列或 <b>打开</b> 一个 <span class="underline">现存的</span> 队列</li>
<li><span class="underline">msgsnd</span> 函数：将 <span class="underline">新消息</span> <b>添加</b> 到 <span class="underline">队列尾端</span> ，每个消息包含：
<ul class="org-ul">
<li>一个 <span class="underline">正长整型</span> <b>类型</b> 字段</li>
<li>一个 <span class="underline">非负</span> <b>长度</b></li>
<li>实际 <b>数据</b> 字节</li>
</ul></li>
<li><span class="underline">msgrcv</span> 函数：从队列中 <b>取消息</b> 
<ul class="org-ul">
<li>并不一定要以 <span class="underline">先进先出</span> 次序取消息，也可以按 <span class="underline">消息的类型</span> 字段取消息</li>
</ul></li>
</ul>
</div>


<div id="outline-container-org774c1ff" class="outline-4">
<h4 id="org774c1ff">msqid_ds结构</h4>
<div class="outline-text-4" id="text-org774c1ff">
<p>
每个队列都有一个 <span class="underline">msqid_ds结构</span> 与其相关。此结构规定了 <b>队列的当前状态</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Structure of record for one message inside the kernel.</span>
<span style="color: #5f9ea0; font-style: italic;">   The type `struct msg' is opaque.</span><span style="color: #5f9ea0; font-style: italic;">  */</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msqid_ds</span>
{
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span> <span style="color: #4eee94;">msg_perm</span>;   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">structure describing operation permission</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msg</span> *<span style="color: #4eee94;">msg_first</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ptr to first message on queue</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msg</span> *<span style="color: #4eee94;">msg_last</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ptr to last message on queue</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">msg_stime</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last msgsnd command</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">msg_rtime</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last msgrcv command</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">msg_ctime</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last change</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msg_cbytes</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">current number of bytes on queue</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">msgqnum_t</span> <span style="color: #4eee94;">msg_qnum</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">number of messages currently on queue</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">msglen_t</span> <span style="color: #4eee94;">msg_qbytes</span>;          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">max number of bytes allowed on queue</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">msg_lspid</span>;            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of last msgsnd()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">msg_lrpid</span>;            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of last msgrcv()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
};
</pre>
</div>
<p>
两个指针 <span class="underline">msg_first</span> 和 <span class="underline">msg_last</span> 分别指向 <b>相应消息在内核中的存放位置</b> 
</p>

<pre class="example" id="orgba1a0f9">
这两个指针对用户进程而言是无价值的
</pre>
</div>
</div>

<div id="outline-container-org0f9fb4e" class="outline-4">
<h4 id="org0f9fb4e">资源限制</h4>
<div class="outline-text-4" id="text-org0f9fb4e">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> 影响消息队列的系统限制</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-right">典型值</td>
</tr>

<tr>
<td class="org-left">MSGMAX</td>
<td class="org-left">可发送的最长消息的字节长度</td>
<td class="org-right">2048</td>
</tr>

<tr>
<td class="org-left">MSGMNB</td>
<td class="org-left">特定队列的最大字节长度(亦即队列中所有消息之和)</td>
<td class="org-right">4096</td>
</tr>

<tr>
<td class="org-left">MSGMNI</td>
<td class="org-left">系统中最大消息队列数</td>
<td class="org-right">50</td>
</tr>

<tr>
<td class="org-left">MSGTOL</td>
<td class="org-left">系统中最大消息数</td>
<td class="org-right">50</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb4eebda" class="outline-4">
<h4 id="orgb4eebda">msgget函数</h4>
<div class="outline-text-4" id="text-orgb4eebda">
<ul class="org-ul">
<li><p>
<span class="underline">msgget</span> 函数：打开一个现存队列或创建一个新队列
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26032;&#24314;&#25110;&#25171;&#24320;&#19968;&#20010;&#28040;&#24687;&#38431;&#21015;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * key: &#28040;&#24687;&#38431;&#21015;&#20851;&#38190;&#23383;&#65292;&#20869;&#26680;&#26681;&#25454;&#35268;&#21017;&#36716;&#25442;&#20026;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;"> * flag: &#28040;&#24687;&#38431;&#21015;&#26435;&#38480;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#28040;&#24687;&#38431;&#21015;ID&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgget</span>(<span style="color: #98f5ff;">key_t</span> <span style="color: #4eee94;">key</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
当 <b>创建</b> 一个新队列时，初始化 <span class="underline">msqid-ds结构</span> 的下列成员:
</p>
<ul class="org-ul">
<li><span class="underline">ipc-perm</span> 结构按上节中所述进行初始化。该结构中 <span class="underline">mode</span> 按 <span class="underline">flag</span> 中的 <b>相应许可权位</b> 设置</li>
<li>msg_qnum，msg_lspid、msg_lrpid、msg_stime和msg_rtime都设置为 <span class="underline">0</span></li>
<li>msg_ctime设置为 <span class="underline">当前时间</span></li>
<li><span class="underline">msg_qbytes</span> 设置为 <span class="underline">系统限制值</span></li>
</ul>
</div>
</div>

<div id="outline-container-orgf850e94" class="outline-4">
<h4 id="orgf850e94">msgctl函数</h4>
<div class="outline-text-4" id="text-orgf850e94">
<ul class="org-ul">
<li><p>
<span class="underline">msgctl</span> 函数：对队列 <b>执行多种操作</b> ，类似于ioctl函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#31649;&#29702;&#19968;&#20010;&#28040;&#24687;&#38431;&#21015;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * msgid: &#28040;&#24687;&#38431;&#21015;ID</span>
<span style="color: #ffebcd;"> * cmd: &#31649;&#29702;&#21629;&#20196;</span>
<span style="color: #ffebcd;"> * buf: &#28040;&#24687;&#38431;&#21015;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgctl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msqid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">mdqid_ds</span> *<span style="color: #4eee94;">buf</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-orgfb635ac" class="outline-5">
<h5 id="orgfb635ac">cmd参数</h5>
<div class="outline-text-5" id="text-orgfb635ac">
<p>
<span class="underline">cmd</span> 参数指定对于由 <span class="underline">msqid</span> 规定的队列要执行的命令：
</p>
<ul class="org-ul">
<li><span class="underline">IPC_STAT</span> ： <b>取</b> 此队列的 <span class="underline">msqid_ds结构</span> ，并将其 <b>存放</b> 在 <span class="underline">buf指向的结构</span> 中</li>

<li><span class="underline">IPC_SET</span> ：由 <span class="underline">buf指向的结构</span> 中的值， <b>设置</b> 与此队列相关的结构中的下列四个字段: 
<ol class="org-ol">
<li>msg_perm.uid</li>
<li>msg_perm.gid</li>
<li>msg_perm.mode</li>
<li>msg_qbytes</li>
</ol></li>
</ul>

<pre class="example" id="org075ff65">
此命令只能由下列两种进程执行:

其有效用户ID等于msg_perm.cuid或msg_perm.uid 或 具有超级用户特权的进程

只有超级用户才能增加msg_qbytes的值 
</pre>
<ul class="org-ul">
<li><span class="underline">IPC_RMID</span> ：从系统中 <b>删除</b> 该 <span class="underline">消息队列</span> 以及仍在 <span class="underline">该队列上的所有数据</span></li>
</ul>

<pre class="example" id="org8200ea0">
这种删除立即生效。仍在使用这一消息队列的其他进程在它们下一次试图对此队列进行操作时，将出错返回EIDRM

此命令只能由下列两种进程执行：

其有效用户ID等于msg_perm.cuid或msg_perm.uid 或 具有超级用户特权的进程
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdcc6e53" class="outline-4">
<h4 id="orgdcc6e53">msgsnd函数</h4>
<div class="outline-text-4" id="text-orgdcc6e53">
<ul class="org-ul">
<li><p>
<span class="underline">msgsnd</span> 函数：将 <span class="underline">数据</span> <b>放到</b> <span class="underline">消息队列</span> 上
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#24448;&#38431;&#21015;&#26411;&#23614;&#28155;&#21152;&#19968;&#20010;&#28040;&#24687;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * msqid: &#28040;&#24687;&#38431;&#21015;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;"> * ptr: &#28040;&#24687;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * nbytes: &#23454;&#38469;&#25968;&#25454;&#23383;&#33410;</span>
<span style="color: #ffebcd;"> * flag: &#35835;&#21462;&#26041;&#24335;&#26631;&#24535;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgsnd</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msqid</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nbytes</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-orgca8ed73" class="outline-5">
<h5 id="orgca8ed73">ptr指针</h5>
<div class="outline-text-5" id="text-orgca8ed73">
<p>
<span class="underline">ptr指向的消息结构</span> 中包含了 <span class="underline">正整型</span> <b>消息类型</b> ，在其后立即跟随了 <b>消息数据</b> 
</p>

<pre class="example" id="org4541b34">
若nbytes是0，则无消息数据
</pre>

<p>
假设发送的最长消息是512字节，则可定义下列结构:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">mymesg</span>
{
        <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">mtype</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">positive message type</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">mtext</span>[512]; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">message data of length nbytes</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
};
</pre>
</div>
<p>
ptr就是一个 <span class="underline">指向mymesg结构的指针</span> 
</p>

<pre class="example" id="org8ca9e45">
接收者可以使用消息类型以“非先进先出”的次序取消息
</pre>
</div>
</div>

<div id="outline-container-orgd66aa4b" class="outline-5">
<h5 id="orgd66aa4b">flag标记</h5>
<div class="outline-text-5" id="text-orgd66aa4b">
<pre class="example" id="org5bb4284">
flag的值可以指定为 IPC_NOWAIT ，这类似于文件 I/O的非阻塞I/O标志
</pre>

<p>
若消息队列已满(或者是队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值)
</p>
<ul class="org-ul">
<li>如果指定  <span class="underline">IPC_NOWAIT</span> ： <span class="underline">msgsnd</span> <b>立即出错返回</b> <span class="underline">EAGAIN</span></li>
<li>如果没有指定 <span class="underline">IPC_NOWAIT</span> ，则进程 <b>阻塞</b> 直到：
<ol class="org-ol">
<li><span class="underline">有空间</span> 可以容纳要发送的消息</li>
<li>从系统中 <b>删除</b> 了此队列，返回 <span class="underline">EIDRM</span> (“标志符被删除”)报错</li>
<li><span class="underline">捕捉</span> 到一个 <span class="underline">信号</span> ，并从信号处理程序返回，返回 <span class="underline">EINTR</span> 报错</li>
</ol></li>
</ul>

<pre class="example" id="org94b4997">
注意：对消息队列删除的处理不是很完善

因为对每个消息队列并没有设置一个引用计数器(对打开文件则有这种计数器)
所以删除一个队列使得仍在使用这一队列的进程在下次对队列进行操作时出错返回

信号量机构也以同样方式处理其删除

而删除一个文件则要等到使用该文件的最后一个进程关闭了它，才能删除文件的内容
</pre>
</div>
</div>
</div>
<div id="outline-container-org3fcde4a" class="outline-4">
<h4 id="org3fcde4a">msgrcv函数</h4>
<div class="outline-text-4" id="text-org3fcde4a">
<ul class="org-ul">
<li><p>
<span class="underline">msgrcv</span> 函数：从队列中取消息  
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#38431;&#21015;&#20013;&#21462;&#36208;&#19968;&#20010;&#28040;&#24687;&#65292;&#36825;&#24847;&#21619;&#30528;&#28040;&#24687;&#20250;&#34987;&#31227;&#20986;&#38142;&#34920;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * msqid: &#28040;&#24687;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;"> * ptr: &#28040;&#24687;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * nbytes: &#28040;&#24687;&#23454;&#38469;&#23383;&#33410;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> * type: &#28040;&#24687;&#31867;&#22411;</span>
<span style="color: #ffebcd;"> * flag: &#21462;&#36208;&#26631;&#24535;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#28040;&#24687;&#25968;&#25454;&#37096;&#20998;&#30340;&#38271;&#24230;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgrcv</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msqid</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nbytes</span>, <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
如同msgsnd中一样：
</p>
<ul class="org-ul">
<li><span class="underline">ptr</span> 参数指向一个长整型数(返回的消息类型存放在其中)，跟随其后的是存放实际消息数据的缓存</li>
<li><span class="underline">nbytes</span> 说明数据 <b>缓存的长度</b> 。若返回的 <span class="underline">消息大于nbytes</span> :
<ul class="org-ul">
<li>在flag中设置了 <span class="underline">MSG_NOERROR</span> ，则该消息被 <b>截短</b> (在这种情况下，不通知消息截短了)</li>
<li>如果没有设置这一标志，而消息又太长，则 <b>出错</b> 返回 <span class="underline">E2BIG</span> (消息仍留在队列中)</li>
</ul></li>
<li>flag值指定IPC_NOWAIT，使操作不阻塞。这使得如果没有所指定类型的消息，则msgrcv出错返回ENOMSG</li>
<li>如果flag没有指定IPC_NOWAIT，则进程阻塞直至：
<ul class="org-ul">
<li>有了指定类型的消息</li>
<li>从系统中删除了此队列(出错返回EIDRM)</li>
<li>捕捉到一个信号并从信号处理程序返回(出错返回EINTR)。</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org40bdebe" class="outline-5">
<h5 id="org40bdebe">type参数</h5>
<div class="outline-text-5" id="text-org40bdebe">
<p>
参数 <span class="underline">type</span> 可以指定想要 <b>哪一种</b> 消息：
</p>
<ul class="org-ul">
<li><span class="underline">type == 0</span> ： 返回队列中的 <b>第一个消息</b></li>
<li><span class="underline">type &gt; 0</span> ：返回队列中 <b>消息类型为type的第一个消息</b></li>
<li><span class="underline">type &lt; 0</span> ：返回队列中 <b>消息类型值小于或等于type绝对值</b> ，而且在这种消息中，其 <b>类型值又是最小的消息</b></li>
</ul>

<pre class="example" id="org3e94c57">
非零的type用于以非先进先出次序读消息

例如，若应用程序对消息赋优先权，那么type就可以是优先权值

如果一个消息队列由多个客户机和一个服务器使用，那么type字段可以用来包含客户机进程ID。 
</pre>
</div>
</div>
</div>

<div id="outline-container-org1853260" class="outline-4">
<h4 id="org1853260">实例</h4>
<div class="outline-text-4" id="text-org1853260">
<p>
向一个消息队列写入消息，读取出对应类型的消息
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28040;&#24687;&#32467;&#26500;</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">message</span>{
        <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mtype</span>;
        <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">mtext</span>[512];
};

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#28040;&#24687;&#38431;&#21015;</span>
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msgid</span> = msgget(IPC_PRIVATE,0666);
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#28040;&#24687;&#32467;&#26500;</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">message</span> <span style="color: #4eee94;">snd</span>;
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28040;&#24687;&#31867;&#22411;</span>
        snd.mtype = 911;
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28040;&#24687;&#20869;&#23481;</span>
        strcpy(snd.mtext,<span style="color: #deb887;">"help"</span>);
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#36865;&#28040;&#24687;&#21040;&#38431;&#21015;</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(msgsnd(msgid,&amp;snd,5,0) == -1){
                printf(<span style="color: #deb887;">"msgsnd %m\n"</span>);
                <span style="color: #00bfff; font-weight: bold;">return</span> -1;
        }

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#35835;&#21462;&#28040;&#24687;&#38431;&#21015;&#20449;&#24687;</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msqid_ds</span> <span style="color: #4eee94;">ds</span>;
        <span style="color: #00bfff; font-weight: bold;">if</span>(msgctl(msgid, IPC_STAT, &amp;ds) == -1){
                printf(<span style="color: #deb887;">"msgctl IPC_STAT %m\n"</span>);
                <span style="color: #00bfff; font-weight: bold;">return</span> -1;
        }
        printf(<span style="color: #deb887;">"current bytes:%d ,current number:%d ,max bytes:%d \n"</span>,
               ds.msg_cbytes, ds.msg_qnum, ds.msg_qbytes);

        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">message</span> <span style="color: #4eee94;">rcv</span>;
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#38750;&#38459;&#22622;&#35835;&#21462;&#28040;&#24687;&#31867;&#22411;&#20026;910&#30340;&#28040;&#24687;&#65292;&#20986;&#38169;&#36820;&#22238;</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(msgrcv(msgid, &amp;rcv, 512, 910, IPC_NOWAIT) == -1){
                printf(<span style="color: #deb887;">"msgrcv1 %m\n"</span>);
        }
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#38459;&#22622;&#35835;&#21462;&#28040;&#24687;&#31867;&#22411;&#20026;911&#30340;&#28040;&#24687;</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(msgrcv(msgid, &amp;rcv, 521, 911, 0) == -1){
                printf(<span style="color: #deb887;">"msgrcv2 %m\n"</span>);
                <span style="color: #00bfff; font-weight: bold;">return</span> -1;
        }
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#25171;&#21360;&#35835;&#21462;&#30340;&#28040;&#24687;</span>
        printf(<span style="color: #deb887;">"%s\n"</span>,rcv.mtext);
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#38500;&#28040;&#24687;&#38431;&#21015;</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(msgctl(msgid,IPC_RMID,<span style="color: #ffd700;">NULL</span>)==-1){
                printf(<span style="color: #deb887;">"msgctl IPC_RMID %m\n"</span>);
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/msg1 

current bytes:5 ,current number:1 ,max bytes:16384 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24403;&#21069;&#28040;&#24687;&#38431;&#21015;&#20449;&#24687;&#65306;&#20889;&#20837;5&#20010;&#23383;&#33410;&#65292;&#25317;&#26377;1&#20010;&#28040;&#24687;&#65292;&#26368;&#22823;&#21487;&#20889;&#20837;&#23383;&#33410;&#25968;&#26159;16384 </span>
msgrcv1 No message of desired type <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#26080;&#27861;&#35835;&#21462;&#31867;&#22411;&#20026;910&#30340;&#28040;&#24687;</span>
<span style="color: #f08080;">help</span> <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#35835;&#21462;&#20986;&#30340;&#28040;&#24687;</span>
</pre>
</div>

<pre class="example" id="org2cd6f3c">
如若需要客户机和服务器之间的“双向数据流”，可以使用“消息队列“或”流管道“(用Socket套接字来实现)

消息队列原来的目的是“提供比一般IPC更高速度的进程通信方法”，而现在这个优点已经不复存在，所以不推荐使用消息队列！ 
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdc4c516" class="outline-3">
<h3 id="orgdc4c516">信号量</h3>
<div class="outline-text-3" id="text-orgdc4c516">
<p>
信号量与已经介绍过的IPC(管道、FIFO以及消息列队)不同。它是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
</p>
<ol class="org-ol">
<li>测试控制该资源的信号量</li>
<li>若此信号量的值为正，则进程可以使用该资源。进程将信号量值减1，表示它使用了一个资源单位</li>
<li>若此信号量的值为0，则进程进入睡眠状态，直至信号量值大于0。若进程被唤醒后， 它返回至第1步</li>
</ol>

<p>
当进程不再使用由一个信息量控制的共享资源时，该信号量值增1。如果有进程正在睡眠等待此信号量，则唤醒它们 
</p>
</div>

<div id="outline-container-org8b2d17d" class="outline-4">
<h4 id="org8b2d17d">实现</h4>
<div class="outline-text-4" id="text-org8b2d17d">
<p>
为了正确地实现信息量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的
</p>

<p>
常用的信号量形式被称之为双态信号量(binary semaphore)。它控制单个资源，其初始值为1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。
</p>

<p>
不幸的是，系统V的信号量与此相比要复杂得多。三种特性造成了这种并非必要的复杂性:
</p>
<ol class="org-ol">
<li>信号量并非是一个非负值，而必需将信号量定义为含有一个或多个信号量值的集合。当创建一个信号量时，要指定该集合中的各个值</li>
<li>创建信息量(semget)与对其赋初值(semctl)分开。这是一个致命的弱点，因为不能原子地创建一个信号量集合，并且对该集合中的所有值赋初值</li>
<li>即使没有进程正在使用各种形式的IPC，它们仍然是存在的，所以不得不为这种程序担心，它在终止时并没有释放已经分配给它的信号量。下面将要说明的undo功能就是假定要处理这种情况的</li>
</ol>
</div>
</div>

<div id="outline-container-org9bb3938" class="outline-4">
<h4 id="org9bb3938">semid_ds结构</h4>
<div class="outline-text-4" id="text-org9bb3938">
<p>
内核为每个信号量设置了一个semid_ds结构：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">semid_ds</span>
{
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span> <span style="color: #4eee94;">sem_perm</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">see Section 14.6.2</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sem</span> *<span style="color: #4eee94;">sem_base</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ptr to first semaphore in set</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">sem_nsems</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;"># of semaphores in set</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">sem_otime</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">last-semop() time</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">sem_ctime</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">last-change time</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
};
</pre>
</div>
<p>
对用户而言，sem_base指针是没有价值的，它指向内核中的sem结构数组，该数组中包含了sem_nsems个元素，每个元素各对应于集合中的一个信号量值
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sem</span>
{
        <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">semval</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">semaphore value always &gt;= 0</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">sempid</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid for last operation</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">semncnt</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;"># processes awaiting semval &gt; currentval</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">semzcnt</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;"># processes awaiting semval = 0</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c973ae" class="outline-4">
<h4 id="org9c973ae">资源限制</h4>
<div class="outline-text-4" id="text-org9c973ae">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> 影响信号量的系统限制</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-right">典型值</td>
</tr>

<tr>
<td class="org-left">SEMVMX</td>
<td class="org-left">任一信号量的最大值</td>
<td class="org-right">32767</td>
</tr>

<tr>
<td class="org-left">SEMAEM</td>
<td class="org-left">任一信号量的最大终止时调整值</td>
<td class="org-right">16384</td>
</tr>

<tr>
<td class="org-left">SEMMNI</td>
<td class="org-left">系统中信号量集的最大数</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">SEMMNS</td>
<td class="org-left">系统中信号量集的最大数</td>
<td class="org-right">60</td>
</tr>

<tr>
<td class="org-left">SEMMSL</td>
<td class="org-left">每个信号量集中的最大信号量数</td>
<td class="org-right">25</td>
</tr>

<tr>
<td class="org-left">SEMMNU</td>
<td class="org-left">系统中undo结构的最大数</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-left">SEMUME</td>
<td class="org-left">每个undo结构中的最大undo项数</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">SEMOPM</td>
<td class="org-left">每个semop调用所包含的最大操作数</td>
<td class="org-right">10</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org98cfb2a" class="outline-4">
<h4 id="org98cfb2a">semget函数</h4>
<div class="outline-text-4" id="text-org98cfb2a">
<ul class="org-ul">
<li><p>
semget函数：获得一个信号量ID
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26032;&#24314;&#25110;&#25171;&#24320;&#19968;&#20010;&#20449;&#21495;&#37327;&#38598;</span>

<span style="color: #ffebcd;">   key&#65306;&#20449;&#21495;&#37327;&#20851;&#38190;&#23383;&#65292;&#20869;&#26680;&#26681;&#25454;&#35268;&#21017;&#36716;&#25442;&#20026;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   nsems&#65306;&#20449;&#21495;&#37327;&#38598;&#20013;&#30340;&#20449;&#21495;&#25968;&#65292;&#22914;&#26524;&#35843;&#29992;&#35813;&#20989;&#25968;&#26159;&#20026;&#20102;&#24341;&#29992;&#19968;&#20010;&#29616;&#23384;&#30340;&#20449;&#21495;&#37327;&#38598;&#65292;&#21017;&#24212;&#35774;&#20026; 0</span>
<span style="color: #ffebcd;">   flag&#65306;&#20462;&#25913;&#26631;&#35760;&#20301;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#36820;&#22238;&#20449;&#21495;&#37327;&#26631;&#35782;&#31526;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">semget</span>(<span style="color: #98f5ff;">key_t</span> <span style="color: #4eee94;">key</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nsems</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
创建一个新集合时，对semid_ds结构的下列成员赋初值：
</p>
<ul class="org-ul">
<li>对ipc_perm结构赋初值。该结构中的mode被设置为flag中的相应许可权位</li>
<li>sem_otime设置为0</li>
<li>sem_ctime设置为当前时间</li>
<li>sem_nsems设置为nsems。</li>
</ul>

<p>
nsems是该集合中的信号量数。如果是创建新集合(一般在服务器中)，则必须指定nsems。如果引用一个现存的集合(一个客户机)，则将nsems指定为0
</p>
</div>
</div>

<div id="outline-container-org62429ab" class="outline-4">
<h4 id="org62429ab">semctl函数</h4>
<div class="outline-text-4" id="text-org62429ab">
<ul class="org-ul">
<li><p>
semctl函数：信号量操作函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#31649;&#29702;&#19968;&#20010;&#20449;&#21495;&#37327;&#38598;</span>

<span style="color: #ffebcd;">   semid&#65306;&#25351;&#23450;&#30340;&#20449;&#21495;&#37327;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   semnum&#65306;&#38598;&#21512;&#20013;&#25351;&#23450;&#30340;&#20449;&#21495;&#37327;&#65292;&#21462;&#20540;&#33539;&#22260;&#20026;0&#21040;&#24635;&#25968;-1</span>
<span style="color: #ffebcd;">   cmd&#65306;&#25351;&#23450;&#30340;&#25805;&#20316;</span>
<span style="color: #ffebcd;">   arg&#65306;&#25968;&#25454;&#28304;,&#23427;&#26159;&#19968;&#20010;&#32852;&#21512;&#20307;union semun&#31867;&#22411;</span>

<span style="color: #ffebcd;">   return&#65306;&#26681;&#25454;cmd&#19981;&#21516;&#65292;&#36820;&#22238;&#19981;&#21516;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">semctl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semnum</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, ... <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">union semun arg</span><span style="color: #5f9ea0; font-style: italic;"> */</span>);

<span style="color: #00bfff; font-weight: bold;">union</span> <span style="color: #98f5ff;">semun</span>
{
        <span style="color: #98f5ff;">int</span>              <span style="color: #4eee94;">val</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">cmd &#20026; SETVAL &#26102;&#20316;&#20026;&#25968;&#25454;&#28304;</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">semid_ds</span> *<span style="color: #4eee94;">buf</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">cmd &#20026; IPC_STAT &#21644; IPC_SET &#26102;&#30340;&#25968;&#25454;&#28304;</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span>  *<span style="color: #4eee94;">array</span>;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">cmd &#20026; GETALL &#21644; SETALL &#26102;&#30340;&#25968;&#25454;&#28304;</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
}
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org4e17128" class="outline-5">
<h5 id="org4e17128">cmd参数</h5>
<div class="outline-text-5" id="text-org4e17128">
<p>
cmd参数指定下列十种命令中的一种，使其在semid指定的信号量集合上执行此命令。其中有五条命令是针对一个特定的信号量值的，它们用semnum指定该集合中的一个成员。semnum值在0和nsems-1之间(包括0和nsems-1)：
</p>
<ul class="org-ul">
<li>IPC_STAT：对此集合取semid_ds结构，并存放在由arg.buf指向的结构中</li>
<li>IPC_SET：由arg.buf指向的结构中的值设置与此集合相关结构中的下列三个字段值:
<ol class="org-ol">
<li>sem_perm.uid</li>
<li>sem_perm.gid</li>
<li>sem_perm.mode</li>
</ol></li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于sem_perm.cuid或sem_perm.uid的进程或是具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>IPC_RMID：从系统中删除该信号量集合。这种删除是立即的。仍在使用此信号量的其他进程在它们下次意图对此信号量进行操作时，将出错返回EIDRM</li>
</ul>

<p>
此命令只能由下列两种进程执行：有效用户ID等于sem_perm.cuid或sem_perm.uid的进程或是具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>GETVAL：返回成员semnum的semval值</li>
<li>SETVAL：设置成员semnum的semval值，该值由arg.val指定</li>
<li>GETPID：返回成员semnum的sempid值</li>
<li>GETNCNT：返回成员semnum的semncnt值</li>
<li>GETZCNT：返回成员semnum的semzcnt值</li>
<li>GETALL：取该集合中所有信号量的值，并将它们存放在由arg.array指向的数组中</li>
<li>SETALL：按arg.array指向的数组中的值设置该集合中所有信号量的值</li>
</ul>

<p>
对于除GETALL以外的所有GET命令，semctl函数都返回相应值。其他命令的返回值为0
</p>
</div>
</div>
</div>

<div id="outline-container-org6fd7980" class="outline-4">
<h4 id="org6fd7980">semop函数</h4>
<div class="outline-text-4" id="text-org6fd7980">
<ul class="org-ul">
<li><p>
semop函数：自动执行信号量集合上的操作数组
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20351;&#29992;&#20449;&#21495;&#37327;</span>

<span style="color: #ffebcd;">   semid&#65306;&#20449;&#21495;&#37327;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   semoarray&#65306;&#19968;&#32452;sembuf&#23545;&#35937;</span>
<span style="color: #ffebcd;">   nops&#65306;semoarray&#30340;&#20803;&#32032;&#20010;&#25968;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">semop</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semid</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span> <span style="color: #4eee94;">semoparray</span>[], <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nops</span>);
</pre>
</div></li>
</ul>
</div>


<div id="outline-container-orgb2402ea" class="outline-5">
<h5 id="orgb2402ea">semoarray参数</h5>
<div class="outline-text-5" id="text-orgb2402ea">
<p>
semoparray是一个指针，它指向一个信号量操作sembuf结构数组：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span>
{
        <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">sem_num</span>;   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25351;&#23450;&#38598;&#21512;&#20013;&#30340;&#20449;&#21495;&#37327;,&#21462;&#20540; 0 ~ nsems-1</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">short</span>          <span style="color: #4eee94;">sem_op</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25351;&#23450;&#25805;&#20316;&#25968;</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">short</span>          <span style="color: #4eee94;">sem_flg</span>;   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#25324; IPC_NOWAIT &#21644; SEM_UNDO</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
}
</pre>
</div>
<p>
nops规定该数组中操作的数量(元素数)
</p>
</div>

<ul class="org-ul">
<li><a id="org08c3c26"></a>sem_op成员<br />
<div class="outline-text-6" id="text-org08c3c26">
<p>
对集合中每个成员的操作由相应的sem_op规定。此值可以是负值、0或正值。其undo标志对应于相应sem_flg成员的SEM_UNDO位：
</p>
<ul class="org-ul">
<li>sem_op &gt; 0：这对应于释放进程占用的资源。sem_op值加到信号量的值上。如果指定了undo标志，则也从该进程的此信号量调整值中减去sem_op</li>

<li>若sem_op &lt; 0：则表示要获取由该信号量控制的资源
<ul class="org-ul">
<li>如若该信号量的值大于或等于sem_op的绝对值(具有所需的资源)，则从信号量值中减去sem_op的绝对值。这保证信号量的结果值大于或等于0。如果指定了undo标志，则sem_op的绝对值也加到该进程的此信号量调整值上</li>
<li>如果信号量值小于sem_op的绝对值(资源不能满足要求)，则:
<ul class="org-ul">
<li>若指定了IPC_NOWAIT：则出错返回EAGAIN</li>
<li>若未指定IPC_NOWAIT：则该信号量的semncnt值加1(因为将进入睡眠状态)，然后调用进程被挂起直至下列事件之一发生:
<ul class="org-ul">
<li>此信号量变成大于或等于sem_op的绝对值(即某个进程已释放了某些资源)。此信号量的semncnt值减1(因为已结束等待)，并且从信号量值中减去sem_op的绝对值。如果指定了undo标志，则sem_op的绝对值也加到该进程的此信号量调整值上</li>
<li>从系统中删除了此信号量。在此情况下，函数出错返回ERMID</li>
<li>进程捕捉到一个信号，并从信号处理程序返回，在此情况下，此信号量的semncnt值减1(因为不再等待)，并且函数出错返回EINTR</li>
</ul></li>
</ul></li>
</ul></li>

<li>若sem_op为0，这表示希望等待到该信号量值变成0：
<ul class="org-ul">
<li>如果信号量值当前是0，则此函数立即返回</li>
<li>如果信号量值非0，则:
<ul class="org-ul">
<li>若指定了IPC_NOWAIT，则出错返回EAGAIN</li>
<li>若未指定IPC_NOWAIT，则该信号量的semncnt值加1(因为将进入睡眠状态)，然后调用进程被挂起，直至下列事件之一发生：
<ul class="org-ul">
<li>此信号量值变成0。此信号量的semzcnt值减1(因为已结束等待)</li>
<li>从系统中删除了此信号量。在此情况下，函数出错返回ERMID</li>
<li>进程捕捉到一个信号，并从信号处理程序返回。在此情况下，此信号量的semzcnt值减1(因为不再等待)，并且函数出错返回EINTR</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
semop具有原子性，因为它或者执行数组中的所有操作，或者一个也不做
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org52cb8f5" class="outline-5">
<h5 id="org52cb8f5">exit时的信号量调整</h5>
<div class="outline-text-5" id="text-org52cb8f5">
<p>
如果在进程终止时，它占用了经由信号量分配的资源，那么就会成为一个问题。无论何时只要为信号量操作指定了SEM_UNDO标志，然后分配资源(sem_op值小于0)，那么内核就会记住对于该特定信号量，分配给我们多少资源(sem_op的绝对值)。当该进程终止时，不论自愿或者不自愿，内核都将检验该进程是否还有尚未处理的信号量调整值，如果有，则按调整值对相应量值进行调整
</p>

<p>
如果用带SETVAL或SETALL命令的semctl设置一信号量的值，则在所有进程中，对于该信号量的调整值都设置为0
</p>
</div>
</div>
</div>

<div id="outline-container-org93d9dad" class="outline-4">
<h4 id="org93d9dad">实例</h4>
<div class="outline-text-4" id="text-org93d9dad">
<p>
通过信号量来同步父子进程：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>){

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#20449;&#21495;&#37327;&#38598;</span>
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semid</span> = semget(IPC_PRIVATE, 1, 0666);
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">value</span> = 0;

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21021;&#22987;&#21270;&#20449;&#21495;&#37327;&#65292;&#35774;&#32622;&#20449;&#21495;&#37327;&#38598;&#30340;&#31532;&#19968;&#20010;&#20449;&#21495;&#37327;&#30340;&#24403;&#21069;&#20540;&#20026;0</span>
        semctl(semid, 0, SETVAL, &amp;value);

        <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>=fork();
        <span style="color: #00bfff; font-weight: bold;">if</span>(pid==0){<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child</span>
                <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span> <span style="color: #4eee94;">buf</span>;
                buf.sem_num = 0;
                buf.sem_op = -1;
                printf(<span style="color: #deb887;">"child wait to exit\n"</span>);
                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20174;&#20449;&#21495;&#37327;&#38598;&#30340;&#31532;&#19968;&#20010;&#20449;&#21495;&#37327;&#33719;&#21462;&#19968;&#20010;&#36164;&#28304;</span>
                semop(semid, &amp;buf, 1);
                printf(<span style="color: #deb887;">"child about to exit\n"</span>);
                <span style="color: #00bfff; font-weight: bold;">return</span> 0;
        }

        sleep(2);
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span> <span style="color: #4eee94;">buf</span>;
        buf.sem_num = 0;
        buf.sem_op = 1;
        printf(<span style="color: #deb887;">"tell child ready\n"</span>);
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21521;&#20449;&#21495;&#37327;&#38598;&#30340;&#31532;&#19968;&#20010;&#20449;&#21495;&#37327;&#22686;&#21152;&#19968;&#20010;&#36164;&#28304;</span>
        semop(semid,&amp;buf,1);
        wait(<span style="color: #ffd700;">NULL</span>);

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#29702;&#20449;&#21495;&#37327;&#38598;</span>
        semctl(semid, 0, IPC_RMID);
        <span style="color: #00bfff; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/semp1

child wait to exit
child about to exit
tell child ready

</pre>
</div>
</div>
</div>

<div id="outline-container-org309b047" class="outline-4">
<h4 id="org309b047">信号量 VS 文件锁</h4>
<div class="outline-text-4" id="text-org309b047">
<p>
如果多个进程共享一个资源，则可使用信号量或记录锁
</p>

<p>
虽然实际上记录锁稍慢于信号量锁，但如果只需锁一个资源并且不需要使用信号量的所有花哨的功能，则宁可使用记录锁。理由是：
</p>
<ul class="org-ul">
<li>使用简易</li>
<li>进程终止时，会处理任一遗留下的锁</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcf4d37a" class="outline-3">
<h3 id="orgcf4d37a">共享内存</h3>
<div class="outline-text-3" id="text-orgcf4d37a">
<p>
共享存储允许两个或多个进程共享一给定的存储区。因为数据不需要在客户机和服务器之间复制，所以这是最快的一种IPC。使用共享存储的唯一窍门是多个进程之间对一给定存储区 
的同步存取。若服务器将数据放入共享存储区，则在服务器做完这一操作之前，客户机不应当去取这些数据。通常信号量被用来实现对共享存储存取的同步
</p>
</div>

<div id="outline-container-org902bcd7" class="outline-4">
<h4 id="org902bcd7">shmid_ds结构</h4>
<div class="outline-text-4" id="text-org902bcd7">
<p>
内核为每个共享存储段设置了一个shmid_ds结构：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">shmid_ds</span>
{
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span> <span style="color: #4eee94;">shm_perm</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">operation permission struct</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">anop_map</span> *<span style="color: #4eee94;">shm_amp</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pointer in kernel</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">shm_segsz</span>;                   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">size of segment in bytes</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">shm_atime</span>;                 <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last shmat()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">shm_dtime</span>;                 <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last shmdt()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">shm_ctime</span>;                 <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last change by shmctl()</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">shm_cpid</span>;                   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of creator</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">shm_lpid</span>;                   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of last shmop</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">shmatt_t</span> <span style="color: #4eee94;">shm_nattch</span>;                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">number of current attaches</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
        <span style="color: #98f5ff;">shmatt_t</span> <span style="color: #4eee94;">shm_cattch</span>;              <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">used only for shminfo</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgccff110" class="outline-4">
<h4 id="orgccff110">资源限制</h4>
<div class="outline-text-4" id="text-orgccff110">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 6:</span> 影响共享内存的系统限制</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-right">典型值</td>
</tr>

<tr>
<td class="org-left">shmmax</td>
<td class="org-left">共享存储段的最大字节数</td>
<td class="org-right">131072</td>
</tr>

<tr>
<td class="org-left">shmmin</td>
<td class="org-left">共享存储段的最小字节数</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">shmmni</td>
<td class="org-left">系统中共享存储段的最大段数</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-left">shmseg</td>
<td class="org-left">每个进程,共享存储段的最大段数</td>
<td class="org-right">6</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga090675" class="outline-4">
<h4 id="orga090675">shmget函数</h4>
<div class="outline-text-4" id="text-orga090675">
<ul class="org-ul">
<li><p>
shmget函数：获得一个共享存储标识符
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26032;&#24314;&#25110;&#25171;&#24320;&#19968;&#20010;&#20849;&#20139;&#20869;&#23384;&#23545;&#35937;</span>

<span style="color: #ffebcd;">   key&#65306;&#20849;&#20139;&#20869;&#23384;&#20851;&#38190;&#23383;&#65292;&#20869;&#26680;&#26681;&#25454;&#35268;&#21017;&#36716;&#25442;&#20026;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   size&#65306;&#26032;&#24314;&#24212;&#21462;PAGESIZE&#30340;&#25972;&#25968;&#20493;&#65292;&#29992;&#20316;&#25171;&#24320;&#29616;&#23384;&#30340;&#20849;&#20139;&#20869;&#23384;&#23545;&#35937;&#26102;&#65292;size&#24212;&#35774;&#20026;0</span>
<span style="color: #ffebcd;">   flag&#65306;&#20849;&#20139;&#20869;&#23384;&#23384;&#21462;&#36873;&#39033;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#20849;&#20139;&#20869;&#23384;&#26631;&#35782;&#31526;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">shmget</span>(<span style="color: #98f5ff;">key_t</span> <span style="color: #4eee94;">key</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
当创建一个新共享内存段时，初始化shmid_ds结构的下列成员:
</p>
<ul class="org-ul">
<li>ipc_perm结构按前面所述进行初始化，该结构中的mode按flag中的相应许可权位设置</li>
<li>shm_lpid、shm_nattach、shm_atime、以及shm_dtime都设置为0</li>
<li>shm_ctime设置为当前时间</li>
</ul>

<p>
size是该共享存储段的最小值。如果正在创建一个新段(一般在服务器中)，则必须指定其size。如果正在存访一个现存的段(一个客户机)，则将size指定为0
</p>
</div>
</div>

<div id="outline-container-orgcac8c77" class="outline-4">
<h4 id="orgcac8c77">shmctl函数</h4>
<div class="outline-text-4" id="text-orgcac8c77">
<ul class="org-ul">
<li><p>
shmctl函数：对共享存储段执行多种操作
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#31649;&#29702;&#20849;&#20139;&#20869;&#23384;&#23545;&#35937;</span>

<span style="color: #ffebcd;">   shmid&#65306;&#20849;&#20139;&#20869;&#23384;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   cmd&#65306;&#31649;&#29702;&#21629;&#20196;</span>
<span style="color: #ffebcd;">   buf&#65306;&#20849;&#20139;&#20869;&#23384;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">shmctl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">shmid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">shmid_ds</span> *<span style="color: #4eee94;">buf</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org66a590a" class="outline-5">
<h5 id="org66a590a">cmd参数</h5>
<div class="outline-text-5" id="text-org66a590a">
<p>
cmd参数指定下列5种命令中一种，使其在shmid指定的段上执行：
</p>
<ul class="org-ul">
<li>IPC_STAT：对此段取shmid_ds结构，并存放在由buf指向的结构中</li>
<li>IPC_SET：按buf指向的结构中的值设置与此段相关结构中的下列三个字段:
<ol class="org-ol">
<li>shm_perm.uid</li>
<li>shm_perm.gid</li>
<li>shm_perm.mode</li>
</ol></li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程或具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>IPC_RMID：从系统中删除该共享存储段。因为每个共享存储段有一个连接计数(shm_nattch在shmid_ds结构中)，所以除非使用该段的最后一个进程终止或与该段脱接，否则不会实际上删除该存储段。不管此段是否仍在使用，该段标识符立即被删除，所以不能再用shmat与该段连接</li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程或具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>SHM_LOCK：锁住共享存储段。此命令只能由超级用户执行</li>
<li>SHM_UNLOCK：解锁共享存储段。此命令只能由超级用户执行</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4239445" class="outline-4">
<h4 id="org4239445">shmat函数</h4>
<div class="outline-text-4" id="text-org4239445">
<ul class="org-ul">
<li><p>
shmat函数：一旦创建了一个共享存储段，进程就可调用shmat将其连接到它的地址空间中
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36830;&#25509;&#20849;&#20139;&#20869;&#23384;&#21040;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#65292;&#19968;&#33324;&#20026;&#22534;&#26632;</span>

<span style="color: #ffebcd;">   shmid&#65306;&#20849;&#20139;&#20869;&#23384;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   addr&#65306;&#25351;&#23450;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#30340;&#39318;&#22336;&#65292;&#20294;&#19968;&#33324;&#24212;&#21462;NULL&#35753;&#31995;&#32479;&#33258;&#34892;&#36873;&#25321;&#22320;&#22336;</span>
<span style="color: #ffebcd;">   flag&#65306;&#36830;&#25509;&#36873;&#39033;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#21521;&#20849;&#20139;&#23384;&#20648;&#27573;&#30340;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">shmat</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">shmid</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
共享存储段连接到调用进程的哪个地址上与addr参数以及在flag中是否指定SHM_RND位有关：
</p>
<ul class="org-ul">
<li>如果addr为0：则此段连接到由内核选择的第一个可用地址上</li>
<li>如果addr非0：
<ul class="org-ul">
<li>没有指定SHM_RND：则此段连接到addr所指定的地址上</li>
<li>指定了SHM_RND：则此段连接到(addr - (addr mod SHMLBA))所表示的地址上。SHM_RND意思是取整，SHMLBA的意思是低边界地址倍数，它总是2的乘方。因此该算式是将地址向下取最近1个SHMLBA的倍数。</li>
</ul></li>
</ul>

<p>
除非只计划在一种硬件上运行应用程序，否则不用指定共享段所连接到的地址。所以一般应指定addr为0，以便由内核选择地址
</p>

<ul class="org-ul">
<li>如果在flag中指定了SHM_RDONLY位，则以只读方式连接此段。否则以读写方式连接此段</li>

<li>shmat的返回值是该段所连接的实际地址，如果出错则返回-1</li>
</ul>
</div>
</div>

<div id="outline-container-orge694ed7" class="outline-4">
<h4 id="orge694ed7">shmdt函数</h4>
<div class="outline-text-4" id="text-orge694ed7">
<ul class="org-ul">
<li>shmdt函数：当对共享存储段的操作已经结束时，则调用shmdt脱接该段</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35299;&#38500;&#20849;&#20139;&#20869;&#23384;&#30340;&#36830;&#25509;</span>

<span style="color: #ffebcd;">   addr&#65306;&#25351;&#21521;&#20849;&#20139;&#20869;&#23384;&#30340;&#25351;&#38024;&#65292;&#20197;&#21069;&#35843;&#29992;shmat&#26102;&#30340;&#36820;&#22238;&#20540;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">shmdt</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>);
</pre>
</div>
<p>
注意：这并不从系统中删除其标识符以及其数据结构。该标识符仍然存在，直至某个进程(一般是服务器)调用shmctl(带命令IPC_RMID)特地删除它 
</p>
</div>
</div>


<div id="outline-container-org9f4b2e1" class="outline-4">
<h4 id="org9f4b2e1">打印不同类型的数据所存放的位置</h4>
<div class="outline-text-4" id="text-org9f4b2e1">
<p>
内核将以地址0连接的共享存储段放在什么位置上与系统密切相关。下面程序打印一些信息，它们与指定系统将不同类型的数据放在什么位置有关：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">ARRAY_SIZE</span>  40000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">MALLOC_SIZE</span> 100000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SHM_SIZE</span>    100000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SHM_MODE</span>    ( SHM_R | SHM_W )   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">user read/write</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

<span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">array</span>[ARRAY_SIZE];  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">uninitialized data = bss</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">shmid</span>;
        <span style="color: #98f5ff;">char</span>    *<span style="color: #4eee94;">ptr</span>, *<span style="color: #4eee94;">shmptr</span>;

        printf(<span style="color: #deb887;">"array[] from %lx to %lx\n"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;array[0],
               (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;array[ARRAY_SIZE]);
        printf(<span style="color: #deb887;">"stack around %lx\n"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;shmid);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((ptr = malloc(MALLOC_SIZE)) == <span style="color: #ffd700;">NULL</span>)
                err_sys(<span style="color: #deb887;">"malloc error"</span>);

        printf(<span style="color: #deb887;">"malloced from %lx to %lx\n"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)ptr,
               (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>) ptr + MALLOC_SIZE);

        <span style="color: #00bfff; font-weight: bold;">if</span> ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) &lt; 0)
                err_sys(<span style="color: #deb887;">"shmget error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> ((shmptr = shmat(shmid, 0, 0)) == (<span style="color: #98f5ff;">void</span> *)-1)
                err_sys(<span style="color: #deb887;">"shmat error"</span>);
        printf(<span style="color: #deb887;">"shared memory attached from %lx to %lx\n"</span>,
               (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)shmptr, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)shmptr+SHM_SIZE);

        <span style="color: #00bfff; font-weight: bold;">if</span> (shmctl(shmid, IPC_RMID, 0) &lt; 0)
                err_sys(<span style="color: #deb887;">"shmctl error"</span>);

        exit(0);
}
</pre>
</div>

<p>
测试结果与实际系统有关：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/tshm

array[] from 602100 to 60bd40 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">bss&#27573;</span>
stack around 7ffea7bbf2e4 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20989;&#25968;&#26632;</span>
malloced from 220c420 to 2224ac0 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#22534;</span>
shared memory attached from 7f6e70571000 to 7f6e705896a0 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20849;&#20139;&#20869;&#23384;&#21306;&#22495;</span>
</pre>
</div>

<p>
下图显示了这种情况，这与以前讲述的典型存储区布局类似：
</p>

<div id="orgce92379" class="figure">
<p><img src="pic/shm.png" alt="shm.png" width="60%" />  
</p>
</div>

<p>
注意：共享存储段紧靠在栈之下。实际上在共享存储段和栈之间有大约几M字节的未用地址空间
</p>
</div>
</div>

<div id="outline-container-org54542f6" class="outline-4">
<h4 id="org54542f6">/dev/zero的存储映射</h4>
<div class="outline-text-4" id="text-org54542f6">
<p>
共享存储可由不相关的进程使用。但是如果进程是相关的，则SVR4提供了一种不同的技术
</p>

<p>
设备/dev/zero在读时，是0字节的无限资源。此设备也接收写向它的任何数据，但忽略此数据。我们对此设备作为IPC的兴趣在于，当对其进行存储映射时，它具有一些特殊性质:
</p>
<ul class="org-ul">
<li>创建一个未名存储区，其长度是mmap的第二个参数，将其取整为系统上的最近页长</li>
<li>存储区都初始化为0</li>
<li>如果多个进程的共同祖先进程对mmap指定了MAP_SHARED标志，则这些进程可共享此存储区</li>
</ul>

<p>
程序14-12是使用此特殊设备的一个例子。它打开此/dev/zero设备，然后指定一个长整型调用mmap。一旦该存储区被映射了，就能关闭此设备。然后，进程创建一个子进程。因为在调用mmap时指定了MAP_SHARED，所以一个进程写到存储映照区的数据可由另一进程见到
</p>

<p>
然后父、子进程交替运行，使用父子进程同步函数各自对共享存储映射区中的一个长整型数加1。存储映射区由mmap初始化为0。父进程先对它进行增1操作，使其成为1，然后子
进程对其进行增1操作，使其成为2，然后父进程使其成为3&#x2026;&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">NLOOPS</span>      1000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIZE</span>        <span style="color: #00bfff; font-weight: bold;">sizeof</span>(<span style="color: #98f5ff;">long</span>)    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">size of shared memory area</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">update</span>(<span style="color: #98f5ff;">long</span> *<span style="color: #4eee94;">ptr</span>)
{
        <span style="color: #00bfff; font-weight: bold;">return</span>((*ptr)++);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">return value before increment</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">counter</span>;
        <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
        <span style="color: #98f5ff;">void</span>    *<span style="color: #4eee94;">area</span>;

        <span style="color: #00bfff; font-weight: bold;">if</span> ((fd = open(<span style="color: #deb887;">"/dev/zero"</span>, O_RDWR)) &lt; 0)
                err_sys(<span style="color: #deb887;">"open error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> ((area = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
                         fd, 0)) == MAP_FAILED)
                err_sys(<span style="color: #deb887;">"mmap error"</span>);
        close(fd);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">can close /dev/zero now that it's mapped</span><span style="color: #5f9ea0; font-style: italic;"> */</span>

        TELL_WAIT();

        <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
                err_sys(<span style="color: #deb887;">"fork error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">for</span> (i = 0; i &lt; NLOOPS; i += 2) {
                        <span style="color: #00bfff; font-weight: bold;">if</span> ((counter = update((<span style="color: #98f5ff;">long</span> *)area)) != i)
                                err_quit(<span style="color: #deb887;">"parent: expected %d, got %d"</span>, i, counter);

                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">printf("parent counter: %d \n", counter);</span>

                        TELL_CHILD(pid);
                        WAIT_CHILD();
                }
        } <span style="color: #00bfff; font-weight: bold;">else</span> {                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child</span><span style="color: #5f9ea0; font-style: italic;"> */</span>
                <span style="color: #00bfff; font-weight: bold;">for</span> (i = 1; i &lt; NLOOPS + 1; i += 2) {
                        WAIT_PARENT();

                        <span style="color: #00bfff; font-weight: bold;">if</span> ((counter = update((<span style="color: #98f5ff;">long</span> *)area)) != i)
                                err_quit(<span style="color: #deb887;">"child: expected %d, got %d"</span>, i, counter);

                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">printf("child counter: %d \n", counter);</span>

                        TELL_PARENT(getppid());
                }
        }

        exit(0);
}
</pre>
</div>
<p>
注意，当在update函数中，对长整型值增1时，必须使用括号，因为增加的是其值，而不是指针
</p>
</div>

<div id="outline-container-org367076e" class="outline-5">
<h5 id="org367076e">匿名存储映射</h5>
<div class="outline-text-5" id="text-org367076e">
<p>
4.3+BSD提供了一种类似于/dev/zero的施设，称为匿名存储映射。为了使用这种功能，在调用mmap时指定MAP_ANON标志，并将描述符指定为-1。结果得到的区域是匿名的(因为它并不通过一个文件描述符与一个路径名相结合)，并且创建一个存储区，它可与后代进程共享：
</p>

<p>
为了使上面程序应用4.3+BSD的这种特征，需要做两个修改：
</p>
<ol class="org-ol">
<li>删除/dev/zero的open条语句</li>
<li><p>
将mmap调用修改成下列形式:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">if</span> ( (area = mmap(0, SIZE, PROT_READ | PROT_WRITE,
                  MAP_ANON | MAP_SHARED, -1, 0)) == (<span style="color: #98f5ff;">caddr_t</span>) -1)
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org33bfb44" class="outline-5">
<h5 id="org33bfb44">共享存储 VS mmap</h5>
<div class="outline-text-5" id="text-org33bfb44">
<ul class="org-ul">
<li>mmap的优点：使用简单</li>
<li>mmap的缺点：只能在相关进程间使用，不相关进程只能使用共享存储</li>
</ul>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org69df744" class="outline-2">
<h2 id="org69df744">客户机-服务器模型</h2>
<div class="outline-text-2" id="text-org69df744">
<p>
下面详细说明客户机和服务器的属性，这些属性受到它们之间所使用的IPC的不同类型的影响
</p>
</div>

<div id="outline-container-org3ad86da" class="outline-3">
<h3 id="org3ad86da">单向管道</h3>
<div class="outline-text-3" id="text-org3ad86da">
<p>
客户机fork并执行所希望的服务器。在fork之前先创建两个单向管道以使数据可在两个方向传输。被执行的服务器可能是设置-用户-ID的程序，这使它具有了特权。查看客户机的实际用户ID就可以决定客户机的身份
</p>

<p>
在这种安排下，可以构筑一个“开放式服务器”。它为客户机开放文件而不是客户机调用open函数。这样就可以增加在正常的UNIX用户/组/其他许可权之上或之外的附加的许可权检查。假定服务器是设置-用户-ID程序，这给予了它附加的许可权(很可能是root许可权)。服务器用客户机的实际用户ID以决定是否给予它对所要求的文件的存取。使用这种方式，可以构筑一个服务器，它允许某种用户通常没有的存取权
</p>

<p>
因为服务器是父进程的子进程，所以它能做的一切是将文件内容传送给父进程。这种方式对一般文件工作得很好，同时也可被用于专用设备文件
但问题在于进程关系依赖：虽然父进程可向子进程传送打开文件描述符，然而子进程则不能向父进程传回一个描述符
</p>
</div>
</div>

<div id="outline-container-orgf8240a9" class="outline-3">
<h3 id="orgf8240a9">FIFO</h3>
<div class="outline-text-3" id="text-orgf8240a9">
<p>
服务器是一个守护进程，客户机则用某种形式的IPC与其联系。可以将管道用于这种形式的客户机-服务器关系。要求有一种命名的IPC，例如FIFO。如果服务器必需将数据送回客户机，则对每个客户机都要有单独使用的FIFO。如果客户机-服务器应用程序只有客户机向服务器送数据，则只需要一个众所周知的FIFO。例如，系统V行式打印机假脱机程序使用这种形式的客户机-服务器。客户机是lp(1)命令，服务器是lpsched进程。因为只有从客户机到服务器的数据流，没有任何数据需送回客户机，所以只需使用一个FIFO
</p>

<p>
主要缺点有：
</p>
<ul class="org-ul">
<li>处理管道异常信号</li>
<li>清理已失效的FIFO</li>
</ul>
</div>
</div>

<div id="outline-container-org8fe11bd" class="outline-3">
<h3 id="org8fe11bd">消息队列</h3>
<div class="outline-text-3" id="text-org8fe11bd">
<p>
使用消息队列则存在多种可能性：
</p>
<ol class="org-ol">
<li>在服务器和客户机之间可以只使用一个队列，使用每个消息的类型字段指明谁是消息的接受者。例如，客户机可以用类型字段为1发送它们的消息。在要求之中应包括客户机的进程ID。此后，服务器在发送响应消息时，将类型字段设置为客户机的进程ID。服务器只接受类型字段为1的消息(msgrcv的第四个参数)，客户机则只接受类型字段等于它们的进程ID的消息</li>
<li>另一种方法是每个客户机使用一个单独的消息队列。在向服务器发送第一个请求之前，每个客户机先创建它自己的消息队列，创建时使用关键字IPC_PRIVATE。服务器也有它自己的队列，其关键字或标识符是所有客户机知道的。客户机将其第一个请求送到服务器的众所周知的队列上，该请求中应包含其客户机消息队列的队列ID。服务器将其第一个响应送至客户机队列，此后的所有请求和响应都在此队列上交换</li>
</ol>

<p>
第二种技术的缺点是：
</p>
<ul class="org-ul">
<li>每个客户机专用队列通常只有一个消息在其中或者是对服务器的一个请求，或者是对客户机的响应。这似乎是对有限的系统资源(消息队列)的浪费，可以用一个FIFO来代替</li>
<li>服务器需从多个队列读消息。对于消息队列，select和poll都不起作用</li>
</ul>
</div>


<div id="outline-container-org8929ca3" class="outline-4">
<h4 id="org8929ca3">实现</h4>
<div class="outline-text-4" id="text-org8929ca3">
<p>
使用消息队列的这两种技术都可以用共享存储段和同步方法(信号量或记录锁)实现。使用共享存储段的问题是一次只能有一个消息在共享存储段中（类似于队列限制为只能有一个消息）。为此，在使用共享存储IPC时，通常每个客户机使用一个共享存储段
</p>
</div>
</div>

<div id="outline-container-orgb880d23" class="outline-4">
<h4 id="orgb880d23">缺陷</h4>
<div class="outline-text-4" id="text-orgb880d23">
<p>
消息队列的问题在于：服务器如何准确地标识客户机。除非服务器正在执行一种非特权操作，否则服务器知道谁是客户机是很重要的。例如，若服务器是一个设置-用户-ID程序，就有这种要求。虽然，所有这几种形式的IPC都经由内核，但是它们并未提供任何措施使内核能够标识发送者
</p>

<p>
对于消息队列，如果在客户机和服务器之间使用一个专用队列(于是一次只有一个消息在该队列上)，那么队列的msg_lspid包含了对方进程的进程ID。但是当客户机将请求发送给服务器时，我们想要的是客户机的有效用户ID，而不是它的进程ID。现在还没有一种可移植的方法，在已知进程ID情况下用其可以得到有效用户ID。由于任意进程只要拿到标识符(而无需其它授权)就可以读取消息(使得消息出队)，因此需要针对此专门设计安全措施
</p>
</div>

<div id="outline-container-orgcc046be" class="outline-5">
<h5 id="orgcc046be">安全措施</h5>
<div class="outline-text-5" id="text-orgcc046be">
<p>
同样的技术可用于FIFO、消息队列、信号量或共享存储。下面的说明具体针对FIFO：
</p>

<p>
客户机必须创建它自己的FIFO，并且设置FIFO的文件存取许可权，使得只允许用户-读，用户-写。假定服务器具有超级用户特权或者它很可能并不关心客户机的真实标识，所以服务器仍可读、写此FIFO。当服务器在众所周知的FIFO上接受到客户机的第一个请求时(它应当包含客户机专用FIFO的标识)，服务器调用针对客户机专用FIFO的stat或fstat。服务器所采用的假设是客户机的有效用户ID是FIFO的所有者(stat结构的st_uid字段)。服务器验证该FIFO只有用户-读、用户-写许可权。服务器还应检查是该FIFO的三个时间量(stat结构中的st_atime，st_mtime和st_ctime字段)，要检查它们与当前时间是否很接近(例如不早于当前时间15秒或30秒)。如果一个有预谋的客户机可以创建一个FIFO，使另一个用户成为其所有者，并且设置该文件的许
可权为用户-读和用户-写，那么在系统中就存在了其他基础性的安全问题
</p>

<p>
为了在系统VIPC中应用这种技术，回想一下与每个消息队列、信号量、以及共享存储段相关的ipc_perm结构，其中cuid和cgid字段标识IPC结构的创建者。以FIFO为例，服务器应当要求客户机创建该IPC结构，并使客户机将存取权设置为只允许用户-读和用户-写。服务器也应检验与该IPC相关的时间量与当前时间是否很接近(因为这些IPC结构在显式地删除之前一直存在)
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org9d4a616" class="outline-2">
<h2 id="org9d4a616">总结</h2>
<div class="outline-text-2" id="text-org9d4a616">
<ul class="org-ul">
<li>掌握匿名管道和FIFO技术，因为它们清晰简单</li>
<li>尽量不使用消息队列和信号量，而以流管道和记录锁代替之</li>
<li>可以用mmap代替共享内存</li>
<li><p>
尽量用套接字代替System V的三种IPC
</p>

<p>
<a href="daemon.html">Previous：守护进程</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
