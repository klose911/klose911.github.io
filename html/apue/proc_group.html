<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程关系</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="process.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程关系</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org284c859">登录</a>
<ul>
<li><a href="#orgb063a5a">终端登录</a>
<ul>
<li><a href="#org4da0ba0">4.3+BSD</a></li>
<li><a href="#org0325672">SVR4</a></li>
</ul>
</li>
<li><a href="#orgc475582">网络登录</a>
<ul>
<li><a href="#org57e2fea">4.3+BSD</a></li>
<li><a href="#org0ebea6f">SVR4</a></li>
</ul>
</li>
<li><a href="#org8482d5b">总结</a></li>
</ul>
</li>
<li><a href="#org649b30c">进程组</a>
<ul>
<li><a href="#org7cd1bbf">getpgrp</a></li>
<li><a href="#org491232c">setgpid</a></li>
</ul>
</li>
<li><a href="#org8690808">会话期</a>
<ul>
<li><a href="#orgf4dc90f">setsid</a></li>
</ul>
</li>
<li><a href="#orgfb2f121">控制终端</a>
<ul>
<li><a href="#orgd74a1fe">tcgetpgrp, tcsetpgrp</a></li>
</ul>
</li>
<li><a href="#org0725b1d">作业控制</a>
<ul>
<li><a href="#org2657f74">信号</a>
<ul>
<li><a href="#org01824c8">后台进程读取终端输入</a></li>
<li><a href="#org34629e2">后台进程向终端输出</a></li>
</ul>
</li>
<li><a href="#orgc4abe3e">总结</a></li>
</ul>
</li>
<li><a href="#org20f816c">shell执行程序</a>
<ul>
<li><a href="#org5eb8a37">Bourne shell</a>
<ul>
<li><a href="#org7e1802b">前台进程</a></li>
<li><a href="#org59ff89f">后台进程</a></li>
<li><a href="#orgce610f5">管道</a></li>
<li><a href="#orgad5abd8">后台进程读取控制终端</a></li>
</ul>
</li>
<li><a href="#orgcba1fc4">Bash</a>
<ul>
<li><a href="#org2430d0e">前台进程</a></li>
<li><a href="#orgf4f3cb6">后台进程</a></li>
<li><a href="#org9d6dba4">前台管道</a></li>
<li><a href="#orgfb24970">后台管道</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf2024d8">孤儿进程组</a>
<ul>
<li><a href="#orgdb84949">实例</a></li>
</ul>
</li>
<li><a href="#org6eaddea">BSD实现</a>
<ul>
<li><a href="#orgbf710df">session结构</a></li>
<li><a href="#org54a326d">tty结构</a></li>
<li><a href="#orgec0aefb">pgrp结构</a></li>
<li><a href="#org5246a94">proc结构</a></li>
<li><a href="#org6b92240">vnode结构</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  本章将详细地说明 进程组 以及 POSIX.1 引进的 对话期新概念

  还将介绍登录shell(登录时所调用的)和所有从登录shell起动的进程之间的关系 

  在说明这些关系时不可能不谈及信号，而谈论信号又需要很多本章介绍的概念
</pre>

<div id="outline-container-org284c859" class="outline-2">
<h2 id="org284c859">登录</h2>
<div class="outline-text-2" id="text-org284c859">
</div>
<div id="outline-container-orgb063a5a" class="outline-3">
<h3 id="orgb063a5a">终端登录</h3>
<div class="outline-text-3" id="text-orgb063a5a">
<pre class="example">
     在早期的UNIX系统中，例如V7，用户用哑终端(通过RS-232连到主机)进行登录

     终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)

     在这两种情况下登录都经由内核中的终端设备驱动程序，例如在PDP-11上常用的设备是DH-11和DZ-11

     因为连到主机上的终端设备数已经确定，所以同时的登录数也就有了已知的上限
</pre>
<p>
下面说明的登录过程适用于使用一个 <span class="underline">RS-232</span> 终端登录到UNIX系统中
</p>
</div>
<div id="outline-container-org4da0ba0" class="outline-4">
<h4 id="org4da0ba0">4.3+BSD</h4>
<div class="outline-text-4" id="text-org4da0ba0">
<p>
登录过程在历史上并没有多少改变：
</p>
<ul class="org-ul">
<li>系统管理者创建一个通常名为 <span class="underline">/etc/ttys</span> 的文件：其中 <b>每个终端设备有一行</b> 
<ul class="org-ul">
<li><span class="underline">设备名</span></li>
<li>传到 <b>getty</b> 程序的 <span class="underline">参数</span> ： 说明了终端的 <span class="underline">波特率</span> 等</li>
</ul></li>
<li>当系统启动时，内核创建进程 <span class="underline">ID1</span> ，也就是 <b>init</b> 进程</li>
<li>init进程使系统进入 <span class="underline">多用户</span> 状态</li>
<li>init <b>读文件</b>  <span class="underline">/etc/ttys</span>
<ul class="org-ul">
<li>对每一个 <b>允许登录的终端设备</b> ，init <b>调用</b> 一次 <span class="underline">fork</span>
<ul class="org-ul">
<li>它所生成的 <span class="underline">子进程</span> 则 <b>执行</b> 程序 <span class="underline">getty</span></li>
</ul></li>
</ul></li>
</ul>


<div class="figure">
<p><img src="pic/console-login.png" alt="console-login.png" width="50%" />
</p>
</div>

<pre class="example">
图中各个进程的 实际用户ID 和 有效用户ID 都是0 (也就是它们都具有超级用户特权)

init以 空环境 执行getty程序
</pre>

<ul class="org-ul">
<li>getty对 <span class="underline">终端设备</span> 调用 <b>open</b> 函数，以 <span class="underline">读 、 写</span> 方式将终端打开
<ul class="org-ul">
<li>如果设备是调制解调器，则 <span class="underline">open</span> 可能会在 <span class="underline">设备驱动程序</span> 中 <b>滞留</b> ，直到 <span class="underline">用户拨号调制解调器</span> ，并且 <span class="underline">线路被接通</span></li>
</ul></li>
<li>一旦设备被打开，则 <span class="underline">文件描述符</span> 0、1、2就被 <b>设置</b> 到 <span class="underline">该设备</span></li>
<li>getty <b>输出</b> <span class="underline">login:</span> 之类的信息，并 <b>等待用户</b> <span class="underline">键入用户名</span> 
<ul class="org-ul">
<li>如果终端 <b>支持多种速度</b> ，则getty可以 <b>测试特殊字符</b> 以便适当地 <span class="underline">更改终端速度</span> (波特率)</li>
</ul></li>
<li>当 <span class="underline">用户键入了用户名</span> 后getty就完成了，然后它以类似于下列的方式 <b>调用login</b> 程序：</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22312;gettytab&#25991;&#20214;&#20013;&#21487;&#33021;&#20250;&#26377;&#19968;&#20123;&#36873;&#25321;&#39033;&#20351;&#20854;&#35843;&#29992;&#20854;&#20182;&#31243;&#24207;&#65292;&#20294;&#31995;&#32479;&#40664;&#35748;&#26159;login&#31243;&#24207;</span>
execle(<span style="color: #deb887;">"/usr/bin/login"</span>, <span style="color: #deb887;">"login"</span>, <span style="color: #deb887;">"-p"</span>, username, (<span style="color: #98f5ff;">char</span>*)0, envp);
</pre>
</div>

<pre class="example">
getty以终端名(例如TERM=foo，其中终端foo的类型取自gettytab文件)和 在 gettytab 中的 环境字符串 为login创建一个环境(envp参数)

-p 标志：通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它
</pre>

<p>
下图显示了login刚被调用后这些进程的状态：
</p>

<div class="figure">
<p><img src="pic/login-begin.png" alt="login-begin.png" width="50%" />
</p>
</div>


<pre class="example">
      因为最初的init进程具有超级用户优先权，所以图9-2中的所有进程都有超级用户优先权

      图9-2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变

      并且除了最初的init进程，所有的进程均有一个父进程ID
</pre>

<p>
login能处理多项工作：
</p>
<ul class="org-ul">
<li>因为它得到了 <span class="underline">用户名</span> ，所以能调用 <span class="underline">getpwnam</span> 取得相应 <b>用户的口令文件登录项</b></li>
<li>调用 <span class="underline">getpass(3)</span> 以显示提示 <span class="underline">Password</span></li>
<li><b>读</b> <span class="underline">用户键入的口令</span>  (自然 <b>禁止回送用户键入的口令</b> )</li>
<li>调用 <span class="underline">crypt(3)</span> 将 <span class="underline">用户键入的口令</span> <b>加密</b></li>
<li>与该 <span class="underline">用户口令文件</span> 中 <span class="underline">登录项</span> 的 <b>pw_passwd字段</b> 相 <b>比较</b> 
<ul class="org-ul">
<li>如果用户几次键入的口令都无效，则 <span class="underline">login</span> 以 <span class="underline">参数 1</span>  调用 <span class="underline">exit</span> 表示 <b>登录过程失败</b> 
<ul class="org-ul">
<li>父进程 <span class="underline">init</span> 了解到 <span class="underline">子进程的终止情况</span> 后
<ul class="org-ul">
<li>再次调用 <span class="underline">fork</span> ，其后又跟随着执行 <span class="underline">getty</span> ，对此 <b>终端重复上述过程</b></li>
</ul></li>
</ul></li>
<li>如果用户 <span class="underline">正确登录</span> 
<ul class="org-ul">
<li><span class="underline">login</span> 就将 <span class="underline">当前工作目录</span> 更改为 <b>该用户的起始目录</b> (chdir)</li>
<li>调用 <span class="underline">chown</span>  改变 <b>该终端的所有权</b> ，使该用户成为所有者和组所有者</li>
<li>将对该 <span class="underline">终端设备</span> 的 <span class="underline">存取许可权</span> 改变成： <b>用户读、写和组写</b></li>
<li>调用 <span class="underline">setgid</span> 及 <span class="underline">initgroups</span> 设置 <span class="underline">进程的组ID</span></li>
<li>用login所得到的所有信息 <b>初始化环境</b> ：
<ul class="org-ul">
<li>HOME: 起始目录</li>
<li>SHELL: shell</li>
<li>USER和LOGNAME : 用户名</li>
<li>PATH:  <span class="underline">系统默认路径</span></li>
</ul></li>
<li>login进程用 <span class="underline">setuid</span> 改变为 <b>登录用户</b> 的 <span class="underline">用户ID</span></li>
<li>调用 <b>该用户的登录shell</b> ，其方式类似于:</li>
</ul></li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">argv[0]&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;-&#26159;&#19968;&#20010;&#26631;&#24535;&#65292;&#34920;&#31034;&#35813;shell&#34987;&#35843;&#29992;&#20026;&#30331;&#24405;shell&#12290;shell&#21487;&#20197;&#26597;&#30475;&#27492;&#23383;&#31526;&#65292;&#24182;&#30456;&#24212;&#22320;&#20462;&#25913;&#20854;&#36215;&#21160;&#36807;&#31243;</span>
execl(<span style="color: #deb887;">"/bin/sh"</span>, <span style="color: #deb887;">"-sh"</span>, (<span style="color: #98f5ff;">char</span> *) 0);
</pre>
</div>
<pre class="example">
login所做的比上面说的要多。它可选地打印 message-of-the-day文件，检查新邮件以及其他一些功能

因为setuid是由超级用户调用的，它更改所有三个用户ID: 实际、有效和保存的用户ID

login在较早时间调用的setgid对所有三个组ID也有同样效果
</pre>

<p>
到此为止登录用户的登录shell开始运行：
</p>
<ul class="org-ul">
<li>其 <span class="underline">父进程ID</span> 是 <span class="underline">init</span> 进程ID(进程ID 1)</li>
<li>当此登录shell <span class="underline">终止</span> 时， <span class="underline">init</span> 会 <b>得到通知</b> (接到 <span class="underline">SIGCHLD</span> 信号)
<ul class="org-ul">
<li>它会对该终端重复全部上述过程</li>
</ul></li>
<li>登录 <span class="underline">shell</span> 的 <b>文件描述符</b> <span class="underline">0，1和2</span> 设置为 <b>终端设备</b>  。图9-3显示了这种安排：</li>
</ul>

<div class="figure">
<p><img src="pic/finish-login.png" alt="finish-login.png" width="50%" />
</p>
</div>

<pre class="example">
      现在登录shell读对应的启动文件(Bourneshell和KornShell是.profile，Cshell是.cshrc和.login)

      这些配置文件通常改变某些环境变量，加上一些环境变量

      例如很多用户设置他们自己的PATH，常常提示实际终端类型(TERM)

      当执行完启动文件后，用户最后得到shell的提示符，并能键入命令
</pre>
</div>
</div>

<div id="outline-container-org0325672" class="outline-4">
<h4 id="org0325672">SVR4</h4>
<div class="outline-text-4" id="text-org0325672">
<p>
SVR4支持两种形式的终端登录：
</p>
<ul class="org-ul">
<li><span class="underline">getty</span> ：这与上面所说明的一样，通常用于控制台</li>
<li><span class="underline">ttymon</span> ：用于 <span class="underline">其他终端</span> 的登录</li>
</ul>

<pre class="example">
ttymon是名为服务存取设施(ServiceAccessFacility，SAF)的一部分。简单说明从init到登录shell之间工作过程

1. init是sac(服务存取控制器)的父进程，sac调用fork，然后其子进程执行ttymon程序，此时系统进入多用户状态
2. ttymon监视列于配置文件中的所有终端端口，当用户键入登录名时，它调用一次fork
3. 子进程又执行登录用户的登录shell，于是到达了图9-3中所示的位置

一个区别是登录shell的父进程现在是ttymon，而在getty登录中，登录shell的父进程是init
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc475582" class="outline-3">
<h3 id="orgc475582">网络登录</h3>
<div class="outline-text-3" id="text-orgc475582">
<pre class="example">
     终端登录中 init 知道哪些终端设备可用来进行登录，并为每个设备生成一个getty进程

     但是对网络登录则情况有所不同，所有登录都经由内核的网络界面驱动程序(例如以太网驱动程序)，事先并不知道将会有多少这样的登录
</pre>
<p>
不是 <span class="underline">使一个进程</span> <b>等待</b> <span class="underline">每一个可能的登录</span> ，而是 <b>必须等待一个网络连接请求</b> 的到达
</p>

<pre class="example">
     在4.3+BSD中，有一个称为 "inetd" 的进程，它等待大多数网络连接
</pre>
</div>
<div id="outline-container-org57e2fea" class="outline-4">
<h4 id="org57e2fea">4.3+BSD</h4>
<div class="outline-text-4" id="text-org57e2fea">
<ul class="org-ul">
<li>作为系统起动的一部分 <span class="underline">init</span> 调用一个 <span class="underline">shell</span> ，使其 <b>执行</b> shell脚本 <span class="underline">etc/rc</span> 
<ul class="org-ul">
<li>shell脚本起动一个后台进程 <span class="underline">inetd</span>
<ul class="org-ul">
<li>一旦此shell脚本终止，inetd的父进程就变成init</li>
<li>inetd: <b>等待TCP/IP连接请求</b> 到达主机
<ul class="org-ul">
<li>一个连接请求到达时，它 <b>执行一次</b> <span class="underline">fork</span></li>
<li>子进程执行适当的程序</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<pre class="example">
假定到达了一个对于 TELNET 服务器的TCP连接请求，TELNET是使用TCP协议的远程登录应用程序

在另一个主机(它通过某种形式的网络，连接到服务器主机上)上的用户
或在同一个主机上的一个用户籍起动TELNET客户进程(client)起动登录过程：

$ telnet hostname

该客户进程打开一个到名为hostname的主机的TCP连接，在hostname主机上起动的程序被称为TELNET服务器

然后客户进程和服务器进程之间使用TELNET应用协议通过TCP连接交换数据
</pre>
<p>
起动 <span class="underline">telnet客户进程的用户</span> 现在 <b>登录</b> 到了 <span class="underline">服务器进程所在的主机</span> 。(自然需要在 <span class="underline">服务器进程主机</span> 上有一个 <span class="underline">有效的账号</span> )。图9-4显示了在执行telnet务器进程(称为telnetd)中所涉及的进程序列
</p>

<div class="figure">
<p><img src="pic/telnetd.png" alt="telnetd.png" width="50%" />
</p>
</div>

<ul class="org-ul">
<li><span class="underline">telnetd进程</span> <b>打开</b> 一个 <span class="underline">伪终端设备</span></li>
<li>用fork生成一个 <span class="underline">子进程</span> 。子进程则执行 <b>login</b>  程序</li>
<li><span class="underline">父进程</span> 处理通过 <b>网络连接的通信</b></li>
<li>父、子进程通过 <b>伪终端</b> 相连接</li>
</ul>

<pre class="example">
在调用exec之前，子进程使其文件描述符0，1，2与伪终端相连

如果登录正确，login就执行9.2节中所述的同样步骤：
1. 更改当前工作目录为起始目录
2. 设置登录用户的组ID和用户ID
3. 登录用户的初始环境

login用exec将其自身替换为登录用户的登录shell
</pre>
<p>
图9-5显示了到达这一点时的进程安排：
</p>

<div class="figure">
<p><img src="pic/network-login.png" alt="network-login.png" width="50%" />
</p>
</div>

<pre class="example">
      很明显在伪终端设备驱动程序和终端实际用户之间有很多事情在进行着

      以后说明伪终端时，再介绍与这种安排相关的所有进程
</pre>
</div>
</div>
<div id="outline-container-org0ebea6f" class="outline-4">
<h4 id="org0ebea6f">SVR4</h4>
<div class="outline-text-4" id="text-org0ebea6f">
<pre class="example">
SVR4中网络登录的情况与4.3+BSD中的几乎一样，同样使用了inetd服务器进程

但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init

最后得到的结果与图9-5中一样
</pre>
</div>
</div>
</div>

<div id="outline-container-org8482d5b" class="outline-3">
<h3 id="org8482d5b">总结</h3>
<div class="outline-text-3" id="text-org8482d5b">
<p>
登录需要理解的重点是： 当通过 <span class="underline">终端</span> 或 <span class="underline">网络登录</span> 时得到一个 <span class="underline">登录shell</span> ，其 <span class="underline">标准输入</span> 、 <span class="underline">标准输出</span> 和 <span class="underline">标准出错</span> <b>连接</b> 到一个 <b>终端设备</b> 或者 <b>伪终端设备</b> 上
</p>

<pre class="example">
     接着会了解到这一登录shell 是一个POSIX.1 “对话期”的开始，而此终端或伪终端则是会话期的“控制终端”
</pre>
</div>
</div>
</div>
<div id="outline-container-org649b30c" class="outline-2">
<h2 id="org649b30c">进程组</h2>
<div class="outline-text-2" id="text-org649b30c">
<pre class="example">
    每个进程除了有一个进程ID之外还属于一个进程组
</pre>
<p>
<span class="underline">进程组</span> ： <b>一个或多个进程</b> 的 <b>集合</b> 
</p>
<ul class="org-ul">
<li>每个进程组有一个 <b>唯一的</b> <span class="underline">进程组ID</span> ，类似于进程ID
<ul class="org-ul">
<li>它是一个 <span class="underline">正整数</span> ，并可存放在 <b>pid_t</b> 数据类型中</li>
</ul></li>
<li>每个进程组有一个 <b>组长进程</b> 
<ul class="org-ul">
<li>组长进程的标识：其 <span class="underline">进程组ID</span> <b>等于</b> 其 <span class="underline">进程ID</span></li>
</ul></li>
</ul>

<pre class="example">
    在讨论信号时，将说明如何将一个信号送给一个进程(由其进程ID标识)或送给一个进程组(由进程组ID标识)

    同样waitpid则可被用来等待一个进程或者指定进程组中的一个进程
</pre>
</div>

<div id="outline-container-org7cd1bbf" class="outline-3">
<h3 id="org7cd1bbf">getpgrp</h3>
<div class="outline-text-3" id="text-org7cd1bbf">
<p>
<span class="underline">getpgrp</span> ：返回  <span class="underline">调用进程</span> 的 <b>进程组ID</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36820;&#22238;&#35843;&#29992;&#36827;&#31243;&#30340;&#36827;&#31243;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pid: &#36827;&#31243;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: pid&#25152;&#23646; &#36827;&#31243;&#32452;&#30340;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">getpgid</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>);
</pre>
</div>
<p>
<span class="underline">进程组组长</span> 可以 <b>创建</b> 一个 <span class="underline">进程组</span> ， <b>创建</b> <span class="underline">该组中的进程</span> ，然后 <b>终止</b> 
</p>

<pre class="example">
     只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关
</pre>

<p>
从 <span class="underline">进程组创建开始</span> 到其中 <span class="underline">最后一个进程离开</span> 为止的 <span class="underline">时间区间</span> 称为 <b>进程组的生命期</b> 
</p>

<pre class="example">
     某个进程组中的最后一个进程可以终止，也可以参加另一个进程组
</pre>
</div>
</div>

<div id="outline-container-org491232c" class="outline-3">
<h3 id="org491232c">setgpid</h3>
<div class="outline-text-3" id="text-org491232c">
<p>
<span class="underline">setgpid</span> : <b>参加</b> 一个 <span class="underline">现存的进程组</span> 或者 <b>创建</b> 一个 <span class="underline">新进程组</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;pid&#36827;&#31243;&#30340;&#36827;&#31243;&#32452;ID&#20026;pgid</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pid: &#36827;&#31243;ID</span>
<span style="color: #ffebcd;"> * pgid: &#36827;&#31243;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#20986;&#38169;&#20026; -1</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setpgid</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>, <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pgid</span>);
</pre>
</div>
<p>
将 <span class="underline">pid进程</span> 的 <span class="underline">进程组ID</span> 设置为 <span class="underline">pgid</span> 
</p>

<p>
一个进程只能为 <span class="underline">它自己</span> 或 <span class="underline">它的子进程</span> 设置 <span class="underline">进程组ID</span> ：
</p>
<ul class="org-ul">
<li>如果 <span class="underline">pid</span> 是 <span class="underline">0</span> ，则让 <span class="underline">调用者的进程ID</span> 成为进程组ID</li>
<li>如果 <span class="underline">pgid</span> 是 <span class="underline">0</span> ，则由 <span class="underline">pid指定的进程ID</span> 成为进程组ID</li>
<li>如果 <span class="underline">这两个参数相等</span> ，则由 <span class="underline">pid指定的进程</span> 变成 <span class="underline">进程组组长</span></li>
<li>在它的 <span class="underline">子进程</span> 调用了 <span class="underline">exec</span> 后，就 <b>不能再设置 <span class="underline">该子进程</span> 的进程组ID</b></li>
<li>如果系统 <span class="underline">不支持作业控制</span> ，此函数返回出错，errno设置为 <span class="underline">ENOSYS</span></li>
</ul>

<pre class="example">
在大多数作业控制shell中，在fork之后调用此函数
1. 使父进程设置其子进程的进程组ID
2. 使子进程设置其自己的进程组ID

虽然这些调用中有一个是冗余的，但这样做可以保证父、子进程在进一步操作之前，子进程都进入了该进程组

如果不这样做的话，就会产生一个竞态条件，因为它依赖于哪一个进程先执行！！！
</pre>
</div>
</div>
</div>

<div id="outline-container-org8690808" class="outline-2">
<h2 id="org8690808">会话期</h2>
<div class="outline-text-2" id="text-org8690808">
<p>
<b>对话期</b> 是 <span class="underline">一个或多个</span> <b>进程组的集合</b> ，图9.6中一个会话期有三个进程组：
</p>

<div class="figure">
<p><img src="pic/session.png" alt="session.png" width="90%" />
</p>
</div>

<p>
通常是由 <span class="underline">shell的管道线</span> 将 <b>几个进程编成一组的</b> ，例如上图中的安排可能是由下列形式的shell命令形成的：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ proc1 | proc2 &amp; 
$ proc3 | proc4 | proc5
</pre>
</div>
</div>

<div id="outline-container-orgf4dc90f" class="outline-3">
<h3 id="orgf4dc90f">setsid</h3>
<div class="outline-text-3" id="text-orgf4dc90f">
<p>
<span class="underline">setsid</span> ： <b>创建</b> 一个 <span class="underline">新的会话期</span> 
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#20250;&#35805;&#26399;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#36827;&#31243;&#32452;ID&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">setsid</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
<ul class="org-ul">
<li>如果 <span class="underline">调用此函数的进程</span> 不是 <span class="underline">一个进程组的组长</span> ，则此函数 <b>创建</b> 一个 <span class="underline">新对话期</span> ：
<ol class="org-ol">
<li>此进程变成该 <span class="underline">新对话期</span> 的 <b>对话期首进程</b> (创建该对话期的进程)
<ul class="org-ul">
<li>是 <span class="underline">该新对话期</span> 中的 <b>唯一进程</b></li>
</ul></li>
<li>此进程成为一个 <span class="underline">新进程组</span> 的 <b>组长进程</b> 
<ul class="org-ul">
<li><span class="underline">新进程组ID</span> 也是 <span class="underline">此调用进程的进程ID</span></li>
</ul></li>
<li>此进程没有 <span class="underline">控制终端</span> 
<ul class="org-ul">
<li>如果在 <span class="underline">调用setsid之前</span> 此进程 <span class="underline">有一个控制终端</span> ，那么这种 <b>关系也被解除</b></li>
</ul></li>
</ol></li>
<li>如果此调用进程 <b>已经是</b> 一个进程组的组长，则此函数 <b>返回出错</b></li>
</ul>

<pre class="example">
     为了保证不出错，通常先调用fork，然后使其父进程终止，而子进程则继续

     因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，所以这就保证了子进程不是一个进程组的组长
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb2f121" class="outline-2">
<h2 id="orgfb2f121">控制终端</h2>
<div class="outline-text-2" id="text-orgfb2f121">
<p>
<span class="underline">对话期</span> 和 <span class="underline">进程组</span> 有一些其他特性:
</p>
<ul class="org-ul">
<li>一个 <span class="underline">对话期</span> 可以有一个 <b>单独的控制终端</b> ，这通常是在其上 <span class="underline">登录的终端设备</span> 或 <span class="underline">伪终端设备</span></li>
<li><span class="underline">控制进程</span> ： <b>建立</b> 与 <span class="underline">控制终端</span> <b>连接的</b> <span class="underline">对话期首进程</span></li>
<li>一个 <span class="underline">对话期中的几个进程组</span> 可被分成 <span class="underline">一个前台进程组</span> 以及 <span class="underline">一个或几个后台进程组</span></li>
<li>无论何时键入 <span class="underline">中断键</span> (常常是 <b>Ctrl-C</b> )或 <span class="underline">退出键</span> (常常是 <b>Ctrl-\</b> )，就会造成将 <span class="underline">中断信号</span> 或 <span class="underline">退出信号</span> <b>送至</b> <span class="underline">前台进程组的所有进程</span></li>
<li>如果 <span class="underline">终端界面</span> <b>检测到</b> <span class="underline">调制解调器已经脱开连接</span> ，则将 <span class="underline">挂断信号</span> <b>送至</b> <span class="underline">控制进程</span> (对话期首进程)</li>
</ul>

<p>
这些特性示于图9-7中：
</p>

<div class="figure">
<p><img src="pic/terminal.png" alt="terminal.png" width="90%" />
</p>
</div>

<p>
通常不必担心控制终端， <span class="underline">登录时</span> 将 <b>自动建立</b> <span class="underline">控制终端</span> 。有时不管 <span class="underline">标准输入</span> 、 <span class="underline">标准输出</span> <b>是否重新定向</b> ，程序都要与 <span class="underline">控制终端</span> <b>交互作用</b>
</p>

<pre class="example">
    保证程序读写控制终端的方法是打开文件/dev/tty，在内核中，此特殊文件是控制终端的同义语

    自然，如果程序没有控制终端，则打开此设备将失败

    典型的例子是用于读口令的getpass(3)函数(终端回送被关闭)，这一函数由crypt(1)程序调用，而此程序则可用于管道中

    例如将文件salaries解密，然后经由管道将输出送至打印程序：
</pre>
<div class="org-src-container">
<pre class="src src-sh">$ crypt &lt; salaries | lpr
</pre>
</div>

<pre class="example">
    因为crypt从其标准输入读取salaries文件，所以标准输入不能用于输入口令

    但是crypt的一个设计特征是每次运行此程序时，都会从控制终端/dev/tty读取加密口令，这样也就不需要将口令存放在文件中
</pre>
</div>

<div id="outline-container-orgd74a1fe" class="outline-3">
<h3 id="orgd74a1fe">tcgetpgrp, tcsetpgrp</h3>
<div class="outline-text-3" id="text-orgd74a1fe">
<ul class="org-ul">
<li><span class="underline">tcgetpgrp</span> ：返回 <span class="underline">拥有控制终端</span> 的 <span class="underline">前台进程组</span> 的 <span class="underline">组ID</span></li>
<li><span class="underline">tcsetpgrp</span> ： 设置 <span class="underline">控制终端</span> 的 <span class="underline">前台进程组</span> 的 <span class="underline">组ID</span></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36820;&#22238;&#26576;&#20010;&#25991;&#20214;&#25551;&#36848;&#31526;&#30456;&#20851;&#32852;&#30340;&#25511;&#21046;&#32456;&#31471;&#30340;&#21069;&#21488;&#36827;&#31243;&#32452;&#30340;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * filedes: &#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#21069;&#21488;&#36827;&#31243;&#32452;ID&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">tcgetpgrp</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;filedes&#25152;&#25171;&#24320;&#30340;&#25511;&#21046;&#32456;&#31471;&#30340;&#21069;&#21488;&#36827;&#31243;&#32452;ID&#20026;pgrpid</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * filedes: &#19982;&#26576;&#20010; tty &#30456;&#20851;&#32852;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> * pgrpid: &#26576;&#20010; tty &#19979;&#30340;&#19968;&#20010;&#23545;&#35805;&#26399;&#20013;&#30340;&#19968;&#20010;&#36827;&#31243;&#32452;&#30340;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#36820;&#22238; 0&#65292;&#22833;&#36133;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">tcsetpgrp</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pgrpid</span>);
</pre>
</div>
<p>
这两个函数用来 <b>通知内核</b> 哪一个进程组是 <span class="underline">前台进程组</span> ，而内核中的 <span class="underline">终端设备驱动程序</span> 也能知道将 <span class="underline">终端输入</span> 和 <span class="underline">终端产生</span> 的 <span class="underline">信号</span> <b>送到何处</b> 
</p>
<pre class="example">
     只有支持作业控制，这两个函数才被定义，否则直接报错
</pre>
</div>
</div>
</div>

<div id="outline-container-org0725b1d" class="outline-2">
<h2 id="org0725b1d">作业控制</h2>
<div class="outline-text-2" id="text-org0725b1d">
<p>
作业控制是伯克利在1980年左右加到UNIX的一个新特性
</p>

<p>
它允许在 <span class="underline">一个终端上</span> <b>起动</b> <span class="underline">多个作业(进程组)</span> ， <b>控制</b>  <span class="underline">哪一个作业</span> <b>可以存取</b> <span class="underline">该终端</span> ，以及 <span class="underline">哪些作业</span> 在 <b>后台运行</b> 。作业控制要求三种形式的支持：
</p>
<ol class="org-ol">
<li><b>支持作业控制</b> 的 <span class="underline">shell</span></li>
<li><span class="underline">内核中</span> 的 <b>终端驱动程序</b> 必须 <span class="underline">支持作业控制</span></li>
<li>必须提供对某些 <b>作业控制信号</b> 的支持</li>
</ol>

<p>
从shell使用作业控制功能角度观察，可以在前台或后台起动一个作业，而 <span class="underline">一个作业</span> 只是 <b>几个进程的集合</b> ，通常是一个 <span class="underline">进程管道</span> 
</p>

<ul class="org-ul">
<li><span class="underline">前台</span> 起动了 <span class="underline">只有一个进程</span> 的 <span class="underline">一个作业</span> ：</li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">$ vi main.c
</pre>
</div>

<ul class="org-ul">
<li>在 <span class="underline">后台</span> 起动了 <span class="underline">两个作业</span> ，这两个后台作业所调用的进程 <span class="underline">都在后台运行</span> 着</li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">$ pr *.c | lpr &amp;

$ make all &amp;
</pre>
</div>

<p>
当起动一个后台作业时， <span class="underline">shell</span> <b>赋与</b> 它一个 <span class="underline">作业标识</span> ，并 <b>打印</b> <span class="underline">一个或几个进程ID</span> 
</p>

<ul class="org-ul">
<li>下面的操作过程显示了Bash Shell是如何处理的：</li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">$ make all &gt; Make.out &amp;
[1] 1475

$ pr *.c | lpr &amp;
[2] 1490

$ &#38190;&#20837;&#22238;&#36710;
[2] + Done pr *.c | lpr &amp;
[1] + Done make all &gt; Make.out &amp;
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">make</span> 是 <span class="underline">作业号1</span> ，所起动的 <span class="underline">进程ID</span> 是 <span class="underline">1475</span></li>
<li><span class="underline">下一个管道线</span> 是 <span class="underline">作业号2</span> ，其 <b>第一个进程的进程ID</b> 是 <span class="underline">1490</span></li>
</ul>
<pre class="example">
    当作业已完成而且键入回车时，shell通知我们作业已经完成

    键入回车是为了让shell打印其提示符，shell并不在任何随意的时间打印后台作业的状态改变，它只在打印其提示符之前这样做

    如果不这样处理，则当我们正输入一行时，它也可能输出
</pre>
</div>

<div id="outline-container-org2657f74" class="outline-3">
<h3 id="org2657f74">信号</h3>
<div class="outline-text-3" id="text-org2657f74">
<p>
可以 <b>键入</b> 一个 <b>影响前台作业</b> 的 <span class="underline">特殊字符</span> ，比如 <span class="underline">挂起键</span> (一般采用 <b>Ctrl-z</b> )与终端进行交互作用。键入此字符使 <span class="underline">终端驱动程序</span> 将 <span class="underline">信号SIGTSTP</span> 送至 <span class="underline">前台进程组</span> 中的 <span class="underline">所有进程</span> ， <b>后台进程组作业则不受影响</b> 。实际上有三个特殊字符可使终端驱动程序产生信号，并将它们送至前台进程组:
</p>
<ul class="org-ul">
<li><span class="underline">中断</span> 字符 (一般采用 <span class="underline">DELETE</span> 或 <span class="underline">Ctrl-c</span> )产生 <span class="underline">SIGINT</span></li>
<li><span class="underline">退出</span> 字符(一般采用 <span class="underline">Ctrl-\</span> )产生 <span class="underline">SIGQUIT</span></li>
<li><span class="underline">挂起</span> 字符(一般采用 <span class="underline">Ctrl-z</span> )产生 <span class="underline">SIGTSTP</span></li>
</ul>
</div>

<div id="outline-container-org01824c8" class="outline-4">
<h4 id="org01824c8">后台进程读取终端输入</h4>
<div class="outline-text-4" id="text-org01824c8">
<p>
<b>只有 <span class="underline">前台作业</span> 接收终端输入</b> ，如果 <span class="underline">后台作业</span> 试图 <span class="underline">读终端</span> ，那么这并不是一个错误，但是 <span class="underline">终端驱动程序</span> 检测这种情况，会 <b>发送</b> 一个 <span class="underline">特定信号SIGTTIN</span> 给 <span class="underline">后台作业</span> 。这通常会 <b>停止此后台作业</b> ，而 <span class="underline">有关用户</span> 则会得到这种情况的通知，然后就可将此作业 <b>转为前台作业运行</b> ，使得它可以读终端输入。下列操作过程显示了这一点：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cat &gt; temp.foo &amp; <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#21518;&#21488;&#21551;&#21160;,&#20294;&#23558;&#20174;&#26631;&#20934;&#36755;&#20837;&#35835;</span>
[1] 1681

$ &#38190;&#20837;&#22238;&#36710;
[1] + Stopped (tty input) cat &gt; temp.foo &amp;

$ fg %1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;1&#21495;&#20316;&#19994;&#25104;&#20026;&#21069;&#21488;&#20316;&#19994;</span>
cat &gt; temp.foo <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">shell&#21578;&#35785;&#25105;&#20204;&#29616;&#22312;&#21738;&#19968;&#20010;&#20316;&#19994;&#22312;&#21069;&#21488;</span>
hello, world <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#36755;&#20837;1&#34892;</span>
&#710;D <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#25991;&#20214;&#32467;&#26463;&#31526;</span>

$ cat temp.foo <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#26816;&#26597;&#35813;&#34892;&#24050;&#36865;&#20837;&#25991;&#20214;</span>
hello, world
</pre>
</div>

<pre class="example">
shell在后台起动cat进程，但是当cat试图读其标准输入(控制终端)时

1. 终端驱动程序知道它是个后台作业，于是将SIGTTIN信号送至该后台作业
2. shell检测到其子进程的状态改变，并通知用户该作业已被停止
3. 用shell的fg命令将此停止的作业送入前台运行，这样使shell将此作业转为前台进程组(tcsetpgrp)
4. 将继续信号(SIGCONT)送给该进程组

因为该作业现在前台进程组中，所以它可以读控制终端
</pre>
</div>
</div>
<div id="outline-container-org34629e2" class="outline-4">
<h4 id="org34629e2">后台进程向终端输出</h4>
<div class="outline-text-4" id="text-org34629e2">
<p>
这是一个 <b>可以允许或禁止</b> 的 <span class="underline">选择项</span> 。通常可以用 <span class="underline">stty(1)</span> 命令改变这一选择项。下面显示了这种操作过程：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cat temp.foo &amp; <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#21518;&#21488;&#25191;&#34892;</span>
[1] 1719
$ hello, world <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#25552;&#31034;&#31526;&#21518;&#20986;&#29616;&#21518;&#21488;&#20316;&#19994;&#30340;&#36755;&#20986;</span>
               <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#22238;&#36710;</span>
[1] + Done   cat temp.foo &amp;

$ stty tostop <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#27490;&#21518;&#21488;&#20316;&#19994;&#21521;&#25511;&#21046;&#32456;&#31471;&#36755;&#20986;</span>

$ cat temp.foo &amp; <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#21518;&#21488;&#20877;&#27425;&#25191;&#34892;</span>
[1] 1721 
$ <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#22238;&#36710;,&#21457;&#29616;&#20316;&#19994;&#24050;&#20572;&#27490;</span>
[1] + Stopped(tty output) cat temp.foo &amp;

$ fg %1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#20572;&#27490;&#30340;&#20316;&#19994;&#24674;&#22797;&#20026;&#21069;&#21488;&#20316;&#19994;</span>
cat temp.foo <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">shell&#21578;&#35785;&#25105;&#20204;&#29616;&#22312;&#21738;&#19968;&#20010;&#20316;&#19994;&#22312;&#21069;&#21488;</span>
hello, world <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#35813;&#20316;&#19994;&#30340;&#36755;&#20986;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4abe3e" class="outline-3">
<h3 id="orgc4abe3e">总结</h3>
<div class="outline-text-3" id="text-orgc4abe3e">
<p>
图9-8摘录了已说明的作业控制的某些功能：
</p>
<ul class="org-ul">
<li><b>穿过终端驱动程序框</b> 的 <span class="underline">实线</span> ： <span class="underline">终端I/O</span> 和 <span class="underline">终端产生的信号</span> 总是从 <span class="underline">前台进程组</span> <b>连接到</b> <span class="underline">实际终端</span></li>
<li><p>
<b>SIGTTOU信号</b> 的 <span class="underline">虚线</span> ： <span class="underline">后台进程组进程的输出</span> 是否 <span class="underline">出现在终端</span> 是 <b>可选择的</b> 
</p>

<div class="figure">
<p><img src="pic/job-controll.png" alt="job-controll.png" width="60%" />
</p>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org20f816c" class="outline-2">
<h2 id="org20f816c">shell执行程序</h2>
<div class="outline-text-2" id="text-org20f816c">
<pre class="example">
    注意：关于管道的内容已经过时

    在现在的sh和bash几乎都是看到先执行第一个命令，再依次执行每一条命令！！！
</pre>
</div>

<div id="outline-container-org5eb8a37" class="outline-3">
<h3 id="org5eb8a37">Bourne shell</h3>
<div class="outline-text-3" id="text-org5eb8a37">
<pre class="example">
Bourne shell不支持作业控制
</pre>
</div>

<div id="outline-container-org7e1802b" class="outline-4">
<h4 id="org7e1802b">前台进程</h4>
<div class="outline-text-4" id="text-org7e1802b">
<div class="org-src-container">
<pre class="src src-sh">$ ps -xj
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#36827;&#31243;ID &#36827;&#31243;ID &#36827;&#31243;&#32452;ID &#20250;&#35805;&#26399;ID &#32456;&#31471;&#36827;&#31243;&#32452;ID &#21629;&#20196;</span>
PPID PID PGID SID TPGID COMMAND
1    163 163  163 163   -sh
163  163 163  163 163   ps 
</pre>
</div>
<p>
<span class="underline">shell</span> 和 <span class="underline">ps</span> 命令两者位于 <b>同一对话期</b> 和 <b>前台进程组</b> <span class="underline">163</span> 中
</p>
<ul class="org-ul">
<li><span class="underline">163</span> 是在 <span class="underline">TPGID列</span> 中显示的 <span class="underline">进程组</span> ，所以称其为 <span class="underline">前台进程组</span></li>
<li><span class="underline">ps的父进程</span> 是 <span class="underline">shell</span></li>
<li><span class="underline">登录shell</span> 是由 <span class="underline">login</span> 作为其 <span class="underline">父进程</span></li>
</ul>


<pre class="example">
"进程与终端进程组ID(TPGID列)"相关联是用词不当，进程并没有终端进程组

进程属于一个进程组，而进程组属于一个对话期。对话期可能有，也可能没有控制终端

如果它确有一个控制终端，则此终端设备知道其前台进程的进程组ID，这一值可以用tcsetpgrp函数在终端驱动程序中设置

前台进程组ID是终端的一个属性，而不是进程的属性，取自终端设备驱动程序的该值是ps在TPGID列中打印的值

如果ps发现此对话期没有控制终端，则它在该列打印 -1 
</pre>
</div>
</div>

<div id="outline-container-org59ff89f" class="outline-4">
<h4 id="org59ff89f">后台进程</h4>
<div class="outline-text-4" id="text-org59ff89f">
<div class="org-src-container">
<pre class="src src-sh">$ ps -xj &amp;

PPID  PID  PGID  SID  TPGID  COMMAND
1     163  163   163  163    -sh
163   169  163   163  163    ps
</pre>
</div>

<pre class="example">
      由于Bourne shell不支持作业控制，所以唯一改变的只有ps命令的进程ID
</pre>
</div>
</div>

<div id="outline-container-orgce610f5" class="outline-4">
<h4 id="orgce610f5">管道</h4>
<div class="outline-text-4" id="text-orgce610f5">
<pre class="example">
      管道中的 最后一个进程 ： shell的子进程

      管道中的 第一个进程： 最后一个进程的子进程
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ ps -xj | cat1

PPID  PID  PGID  SID  TPGID  COMMAND
1     163  163   163  163    -sh
163   200  163   163  163    cat1
200   201  163   163  163    ps 
</pre>
</div>

<ol class="org-ol">
<li><span class="underline">shell</span> 首先会 <span class="underline">fork一个sh副本</span></li>
<li><span class="underline">exec</span> 执行 <b>管道中最后一个命令</b></li>
<li><span class="underline">fork后的sh副本</span> 再为 <span class="underline">管道线中的每条命令</span> 各 <span class="underline">fork一个sh进程</span></li>
<li><p>
再依次 <span class="underline">exec</span> <b>执行管道中每个命令</b> 。例如，在一条管道中执行三个进程：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ps -xj | cat1 | cat2

PPID  PID  PGID  SID  TPGID  COMMAND
1     163  163   163  163    -sh
163   202  163   163  163    cat2
202   203  163   163  163    ps
202   204  163   163  163    cat1
</pre>
</div>

<p>
图9-9显示了上面所发生的情况：
</p>

<div class="figure">
<p><img src="pic/bourne-pipeline.png" alt="bourne-pipeline.png" width="80%" />
</p>
</div></li>
</ol>

<pre class="example">
      对Bourne shell来说后台执行管道线的唯一区别：进程ID发生变化
</pre>
</div>
</div>
<div id="outline-container-orgad5abd8" class="outline-4">
<h4 id="orgad5abd8">后台进程读取控制终端</h4>
<div class="outline-text-4" id="text-orgad5abd8">
<div class="org-src-container">
<pre class="src src-sh">$ cat &gt; temp.foo &amp;
</pre>
</div>
<p>
如果 <span class="underline">该进程自己</span> <span class="underline">不重新定向标准输入</span> ，则Bourne shell <b>自动</b> 将 <span class="underline">后台进程的标准输入</span> <b>重新定向</b> 到 <span class="underline">/dev/null</span> ：
</p>
<ul class="org-ul">
<li><span class="underline">读/dev/null</span> 则产生一个 <b>文件结束</b></li>
</ul>

<pre class="example">
      这意味着后台 cat 进程立即读到文件尾，并正常结束 
</pre>

<p>
如果一个 <span class="underline">后台进程</span>  <b>打开/dev/tty</b> 并且 <b>读该控制终端</b> 
</p>
<pre class="example">
      这种情况依赖系统实现。但是这很可能不是想要的
</pre>
<p>
例如：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ crypt &lt; salaries | lpr &amp;
</pre>
</div>

<pre class="example">
      有可能当执行这条后台管道时，crypt在终端上打印提示符“Password:”
      但是shell读取了我们所输入的加密码口令，并企图执行其中一条命令

      我们输送给shell的下一行，则被crypt进程取为口令行，于是salaries也就不能正确地被译码，结果将一堆没有用的信息送到了打印机

      在这里，我们有了两个进程，它们试图同时读同一设备，其结果则依赖于系统
</pre>

<p>
这也正好说明： <span class="underline">作业控制</span> 以 <b>较好的方式处理 <span class="underline">一个终端</span> 在 <span class="underline">多个进程间</span> 的转接</b> 
</p>
</div>
</div>
</div>
<div id="outline-container-orgcba1fc4" class="outline-3">
<h3 id="orgcba1fc4">Bash</h3>
<div class="outline-text-3" id="text-orgcba1fc4">
<p>
Bash支持作业控制，依次执行刚才的命令：
</p>
</div>
<div id="outline-container-org2430d0e" class="outline-4">
<h4 id="org2430d0e">前台进程</h4>
<div class="outline-text-4" id="text-org2430d0e">
<div class="org-src-container">
<pre class="src src-sh">$ ps -xj

PPID PID PGID SID TPGID COMMAND
1    700 700  700 708   -bash
700  708 708  700 708   ps
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">Bash</span> 将 <b>前台作业</b>  <span class="underline">ps</span> 放入了它 <b>自己的进程组</b>  <span class="underline">708</span> 
<ul class="org-ul">
<li><span class="underline">ps命令</span> 是 <span class="underline">进程组</span> <b>组长进程</b> ，并是 <b>该进程组的唯一进程</b></li>
<li>此进程组具有 <span class="underline">控制终端</span> ，所以它是 <b>前台进程</b></li>
<li><span class="underline">登录shell</span> 在 <span class="underline">执行ps命令时</span> 是 <b>后台进程组</b></li>
</ul></li>
<li><span class="underline">登录shell</span> 和 <span class="underline">ps</span> 这两个进程组 <span class="underline">700</span> 和 <span class="underline">708</span> 都是 <b>同一对话期的成员</b></li>
</ul>
</div>
</div>
<div id="outline-container-orgf4f3cb6" class="outline-4">
<h4 id="orgf4f3cb6">后台进程</h4>
<div class="outline-text-4" id="text-orgf4f3cb6">
<div class="org-src-container">
<pre class="src src-sh">$ ps -xj &amp;

PPID PID PGID SID TPGID COMMAND
1    700 700  700 700   -bash
700  709 709  700 700   ps
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">ps命令</span> 被放入它 <span class="underline">自己的进程组</span>
<ul class="org-ul">
<li><span class="underline">进程组</span> (709) <b>不再是前台进程组</b> 。这是一个 <span class="underline">后台进程组</span></li>
</ul></li>
<li><span class="underline">TPGID</span> 为 <span class="underline">700</span> ： <span class="underline">前台进程组</span> 是 <span class="underline">登录shell</span></li>
</ul>
</div>
</div>
<div id="outline-container-org9d6dba4" class="outline-4">
<h4 id="org9d6dba4">前台管道</h4>
<div class="outline-text-4" id="text-org9d6dba4">
<div class="org-src-container">
<pre class="src src-sh">$ ps -xj | cat1

PPID  PID  PGID  SID  TPGID  COMMAND
1     700  700   700  710    -bash
700   710  710   700  710    ps
710   711  710   700  710    cat1
</pre>
</div>

<p>
<span class="underline">ps</span> 和 <span class="underline">cat1</span> 都在一个 <b>新进程组</b> <span class="underline">710</span> 中，这是一个 <span class="underline">前台进程组</span> 
</p>

<pre class="example">
和Bourne shell实例之间能另一个区别是：

Bourne shell首先创建将执行管道线中“最后一条命令”的进程

bash是fork bash的副本并 exec 执行 “第一个命令”
</pre>
</div>
</div>
<div id="outline-container-orgfb24970" class="outline-4">
<h4 id="orgfb24970">后台管道</h4>
<div class="outline-text-4" id="text-orgfb24970">
<pre class="example">
Bash以Bourne shell相同的方式产生后台管道进程
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ ps -xj | cat1 &amp;

PPID  PID  PGID  SID  TPGID  COMMAND
1     700  700   700  700    -bash
700   712  712   700  700    cat1
712   713  712   700  700    ps
</pre>
</div>

<p>
<span class="underline">cat1</span> 和 <span class="underline">ps</span> 都处在 <b>后台进程组</b> <span class="underline">712</span> 中：
</p>
<ul class="org-ul">
<li><span class="underline">创建</span>  <b>最后一个命令</b> <span class="underline">cat1</span></li>
<li><span class="underline">创建</span> 命令 <span class="underline">ps</span></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf2024d8" class="outline-2">
<h2 id="orgf2024d8">孤儿进程组</h2>
<div class="outline-text-2" id="text-orgf2024d8">
<ul class="org-ul">
<li><span class="underline">孤儿进程</span> ：一个 <span class="underline">父进程</span> <b>已终止</b> 的进程
<ul class="org-ul">
<li>这种进程由 <span class="underline">init进程</span> <b>托管</b></li>
</ul></li>
<li>孤儿进程组：该组中 <span class="underline">每个成员的父进程</span> 要么是 <b>该组的一个成员</b> ，要么 <b>不是该组所属 <span class="underline">对话期</span> 的成员</b> 
<ul class="org-ul">
<li>孤儿进程组将被置于 <b>后台</b> 执行</li>
</ul></li>
</ul>
<pre class="example">
    一个进程组不是孤儿进程组的条件是：

    该组中存在一个进程，其父进程在同一会话的其它进程组中
</pre>

<p>
如果进程组 <span class="underline">不是孤儿进程组</span> ，那么在 <span class="underline">属于同一对话期</span> 的 <span class="underline">另一个组中的父进程</span> 就有机会 <b>重新起动</b> <span class="underline">该组中停止的进程</span> 
</p>
</div>
<div id="outline-container-orgdb84949" class="outline-3">
<h3 id="orgdb84949">实例</h3>
<div class="outline-text-3" id="text-orgdb84949">
<p>
考虑一个进程：
</p>
<ul class="org-ul">
<li>它 <span class="underline">fork了一个子进程</span> 然后 <span class="underline">终止</span> 。这在系统中是经常发生的，并无异常之处</li>
<li><p>
在父进程终止时，如果该 <b>子进程停止</b> (作业控制)，则 <span class="underline">子进程</span> 就成了 <b>孤儿进程组</b> 
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_hup</span>(<span style="color: #98f5ff;">int</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_ids</span>(<span style="color: #98f5ff;">char</span> *);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">c</span>;
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;

    pr_ids(<span style="color: #deb887;">"parent"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork()) &lt; 0)
        err_sys(<span style="color: #deb887;">"fork error"</span>);

    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(pid &gt; 0) { 
        sleep(5);<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#36827;&#31243;&#20808;&#20241;&#30496;&#65292;&#20351;&#24471;&#23376;&#36827;&#31243;&#26377;&#26426;&#20250;&#20808;&#36816;&#34892;</span>
        exit(0); 
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        pr_ids(<span style="color: #deb887;">"child"</span>);
        signal(SIGHUP, sig_hup); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22788;&#29702;&#25346;&#26029;&#20449;&#21495;</span>
        kill(getpid(), SIGTSTP); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#36865;&#20449;&#21495;&#20351;&#24471;&#23376;&#36827;&#31243;&#20572;&#27490;</span>
        pr_ids(<span style="color: #deb887;">"child"</span>); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21464;&#25104;&#23396;&#20799;&#36827;&#31243;&#32452;&#21518;&#65292;&#36716;&#20837;&#21518;&#21488;&#36816;&#34892;</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(read(STDIN_FILENO, &amp;c, 1) != 1)
            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21518;&#21488;&#36827;&#31243;&#32452;&#35835;&#21462;&#25511;&#21046;&#32456;&#31471;&#36755;&#20837;&#20250;&#20135;&#29983;SIGTTIN&#20449;&#21495;&#65292;&#23548;&#33268;&#35835;&#21462;&#25253;&#38169;errno=EIO</span>
            printf(<span style="color: #deb887;">"read error from control terminal, errno = %d\n"</span>, <span style="color: #98f5ff;">errno</span>
                   <span style="color: #daa520; font-weight: bold;">exit</span>(0);
                   }        
    }

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_hup</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
    {
        printf(<span style="color: #deb887;">"SIGHUP received, pid = %d\n"</span>, getpid());
        <span style="color: #00bfff; font-weight: bold;">return</span>;

    }

    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_ids</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>)
    {
        printf(<span style="color: #deb887;">"%s: pid = %d, ppid = %d, pgrp = %d\n"</span>,
               name, getpid(), getppid(), tcgetpgrp(STDIN_FILENO));
        fflush(stdout);
    }
</pre>
</div>

<p>
图9-10显示了父进程已经fork了子进程后的情况：
</p>

<div class="figure">
<p><img src="pic/orphan-process-group.png" alt="orphan-process-group.png" width="50%" />
</p>
</div>

<p>
假定使用了一个作业控制shell。shell将 <span class="underline">前台进程</span> 放在一个 <span class="underline">进程组中</span> (本例中是 <span class="underline">512</span> )， <span class="underline">shell</span> 则留在自己的 <span class="underline">组内</span> ( <span class="underline">442</span> )。 <span class="underline">子进程</span> <b>继承</b> 其 <span class="underline">父进程</span> ( <span class="underline">512</span> )的 <span class="underline">进程组</span> 。在fork之后:
</p>
<ol class="org-ol">
<li><span class="underline">父进程</span> <b>睡眠5秒钟</b> ：
<ul class="org-ul">
<li>让子进程在父进程终止之前运行</li>
</ul></li>
<li><span class="underline">子进程</span> 为 <b>挂断信号</b> ( <span class="underline">SIGHUP</span> ) <b>建立</b> <span class="underline">信号处理程序</span> ：
<ul class="org-ul">
<li>这样就能观察到SIGHUP信号是否已送到子进程</li>
</ul></li>
<li><span class="underline">子进程</span> 用 <b>kill函数</b> 向其 <b>自身发送</b> <span class="underline">停止信号</span> ( <span class="underline">SIGTSTP</span> )：
<ul class="org-ul">
<li>停止了子进程，类似于用终端挂起字符(Ctrl-Z)停止一个前台作业</li>
</ul></li>
<li>当 <span class="underline">父进程</span> <b>终止</b> 时：
<ul class="org-ul">
<li>该 <span class="underline">子进程</span> 成为 <span class="underline">孤儿进程</span> ， <span class="underline">父进程ID</span> 成为 <b>1</b> ，也就是 <span class="underline">init进程</span></li>
</ul></li>
<li><span class="underline">子进程</span> 成为一个 <b>孤儿进程组</b> 的 <span class="underline">成员</span> ：
<ul class="org-ul">
<li>因为 <span class="underline">进程组中所有进程</span> 的 <span class="underline">父进程</span> (如进程513的父进程1) <b>属于另一个对话期</b> ，所以此进程组是孤儿进程组</li>
</ul></li>
<li>POSIX.1要求向 <span class="underline">新孤儿进程组</span> 中处于 <span class="underline">停止状态</span> 的 <span class="underline">每一个进程</span> <b>发送</b> <span class="underline">挂断信号</span> ( <span class="underline">SIGHUP</span> )，接着又向其 <b>发送</b> <span class="underline">继续信号</span> ( <span class="underline">SIGCONT</span> )</li>
<li><p>
在 <b>处理了挂断信号</b> 后， <b>子进程继续</b> 
</p>
<ul class="org-ul">
<li>对 <span class="underline">挂断信号</span> 的系统 <b>默认</b> 动作是 <span class="underline">终止该进程</span> ，所以 <b>提供一个信号处理程序</b> 以捕捉该信号</li>
</ul>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ a.out
parent: pid = 512, ppid = 442, pgrp = 512
child: pid = 513, ppid = 512, pgrp = 512
$ SIGHUP received, pid = 513
child: pid = 513, ppid = 1, pgrp = 512
<span style="color: #f08080;">read</span> error from control terminal, errno = 5
</pre>
</div></li>
</ol></li>
</ul>

<pre class="example">
注意：

因为两个进程登录shell和子进程都写向终端，所以shell提示符和子进程的输出一起出现

子进程的父进程ID变成1，成为了孤儿进程

父进程终止时，子进程变成后台进程组，而父进程是由shell作为前台作业执行的

sig_hup函数中的printf会在pr_ids函数中的printf之前执行

在子进程中调用pr_ids后，程序企图读标准输入
当后台进程组试图读控制终端时，则对该后台进程组产生SIGTTIN，这导致read返回出错，其errno设置为EIO(其值是5)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6eaddea" class="outline-2">
<h2 id="org6eaddea">BSD实现</h2>
<div class="outline-text-2" id="text-org6eaddea">
<p>
图9-11显示了BSD中 <span class="underline">进程</span> ， <span class="underline">进程组</span> ， <span class="underline">会话期</span> ， <span class="underline">控制终端</span> 等各种数据结构：
</p>

<div class="figure">
<p><img src="pic/proc-group-bsd.jpg" alt="proc-group-bsd.jpg" width="80%" />
</p>
</div>
</div>

<div id="outline-container-orgbf710df" class="outline-3">
<h3 id="orgbf710df">session结构</h3>
<div class="outline-text-3" id="text-orgbf710df">
<p>
每个 <b>对话期</b> 都分配了一个 <b>session</b> 结构：
</p>
<ul class="org-ul">
<li>s_count：该对话期中的 <span class="underline">进程组数</span> 。当此计数器减至 <span class="underline">0</span> 时，则可 <b>释放此结构</b></li>
<li>s_leader：指向 <b>对话期首进程</b> <span class="underline">proc</span> 结构的指针
<ul class="org-ul">
<li>4.3+BSD不保持 <span class="underline">对话期ID</span> 字段</li>
<li>SVR4则保持此字段</li>
</ul></li>
<li>s_ttyvp ：指向 <b>控制终端</b> <span class="underline">vnode</span> 结构的指针</li>
<li>s_ttyp：指向 <b>控制终端</b> <span class="underline">tty</span> 结构的指针</li>
</ul>

<pre class="example">
在调用setsid时，在内核中分配一个新的对话期结构：

1. s_count设置为1
2. s_leader设置为调用进程的proc结构的指针
3. 因为新对话期没有控制终端，所以s_ttyvp和s_ttyp设置为空指针
</pre>
</div>
</div>

<div id="outline-container-org54a326d" class="outline-3">
<h3 id="org54a326d">tty结构</h3>
<div class="outline-text-3" id="text-org54a326d">
<p>
每个 <b>终端设备</b> 和每个 <b>伪终端设备</b> 均在内核中分配这样一个 <b>tty</b>  结构：
</p>
<ul class="org-ul">
<li>t_session：指向将此终端作为 <b>控制终端</b> 的 <span class="underline">session</span> 结构
<ul class="org-ul">
<li><span class="underline">session</span> 结构也会 <b>指向</b> <span class="underline">tty</span> 结构</li>
<li>终端在 <span class="underline">失去载波信号</span> 时需要使用此指针 <b>将挂起信号</b> 送给 <span class="underline">对话期首进程</span></li>
</ul></li>
<li>t_pgrp：指向 <b>前台进程组</b> 的 <span class="underline">pgrp</span> 结构
<ul class="org-ul">
<li><span class="underline">终端驱动程序</span> 用此字段 <b>将信号</b> 送向 <span class="underline">前台进程组</span> 
<ul class="org-ul">
<li>由 <b>输入特殊字符</b> ( <span class="underline">中断</span> 、 <span class="underline">退出</span> 和 <span class="underline">挂起</span> )而产生的三个信号被送至 <span class="underline">前台进程组</span></li>
</ul></li>
</ul></li>
<li>t_termios：包含所有这些 <b>特殊字符</b> 和与该 <b>终端有关信息</b> 的结构</li>
<li>t_winsize：包含 <b>终端窗口当前尺寸</b> 的 <span class="underline">winsize</span> 结构</li>
</ul>

<pre class="example">
      注意：为了找到特定对话期的前台进程组，内核从session结构开始

     然后用s_ttyp得到控制终端的tty结构，然后用t_pgrp得到前台进程组的pgrp结构
</pre>
</div>
</div>

<div id="outline-container-orgec0aefb" class="outline-3">
<h3 id="orgec0aefb">pgrp结构</h3>
<div class="outline-text-3" id="text-orgec0aefb">
<p>
<b>pgrp</b> 结构包含一个 <b>进程组</b> 的信息：
</p>
<ul class="org-ul">
<li>pg_id： <span class="underline">进程组ID</span></li>
<li>pg_session：指向此 <span class="underline">进程组</span> 所属的 <span class="underline">session</span> 结构</li>
<li>pg_mem：是指向此 <span class="underline">进程组</span> <b>第一个进程</b> <span class="underline">proc</span> 结构的指针</li>
</ul>
</div>
</div>

<div id="outline-container-org5246a94" class="outline-3">
<h3 id="org5246a94">proc结构</h3>
<div class="outline-text-3" id="text-org5246a94">
<p>
<span class="underline">proc</span> 结构包含一个 <b>进程</b> 的所有信息：
</p>
<ul class="org-ul">
<li>p_pid： <span class="underline">进程ID</span></li>
<li>p_pptr：指向 <span class="underline">父进程</span> proc结构的指针</li>
<li>p_pgrp：指向本进程 <b>所属的进程组</b> 的 <span class="underline">pgrp</span> 结构</li>
<li>p_pgrpnxt：指向 <span class="underline">进程组</span> 中 <b>下一个进程</b> 的指针
<ul class="org-ul">
<li><span class="underline">进程组</span> 中 <b>最后一个进程</b> 的p_pgrpnxt为 <span class="underline">NULL</span> 指针</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org6b92240" class="outline-3">
<h3 id="org6b92240">vnode结构</h3>
<div class="outline-text-3" id="text-org6b92240">
<p>
在 <b>打开</b> <span class="underline">控制终端设备</span> 时 <b>分配vnode结构</b> ， <span class="underline">进程</span> 对 <span class="underline">/dev/tty</span> 的所有 <span class="underline">访问</span> 都通过 <span class="underline">vnode</span> 结构
</p>

<pre class="example">
     在BSD中实际 i 节点是 v 节点的一部分

     而SVR4实现中 v节点 存在 i节点 中
</pre>

<p>
<a href="signal.html">Next：信号</a>
</p>

<p>
<a href="process.html">Previous：进程控制</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
