<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程环境</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="system_file.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程环境</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdf0b0de">main函数</a></li>
<li><a href="#orgd8a76cc">进程终止</a>
<ul>
<li><a href="#orgdaecf92">exit和_exit</a>
<ul>
<li><a href="#orgca3d067">终止状态</a></li>
<li><a href="#org4ce2146">atexit</a>
<ul>
<li><a href="#orgf4c90e6">示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcb18504">小结</a></li>
</ul>
</li>
<li><a href="#orga85ee41">命令行参数</a>
<ul>
<li><a href="#org28c61ef">打印所有命令行参数</a></li>
</ul>
</li>
<li><a href="#org8bb517b">C程序内存模型</a>
<ul>
<li><a href="#org84801cc">存储器布局</a>
<ul>
<li><a href="#org0e50bab">正文段</a></li>
<li><a href="#org2805344">初始化数据段</a></li>
<li><a href="#org0e82b47">非初始化数据段</a></li>
<li><a href="#org5b5e155">栈</a></li>
<li><a href="#org27718a6">堆</a></li>
<li><a href="#orga9f40a5">存储器总结</a></li>
</ul>
</li>
<li><a href="#orga4c9a8c">共享库</a></li>
<li><a href="#org9ba3d7b">动态内存管理</a>
<ul>
<li><a href="#org1ece7f1">分配内存</a></li>
<li><a href="#orga35da49">释放内存</a></li>
<li><a href="#orge7ce111">实现细节</a></li>
<li><a href="#orgc83acfa">注意事项</a></li>
<li><a href="#org32a73d9">alloca函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3b2ee27">环境变量表</a>
<ul>
<li><a href="#org6a3775f">常见环境变量</a></li>
<li><a href="#org7346162">环境变量函数</a>
<ul>
<li><a href="#org6e915d6">getenv</a></li>
<li><a href="#orgfd9ba64">putsenv, setenv, unsetenv</a></li>
<li><a href="#orgcc90c66">实现细节</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org64818bd">栈间跳转</a>
<ul>
<li><a href="#org0a09281">cmd_add</a></li>
<li><a href="#org68c82a6">setjmp, longjmp</a>
<ul>
<li><a href="#org300fc35">cmd_add2</a></li>
</ul>
</li>
<li><a href="#org97f9345">volatile变量</a></li>
<li><a href="#org7cfaa6b">自动变量陷阱</a></li>
</ul>
</li>
<li><a href="#orgd1a12eb">资源限制</a>
<ul>
<li><a href="#org887645d">resource常量</a></li>
<li><a href="#orgc034f6e">rlimit结构</a></li>
<li><a href="#orgbfd4f71">实例</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
本章主要说明：

当执行程序时其main函数是如何被调用的
进程终止的不同方式
命令行参数是如何传送给执行程序的
典型的存储器布局是什么样式
如何分配另外的存储空间进程
如何使用环境变量
longjmp 和 setjmp 函数以及它们与栈的交互作用
进程的资源限制
</pre>

<div id="outline-container-orgdf0b0de" class="outline-2">
<h2 id="orgdf0b0de">main函数</h2>
<div class="outline-text-2" id="text-orgdf0b0de">
<p>
C程序总是 <b>从 <span class="underline">main</span> 函数开始执行</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">argc</span> : <b>命令行参数的数目</b></li>
<li><span class="underline">argv</span> :  <b>指向参数的各个指针所构成的数组</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20027;&#20989;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * argc: &#21629;&#20196;&#34892;&#21442;&#25968;&#30340;&#25968;&#30446;</span>
<span style="color: #ffebcd;"> * argv: &#25351;&#38024;&#25968;&#32452;&#65292;&#20854;&#20803;&#32032;&#26159;&#25351;&#21521;&#21508;&#20010;&#21629;&#20196;&#34892;&#21442;&#25968;&#30340;&#23383;&#31526;&#20018;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[]);
</pre>
</div>

<p>
当内核使用一个 <span class="underline">exec</span> 函数 <b>起动C程序</b> 时，在 <span class="underline">调用main函数</span> 前先调用一个 <b>特殊的起动例程</b> ： 
</p>
<ol class="org-ol">
<li>从 <span class="underline">内核</span> 取得 <span class="underline">命令行参数</span> 和 <span class="underline">环境变量值</span></li>
<li>为调用main函数作好准备</li>
</ol>

<pre class="example">
C语言编译的时候会调用链接器(ld)，而链接器会设置这个“特殊的启动例程”为“可执行文件的起始地址”
</pre>
</div>
</div>

<div id="outline-container-orgd8a76cc" class="outline-2">
<h2 id="orgd8a76cc">进程终止</h2>
<div class="outline-text-2" id="text-orgd8a76cc">
<p>
图7-1显示了一个C程序是如何起动的，以及它终止的各种方式
</p>

<div class="figure">
<p><img src="pic/process-lifecycle.png" alt="process-lifecycle.png" width="90%" />
</p>
</div>

<p>
有五种方式使进程终止:
</p>
<ul class="org-ul">
<li><b>正常</b> 终止:
<ul class="org-ul">
<li><span class="underline">从main返回</span></li>
<li>调用 <b>exit</b></li>
<li>调用 <b>_exit</b></li>
</ul></li>
<li><b>异常</b> 终止:
<ul class="org-ul">
<li>调用 <span class="underline">abort</span></li>
<li>由一个 <b>信号终止</b></li>
</ul></li>
</ul>


<pre class="example">
    上节提及的起动例程使得从 main函数 返回后立即调用 exit 函数：
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #daa520; font-weight: bold;">exit</span>(main(argc&#65292;argv)); 
</pre>
</div>

<pre class="example">
    这里将终止例程以C代码形式表示，实际上该例程常常用汇编语言编写
</pre>
</div>
<div id="outline-container-orgdaecf92" class="outline-3">
<h3 id="orgdaecf92">exit和_exit</h3>
<div class="outline-text-3" id="text-orgdaecf92">
<p>
<span class="underline">exit</span> 和 <b>_exit</b> 函数用于 <b>正常终止</b> 一个程序：
</p>
<ul class="org-ul">
<li><b>_exit</b> :  <b>立刻进入内核</b></li>
<li><span class="underline">exit</span> : 先执行一些 <b>清除处理</b> (包括调用 <span class="underline">执行各终止处理程序</span> ， <span class="underline">关闭所有标准I/O流</span> 等)，然后进入内核</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * &#20808;&#25191;&#34892;&#19968;&#20123;&#28165;&#38500;&#22788;&#29702;&#65292;&#28982;&#21518;&#36827;&#20837;&#20869;&#26680;&#32456;&#27490;&#31243;&#24207;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * status: &#31243;&#24207;&#32456;&#27490;&#36820;&#22238;&#29366;&#24577;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">exit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">status</span>);

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#31435;&#21051;&#36827;&#20837;&#20869;&#26680;&#32456;&#27490;&#31243;&#24207;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * status: &#31243;&#24207;&#36820;&#22238;&#29366;&#24577;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">_exit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">status</span>);
</pre>
</div>

<pre class="example">
exit函数总是执行一个标准I/O库的清除关闭操作：对于所有打开流调用fclose函数，这使得缓存中的所有数据都被刷新(写到文件上)
</pre>
</div>

<div id="outline-container-orgca3d067" class="outline-4">
<h4 id="orgca3d067">终止状态</h4>
<div class="outline-text-4" id="text-orgca3d067">
<p>
exit和_exit 都带一个整型参数，称之为 <span class="underline">终止状态</span> 。如果出现下述状况，则该进程的 <b>终止状态是末定义</b> 的：
</p>
<ol class="org-ol">
<li>调用这些函数时 <b>不带终止状态</b></li>
<li>main执行了一个 <b>无返回值的return语句</b></li>
<li>main执行 <b>隐式返回</b></li>
</ol>

<p>
下列经典性的C语言程序是不完整的，其返回状态未定义
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #daa520; font-weight: bold;">main</span> ()
{
    printf (<span style="color: #deb887;">"hello, world \n"</span>);
}
</pre>
</div>

<p>
大多数UNIX shell都提供 <span class="underline">检查一个进程终止状态</span> 的方法：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/hello 
hello, world 

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238;&#29366;&#24577;&#26410;&#23450;&#20041;</span>
$ echo $<span style="color: #4eee94;">?</span>
14
</pre>
</div>

<p>
向执行此程序的进程 <b>返回终止状态 0</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">return</span> 0;
<span style="color: #98f5ff;">&#25110;&#32773;</span>
<span style="color: #daa520; font-weight: bold;">exit</span>(0);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ce2146" class="outline-4">
<h4 id="org4ce2146">atexit</h4>
<div class="outline-text-4" id="text-org4ce2146">
<p>
<span class="underline">终止处理程序</span> ：这些函数将在 <b>调用后exit被自动调用</b> 
</p>

<p>
<span class="underline">atexit</span> ： <b>登记</b> 注册终止处理程序
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#27880;&#20876;&#31243;&#24207;&#32456;&#27490;&#20989;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * func: &#32456;&#27490;&#22788;&#29702;&#20989;&#25968;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;&#22320;&#22336;&#65289;&#65292;&#26080;&#21442;&#25968;&#65292;&#26080;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0, &#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">atexit</span>(<span style="color: #98f5ff;">void</span> (*<span style="color: #daa520; font-weight: bold;">func</span>)(<span style="color: #98f5ff;">void</span>));
</pre>
</div>
<p>
其中 <span class="underline">atexit</span> 的参数是一个 <b>函数地址</b> ：当调用此函数时 <span class="underline">无需向它传送任何参数</span> ， <span class="underline">也不期望它返回一个值</span> 
</p>

<pre class="example">
      照ANSIC的规定一个进程可以登记多至32个函数
</pre>
</div>

<div id="outline-container-orgf4c90e6" class="outline-5">
<h5 id="orgf4c90e6">示例</h5>
<div class="outline-text-5" id="text-orgf4c90e6">
<p>
以下示例说明了如何使用atexit函数
</p>
<pre class="example">
       注意：main函数使用了return来隐式调用exit函数
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit1</span>(<span style="color: #98f5ff;">void</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit2</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (atexit(my_exit2) != 0)
        err_sys(<span style="color: #deb887;">"can't register my_exit2"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (atexit(my_exit1) != 0)
        err_sys(<span style="color: #deb887;">"can't register my_exit1"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (atexit(my_exit1) != 0)
        err_sys(<span style="color: #deb887;">"can't register my_exit1"</span>);

    printf(<span style="color: #deb887;">"main is done\n"</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit1</span>(<span style="color: #98f5ff;">void</span>)
{
    printf(<span style="color: #deb887;">"first exit handler\n"</span>);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit2</span>(<span style="color: #98f5ff;">void</span>)
{
    printf(<span style="color: #deb887;">"second exit handler\n"</span>);
}

</pre>
</div>

<p>
exit以 <b>登记相反的顺序</b> 调用终止函数
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/doatexit 

main is done
first exit handler
first exit handler
second exit handler
</pre>
</div>
<p>
同一函数如果被登记多次，则也会被调用多次
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcb18504" class="outline-3">
<h3 id="orgcb18504">小结</h3>
<div class="outline-text-3" id="text-orgcb18504">
<ul class="org-ul">
<li>内核使程序执行：调用 <span class="underline">exec</span> 函数</li>
<li>进程 <span class="underline">自愿</span> 终止： <span class="underline">显式</span> 或 <span class="underline">隐式</span> 地调用 <span class="underline">exit</span> 或 <b>_exit</b> 函数
<ul class="org-ul">
<li>exit函数：首先调用各终止处理程序，然后按需多次调用fclose关闭所有打开流</li>
</ul></li>
<li>进程 <span class="underline">非自愿</span> 终止：通过 <span class="underline">信号量</span></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga85ee41" class="outline-2">
<h2 id="orga85ee41">命令行参数</h2>
<div class="outline-text-2" id="text-orga85ee41">
<p>
调用 <span class="underline">exec</span> 函数可将 <b>命令行参数</b> 传递给被 <span class="underline">执行的新程序</span> 
</p>
</div>

<div id="outline-container-org28c61ef" class="outline-3">
<h3 id="org28c61ef">打印所有命令行参数</h3>
<div class="outline-text-3" id="text-org28c61ef">
<p>
ANSIC和POSIX.1都要求 <span class="underline">argv[argc]</span> 是一个空指针结尾，所以 <b>循环可以通过空指针判断来中断</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">echo all command line args</span>
    <span style="color: #00bfff; font-weight: bold;">for</span>(i = 0; argv[i] != <span style="color: #ffd700;">NULL</span>; i++)
        printf(<span style="color: #deb887;">"argv[%d]: %s\n"</span>, i, argv[i]);

    <span style="color: #00bfff; font-weight: bold;">return</span> 0;

}
</pre>
</div>

<pre class="example">
argv[i]  != NULL 等价于 i &lt; argc 
</pre>

<p>
argv的第一个字符串：被执行的程序路径名
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/arg arg1 TEST foo

argv[0]: ./src/environ/arg
argv[1]: arg1
argv[2]: TEST
argv[3]: foo
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8bb517b" class="outline-2">
<h2 id="org8bb517b">C程序内存模型</h2>
<div class="outline-text-2" id="text-org8bb517b">
</div>
<div id="outline-container-org84801cc" class="outline-3">
<h3 id="org84801cc">存储器布局</h3>
<div class="outline-text-3" id="text-org84801cc">
<p>
C程序一直由下列几部分组成：
</p>
</div>
<div id="outline-container-org0e50bab" class="outline-4">
<h4 id="org0e50bab">正文段</h4>
<div class="outline-text-4" id="text-org0e50bab">
<p>
CPU执行的 <b>机器指令</b> 部分，也被称为 <span class="underline">代码段</span> 
</p>

<pre class="example">
      通常正文段是可共享的，所以即使是经常执行的程序(如文本编辑程序、C编译程序、shell等)在存储器中也只需有一个副本

      另外正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令
</pre>
</div>
</div>

<div id="outline-container-org2805344" class="outline-4">
<h4 id="org2805344">初始化数据段</h4>
<div class="outline-text-4" id="text-org2805344">
<p>
此段也被称为 <span class="underline">数据段</span> ，它包含了程序中 <b>需赋初值的变量</b> 。 <b>任何函数之外声明会把变量的初值</b> 存放在初始化数据段中：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">int</span>&#12288;maxcount=99;
</pre>
</div>
</div>
</div>
<div id="outline-container-org0e82b47" class="outline-4">
<h4 id="org0e82b47">非初始化数据段</h4>
<div class="outline-text-4" id="text-org0e82b47">
<p>
通常将此段称为 <span class="underline">bss段</span> ，在程序开始执行之前， <b>内核将此段初始化为0</b> 
</p>

<p>
例如： <b>在函数外声明位初始化的数组</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">sum</span>[1000];
</pre>
</div>
</div>
</div>
<div id="outline-container-org5b5e155" class="outline-4">
<h4 id="org5b5e155">栈</h4>
<div class="outline-text-4" id="text-org5b5e155">
<p>
<b>自动变量</b> 以及每次 <b>函数调用时所需保存的信息</b> 都存放在此段中
</p>

<pre class="example">
      每次函数调用时其 返回地址、以及调用者的 环境信息(例如某些机器寄存器)都存放在栈中

      然后新被调用的函数在栈上为其 自动 和 临时变量分配存储空间

      通过以这种方式使用栈C函数可以递归调用
</pre>
</div>
</div>

<div id="outline-container-org27718a6" class="outline-4">
<h4 id="org27718a6">堆</h4>
<div class="outline-text-4" id="text-org27718a6">
<p>
在堆中进行 <b>动态存储</b> 分配
</p>

<pre class="example">
      由于历史上形成的惯例，堆位于 非初始化数据段顶(bss) 和栈底(stack bottom)之间
</pre>
</div>
</div>

<div id="outline-container-orga9f40a5" class="outline-4">
<h4 id="orga9f40a5">存储器总结</h4>
<div class="outline-text-4" id="text-orga9f40a5">
<p>
图7-3显示了C程序在内存中的一种典型安排方式：
</p>

<div class="figure">
<p><img src="pic/memory.png" alt="memory.png" width="90%" />
</p>
</div>


<pre class="example">
对于VAX上的4.3+BSD而言

1. 正文段从0位置开始，栈顶则在0x7fffffff之下开始，堆顶和栈底之间未用的虚地址空间很大
2. 栈一般是从高地址往低地址增长
3. 堆一般是从低地址往高地址增长
4. 末初始化数据段的内容并不存放在磁盘程序文件中，需要存放在磁盘程序文件中的段只有正文段和初始化数据段
</pre>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">size(1)&#21629;&#20196;&#25253;&#21578;&#27491;&#25991;&#27573;&#12289;&#25968;&#25454;&#27573;&#21644;bss&#27573;&#30340;&#38271;&#24230;(&#21333;&#20301;:&#23383;&#33410;)&#65306;</span>
$ size /usr/bin/cc /bin/sh
   text    data     bss     dec     hex filename
   7537     800       0    8337    2091 /usr/bin/cc
 712531   37360   18656  768547   bba23 /bin/sh
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga4c9a8c" class="outline-3">
<h3 id="orga4c9a8c">共享库</h3>
<div class="outline-text-3" id="text-orga4c9a8c">
<p>
现在很多UNIX系统支持 <span class="underline">共享库</span> 。共享库使得 <b>可执行文件中不再需要包含常用的库函数</b> ，而只需在 <b>所有进程都可存取的存储区中保存这种库例程的一个副本</b> ：
</p>
<ul class="org-ul">
<li>程序第一次执行或者第一次调用某个库函数时，用 <b>动态连接</b> 方法将程序与共享库函数相链接。这 <b>减少了每个可执行文件的长度</b> ，但 <b>增加了一些运行时间开销</b></li>
<li><b>可以用库函数的新版本代替老版本</b> 而 <b>无需对使用该库的程序重新链接编辑</b> (假定参数的数目和类型都没有发生改变)</li>
</ul>
</div>
</div>

<div id="outline-container-org9ba3d7b" class="outline-3">
<h3 id="org9ba3d7b">动态内存管理</h3>
<div class="outline-text-3" id="text-org9ba3d7b">
</div>
<div id="outline-container-org1ece7f1" class="outline-4">
<h4 id="org1ece7f1">分配内存</h4>
<div class="outline-text-4" id="text-org1ece7f1">
<p>
ANSI C说明了三个用于存储空间动态分配的函数： 
</p>
<ol class="org-ol">
<li><span class="underline">malloc</span> ： <b>分配指定字节数的存储区</b> ，此存储区中的初始值不确定</li>
<li><span class="underline">calloc</span> ： <b>为指定长度的对象分配能容纳其指定个数的存储空间</b> ，该空间中的每一位(bit)都 <b>初始化为0</b></li>
<li><p>
<span class="underline">realloc</span> ： <b>更改以前分配区的长度(增加或减少)</b> 
</p>
<ul class="org-ul">
<li>当增加长度时可能需 <b>将以前分配区的内容移到另一个足够大的区域</b> ，而新增区域内的初始值则不确定</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26681;&#25454;&#25152;&#25351;&#23450;&#30340;size&#20998;&#37197;&#31354;&#38388;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * size: &#20998;&#37197;&#31354;&#38388;&#22823;&#23567;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#26102;&#36820;&#22238; &#31354;&#38388;&#30340;&#39318;&#22336;&#65292;&#22833;&#36133;&#26102;&#36820;&#22238; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">malloc</span>(<span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20998;&#37197;nobj &#20010; size&#22823;&#23567;&#30340;&#36830;&#32493;&#31354;&#38388;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * nobj: object&#25968;&#37327;</span>
<span style="color: #ffebcd;"> * size: object&#22823;&#23567;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#26102;&#23558;&#35813;&#27573;&#20869;&#23384; &#20840;&#37096;&#28165;&#38646;&#24182;&#36820;&#22238; &#20854;&#39318;&#22336;&#65292;&#22833;&#36133;&#26102;&#36820;&#22238; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">calloc</span>(<span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nobj</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20026;&#24050;&#20998;&#37197;&#30340;ptr&#37325;&#26032;&#20998;&#37197;&#19968;&#22359;&#22823;&#23567;&#20026;newsize&#30340;&#31354;&#38388;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * ptr: &#24050;&#32463;&#20998;&#37197;&#30340;&#31354;&#38388;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * newsize: &#26032;&#30340;&#31354;&#38388;&#22823;&#23567;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#26102;&#36820;&#22238;&#31354;&#38388;&#30340;&#39318;&#22336;&#65292;&#22833;&#36133;&#26102;&#36820;&#22238;NULL;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">realloc</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">newsize</span>);
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orga35da49" class="outline-4">
<h4 id="orga35da49">释放内存</h4>
<div class="outline-text-4" id="text-orga35da49">
<p>
<span class="underline">free</span> ： <b>释放</b> ptr指向的存储空间
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#37322;&#25918;&#25351;&#23450;&#30340;ptr&#23545;&#24212;&#30340;&#22320;&#22336;&#31354;&#38388;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * ptr: &#24050;&#32463;&#20998;&#37197;&#30340;&#22320;&#22336;&#31354;&#38388;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">free</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge7ce111" class="outline-4">
<h4 id="orge7ce111">实现细节</h4>
<div class="outline-text-4" id="text-orge7ce111">
<p>
分配函数通常通过系统调用 <span class="underline">sbrk(2)</span> 实现来实现
</p>
<ul class="org-ul">
<li>分配函数所返回的指针一定是 <span class="underline">适当对齐</span> 的，遵守 <b>最苛刻的对齐要求</b> ，使其可用于任何数据对象</li>
<li>分配函数所返回的指针可 <b>用于任何指针</b> ，不需要强制转换</li>
<li>大多数实现所分配的 <b>存储空间比所要求的要稍大一些</b> ，额外的空间用来记录管理信息：
<ul class="org-ul">
<li>分配块的长度</li>
<li>指向下一个分配块的指针等等</li>
</ul></li>
<li>free函数 <b>被释放的空间通常被送入可用存储区池</b> ，以后再调用分配函数时再分配，但是这 <b>并不会减小进程的存储开销</b></li>
</ul>
<pre class="example">
      也就是说free释放的空间并不会返回给内核，供其他程序使用
</pre>
</div>
</div>

<div id="outline-container-orgc83acfa" class="outline-4">
<h4 id="orgc83acfa">注意事项</h4>
<div class="outline-text-4" id="text-orgc83acfa">
<ul class="org-ul">
<li>分配函数返回的指针 <b>不应该参与任何指针运算</b></li>
<li>realloc可能会 <b>移动存储区</b> ，任何指向原来分配区内部的指针都可能失效</li>
<li>realloc的最后一个参数是 <b>存储区的newsize(新长度)</b> ，而不是新、旧长度之差</li>
<li>free调用完毕 <b>不会设置对应的ptr指针为NULL</b> ，若再次直接访问ptr指向的地址是不安全的操作</li>
<li><b>释放一个已经释放了的块</b> 和 <b>调用free时所用的指针不是三个alloc函数的返回值</b> 都会发生段异常</li>
<li><b>分配而不再使用的堆空间，应尽快通过free回收</b> ，否则会出现 <span class="underline">内存泄漏</span></li>
</ul>
</div>
</div>

<div id="outline-container-org32a73d9" class="outline-4">
<h4 id="org32a73d9">alloca函数</h4>
<div class="outline-text-4" id="text-org32a73d9">
<p>
<span class="underline">alloca</span> ：类似于malloc，但是不是在堆上分配空间，而是在函数对应的 <b>栈内分配空间</b> 
</p>
<ul class="org-ul">
<li>优点：函数调用结束， <b>自动释放</b></li>
<li>缺点：并 <b>不是所有系统都支持</b></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org3b2ee27" class="outline-2">
<h2 id="org3b2ee27">环境变量表</h2>
<div class="outline-text-2" id="text-org3b2ee27">
<p>
每个程序都接收到一张环境表。与参数表类似， <span class="underline">环境表</span> 也是一个 <b>字符指针数组</b> ，其中每个指针包含一个字符串的地址。全局变量 <b>environ</b> 则 <span class="underline">包含了该指针数组的地址</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #98f5ff;">char</span> **<span style="color: #4eee94;">environ</span>;
</pre>
</div>
<p>
如果该环境包含五个字符串，那么它看起来可能如图7-2中所示：
</p>

<div class="figure">
<p><img src="pic/env.png" alt="env.png" width="90%" />
</p>
</div>

<ul class="org-ul">
<li><span class="underline">环境指针</span> ： <b>environ</b></li>
<li><span class="underline">环境表</span> ：environ指向的 <b>指针数组</b> ，以 <span class="underline">NULL</span> 结尾</li>
<li><span class="underline">环境变量</span> ：各指针指向的 <b>字符串</b> ，以 <span class="underline">'\0'</span> 结尾</li>
</ul>

<p>
按照惯例环境由:
</p>
<pre class="example">
name=value
</pre>
<p>
这样的字符串组成，这与图7-2中所示相同。 <b>大多数环境变量名完全由大写字母组成</b> ，但这也只是一个惯例
</p>
</div>

<div id="outline-container-org6a3775f" class="outline-3">
<h3 id="org6a3775f">常见环境变量</h3>
<div class="outline-text-3" id="text-org6a3775f">
<p>
POSIX.1和XPG3定义了某些环境变量。表7-1列出了由这两个标准定义并受到SVR4和4.3+BSD支持的环境变量：
</p>
<!-- This HTML table template is generated by emacs 26.3 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;POSIX.1&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;XPG3&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.3+BSD&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;HOME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;初始目录&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LANG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;本地语言&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LC_ALL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;本地编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_COLLATE&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;排序编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_CTYPE&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;输入编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_MONETARY
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;货币编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_NUMERIC&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;数字编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LC_TIME&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;日期编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LOGNAME&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;登录名&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      可执行文件搜<br />
      索路径&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;TERM&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;终端类型&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;TZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;本地时区&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-org7346162" class="outline-3">
<h3 id="org7346162">环境变量函数</h3>
<div class="outline-text-3" id="text-org7346162">
<p>
除了取环境变量值，有时也需要设置环境变量，或者是改变现有变量的值，或者是增加新的环境变量。但并不是所有系统都支持这种能力。表7-2列出了由不同的标准及实现支持的各种函数：
</p>
<!-- This HTML table template is generated by emacs 26.3 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;变量&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="3" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;ANSI&nbsp;C&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;POSIX.1&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;XPG3&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;4.3+BSD&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;getenv&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;putenv&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可能&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;setenv&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;unsetenv&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;clearenv&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可能&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>

<div id="outline-container-org6e915d6" class="outline-4">
<h4 id="org6e915d6">getenv</h4>
<div class="outline-text-4" id="text-org6e915d6">
<p>
<span class="underline">getenv</span> ： <b>读取</b> 环境变量
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26681;&#25454;&#32473;&#23450;&#30340;&#29615;&#22659;&#21464;&#37327;&#21517;&#23383;&#36820;&#22238;&#20854;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * name: &#29615;&#22659;&#21464;&#37327;&#21517;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25351;&#21521; &#19982;name&#20851;&#32852;&#30340;value&#30340;&#25351;&#38024;&#65292;&#33509;&#26410;&#25214;&#21040;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">getenv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>);
</pre>
</div>

<pre class="example">
      注意：应当使用 getenv 从环境中取一个环境变量的值，而不是直接存取environ指针！
</pre>
</div>
</div>

<div id="outline-container-orgfd9ba64" class="outline-4">
<h4 id="orgfd9ba64">putsenv, setenv, unsetenv</h4>
<div class="outline-text-4" id="text-orgfd9ba64">
<p>
<span class="underline">putenv</span> ：使用形式为 <span class="underline">name=value</span> 的 <b>字符串将其放到环境表</b> 中。如果name <span class="underline">已经存在</span> ，则 <b>先删除其原来的定义</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#25226;&#21464;&#37327;&#25918;&#36827;&#29615;&#22659;&#34920;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * str: &#24418;&#24335;&#20026;name=value&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">putenv</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>);
</pre>
</div>
<p>
<span class="underline">setenv</span> ：设置名字为 <span class="underline">name的环境变量</span> 其 <span class="underline">值为value</span> 。如果在环境中name已经存在，那么：
</p>
<ul class="org-ul">
<li>若 <span class="underline">rewrite非0</span> ，则首先 <b>删除其现存的定义</b></li>
<li><p>
若 <span class="underline">rewrite为0</span> ，则 <b>不删除其现存定义</b> (name不设置为新的value，而且也不出错)
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#21517;&#23383;&#20026;name&#30340;&#29615;&#22659;&#21464;&#37327;&#20854;&#20540;&#20026;value</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * name: &#29615;&#22659;&#21464;&#37327;&#21517;&#23383;</span>
<span style="color: #ffebcd;"> * value: &#35201;&#35774;&#32622;&#30340;&#29615;&#22659;&#21464;&#37327;&#20540;</span>
<span style="color: #ffebcd;"> * rewrite: &#26159;&#21542;&#35206;&#30422;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setenv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">value</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">rewrite</span>);
</pre>
</div>

<p>
<span class="underline">unsetenv</span> ： <b>删除环境变量名为name的定义</b> 
</p>
<ul class="org-ul">
<li>即使环境表中不存在对应的变量也不会出错</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35299;&#38500;&#29615;&#22659;&#21464;&#37327;&#23450;&#20041;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * name: &#29615;&#22659;&#21464;&#37327;&#21517;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">unsetenv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>);
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgcc90c66" class="outline-4">
<h4 id="orgcc90c66">实现细节</h4>
<div class="outline-text-4" id="text-orgcc90c66">
<p>
<span class="underline">环境表</span> (指向实际name=value字符串的指针数组)和环境字符串典型地存放在 <span class="underline">进程存储空间的顶部</span> (栈之上)
</p>

<ol class="org-ol">
<li>删除： <span class="underline">找到对应的字符串指针</span> ，然后将 <span class="underline">所有环境表中后面元素</span> 指向原来的 <span class="underline">下移一个位置</span></li>
<li>替换：
<ul class="org-ul">
<li><span class="underline">新value的长度</span> <b>少于或等于</b> <span class="underline">现存value的长度</span> ：只要 <b>在原字符串所用空间中写入新字符串</b></li>
<li>如果 <span class="underline">新value的长度</span> <b>大于</b> <span class="underline">原长度</span> ：必须调用 <span class="underline">malloc</span> 为 <b>新字符串分配空间</b> ，然后将新字符写入该空间中，最后使 <b>环境表中针对name的指针指向新分配区</b></li>
</ul></li>
<li>增加：首先调用 <span class="underline">malloc</span> 为 <span class="underline">name=value</span> <b>分配空间</b> ，然后将 <b>该字符串写入此空间</b> 中，然后：
<ul class="org-ul">
<li>第一次增加一个新name：必须调用 <span class="underline">malloc</span> 为 <b>新的指针表分配空间</b> 。将 <b>原来的环境表复制到新分配区</b> ，并将指向新 <span class="underline">name=value</span> 的 <b>指针存在该指针表的表尾</b> ，接着将一个 <b>NULL指针存在其后</b> ，最后使 <span class="underline">environ</span> <b>指向新指针表</b></li>
<li>非第一次增加一个新name：则可知以前已调用malloc在堆中为环境表分配了空间，所以只要调用 <span class="underline">realloc</span> 分配 <b>比原空间多存放一个指针的空间</b> 。然后将该指向新 <span class="underline">name=value</span> <b>字符串的指针存放在该表表尾</b> ，最后在 <b>后面跟着一个NULL指针</b></li>
</ul></li>
</ol>

<pre class="example">
      这意味着：如果第一次在环境表中增加一个frame，环境表会被移至堆中

      但是此表中的大多数指针仍指向栈顶之上的各name=value字符串
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org64818bd" class="outline-2">
<h2 id="org64818bd">栈间跳转</h2>
<div class="outline-text-2" id="text-org64818bd">
</div>
<div id="outline-container-org0a09281" class="outline-3">
<h3 id="org0a09281">cmd_add</h3>
<div class="outline-text-3" id="text-org0a09281">
<p>
先看以下程序的骨干部分：
</p>
<ol class="org-ol">
<li>主循环是从标准输入读一行，然后调用 <span class="underline">do_line</span> 处理</li>
<li>do_line该函数调用 <span class="underline">get_token</span> 从该输入行中取下一个记号
<ul class="org-ul">
<li>假设每一行中的第一个记号对应于某条命令，比如记号是'5'对应加法，就调用cmd_add函数</li>
<li>cmd_add函数继续调用get_token获得其余参数，最后执行的加法逻辑</li>
</ul></li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">TOK_ADD</span>    5

<span style="color: #98f5ff;">void</span>    <span style="color: #daa520; font-weight: bold;">do_line</span>(<span style="color: #98f5ff;">char</span> *);
<span style="color: #98f5ff;">void</span>    <span style="color: #daa520; font-weight: bold;">cmd_add</span>(<span style="color: #98f5ff;">void</span>);
<span style="color: #98f5ff;">int</span>     <span style="color: #daa520; font-weight: bold;">get_token</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>)
        do_line(line);
    exit(0);
}

<span style="color: #98f5ff;">char</span>    *<span style="color: #4eee94;">tok_ptr</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">global pointer for get_token() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">do_line</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>)     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">process one line of input </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">cmd</span>;

    tok_ptr = ptr;
    <span style="color: #00bfff; font-weight: bold;">while</span> ((cmd = get_token()) &gt; 0) {
        <span style="color: #00bfff; font-weight: bold;">switch</span> (cmd) {  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">one case for each command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">case</span> TOK_ADD:
            cmd_add();
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        }
    }
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cmd_add</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">token</span>;

    token = get_token();
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">rest of processing for this command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">get_token</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">fetch next token from line pointed to by tok_ptr </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
图7-4显示了调用了cmd_add之后栈的大致使用情况：
</p>

<div class="figure">
<p><img src="pic/stack.png" alt="stack.png" width="90%" />
</p>
</div>

<p>
<b>自动变量的存储单元在每个函数的栈桢中</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">数组line</span> 在 <span class="underline">main的栈帧</span> 中</li>
<li><span class="underline">整型cmd</span> 在 <span class="underline">do_line的栈帧</span> 中</li>
<li><span class="underline">整型token</span> 在 <span class="underline">cmd_add的栈帧</span> 中</li>
</ul>

<pre class="example">
     一个经常会遇到的问题是：如何处理非致命性的错误？

     例如cmd_add函数发现一个错误，比如说一个无效的数
     那么它可能先打印一个出错消息，然后希望忽略输入行的余下部分，返回main函数并读下一输入行

     如果不得不以检查返回值的方法逐层返回，那就会变得非常麻烦
</pre>

<p>
解决这种问题的方法就是使用 <span class="underline">非局部跳转</span> 。这不是在一个函数内的普通的C语言goto语句，而是在 <b>栈上跳过 <span class="underline">若干调用帧</span> 返回到当前函数调用路径上的一个函数内</b> 
</p>
</div>
</div>

<div id="outline-container-org68c82a6" class="outline-3">
<h3 id="org68c82a6">setjmp, longjmp</h3>
<div class="outline-text-3" id="text-org68c82a6">
<ul class="org-ul">
<li><span class="underline">setjmp</span> ： <b>栈定位信息</b> 保存到 <b>jmp_buf变量</b> <span class="underline">env</span> 中
<ul class="org-ul">
<li>jmp_buf：一种 <span class="underline">特殊数据类型</span> ，某种形式的 <span class="underline">数组</span> ，其中存放在调用 <span class="underline">longjmp</span> 时能用来 <b>恢复栈状态的所有信息</b> ，其中包括 <span class="underline">当初的寄存器上的值</span></li>
</ul></li>
<li><p>
<span class="underline">longjmp</span> ： <b>跳转到保存好的变量 <span class="underline">env</span> 上</b> ，然后返回 <span class="underline">val</span> 
</p>
<ul class="org-ul">
<li><span class="underline">多个longjmp</span> 跳到 <span class="underline">同一个setjmp处</span> 时，就可以 <b>通过返回的不同val值进行区别</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#19968;&#20010;&#20197; env &#20026;&#26631;&#35782;&#30340;&#26632;&#23450;&#20301;&#28857;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * env: &#36339;&#36716;&#28857;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#30452;&#25509;&#35843;&#29992;&#21017;&#20026; 0&#65292;&#33509;&#20174;longjmp&#36820;&#22238;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setjmp</span>(<span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">env</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20110;&#36339;&#36716;&#21040;env&#25152;&#23450;&#20301;&#30340;setjmp&#20989;&#25968;&#22788;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * env: &#36339;&#36716;&#28857;</span>
<span style="color: #ffebcd;"> * val: &#36339;&#36716;&#22238;&#21435;&#21518;setjmp&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">longjmp</span>(<span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">env</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">val</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org300fc35" class="outline-4">
<h4 id="org300fc35">cmd_add2</h4>
<div class="outline-text-4" id="text-org300fc35">
<p>
main函数中 <b>设定跳转点</b> <span class="underline">jmpbuffer</span> ，其 <b>当前返回值是0</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">jmpbuffer</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">if</span> (setjmp(jmpbuffer) != 0)
        printf(<span style="color: #deb887;">"error"</span>);
    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>)
        do_line(line);
    exit(0);
}
</pre>
</div>
<p>
在cmd_add2函数中如果出错，则使用 <span class="underline">longjmp</span>  <b>跳转</b> 到 <span class="underline">jmpbuffer</span> 保存的 <b>栈定位点</b> 上，这时候 <b>setjmp返回的值是1</b> ，也就是 <b>cmd_add2中longjmp的第二个参数</b> 。同样可以在 <span class="underline">get_token</span> 函数内调用 <span class="underline">longjmp(jmpbuffer,2)</span> ，这使得 <b>main函数可以对 <span class="underline">不同的longjmp调用点</span> 进行区别对待</b>  
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cmd_add2</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">token</span>;

    token = get_token();
    <span style="color: #00bfff; font-weight: bold;">if</span> (token &lt; 0)      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">an error has occurred </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        longjmp(jmpbuffer, 1);
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">rest of processing for this command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org97f9345" class="outline-3">
<h3 id="org97f9345">volatile变量</h3>
<div class="outline-text-3" id="text-org97f9345">
<p>
<b>全局和静态变量的值在执行longjmp后保持不变</b> 
</p>
<pre class="example">
     当发生跳转后，在main函数中的自动变量和寄存器变量的状态如何？

     当longjmp返回到main函数时，这些变量的值是否能恢复到以前调用setjmp时的值(即滚回原先值)
     或者这些变量的值保持为调用do_line时的值(do_line调用cmd_add，cmd_add又调用longjmp)?
</pre>

<p>
<b>存放在寄存器内的变量会回滚</b> 到调用setjmp的时候，而 <b>存放在内存中的变量并不会回滚</b> 
</p>

<p>
如果有一个自动变量，而又 <b>不想使其值滚回</b> ，则必须定义其为 <b>volatile</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f1</span>(<span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">int</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f2</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">jmpbuffer</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">count</span>;
    <span style="color: #00bfff; font-weight: bold;">register</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">val</span>;
    <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">sum</span>;

    count = 2;
    val = 3;
    sum = 4;

    <span style="color: #00bfff; font-weight: bold;">if</span>(setjmp(jmpbuffer) != 0){
        printf(<span style="color: #deb887;">"atfer longjmp: count = %d, val = %d, sum = %d\n"</span>, count, val, sum);
        exit(0);
    }

    count = 97;
    val = 98;
    sum = 99;
    f1(count, val, sum);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f1</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">j</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">k</span>)
{
    printf(<span style="color: #deb887;">"in f1(): count = %d, val = %d, sum = %d\n"</span>, i, j, k);
    f2();
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f2</span>(<span style="color: #98f5ff;">void</span>) 
{
    longjmp(jmpbuffer, 1);

}
</pre>
</div>

<p>
从下面测试代码可以看出：
</p>

<ul class="org-ul">
<li><b>不开启编译优化</b> ，哪怕寄存器变量都会被保存在内存中，跳转回来后这些变量 <b>都不回滚</b></li>
<li><p>
而开启优化后 <b>只有volatile变量才保存在内存中</b> ， <span class="underline">其他变量</span> 都可能被 <span class="underline">保存到寄存器</span> 中，这些变量往往都会 <b>回滚到原来的值</b> 
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#36866;&#29992;&#32534;&#35793;&#22120;&#20248;&#21270;&#30340;&#26102;&#20505;</span>
$ cc -o volatileExample1 volatileExample.c
$ ./volatileExample1 

<span style="color: #00bfff; font-weight: bold;">in</span> f1(): count = 97, val = 98, sum = 99
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#20248;&#21270;&#30340;&#21464;&#37327;&#20445;&#23384;&#22312;&#20869;&#23384;&#20013;&#65292;&#36825;&#20123;&#21464;&#37327;&#19981;&#20250;&#22238;&#28378;&#65292;&#36824;&#26159;&#20462;&#25913;&#21518;&#30340;&#20540;</span>
atfer longjmp: count = 97, val = 98, sum = 99

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#32534;&#35793;&#22120;&#20248;&#21270;&#30340;&#26102;&#20505;</span>
$ cc -O -o volatileExample2 volatileExample.c
$ ./volatileExample2

<span style="color: #00bfff; font-weight: bold;">in</span> f1(): count = 97, val = 98, sum = 99
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#32534;&#35793;&#20248;&#21270;&#21518;&#21464;&#37327;&#20250;&#23613;&#37327;&#20445;&#23384;&#21040;&#23492;&#23384;&#22120;&#65292;&#33258;&#21160;&#12289;&#23492;&#23384;&#22120;&#21464;&#37327;&#23558;&#22238;&#28378;&#21040;&#21407;&#26469;&#65292;&#20294;&#26159;volatile&#21464;&#37327;&#36824;&#26159;&#20351;&#29992;&#20462;&#25913;&#21518;&#30340;&#65292;&#22240;&#20026;volaile&#21464;&#37327;&#27704;&#36828;&#20445;&#23384;&#22312;&#20869;&#23384;&#20013;</span>
atfer longjmp: count = 2, val = 3, sum = 99
</pre>
</div></li>
</ul>

<pre class="example">
     如果要编写可移植的非局部跳转，则必须使用volatile属性！
</pre>
</div>
</div>

<div id="outline-container-org7cfaa6b" class="outline-3">
<h3 id="org7cfaa6b">自动变量陷阱</h3>
<div class="outline-text-3" id="text-org7cfaa6b">
<p>
open_data的函数：打开了一个标准I/O流，然后为该流设置缓存
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DATAFILE</span>    <span style="color: #deb887;">"datafile"</span>

<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">open_data</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fp</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">databuf</span>[BUFSIZ];  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">setvbuf makes this the stdio buffer </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fopen(DATAFILE, <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (setvbuf(fp, databuf, _IOLBF, BUFSIZ) != 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>(fp);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">error </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>

<pre class="example">
     当open_data返回时，它在栈上所使用的空间将由下一个被调用函数的栈帧使用

     但是标准I/O库函数仍将使用原先为databuf在栈上分配的存储空间作为该流的缓存

     这就产生了冲突和混乱
</pre>

<p>
因此 <span class="underline">自动变量的函数已经返回</span> 后， <b>必须不再引用</b> 这些自动变量。如果还需这些变量，那就：
</p>
<ol class="org-ol">
<li><span class="underline">extern</span> : <b>全局</b> 变量</li>
<li><span class="underline">static</span> : <b>静态</b> 变量</li>
<li><span class="underline">malloc</span> / <span class="underline">calloc</span> : 使用 <b>堆上的动态分配内存</b></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgd1a12eb" class="outline-2">
<h2 id="orgd1a12eb">资源限制</h2>
<div class="outline-text-2" id="text-orgd1a12eb">
<ul class="org-ul">
<li><span class="underline">getrlimit</span> ： <b>查询</b> 进程的资源限制</li>
<li><span class="underline">setrlimit</span> ： <b>更改</b> 进程的资源限制</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/resource.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26597;&#35810;&#36164;&#28304;&#38480;&#21046;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * resource: &#20195;&#34920;&#36164;&#28304;&#30340;&#24120;&#37327;</span>
<span style="color: #ffebcd;"> * rlptr: &#36164;&#28304;&#38480;&#21046;&#32467;&#26500;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#22833;&#36133;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getrlimit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">resource</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span> *<span style="color: #4eee94;">rlptr</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20462;&#25913;&#36164;&#28304;&#38480;&#21046;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * resource: &#20195;&#34920;&#36164;&#28304;&#30340;&#24120;&#37327;</span>
<span style="color: #ffebcd;"> * rlptr: &#36164;&#28304;&#38480;&#21046;&#32467;&#26500;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#22833;&#36133;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setrlimit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">resource</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span> *<span style="color: #4eee94;">rlptr</span>);
</pre>
</div>
</div>

<div id="outline-container-org887645d" class="outline-3">
<h3 id="org887645d">resource常量</h3>
<div class="outline-text-3" id="text-org887645d">
<p>
resource参数取下列值之一：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 资源限制常量</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">资源常量名</td>
<td class="org-left">支持系统</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">RLIMIT_CORE</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">core文件的最大字节数，若其值为0则阻止创建core文件</td>
</tr>

<tr>
<td class="org-left">RLIMIT_CPU</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">CPU时间的最大量值(秒)，当超过此软限制时，向该进程发送SIGXCPU信号</td>
</tr>

<tr>
<td class="org-left">RLIMIT_DATA</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">数据段的最大字节长度。初始化数据、非初始化数据以及堆的总和</td>
</tr>

<tr>
<td class="org-left">RLIMIT_FSIZE</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送SIGXFSZ信号</td>
</tr>

<tr>
<td class="org-left">RLIMIT_MEMLOCK</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">锁定在存储器地址空间(尚未实现)</td>
</tr>

<tr>
<td class="org-left">RLIMIT_NOFILE</td>
<td class="org-left">SVR4</td>
<td class="org-left">每个进程能打开的最多文件数</td>
</tr>

<tr>
<td class="org-left">RLIMIT_NPROC</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">每个实际用户ID所拥有的最大子进程数</td>
</tr>

<tr>
<td class="org-left">RLIMIT_OFILE</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">与RLIMIT_NOFILE相同</td>
</tr>

<tr>
<td class="org-left">RLIMIT_RSS</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">最大驻内存集字节长度(RSS)</td>
</tr>

<tr>
<td class="org-left">RLIMIT_STACK</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">栈的最大字节长度</td>
</tr>

<tr>
<td class="org-left">RLIMIT_VMEM</td>
<td class="org-left">SVR4</td>
<td class="org-left">可映照地址空间的最大字节长度</td>
</tr>
</tbody>
</table>

<pre class="example">
     注意：并非所有资源限制都受到每个系统的支持
</pre>
</div>
</div>

<div id="outline-container-orgc034f6e" class="outline-3">
<h3 id="orgc034f6e">rlimit结构</h3>
<div class="outline-text-3" id="text-orgc034f6e">
<p>
在更改资源限制时，须遵循下列三条规则：
</p>
<ol class="org-ol">
<li>任何一个进程都可将一个 <span class="underline">软限制</span> 更改为 <b>小于或等于</b> 其 <span class="underline">硬限制</span></li>
<li>任何一个进程都可 <b>降低</b> 其 <span class="underline">硬限制值</span> ，但它必须 <b>大于或等于</b> 其 <span class="underline">软限制值</span> ，这种降低对普通用户而言是 <b>不可逆反</b> 的</li>
<li><p>
只有 <b>超级用户</b> 可以 <b>提高</b> <span class="underline">硬限制</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span> {
    <span style="color: #98f5ff;">rlim_t</span> <span style="color: #4eee94;">rlim_cur</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">soft limit: current limit </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">rlim_t</span> <span style="color: #4eee94;">rlim_max</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">hard limit: maximum value for rlim_cur </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div></li>
</ol>
<p>
一个 <span class="underline">无限量的限制</span> 由常数 <b>RLIM_INFINITY</b> 指定    
</p>
</div>
</div>
<div id="outline-container-orgbfd4f71" class="outline-3">
<h3 id="orgbfd4f71">实例</h3>
<div class="outline-text-3" id="text-orgbfd4f71">
<p>
打印linux系统支持的某些进程资源的当前软限制和硬限制：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/resource.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">FMT</span> <span style="color: #deb887;">"%10ld  "</span>
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">doit</span>(<span style="color: #4eee94;">name</span>)  pr_limits(#name, name)

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_limits</span>(<span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">int</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_AS
    doit(RLIMIT_AS);
<span style="color: #ffd700;">#endif</span>
    doit(RLIMIT_CORE);
    doit(RLIMIT_CPU);
    doit(RLIMIT_DATA);
    doit(RLIMIT_FSIZE);
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_LOCKS
    doit(RLIMIT_LOCKS);
<span style="color: #ffd700;">#endif</span>
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_MEMLOCK
    doit(RLIMIT_MEMLOCK);
<span style="color: #ffd700;">#endif</span>
    doit(RLIMIT_NOFILE);
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_NPROC
    doit(RLIMIT_NPROC);
<span style="color: #ffd700;">#endif</span>
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_RSS
    doit(RLIMIT_RSS);
<span style="color: #ffd700;">#endif</span>
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_SBSIZE
    doit(RLIMIT_SBSIZE);
<span style="color: #ffd700;">#endif</span>
    doit(RLIMIT_STACK);
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_VMEM
    doit(RLIMIT_VMEM);
<span style="color: #ffd700;">#endif</span>
    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_limits</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">resource</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span>   <span style="color: #4eee94;">limit</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (getrlimit(resource, &amp;limit) &lt; 0)
        err_sys(<span style="color: #deb887;">"getrlimit error for %s"</span>, name);
    printf(<span style="color: #deb887;">"%-14s  "</span>, name);
    <span style="color: #00bfff; font-weight: bold;">if</span> (limit.rlim_cur == RLIM_INFINITY)
        printf(<span style="color: #deb887;">"(infinite)  "</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span>
        printf(FMT, limit.rlim_cur);
    <span style="color: #00bfff; font-weight: bold;">if</span> (limit.rlim_max == RLIM_INFINITY)
        printf(<span style="color: #deb887;">"(infinite)"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span>
        printf(FMT, limit.rlim_max);
    putchar((<span style="color: #98f5ff;">int</span>)<span style="color: #deb887;">'\n'</span>);
}
</pre>
</div>
<p>
运行结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/rlimitExample

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#36164;&#28304;&#21517;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#36719;&#38480;&#21046;&#12288;&#12288;&#12288;&#12288;&#30828;&#38480;&#21046;</span>
<span style="color: #daa520; font-weight: bold;">RLIMIT_AS</span>       (infinite)  (infinite)
RLIMIT_CORE              0  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_CPU</span>      (infinite)  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_DATA</span>     (infinite)  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_FSIZE</span>    (infinite)  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_LOCKS</span>    (infinite)  (infinite)
RLIMIT_MEMLOCK       65536       65536  
RLIMIT_NOFILE         1024        4096  
RLIMIT_NPROC         15591       15591  
<span style="color: #daa520; font-weight: bold;">RLIMIT_RSS</span>      (infinite)  (infinite)
RLIMIT_STACK       8388608  (infinite)
</pre>
</div>

<pre class="example">
     资源限制影响到调用进程并由其子进程继承

     这就意味着为了影响一个用户的所有后续进程，需要将进程资源放在 shell 中进行 
</pre>

<p>
事实上sh，bash也都具有 <span class="underline">ulimit(1)</span> 命令来查看和修改进程资源限制：　
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ulimit -a <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#26597;&#30475;&#25152;&#26377;bash&#19979;&#30340;&#36827;&#31243;&#36164;&#28304;&#38480;&#21046;</span>
core file size          (blocks, -c) 0 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_CORE</span>
data seg size           (kbytes, -d) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_DATA</span>
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_FSIZE</span>
pending signals                 (-i) 15591 
max locked memory       (kbytes, -l) 64 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_MEMLOCK</span>
max memory size         (kbytes, -m) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_RSS</span>
open files                      (-n) 1024 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_NOFILE</span>
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_STACK</span>
cpu time               (seconds, -t) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_CPU</span>
max user processes              (-u) 15591 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_NPROC</span>
virtual memory          (kbytes, -v) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_AS</span>
file locks                      (-x) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_LOCKS</span>
</pre>
</div>

<p>
<a href="process.html">Next：进程控制</a>
</p>

<p>
<a href="system_file.html">Previous：系统文件</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
