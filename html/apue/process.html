<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程控制</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="env.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程控制</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3ad9cfa">进程标识</a></li>
<li><a href="#org62cb846">进程生命周期</a>
<ul>
<li><a href="#org76e3dad">创建进程</a>
<ul>
<li><a href="#orgca78b3d">fork</a>
<ul>
<li><a href="#org5b8b82f">子进程的进程环境</a></li>
<li><a href="#org6f9a08b">写时复制</a></li>
<li><a href="#org9f9b5a4">fork实例</a></li>
<li><a href="#org1e38701">父、子进程的资源共享</a></li>
<li><a href="#orgeeddc0c">父、子进程的区别</a></li>
<li><a href="#org4d30788">fork的常见用法</a></li>
</ul>
</li>
<li><a href="#org9593ed4">vfork</a>
<ul>
<li><a href="#org163e229">vfork实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfdb7e13">终止进程</a>
<ul>
<li><a href="#org418be6e">僵尸进程</a></li>
<li><a href="#org01f4049">wait</a>
<ul>
<li><a href="#orgdd04338">wait实例</a></li>
</ul>
</li>
<li><a href="#org4383302">waitpid</a>
<ul>
<li><a href="#org3cf7361">waitpid实例</a></li>
</ul>
</li>
<li><a href="#org3a29e34">wait3和wait4</a></li>
</ul>
</li>
<li><a href="#org836cb2a">竞争条件</a>
<ul>
<li><a href="#org07decf2">竞争条件实例</a></li>
</ul>
</li>
<li><a href="#org099002c">执行程序</a>
<ul>
<li><a href="#org20069fc">exec家族函数</a>
<ul>
<li><a href="#org095aa5f">exec进程特征</a></li>
<li><a href="#org2c0987a">exec实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8454455">更改用户ID和组ID</a>
<ul>
<li><a href="#org8f72822">setuid, setgid</a>
<ul>
<li><a href="#org06b5356">改变ID规则</a>
<ul>
<li><a href="#org6a6385b">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge87ed22">setreuid, setregid</a></li>
<li><a href="#orged7547f">seteuid和setegid函数</a></li>
<li><a href="#org1b0d04c">总结</a></li>
<li><a href="#org62c0799">组ID</a></li>
</ul>
</li>
<li><a href="#org53fb922">解释器</a>
<ul>
<li><a href="#org8361ad3">exec调用解释器文件</a></li>
<li><a href="#org03993c4">awk实例</a></li>
<li><a href="#org7d85c32">解释器文件的优劣</a></li>
</ul>
</li>
<li><a href="#orga17e3ed">system函数</a>
<ul>
<li><a href="#org92806c7">system简单实现</a>
<ul>
<li><a href="#org1b6295e">mysystem实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org71549bc">进程会计</a>
<ul>
<li><a href="#orge5526cf">acct结构</a>
<ul>
<li><a href="#orgf5e8230">会记记录的缺陷</a></li>
</ul>
</li>
<li><a href="#orgb274177">用户标识</a></li>
<li><a href="#org7985474">进程时间</a>
<ul>
<li><a href="#org20449b4">打印进程时间实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  本章介绍Unix的进程控制：

  创建新进程、执行程序和进程终止
  进程的实际、有效和保存的用户和组ID
  解释器文件和system函数
  进程会计机制
</pre>

<div id="outline-container-org3ad9cfa" class="outline-2">
<h2 id="org3ad9cfa">进程标识</h2>
<div class="outline-text-2" id="text-org3ad9cfa">
<p>
每个进程都有一个 <b>非负整型</b> 的 <b>唯一</b> 进程ID。因为进程ID标识符总是唯一的，常将其用做 <b>其他标识符的一部分</b> 以保证其唯一性：
</p>
<ol class="org-ol">
<li>ID 0进程： <span class="underline">调度</span> 进程，它是 <b>内核</b> 进程，用来执行 <b>进程管理</b> ，也被称为交换进程</li>
<li>ID 1进程：通常是 <span class="underline">init</span> 进程，在boot过程结束时由内核调用 <span class="underline">/sbin/init</span> ：
<ul class="org-ul">
<li>读与系统有关的初始化文件(/etc/rc*文件)</li>
<li>将系统引导到一个状态(例如多用户)</li>
<li>init进程决不会终止，它是一个 <b>普通的用户</b> 进程(不是内核中的系统进程)，但是它以 <b>超级用户特权</b> 运行</li>
</ul></li>
</ol>

<pre class="example">
    对于x86的CPU架构来说，所谓的内核进程实际上指的是保护模式的特权级，这是硬件层面的保护措施：

    调度进程运行在保护模式的特权级0上，init进程运行在保护模式的特权级3上
</pre>

<p>
除了进程ID每个进程还有一些其他标识符，下列函数返回这些标识符：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#36827;&#31243;ID&#12288;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * &#36820;&#22238;: &#35843;&#29992;&#36827;&#31243;&#30340; &#36827;&#31243;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">getpid</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#29238;&#36827;&#31243;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#35843;&#29992;&#36827;&#31243;&#30340; &#29238;&#36827;&#31243;ID </span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">getppid</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340; &#23454;&#38469;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#35843;&#29992;&#36827;&#31243;&#30340; &#23454;&#38469;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">uid_t</span> <span style="color: #daa520; font-weight: bold;">getuid</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340; &#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#35843;&#29992;&#36827;&#31243;&#30340; &#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">uid_t</span> <span style="color: #daa520; font-weight: bold;">geteuid</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#23454;&#38469;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#35843;&#29992;&#36827;&#31243;&#30340; &#23454;&#38469;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">gid_t</span> <span style="color: #daa520; font-weight: bold;">getgid</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#26377;&#25928;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#35843;&#29992;&#36827;&#31243;&#30340;&#26377;&#25928;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">gid_t</span> <span style="color: #daa520; font-weight: bold;">getegid</span>(<span style="color: #98f5ff;">void</span>); 
</pre>
</div>

<pre class="example">
    这些函数都没有出错返回！
</pre>
</div>
</div>

<div id="outline-container-org62cb846" class="outline-2">
<h2 id="org62cb846">进程生命周期</h2>
<div class="outline-text-2" id="text-org62cb846">
</div>
<div id="outline-container-org76e3dad" class="outline-3">
<h3 id="org76e3dad">创建进程</h3>
<div class="outline-text-3" id="text-org76e3dad">
</div>
<div id="outline-container-orgca78b3d" class="outline-4">
<h4 id="orgca78b3d">fork</h4>
<div class="outline-text-4" id="text-orgca78b3d">
<p>
<span class="underline">fork</span> ： <b>创建新进程</b> 的唯一方法 
</p>

<pre class="example">
(除了上面提到的那些特殊进程，它们是内核启动时候以特殊方式创建的)
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#26032;&#36827;&#31243;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#23376;&#36827;&#31243;&#36820;&#22238; 0&#65292;&#29238;&#36827;&#31243;&#36820;&#22238; &#23376;&#36827;&#31243;&#30340;ID&#65292;&#20986;&#38169;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">fork</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
<p>
由 <b>fork创建的新进程</b> 被称为 <span class="underline">子进程</span> 。因为子进程和父进程都会继续执行fork之后的指令，所以该函数虽然被调用一次，但却会返回两次结果。两次返回的区别是 <b>子进程的返回值是0</b> ，而 <b>父进程的返回值则是新子进程的进程ID</b> ：
</p>
<ul class="org-ul">
<li>将子进程ID返回给父进程的理由是： <span class="underline">一个进程的子进程可以多于一个</span> ，没有一个函数可以使一个进程获得其所有子进程的进程ID。如果接下来 <span class="underline">父进程要使用子进程ID</span> ，那么 <b>只能在fork后记录返回的子进程ID</b></li>
<li>fork使子进程得到返回值0的理由是：
<ol class="org-ol">
<li>进程ID为0总是由调度/交换进程使用， <span class="underline">一个子进程的进程ID不可能为0</span> ，所以可以 <b>通过fork的返回结果来判断是不是子进程</b></li>
<li>一个进程 <span class="underline">只会有一个父进程</span> ， <b>子进程可以调用 <span class="underline">getppid</span> 以获得其父进程的进程ID</b> ，所以没有必要去返回父进程的ID</li>
</ol></li>
</ul>
</div>

<div id="outline-container-org5b8b82f" class="outline-5">
<h5 id="org5b8b82f">子进程的进程环境</h5>
<div class="outline-text-5" id="text-org5b8b82f">
<p>
子进程是父进程的复制品：
</p>
<ul class="org-ul">
<li>如果正文段是 <span class="underline">只读的</span> ，则父、子进程 <b>共享正文段</b></li>
<li>获得父进程的 <b>复制品</b> ：
<ul class="org-ul">
<li>数据段</li>
<li>非初始化数据段(bss)</li>
<li>堆</li>
<li>栈</li>
</ul></li>
</ul>

<pre class="example">
       注意：数据段，bss， 堆，栈是子进程所拥有的独立拷贝

       父、子进程并不共享这些存储空间部分！！！
</pre>
</div>
</div>

<div id="outline-container-org6f9a08b" class="outline-5">
<h5 id="org6f9a08b">写时复制</h5>
<div class="outline-text-5" id="text-org6f9a08b">
<pre class="example">
       现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在 fork 之后经常跟随着 exec 执行另外一个程序
       而作为替代使用了在写时复制(Copy-On-Write)的技术
</pre>

<p>
例如：
</p>
<ul class="org-ul">
<li>fork函数刚刚创建子进程的时候，父、子进程的数据 <b>指向同一块物理内存</b> ，但是内核将这些 <b>内存的访问变为只读</b> 的了</li>
<li>当父、子进程中的任何一个想要 <span class="underline">修改数据</span> 的时候
<ol class="org-ol">
<li>内核会为 <span class="underline">修改区域的那块内存</span> 制作一个 <b>副本</b></li>
<li>并将自己的 <span class="underline">虚拟地址</span> 映射到 <span class="underline">物理地址</span> 的指向修改为 <b>副本的地址</b></li>
</ol></li>
<li><p>
从此父子进程互不干扰，效率也提高了许多。新分配的副本大小通常是 <b>虚拟存储系统中的一个页</b> 
</p>

<p width="90%">
<img src="pic/child-process.png" alt="child-process.png" width="90%" />]]
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org9f9b5a4" class="outline-5">
<h5 id="org9f9b5a4">fork实例</h5>
<div class="outline-text-5" id="text-org9f9b5a4">
<p>
fork一个进程，修改相关变量并打印
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">glob</span> = 6;
<span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[] = <span style="color: #deb887;">"a write to stdin\n"</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">var</span>;
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;

    var = 88;
    <span style="color: #00bfff; font-weight: bold;">if</span>(write(STDOUT_FILENO, buf, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(buf) - 1) != (<span style="color: #00bfff; font-weight: bold;">sizeof</span>(buf) - 1))
        err_sys(<span style="color: #deb887;">"write error"</span>);
    printf(<span style="color: #deb887;">"before fork\n"</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">we don't flush stdout</span>

    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #deb887;">"fork error"</span>);

    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(0 == pid) { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child process</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">modify variable</span>
        glob++; 
        var++; 
    } <span style="color: #00bfff; font-weight: bold;">else</span> { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">parent process</span>
        sleep(2);
    }

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child &amp; parent share code</span>
    printf(<span style="color: #deb887;">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var);
    exit(0);
}
</pre>
</div>
<p>
一般来说，在fork之后是 <b>父进程先执行还是子进程先执行是不确定的</b> ，这取决于内核所使用的 <span class="underline">调度</span> 算法
</p>

<pre class="example">
       如果要求父、子进程之间相互同步，则要求某种形式的进程间通信

       在这个程序中父进程使自己睡眠2秒钟，以此使子进程先执行，但2秒钟并不一定保证已经足够
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/forkExample

a write to stdin
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#32456;&#31471;&#26159;&#34892;&#32531;&#23384;&#30340;&#65292;&#25152;&#20197;printf("before fork")&#30452;&#25509;&#36755;&#20986;</span>
before fork
pid = 8898, glob = 7, var = 89 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;&#25171;&#21360;&#25913;&#21464;&#21518;&#30340;&#21464;&#37327;&#20540;</span>
pid = 8897, glob = 6, var = 88 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#36827;&#31243;&#25171;&#21360;&#26410;&#25913;&#21464;&#30340;&#21464;&#37327;&#20540;</span>

$ ./src/process/forkExample &gt; temp.out

$ cat temp.out 
a write to stdin
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#25991;&#20214;&#26159;&#20840;&#32531;&#23384;&#30340;&#65292;&#25152;&#20197;fork&#20043;&#21069;&#30340;printf&#25226;"before fork\n"&#25918;&#20837;&#20102;&#32531;&#23384;&#65292;&#20294;&#24182;&#27809;&#26377;&#36755;&#20986;</span>
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">fork&#25226;&#29238;&#36827;&#31243;&#30340;&#26631;&#20934;IO&#32531;&#23384;&#22797;&#21046;&#20102;&#65292;&#22240;&#27492;&#22312;&#26368;&#21518;&#30340;prinf("pid= %d ...)&#20063;&#36755;&#20986;&#20102;before fork\n</span>
before fork 
pid = 8962, glob = 7, var = 89 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;</span>
before fork
pid = 8961, glob = 6, var = 88 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#36827;&#31243;</span>
</pre>
</div>
<p>
fork与I/O函数之间的关系：
</p>
<ul class="org-ul">
<li><span class="underline">文件IO</span> 是 <b>不带缓存</b> 的：所以"a write to stdin"只被write函数写到标准输出一次</li>
<li><span class="underline">标准I/O</span> 库是 <b>带缓存</b> 的：如果标准输出连到终端设备，则它是 <span class="underline">行缓存</span> 的，否则它是 <span class="underline">全缓存</span> 的
<ul class="org-ul">
<li>当以 <span class="underline">交互方式</span> 运行该程序时：因为标准输出缓存由新行符刷新，所以"before fork"只被printf输出一次</li>
<li>当将 <span class="underline">标准输出</span> <b>重新定向</b> 到 <span class="underline">一个文件</span> 时：
<ol class="org-ol">
<li>在fork之前调用了printf("before fork")一次，但 <b>当调用fork时该行数据仍在缓存内</b></li>
<li>在 <span class="underline">父进程数据空间</span> <b>复制</b> 到 <span class="underline">子进程</span> 中时该 <b>缓存数据也被复制到子进程</b> 中，于是那时父、子进程各自有了"before fork"的缓存</li>
<li>所以当每个进程终止时，其 <b>缓存中的所有内容被写到相应文件中</b></li>
</ol></li>
</ul></li>
</ul>

<pre class="example">
       因此在 fork进程前 请务必考虑 flush 所有的缓存！！！
</pre>

<pre class="example">
       所有由父进程打开的描述符都被复制到子进程中，父、子进程每个相同的打开描述符共享一个文件表项

       所以在上面程序中重定向了父进程的标准输出时，子进程的标准输出也被同样重定向
</pre>

<p>
再比如一个进程打开了三个不同文件，它们是 <span class="underline">标准输入</span> 、 <span class="underline">标准输出</span> 和 <span class="underline">标准出错</span> 。在从fork返回时，有了如图8-1中所示的安排
</p>
<p width="90%">
<img src="pic/child-fd.png" alt="child-fd.png" width="90%" />
这种共享文件的方式使 <b>父、子进程对同一文件使用了一个文件位移量</b> 
</p>

<pre class="example">
       如果父、子进程写到同一描述符文件，但又没有任何形式的同步(例如使父进程等待子进程)，那么它们的输出就会相互混合，但是这种情况并不常见
</pre>

<p>
在fork之后处理文件描述符有两种常见的情况：
</p>
<ol class="org-ol">
<li><b>父进程等待子进程完成</b> 。父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件位移量已做了相应更新</li>
<li>父、子进程各自执行不同的程序段。在fork之后 <b>父、子进程 <span class="underline">各自关闭</span> 它们 <span class="underline">不需使用</span> 的文件描述符</b> ，并且不干扰对方使用的文件描述符。这种方法是网络服务进程中经常使用</li>
</ol>
</div>
</div>

<div id="outline-container-org1e38701" class="outline-5">
<h5 id="org1e38701">父、子进程的资源共享</h5>
<div class="outline-text-5" id="text-org1e38701">
<p>
除了打开文件之外，很多父进程的其他性质也由子进程继承:
</p>
<ul class="org-ul">
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>添加组ID</li>
<li><b>进程组ID</b></li>
<li><b>对话期ID</b></li>
<li><b>控制终端</b></li>
<li>设置-用户-ID标志和设置-组-ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li><b>文件方式创建屏蔽字</b></li>
<li><b>信号屏蔽和排列</b></li>
<li>对任一打开 <b>文件描述符的在执行时关闭标志</b></li>
<li><b>环境</b></li>
<li><b>链接的共享存储段</b></li>
<li><b>资源限制</b></li>
</ul>
</div>
</div>
<div id="outline-container-orgeeddc0c" class="outline-5">
<h5 id="orgeeddc0c">父、子进程的区别</h5>
<div class="outline-text-5" id="text-orgeeddc0c">
<ul class="org-ul">
<li>fork的返回值</li>
<li>进程ID</li>
<li>不同的父进程ID</li>
<li>子进程的tms_utime，tms_stime，tms_cutime以及tms_ustime设置为0</li>
<li><b>父进程设置的锁</b> ，子进程不继承</li>
<li><b>子进程的未决告警</b> 被清除</li>
<li><b>子进程的未决信号集</b> 设置为空集</li>
</ul>
</div>
</div>
<div id="outline-container-org4d30788" class="outline-5">
<h5 id="org4d30788">fork的常见用法</h5>
<div class="outline-text-5" id="text-org4d30788">
<ul class="org-ul">
<li><p>
一个父进程希望复制自己，使 <b>父、子进程同时执行不同的代码段</b> 
</p>
<pre class="example">
	 这在网络服务进程中是常见的：

	 父进程等待委托者的服务请求，当这种请求到达时，父进程调用fork
	 使子进程处理此请求，父进程则继续等待下一个服务请求
</pre></li>

<li>一个进程要 <b>执行一个不同的程序</b> 。这对 <span class="underline">shell</span> 是常见的情况。在这种情况下，子进程在从 <span class="underline">fork</span> 返回后立即调用 <span class="underline">exec</span></li>
</ul>

<pre class="example">
某些操作系统将第二种用法中的两个操作(fork之后执行exec)组合成一个，并称其为spawn

UNIX将这两个操作分开，因为在很多场合需要单独使用fork，其后并不跟随exec
</pre>
</div>
</div>
</div>
<div id="outline-container-org9593ed4" class="outline-4">
<h4 id="org9593ed4">vfork</h4>
<div class="outline-text-4" id="text-org9593ed4">
<p>
<span class="underline">vfork</span> ：用于创建一个新进程，而 <b>该新进程的目的是为了exec一个新程序</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#26032;&#36827;&#31243;&#65292;&#32780;&#35813;&#26032;&#36827;&#31243;&#26159;&#30446;&#30340;&#26159;&#20026;&#20102;exec&#19968;&#20010;&#26032;&#31243;&#24207;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#23376;&#36827;&#31243;&#36820;&#22238; 0&#65292;&#29238;&#36827;&#31243;&#36820;&#22238; &#23376;&#36827;&#31243;&#30340;ID&#65292;&#20986;&#38169;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">vfork</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
<p>
vfork与fork的不同：
</p>
<ul class="org-ul">
<li>vfork <b>并不将父进程的地址空间复制到子进程</b> 中，在 <b>子进程exec之前完全使用父进程的地址空间</b></li>
</ul>
<pre class="example">
      这意味着子进程如果修改了某个变量，这个修改对父进程也是可见的！
</pre>
<ul class="org-ul">
<li>vfork保证了 <b>子进程在父进程之前执行</b> ，父进程会 <b>阻塞运行</b> 直到子进程执行了 <span class="underline">exec</span> 或者 <span class="underline">exit</span> 函数</li>
</ul>
<pre class="example">
      如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致“死锁”！！！

      特别是子进程并不继承父进程的记录锁，这时使用父进程打开的文件时可能会被阻塞！！！
</pre>
</div>
<div id="outline-container-org163e229" class="outline-5">
<h5 id="org163e229">vfork实例</h5>
<div class="outline-text-5" id="text-org163e229">
<p>
改写fork实例
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">external variable in initialized data</span>
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">glob</span> = 6;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">automatic variable on the stack</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">var</span>;
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;

    var = 88;
    printf(<span style="color: #deb887;">"before fork\n"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span>((pid = vfork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(pid == 0) { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child </span>
        glob++; <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">change variable </span>
        var++; 
        _exit(0); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child terminated</span>
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">exit(0) </span>
    }

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">parent</span>
    printf(<span style="color: #deb887;">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var);
    exit(0);
}
</pre>
</div>

<p>
子进程对变量glob和var做加1操作，结果 <b>改变了父进程中的变量值</b> 。因为子进程在父进程的地址空间中运行
</p>
<div class="org-src-container">
<pre class="src src-sh">$ gcc -I/home/klose/Documents/programming/c/apue/include -c -o vforkExample.o src/process/vforkExample.c <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#32534;&#35793;c&#25991;&#20214;&#65292;&#27880;&#24847;&#19981;&#33021;&#26377;&#20248;&#21270;&#21442;&#25968;&#65281;</span>
$ gcc -o vforkExample vforkExample.o src/lib/libapue.a <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#38142;&#25509;&#38745;&#24577;&#24211;&#25991;&#20214;&#65292;&#20135;&#29983;&#21487;&#25191;&#34892;&#25991;&#20214;</span>

$ ./vforkExample 
before fork
pid = 19302, glob = 7, var = 89

$ gcc -O2 -I/home/klose/Documents/programming/c/apue/include -c -o vforkExample1.o src/process/vforkExample.c 
$ gcc -O2 -o vforkExample1 vforkExample1.o src/lib/libapue.a

$ ./vforkExample1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#30001;&#20110;&#20248;&#21270;&#65292;var&#34987;&#25918;&#22312;&#23492;&#23384;&#22120;&#20869;&#65292;&#25152;&#20197;&#20002;&#22833;&#20102;&#23376;&#32447;&#31243;&#30340;&#20462;&#25913;</span>
before fork
pid = 19471, glob = 7, var = 88
</pre>
</div>
<pre class="example">
       子进程对变量的改动只对保存在内存中的变量有效，而对寄存器中的变量有可能会回滚

       如果编译使用了优化参数，结果可能并不同，为了保证效果可以使用 volatile
</pre>

<p>
因为写时复制技术的普及，实际上 vfork 已经是个 <span class="underline">过时的</span> 函数， <b>尽量避免使用vfork</b> 
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfdb7e13" class="outline-3">
<h3 id="orgfdb7e13">终止进程</h3>
<div class="outline-text-3" id="text-orgfdb7e13">
<p>
进程有三种正常终止法及两种异常终止法：
</p>
<ul class="org-ul">
<li><span class="underline">正常</span> 终止:
<ol class="org-ol">
<li>在main函数内执行 <span class="underline">return语句</span> ，这等效于 <b>调用exit</b></li>
<li><span class="underline">调用exit</span> 函数，其操作
<ul class="org-ul">
<li>调用各终止处理程序(终止处理程序在调用 <span class="underline">atexit</span> 函数时注册)</li>
<li>关闭所有标准I/O流等</li>
<li>但因为并不处理 <span class="underline">文件描述符</span> 、 <span class="underline">多进程</span> (父、子进程)以及 <span class="underline">作业控制</span> ，所以 <b>这一定义对UNIX系统而言是不完整的</b></li>
</ul></li>
<li>调用 <b>_exit系统调用</b> 函数，此函数由exit调用，它 <b>处理UNIX特定的细节</b> 。_exit是由POSIX.1说明的</li>
</ol></li>
<li><span class="underline">异常</span> 终止:
<ol class="org-ol">
<li>调用 <span class="underline">abort</span> 产生 <span class="underline">SIGABRT</span> 信号，是下一种 <b>异常终止的一种特例</b></li>
<li>当进程 <span class="underline">接收到某个信号</span></li>
</ol></li>
</ul>

<pre class="example">
     进程本身，例如：调用abort函数

     其他进程和内核都能产生传送到某一进程的信号，例如： 进程越出其地址空间访问存储单元，或者除以0

     内核就会为该进程产生相应的信号
</pre>
<p>
不管进程如何终止，最后都会执行 <span class="underline">内核中的同一段代码</span> ：为相应进程关闭所有打开的文件描述符，释放它所使用的存储器等等
</p>

<pre class="example">
     对上述任意一种终止情形，都希望终止进程能够通知其父进程它是如何终止的

     对于exit和_exit，这是依靠传递给它们的“退出状态”参数来实现的
     在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的“终止状态”

     注意：这里使用了“退出状态：和“终止状态”两个不同术语
     事实上最后调用 _exit 函数时内核会将 ”退出状态“转化为”终止状态“
</pre>

<p>
在任意一种情况下， <b>该终止进程的父进程</b> 都能用 <span class="underline">wait</span> 或 <span class="underline">waitpid</span> 函数取得其 <b>终止状态</b> ：
</p>
<ul class="org-ul">
<li>如果 <b>父进程在子进程之前终止</b> ，对于其父进程已经终止的所有进程，它们的 <b>父进程都改变为init进程</b> 。这些进程由init进程领养。其操作过程大致是：
<ul class="org-ul">
<li>在一个进程终止时， <span class="underline">内核</span> 逐个 <b>检查</b> <span class="underline">所有活动进程</span> ，以判断它是否是正要终止的进程的子进程</li>
<li>如果是则该进程的 <b>父进程ID就更改为1</b> (init进程的ID)</li>
<li>这种处理方法保证了每个进程有一个父进程</li>
</ul></li>
<li>如果 <b>子进程在父进程之前终止</b> ， <b>内核为 <span class="underline">每个终止子进程</span> 保存了一定量的信息</b> ，所以当终止进程的父进程调用wait或waitpid时，可以得到有关信息
<ul class="org-ul">
<li>这种信息至少包括：
<ul class="org-ul">
<li>进程ID</li>
<li>该进程的 <span class="underline">终止状态</span></li>
<li>该进程使用的CPU时间总量</li>
</ul></li>
<li>内核可以 <b>释放</b> 终止进程所使用的 <span class="underline">所有存储器</span> ， <b>关闭</b> 其 <span class="underline">所有打开文件</span></li>
</ul></li>
</ul>
</div>

<div id="outline-container-org418be6e" class="outline-4">
<h4 id="org418be6e">僵尸进程</h4>
<div class="outline-text-4" id="text-org418be6e">
<p>
一个 <span class="underline">已经终止</span> ，但是其 <b>父进程尚未对其进行善后处理</b> ( <span class="underline">获取终止子进程的有关信息</span> 、 <span class="underline">释放它仍占用的资源</span> )的进程被称为 <b>僵尸进程</b> 。 <span class="underline">ps(1)</span> 命令会将僵尸进程状态打印为Z
</p>

<pre class="example">
      一个由init进程领养的进程终止时不会变成一个僵尸进程

      因为init 被编写成只要有一个子进程终止，init就会调用一个 wait函数 取得其终止状态

      这样也就防止了在系统中有很多僵尸进程
</pre>
</div>
</div>

<div id="outline-container-org01f4049" class="outline-4">
<h4 id="org01f4049">wait</h4>
<div class="outline-text-4" id="text-org01f4049">
<p>
当一个进程正常或异常终止时， <b>内核就向其父进程发送 <span class="underline">SIGCHLD</span> 信号</b> 。因为子进程终止是个 <span class="underline">异步事件</span> ，所以这种信号也是 <b>内核向父进程发的异步通知</b> 。父进程可以 <span class="underline">忽略</span> 该信号，或者 <span class="underline">提供一个该信号发生时即被调用执行的函数</span> 。对于这种信号的 <b>系统默认动作是忽略</b> 它
</p>

<p>
现在只需要知道的是调用wait的进程可能会:
</p>
<ul class="org-ul">
<li>如果其 <span class="underline">所有子进程都还在运行</span> ： <b>阻塞</b> 调用wait的进程</li>
<li>如果一个 <span class="underline">子进程已终止</span> ，并且 <span class="underline">正等待父进程</span> 存取其 <span class="underline">终止状态</span> ： 立即返回 <b>带子进程的终止状态</b></li>
<li><p>
如果它 <span class="underline">没有任何子进程</span> ： <b>出错</b> 立即返回
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#38459;&#22622;&#31561;&#24453;&#30452;&#21040;&#26377;&#19968;&#20010;&#23376;&#36827;&#31243;&#36864;&#20986;&#65292;&#24182;&#23558;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;&#35760;&#24405;&#21040;status&#22788;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * status: &#25972;&#24418;&#25351;&#38024;&#65292;&#35760;&#24405; &#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;&#65292;&#22914;&#26524;&#19981;&#20851;&#24515;&#32456;&#27490;&#29366;&#24577;&#65292;&#21017;&#21487;&#23558;&#35813;&#21442;&#25968;&#25351;&#23450;&#20026; &#31354;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#36820;&#22238;&#32456;&#27490; &#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">wait</span>(<span style="color: #98f5ff;">int</span> *<span style="color: #4eee94;">status</span>);
</pre>
</div>
<p>
status是一个 <span class="underline">整型指针</span> ：
</p></li>
<li>如果status <span class="underline">不是一个空指针</span> ，则 <span class="underline">终止进程的终止状态</span> 就 <b>存放</b> 在它所 <span class="underline">指向的单元</span> 内</li>
<li>如果 <b>不关心终止状态</b> ，则可将该参数指定为 <span class="underline">空指针</span></li>
</ul>

<pre class="example">
status状态整形字是由实现定义的，其中

某些位表示退出状态(正常返回)
其他位则指示信号编号(异常返回)
有一位指示是否产生了一个core文件等等
</pre>

<p>
POSIX.1规定：终止状态用定义在 <span class="underline">&lt;sys/wait.h&gt;</span> 中有三个互斥的宏可用来取得 <span class="underline">进程终止的原因</span> ，基于它们中哪一个值是真,就可选用其他宏来取得 <span class="underline">终止状态</span> 、 <span class="underline">信号编号</span> 等。这些都在表8-1中给出：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 检查wait和waitpid所返回的终止状态的宏</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">宏</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left"><span class="underline">WIFEXITED</span> (status)</td>
<td class="org-left">如果子进程是 <b>正常</b> 终止则为真，执行 <span class="underline">WEXITSTATUS</span> (status)获得子进程传送给exit或_exit参数的 <span class="underline">低8位</span></td>
</tr>

<tr>
<td class="org-left"><span class="underline">WIFSIGNALED</span> (status)</td>
<td class="org-left">如果子进程是 <b>异常</b> 终止则为真，执行 <span class="underline">WTERMSIG</span> (status)获得子进程 <span class="underline">终止的信号编号</span> 。另外SVR4和4.3+BSD(非POSIX.1)定义宏:  <span class="underline">WCOREDUMP</span> (status)若已 <span class="underline">产生终止进程的core文件</span> 则返回真</td>
</tr>

<tr>
<td class="org-left"><span class="underline">WIFSTOPPED</span> (status)</td>
<td class="org-left">如果是子进程的状态是 <b>暂停</b> 则为真，执行 <span class="underline">WSTOPSIG</span> (status)获得使子进程 <span class="underline">暂停的信号编号</span></td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-orgdd04338" class="outline-5">
<h5 id="orgdd04338">wait实例</h5>
<div class="outline-text-5" id="text-orgdd04338">
<p>
pr_exit使用表8-1中的宏以打印进程的终止状态
</p>

<pre class="example">
       注意：如果定义了WCOREDUMP，则此函数也处理该宏
</pre>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_exit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">status</span>) 
{
    <span style="color: #00bfff; font-weight: bold;">if</span>( WIFEXITED(status) )
        printf(<span style="color: #deb887;">"normal termination, exit status = %d\n"</span>,
               WEXITSTATUS(status));

    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>( WIFSIGNALED(status) )
        printf(<span style="color: #deb887;">"abnormal termination, signal number = %d%s\n"</span>,
               WTERMSIG(status),
<span style="color: #ffd700;">#ifdef</span> WCOREDUMP
               WCOREDUMP(status) ? <span style="color: #deb887;">"(corefile generated)"</span> : <span style="color: #deb887;">""</span>);

<span style="color: #ffd700;">#else</span>
    <span style="color: #deb887;">""</span>);
<span style="color: #ffd700;">#endif</span>

<span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>( WIFSTOPPED(status) ) 
    printf(<span style="color: #deb887;">"child stopped, signal number = %d\n"</span>,
           WSTOPSIG(status));
}
</pre>
</div>
<p>
打印不同终止的状态值
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">status</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(0 == pid)
        exit(7); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;&#27491;&#24120;&#36864;&#20986;</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ( wait(&amp;status) != pid)
        err_sys(<span style="color: #deb887;">"wait error"</span>);
    pr_exit(status);

    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(0 == pid)
        abort(); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;&#35843;&#29992;abort</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ( wait(&amp;status) != pid)
        err_sys(<span style="color: #deb887;">"wait error"</span>);
    pr_exit(status);

    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(0 == pid)
        status /= 0; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;&#20135;&#29983;&#24322;&#24120;&#20449;&#21495;</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ( wait(&amp;status) != pid)
        err_sys(<span style="color: #deb887;">"wait error"</span>);
    pr_exit(status);

    exit(0);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/waitExample

normal termination, exit status = 7
abnormal termination, signal number = 6 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">SIGABRT</span>
abnormal termination, signal number = 8 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">SIGFPE</span>
</pre>
</div>

<pre class="example">
       不幸的是：没有一种可移植的方法将 WTERMSIG 得到的信号编号映射为说明性的名字

       必须查看&lt;signal.h&gt;头文件才能知道 SIGABRT 的值是 6， SIGFPE 的值是 8
</pre>
</div>
</div>
</div>
<div id="outline-container-org4383302" class="outline-4">
<h4 id="org4383302">waitpid</h4>
<div class="outline-text-4" id="text-org4383302">
<p>
waitpid：可以 <b>指定子进程的PID</b> ，并 <b>设置相关阻塞选项</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * wait&#30340;&#25193;&#23637;&#29256;&#26412;&#65292;&#21487;&#20197;&#25351;&#23450;&#23376;&#36827;&#31243;pid&#65292;&#20197;&#21450;&#30456;&#20851;&#38459;&#22622;&#36873;&#39033;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pid: &#23376;&#36827;&#31243;pid</span>
<span style="color: #ffebcd;"> * status: &#23384;&#20648;&#32456;&#27490;&#29366;&#24577;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * options: &#38459;&#22622;&#36873;&#39033;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#36820;&#22238;&#32456;&#27490; &#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">waitpid</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>, <span style="color: #98f5ff;">int</span> *<span style="color: #4eee94;">status</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">options</span>);
</pre>
</div>

<p>
pid参数与其值有关：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> waitpid的pid参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">pid取值</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">pid == -1</td>
<td class="org-left">等待 <span class="underline">任一子进程</span> ，与wait等效</td>
</tr>

<tr>
<td class="org-left">pid &gt; 0</td>
<td class="org-left">等待其进程 <span class="underline">ID与pid相等</span> 的子进程</td>
</tr>

<tr>
<td class="org-left">pid == 0</td>
<td class="org-left">等待其 <span class="underline">组ID</span> 等于 <span class="underline">调用进程的组ID</span> 的 <span class="underline">任一子进程</span></td>
</tr>

<tr>
<td class="org-left">pid &lt; -1</td>
<td class="org-left">等待其 <span class="underline">组ID</span> 等于 <span class="underline">pid的绝对值的任一子进程</span></td>
</tr>
</tbody>
</table>

<p>
options 参数或者是 0，或者是下表中常数的逐位 <span class="underline">或运算</span> 
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> waitpid的option参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">常量</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left"><span class="underline">WNOHANG</span></td>
<td class="org-left">如果pid指定的子进程并不立即可用，则 <b>waitpid不阻塞</b> ，直接返回值为 <span class="underline">0</span></td>
</tr>

<tr>
<td class="org-left"><span class="underline">WUNTRACED</span></td>
<td class="org-left">如果实现 <span class="underline">支持作业控制</span> ，则由pid指定的任一子进程 <span class="underline">状态已暂停</span> ，并且 <b>其状态自暂停以来还未报告过</b> ，则返回 <span class="underline">其状态</span> 。 <span class="underline">WIFSTOPPED</span> 宏确定返回值是否对应于一个 <span class="underline">暂停</span> 子进程</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-left"><b>阻塞</b> 并 <b>等待</b> pid指定的子进程终止</td>
</tr>
</tbody>
</table>

<p>
因此waitpid函数提供了wait函数没有提供的三个功能:
</p>
<ol class="org-ol">
<li>waitpid <b>等待一个特定的进程</b> (而wait则返回 <span class="underline">任一终止子进程</span> 的状态)</li>
<li>waitpid提供了一个wait的 <b>非阻塞版本</b> 
<ul class="org-ul">
<li>只是希望取得一个子进程的状态，但不想阻塞</li>
</ul></li>
<li>waitpid支持 <b>作业控制</b> (以 <span class="underline">WUNTRACED</span> 选择项)</li>
</ol>
</div>

<div id="outline-container-org3cf7361" class="outline-5">
<h5 id="org3cf7361">waitpid实例</h5>
<div class="outline-text-5" id="text-org3cf7361">
<pre class="example">
       如果一个进程要fork一个子进程，但不要求它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止
</pre>
<p>
这可以通过 <b>调用fork两次</b> 来实现：
</p>
<ul class="org-ul">
<li><span class="underline">第一个fork子线程</span> <b>提前终止</b> ，使得由它 <span class="underline">fork的第二个子进程</span> 被 <span class="underline">init</span> 托管</li>
<li><span class="underline">第二个子进程</span> 结束会 <b>自动被 <span class="underline">init</span> 进程调用 <span class="underline">wait</span> 处理</b></li>
<li><p>
<span class="underline">主进程</span> 只需要 <b>等待</b> <span class="underline">第一个子进程终止</span> 即可
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36827;&#31243;p</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>( ( pid = fork() ) &lt; 0)
        err_sys(<span style="color: #deb887;">"1. fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (0 == pid) { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;1&#65292;&#23427;&#30340;&#29238;&#36827;&#31243;&#26159;&#36827;&#31243;p</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>( ( pid = fork() ) &lt; 0)
            err_sys(<span style="color: #deb887;">"2.fork error"</span>);
        <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(pid &gt; 0) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;1 </span>
            exit(0); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#32467;&#26463;&#23376;&#36827;&#31243;1</span>

        <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">          &#36825;&#26159;&#23376;&#36827;&#31243;2&#65292;&#23427;&#30340;&#29238;&#36827;&#31243;&#21407;&#26412;&#26159;&#23376;&#36827;&#31243;1&#65292;&#20294;&#26159;&#22240;&#20026;&#23376;&#36827;&#31243;&#27491;&#24120;&#32456;&#27490;&#20102;&#65292;&#25152;&#20197;&#30001;init&#36827;&#31243;&#25176;&#31649;</span>
<span style="color: #5f9ea0; font-style: italic;">        </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        sleep(2);
        printf(<span style="color: #deb887;">"second child parent pid = %d\n"</span>, getppid());
        exit(0); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#24403;&#23376;&#36827;&#31243;2&#32456;&#27490;&#26102;&#65292;init&#36827;&#31243;&#20250;&#35843;&#29992;wait&#28165;&#29702;&#23376;&#36827;&#31243;2</span>
    }

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36827;&#31243;p&#38459;&#22622;&#31561;&#24453;&#23376;&#36827;&#31243;1&#32456;&#27490;&#65292;&#24182;&#28165;&#29702;&#23376;&#36827;&#31243;1</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) != pid)
        err_sys(<span style="color: #deb887;">"waitpid error"</span>); 

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36827;&#31243;p&#32456;&#27490;</span>
    exit(0);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/zombieAvoid

$ second child parent pid = 1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#31532;&#19968;&#20010;fork&#30340;&#23376;&#36827;&#31243;&#32456;&#27490;&#20102;&#65292;&#23427;&#30340;&#23376;&#36827;&#31243;&#34987;init&#36827;&#31243;&#25176;&#31649;</span>
</pre>
</div></li>
</ul>

<pre class="example">
       在第二个子进程中调用 sleep 是为了保证在打印父进程ID时第一个子进程已终止

       在fork之后，父、子进程都可继续执行，但无法预知哪一个会先执行

       如果不使第二个子进程睡眠，则在fork之后它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程，而不是init进程
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a29e34" class="outline-4">
<h4 id="org3a29e34">wait3和wait4</h4>
<div class="outline-text-4" id="text-org3a29e34">
<p>
<span class="underline">wait3</span> 和 <span class="underline">wait4</span> 这两个函数比 <span class="underline">wait</span> 和 <span class="underline">waitpid</span> 分别要多一个参数 <b>rusage</b> ，该参数用于内核返回由 <b>终止进程及其所有子进程使用的资源信息摘要</b> ，包括：
</p>
<ul class="org-ul">
<li>用户CPU时间总量</li>
<li>系统CPU时间总量</li>
<li>缺页次数</li>
<li>接收到信号的次数等</li>
</ul>

<pre class="example">
    这些资源信息只包括终止子进程，并不包括处于停止状态的子进程
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/time.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/resources.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#31561;&#24453;&#20219;&#19968;&#36827;&#31243;&#32456;&#27490;&#65292;&#24182;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * status: &#23384;&#20648;&#23376;&#36827;&#31243;&#30340; &#32456;&#27490;&#29366;&#24577;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * options: &#38459;&#22622;&#36873;&#39033;</span>
<span style="color: #ffebcd;"> * rusage: &#23384;&#20648; &#32456;&#27490;&#23376;&#36827;&#31243; &#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201; &#30340;&#32467;&#26500;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#36820;&#22238; &#32456;&#27490;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">wait3</span>(<span style="color: #98f5ff;">int</span> *<span style="color: #4eee94;">status</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">options</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rusage</span> *<span style="color: #4eee94;">rusage</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#31561;&#24453;&#25351;&#23450;&#23376;&#36827;&#31243;&#32456;&#27490;&#65292;&#24182;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pid: &#25351;&#23450; &#23376;&#36827;&#31243;ID</span>
<span style="color: #ffebcd;"> * status: &#23384;&#20648;&#23376;&#36827;&#31243;&#30340; &#32456;&#27490;&#29366;&#24577; &#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * options: &#38459;&#22622;&#36873;&#39033;</span>
<span style="color: #ffebcd;"> * rusage&#65306;&#23384;&#20648; &#32456;&#27490;&#23376;&#36827;&#31243; &#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201; &#30340;&#32467;&#26500;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return&#65306;&#33509;&#25104;&#21151;&#36820;&#22238; &#32456;&#27490;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">wait4</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>, <span style="color: #98f5ff;">int</span> *<span style="color: #4eee94;">status</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">options</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rusage</span> *<span style="color: #4eee94;">rusage</span>);
</pre>
</div>
<p>
表8-4中列出了各个wait函数所支持的不同的参数：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> 不同系统上各个wait函数所支持的参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数</td>
<td class="org-left">pid</td>
<td class="org-left">options</td>
<td class="org-left">rusage</td>
<td class="org-left">POSIX</td>
<td class="org-left">SVR4</td>
<td class="org-left">4.3+BSD</td>
</tr>

<tr>
<td class="org-left">wait</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">waitpid</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">wait3</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">wait4</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>
</tbody>
</table>

<pre class="example">
      对Linux而言，wait4是wait家族各个函数的系统调用入口，其它几个函数都基于wait4重新实现
</pre>
</div>
</div>
</div>

<div id="outline-container-org836cb2a" class="outline-3">
<h3 id="org836cb2a">竞争条件</h3>
<div class="outline-text-3" id="text-org836cb2a">
<p>
当多个进程都企图对 <b>共享数据</b> 进行某种处理，而 <b>最后的结果</b> 又取决于 <b>进程运行的顺序</b> 时，这就产生了 <span class="underline">竞态</span> 条件。如果在 <span class="underline">fork之后</span> 的 <span class="underline">某种逻辑</span> <span class="underline">显式或隐式</span> 地 <b>依赖</b> 于在fork之后是 <span class="underline">父进程先运行</span> 还是 <span class="underline">子进程先运行</span> ，那么 <b>fork函数就会是竞态条件</b> 活跃的孳生地
</p>

<pre class="example">
     通常无法预料哪一个进程先运行。即使知道哪一个进程先运行，那么在该进程开始运行后所发生的事情也依赖于系统负载以及内核的调度算法

     例如在waitpid的实例中，当第二个子进程打印其父进程ID时就可以看到了一个潜在的竞态条件
     如果第二个子进程在第一个子进程之前运行，则其父进程将会是第一个子进程
     但是如果第一个子进程先运行，并有足够的时间到达并执行exit，则第二个子进程的父进程就是init
     即使在程序中调用sleep，这也不保证什么。如果系统负担很重，那么在第二个子进程从sleep返回时，可能第一个子进程还没有得到机会运行

     这种形式的问题很难排除，因为在大部分时间，这种问题并不出现
</pre>
<ul class="org-ul">
<li>如果一个进程希望等待一个子进程终止，则它必须调用 <span class="underline">wait</span> 函数</li>
<li><p>
如果一个进程要等待其父进程终止，则可使用下列 <span class="underline">轮询</span> :
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">while</span>(getppid() != 1) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#36827;&#31243;&#32456;&#27490;&#65292;&#23376;&#36827;&#31243;&#30001;init&#36827;&#31243;&#25176;&#31649;</span>
    sleep(1);
</pre>
</div></li>
</ul>

<pre class="example">
     但轮询的问题是它浪费了CPU时间，因为调用者每隔1秒都被唤醒，然后进行条件测试
</pre>

<p>
为了避免竞态条件和定期询问，在多个进程之间需要有某种形式的 <b>信号</b> 机制
</p>

<pre class="example">
   在UNIX中可以使用信号机制和各种形式的进程间通信
</pre>
</div>

<div id="outline-container-org07decf2" class="outline-4">
<h4 id="org07decf2">竞争条件实例</h4>
<div class="outline-text-4" id="text-org07decf2">
<p>
输出两个字符串：一个由子进程输出，一个由父进程输出。因为输出依赖于内核使进程运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞态条件
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">charatatime</span>(<span style="color: #98f5ff;">char</span> *);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>( ( pid = fork() ) &lt; 0)
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(0 == pid) {
        charatatime(<span style="color: #deb887;">"output from child\n"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        charatatime(<span style="color: #deb887;">"output from parent\n"</span>);
    }

    exit(0);

}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">charatatime</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>)
{
    <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>;

    setbuf(stdout, <span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">for</span>(ptr = str; c = *ptr++; )
        putc(c, stdout);

}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/raceCondition <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20808;&#32467;&#26463;&#20102;&#23376;&#36827;&#31243; </span>
output from parent 
output from child

$ ./src/process/raceCondition <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20808;&#32467;&#26463;&#20102;&#29238;&#36827;&#31243;</span>
output from parent
$ output from child
</pre>
</div>

<p>
下面的代码会保证父进程比子进程先打印
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;

+   TELL_WAIT();

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
    err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) {
+       WAIT_PARENT();      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent goes first </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    charatatime(<span style="color: #deb887;">"output from child\n"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
    charatatime(<span style="color: #deb887;">"output from parent\n"</span>);
+       TELL_CHILD(pid);
    }
    exit(0);
}
</pre>
</div>

<pre class="example">
      以后会用信号量来实现五个例程TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD
</pre>
</div>
</div>
</div>

<div id="outline-container-org099002c" class="outline-3">
<h3 id="org099002c">执行程序</h3>
<div class="outline-text-3" id="text-org099002c">
<p>
当进程调用一种 <span class="underline">exec</span> 函数时，该进程 <b>完全由新程序</b> 代换，而新程序则从其 <span class="underline">main</span> 函数开始执行
</p>

<pre class="example">
调用exec并不创建新进程，因此进程ID并未改变

exec 只是用另一个新程序替换了当前进程的 正文、数据、堆 和 栈段
</pre>
</div>

<div id="outline-container-org20069fc" class="outline-4">
<h4 id="org20069fc">exec家族函数</h4>
<div class="outline-text-4" id="text-org20069fc">
<p>
<span class="underline">exec</span> 家族函数： <b>将指定的程序装入当前进程，使之替换掉当前进程大部分的上下文环境</b> 。一共6个变体，使用类似但形式不同的参数。
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">execl</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">arg0</span>, ..., <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">(char *)0 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">execlp</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">filename</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">arg</span>, ..., <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">(char *)0 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">execle</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">arg0</span>, ..., <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">(char *)0, char *const envp[] </span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">execv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #4eee94;">argv</span>[]);
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">execvp</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">filename</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #4eee94;">argv</span>[]);
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">execve</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #4eee94;">argv</span>[], <span style="color: #98f5ff;">char</span> *<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #4eee94;">envp</span>[]);
</pre>
</div>
<p>
这六个函数若出错则为 <span class="underline">-1</span> ，若成功则 <span class="underline">不返回</span> 
</p>

<ul class="org-ul">
<li><b>路径</b> ：
<ul class="org-ul">
<li>字母 <span class="underline">p</span> ：该函数取 <span class="underline">filename</span> 作为参数，并且用 <span class="underline">PATH环境变量</span> <b>寻找</b> <span class="underline">可执行文件</span></li>
<li><span class="underline">没有</span> 字母 <span class="underline">ｐ</span> ： <span class="underline">pathname</span> 路径名</li>
</ul></li>
<li><b>参数表</b> ：
<ul class="org-ul">
<li>字母 <span class="underline">l</span> ： <span class="underline">*arg0</span> 指针</li>
<li>字母 <span class="underline">v</span> ： <span class="underline">*argv[]</span> 数组</li>
<li>两种形式互斥</li>
</ul></li>
<li><p>
<b>环境变量</b> 
</p>
<ul class="org-ul">
<li>字母 <span class="underline">e</span> ： <span class="underline">*envp[]</span> 数组</li>
<li><span class="underline">没有</span> 字母 <span class="underline">e</span> ： <span class="underline">不使用当前环境</span></li>
</ul>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boade">
<caption class="t-above"><span class="table-number">Table 5:</span> 6个exec函数的参数区别</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数</td>
<td class="org-left">pathname</td>
<td class="org-left">filename</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">参数表</td>
<td class="org-left">argv[]</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">enviorn</td>
<td class="org-left">envp[]</td>
</tr>

<tr>
<td class="org-left">execl</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">execlp</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">execle</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">execv</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">execvp</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">execve</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">字母表示</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">p</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">l</td>
<td class="org-left">v</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
</tr>
</tbody>
</table></li>
</ul>

<pre class="example">
      在很多UNIX实现中，这六个函数中只有一个 execve 是内核的系统调用

      另外五个只是库函数，它们最终都要调用execve系统调用
</pre>
<p>
这六个函数之间的关系示于图8-2中：
</p>

<div class="figure">
<p><img src="pic/exec-family.jpg" alt="exec-family.jpg" width="90%" />
</p>
</div>
</div>
<div id="outline-container-org095aa5f" class="outline-5">
<h5 id="org095aa5f">exec进程特征</h5>
<div class="outline-text-5" id="text-org095aa5f">
<p>
执行 <span class="underline">exec后进程</span> 还 <b>保持</b> 了原进程的下列特征:
</p>
<ul class="org-ul">
<li><span class="underline">进程ID</span> 和 <span class="underline">父进程ID</span></li>
<li><span class="underline">实际用户ID</span> 和 <span class="underline">实际组ID</span></li>
<li><span class="underline">添加组ID</span></li>
<li><span class="underline">进程组ID</span></li>
<li><span class="underline">对话期ID</span></li>
<li><span class="underline">控制终端</span></li>
<li><b>闹钟尚余留</b> 的时间</li>
<li><span class="underline">当前工作目录</span></li>
<li><span class="underline">根目录</span></li>
<li><b>文件方式创建屏蔽字</b></li>
<li><b>文件锁</b></li>
<li><b>进程信号屏蔽</b></li>
<li><b>未决信号</b></li>
<li><span class="underline">资源限制</span></li>
<li>tms_utime，tms_stime，tms_cutime以及tms_ustime值</li>
</ul>

<pre class="example">
     与fork进程相比较，子进程是不继承文件锁，未决信号集！！！
</pre>

<p>
对打开文件的处理与每个描述符的 <span class="underline">exec关闭标志值</span> <b>FD_CLOEXEC</b> 有关。进程中每个 <span class="underline">打开描述符</span> 都有一个 <span class="underline">exec关闭标志</span> ：
</p>
<ul class="org-ul">
<li>若 <span class="underline">此标志设置</span> ，则在执行 <b>exec时关闭该描述符</b> ，否则该描述符仍打开</li>
<li>除非 <b>特地用fcntl设置了该标志</b> ，否则系统的 <span class="underline">默认</span> 操作是在 <b>exec后仍保持这种描述符打开</b></li>
</ul>

<pre class="example">
POSIX.1明确要求在exec时关闭打开目录流

这通常是由 opendir 函数实现的，它调用fcntl函数为对应于打开目录流的描述符设置exec关闭标志
</pre>

<p>
exec的进程  <b>有效ID</b> 是否改变则取决于 <span class="underline">所执行程序的文件</span> 的 <b>设置-用户-ID位</b> 和 <b>设置-组-ID位</b> 是否设置：
</p>
<ul class="org-ul">
<li>如果新程序的 <span class="underline">设置-用户-ID位</span> <b>已设置</b> ，则 <span class="underline">有效用户ID</span> <b>变成</b> <span class="underline">程序文件所有者的ID</span></li>
<li>否则： <span class="underline">有效用户ID</span> <b>不变</b></li>
<li>对 <span class="underline">组ID</span> 的处理方式与此相同</li>
</ul>

<pre class="example">
       在exec前后 实际用户ID 和 实际组ID 保持不变
</pre>
</div>
</div>

<div id="outline-container-org2c0987a" class="outline-5">
<h5 id="org2c0987a">exec实例</h5>
<div class="outline-text-5" id="text-org2c0987a">
<p>
程序 <span class="underline">echoall</span> 是一个普通程序， <b>回送</b> 其所有 <span class="underline">命令行参数</span> 及其全部 <span class="underline">环境表</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #98f5ff;">char</span> **<span style="color: #4eee94;">ptr</span>;
    <span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #98f5ff;">char</span> **<span style="color: #4eee94;">environ</span>;

    <span style="color: #00bfff; font-weight: bold;">for</span>(i = 0; i &lt; argc; i++)
        printf(<span style="color: #deb887;">"argv[%d]: %s\n"</span>, i, argv[i]);

    <span style="color: #00bfff; font-weight: bold;">for</span>(ptr = environ; *ptr != 0 ; ptr++ )
        printf(<span style="color: #deb887;">"%s\n"</span>, *ptr);

    exit(0);  
}
</pre>
</div>

<p>
调用execle要求一个 <span class="underline">路径名</span> 和一个 <span class="underline">特定的环境</span> 。下一个调用的是execlp用一个文件名，并将调用者的环境传送给新程序
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">env_init</span>[] = { <span style="color: #deb887;">"USER=unknown"</span>, <span style="color: #deb887;">"PATH=/tmp"</span>, <span style="color: #ffd700;">NULL</span>};

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;
    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork() ) &lt; 0 )
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>( 0 == pid ) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(execle(<span style="color: #deb887;">"/home/klose/bin/echoall"</span>,
              <span style="color: #deb887;">"echoall"</span>, <span style="color: #deb887;">"myarg1"</span>, <span style="color: #deb887;">"MY ARG2"</span>, (<span style="color: #98f5ff;">char</span> *) 0,
              env_init) &lt; 0 )
            err_sys(<span style="color: #deb887;">"execle error"</span>);

    }

    <span style="color: #00bfff; font-weight: bold;">if</span> (waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) &lt; 0)
        err_sys(<span style="color: #deb887;">"wait error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork() ) &lt; 0 )
        err_sys(<span style="color: #deb887;">"fork error"</span>);

    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (0 == pid) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(execlp(<span style="color: #deb887;">"echoall"</span>,
              <span style="color: #deb887;">"echoall"</span>, <span style="color: #deb887;">"only 1 arg"</span>, (<span style="color: #98f5ff;">char</span> *) 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"execlp error"</span>);
    }

    exit(0);

}
</pre>
</div>

<p>
测试代码如下
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./execExample
argv[0]: echoall <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">execle&#25191;&#34892;echoall  </span>
argv[1]: myarg1
argv[2]: MY ARG2
<span style="color: #4eee94;">USER</span>=unknown
<span style="color: #4eee94;">PATH</span>=/tmp
argv[0]: echoall <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">execlp&#25191;&#34892;echoall</span>
$ argv[1]: only 1 arg
<span style="color: #4eee94;">LC_PAPER</span>=en_US.UTF8
<span style="color: #4eee94;">HOME</span>=/home/klose
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">...... &#20854;&#20182;&#21508;&#31181;&#29615;&#22659;&#21464;&#37327; </span>
<span style="color: #4eee94;">_</span>=./execExample
</pre>
</div>

<pre class="example">
shell提示符号 '$' 出现在 第二个exec 打印 "echo all" 和 "only 1 arg" 之间

这是因为父进程并不等待该子进程结束
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8454455" class="outline-2">
<h2 id="org8454455">更改用户ID和组ID</h2>
<div class="outline-text-2" id="text-org8454455">
<ul class="org-ul">
<li>通过 <span class="underline">fork</span> <b>创建的子进程</b> ，其 <span class="underline">实际用户ID</span> 和 <span class="underline">有效用户ID</span> 将 <b>继承自父进程</b></li>
<li>用 <span class="underline">exec</span> 执行一个程序时，若该进程的程序文件有 <span class="underline">保存设置-用户-ID</span> 位，则其 <span class="underline">有效用户ID</span> 为 <b>exec执行程序的文件所属用户的ID</b> ，否则 <span class="underline">继承自exec之前的上下文</span></li>
<li><span class="underline">实际组ID</span> 和 <span class="underline">有效组ID</span> 的情况与之类似</li>
</ul>
</div>
<div id="outline-container-org8f72822" class="outline-3">
<h3 id="org8f72822">setuid, setgid</h3>
<div class="outline-text-3" id="text-org8f72822">
<ul class="org-ul">
<li>setuid：设置 <span class="underline">实际用户ID</span> 和 <span class="underline">有效用户ID</span></li>
<li><p>
setgid：设置 <span class="underline">实际组ID</span> 和 <span class="underline">有效组ID</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#23454;&#38469;&#29992;&#25143;ID&#21644;&#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * uid: &#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1&#65292;&#24182;&#35774;&#32622; errno</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setuid</span>(<span style="color: #98f5ff;">uid_t</span> <span style="color: #4eee94;">uid</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#23454;&#38469;&#32452;ID&#21644;&#26377;&#25928;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * gid: &#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1&#65292;&#24182;&#35774;&#32622; errno</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setgid</span>(<span style="color: #98f5ff;">gid_t</span> <span style="color: #4eee94;">gid</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org06b5356" class="outline-4">
<h4 id="org06b5356">改变ID规则</h4>
<div class="outline-text-4" id="text-org06b5356">
<p>
setuid/setgid的规则：
</p>
<ol class="org-ol">
<li>如果 <span class="underline">进程</span> <b>具有</b>  <span class="underline">超级用户特权</span> ： <span class="underline">setuid</span> 函数将 <span class="underline">实际用户ID</span> 、 <span class="underline">有效用户ID</span> 和 <span class="underline">保存的设置-用户-ID</span> 都设置为 <b>uid</b></li>
<li>如果 <span class="underline">进程</span> <b>没有</b>  <span class="underline">超级用户特权</span> ，但是 <span class="underline">uid</span> 等于 <span class="underline">实际用户ID</span> 或 <span class="underline">保存的设置-用户-ID</span> ：只将 <span class="underline">有效用户ID</span> 设置为 <span class="underline">uid</span> 。 <b>不改变实际用户ID和保存的设置-用户-ID</b></li>
<li>如果上面两个条件都不满足，则 <span class="underline">errno</span> 设置为 <b>EPERM</b> ，并返回出错</li>
</ol>

<pre class="example">
      只有超级用户进程可以更改实际用户ID
      通常，实际用户ID是在用户登录时由login(1)程序设置的，而且决不会改变它
      因为login是一个超级用户进程，当它调用setuid时设置所有三个用户ID

      仅当对程序文件设置了设置-用户-ID位时，exec函数设置有效用户ID
      如果设置-用户-ID位没有设置，则exec函数不会改变有效用户ID，而将其维持为原先值
      任何时候都可以调用setuid，将有效用户ID设置为实际用户ID或保存的设置-用户-ID，但是不能将有效用户ID设置为任一随机值

      保存的设置-用户-ID是由exec从有效用户ID复制的
      在exec按文件用户ID设置了有效用户ID后，即进行这种复制，并将此副本保存起来
</pre>

<p>
下面表格列出了改变这三个用户ID的不同方法：
</p>
<!-- This HTML table template is generated by emacs 26.3 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;设置-用户-ID关闭&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;设置-用户-ID打开&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;超级用户&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非超级用户&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;实际用户ID&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;有效用户ID&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;程序文件的用户ID&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      保存的设置-用户-ID
    </td>
    <td align="left" valign="top">
      &nbsp;从有效用户ID复制&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;从有效用户ID复制&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>

<div id="outline-container-org6a6385b" class="outline-5">
<h5 id="org6a6385b">实例</h5>
<div class="outline-text-5" id="text-org6a6385b">
<pre class="example">
       观察的tip(1)程序，这个程序连接到一个远程系统，或者是直接连接，或者是拨号一个调制解调器

       当tip使用调制解调器时，它必须通过使用锁文件来独占使用它
       此锁文件与UUCP程序共享，因为这两个程序可能要同时使用同一调制解调器
</pre>

<p>
对tip的工作步骤说明如下:
</p>
<ol class="org-ol">
<li>tip程序文件是由用户 <span class="underline">uucp</span> 拥有的，并且其 <span class="underline">设置-用户-ID位</span> 已设置。当exec此程序时，则关于用户ID得到下列结果:
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID</li>
<li>有效用户ID = uucp</li>
<li>保存设置-用户-ID = uucp</li>
</ul></li>
<li>tip存取所要求的锁文件。这些 <span class="underline">锁文件</span> 是由 <span class="underline">uucp的用户所拥有的</span> ，因为 <span class="underline">有效用户ID</span> 是 <span class="underline">uucp</span> ，所以tip <b>可以存取这些锁文件</b></li>
<li>tip执行setuid(getuid())。因为 <span class="underline">tip不是超级用户进程</span> ，所以这 <b>仅仅改变有效用户ID</b> 。此时得到：
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID(未改变)</li>
<li>有效用户-ID = <span class="underline">我们的用户ID(改变)</span> ： <b>这就意味着能存取的只有我们通常可以存取的，没有额外的许可权</b></li>
<li>保存设置-用户-ID=uucp(未改变)</li>
</ul></li>
<li>当执行完所需的操作后，tip执行setuid(uucpuid)，其中 <span class="underline">uucpuid</span> 是 <span class="underline">用户uucp的数值用户ID</span> (tip很可能在起动时调用geteuid，得到uucp的用户ID，然后将其保存起来，我们并不认为tip会搜索口令文件以得到这一数值用户ID)。因为 <span class="underline">setuid的参数</span> 等于 <span class="underline">保存的设置-用户-ID</span> ，所以这种 <b>调用是许可的</b> (这就是 <span class="underline">为什么需要保存的设置-用户-ID的原因</span> )。现在得到: 
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID(未改变)</li>
<li>有效用户ID = <span class="underline">uucp</span></li>
<li>保存设置-用户-ID = uucp(未改变)</li>
</ul></li>
<li>tip现在可 <b>对其锁文件进行操作以释放</b> 它们，因为 <span class="underline">tip的有效用户ID</span> 是 <span class="underline">uucp</span></li>
</ol>

<pre class="example">
       以这种方法使用保存的设置-用户-ID：

       在进程的开始和结束部分就可以使用由于程序文件的”设置用户ID而得到的额外优先权“， 但是进程在其运行的大部分时间只具有”普通的许可权“

       如果进程不能在其结束部分 切换回保存的设置-用户-ID，那么就不得不在全部运行时间都保持额外的许可权，这无疑会造成安全问题
</pre>

<pre class="example">
       如果在tip运行时生成一个shell进程，先fork，然后exec将发生什么？
</pre>

<ul class="org-ul">
<li>因为 <span class="underline">实际用户ID</span> 和 <span class="underline">有效用户ID</span> 都是 <span class="underline">我们的普通用户ID</span> (上面的第(3)步)，所以 <b>该shell没有额外的许可权</b></li>
<li>它 <b>不能存取tip运行时设置成 <span class="underline">保存的设置-用户-ID</span> uucp</b> ，因为 <span class="underline">该shell所保存的设置-用户-ID</span> 是由 <span class="underline">exec shell进程</span> <b>复制</b> <span class="underline">tip进程的有效用户ID</span> 而得到的</li>
<li><p>
所以在执行exec的子进程中：
</p>
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID</li>
<li>有效用户ID = 我们的用户ID</li>
<li>保存设置-用户-ID = 我们的用户ID</li>
</ul>

<pre class="example">
对于进程特权的改变，应遵循“使用能完成工作的最小特权”的原则，以避免用户进程越权操作：

1. 在不需要设置-用户-ID带来的权限时，使用setuid(getuid()) “降低有效用户ID”的特权

2. getuid和geteuid函数只能获得实际用户ID和有效用户ID的当前值，
  而不能获得所保存的设置-用户-ID的当前值。必须在降低权限前通过”调用geteuid”然后 “保存”

3. 再次需要高级权限的时候，可以通过“setuid(保存的euid)来恢复”

4. 在“子进程执行exec之前”，应“setuid(getuid())”以避免设置-用户-ID引起的”特权传递“

5. 如果程序的设置-用户-ID为 root，以超级用户特权调用setuid就会设置所有三个用户ID，慎用！！！
</pre></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orge87ed22" class="outline-3">
<h3 id="orge87ed22">setreuid, setregid</h3>
<div class="outline-text-3" id="text-orge87ed22">
<ul class="org-ul">
<li><span class="underline">setreuid</span> ： <b>交换</b> <span class="underline">实际用户ID</span> 和 <span class="underline">有效用户ID</span> 的值</li>
<li><p>
<span class="underline">setregid</span> ： <b>交换</b> <span class="underline">实际组ID</span> 和 <span class="underline">有效组ID</span> 的值
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20132;&#25442;&#23454;&#38469;&#29992;&#25143;ID&#21644;&#26377;&#25928;&#29992;&#25143;ID&#30340;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * ruid: &#23454;&#38469;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> * euid: &#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setreuid</span>(<span style="color: #98f5ff;">uid_t</span> <span style="color: #4eee94;">ruid</span>, <span style="color: #98f5ff;">uid_t</span> <span style="color: #4eee94;">euid</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20132;&#25442;&#23454;&#38469;&#32452;ID&#21644;&#26377;&#25928;&#32452;ID&#30340;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * rgid: &#23454;&#38469;&#32452;ID</span>
<span style="color: #ffebcd;"> * egid: &#26377;&#25928;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setregid</span>(<span style="color: #98f5ff;">gid_t</span> <span style="color: #4eee94;">rgid</span>, <span style="color: #98f5ff;">gid_t</span> <span style="color: #4eee94;">egid</span>);
</pre>
</div></li>
</ul>
<p>
一个 <span class="underline">非特权用户</span>  <b>总能交换</b> <span class="underline">实际用户ID</span> 和 <span class="underline">有效用户ID</span> ：
</p>
<ul class="org-ul">
<li><b>允许一个 <span class="underline">设置-用户-ID</span> 程序转换成 <span class="underline">只具有用户的普通</span> 许可权</b> ，以后又可 <b>再次转换回</b> 设置-用户-ID所得到的额外许可权</li>
</ul>

<pre class="example">
POSIX.1引进了保存的设置-用户-ID特征后，其作用也相应加强

它也允许一个非特权用户将其有效用户ID设置为保存的设置-用户-ID

实际上更方便了调用上述程序，而无须手动进行保存有效用户ID，再手动setuid
</pre>
</div>
</div>

<div id="outline-container-orged7547f" class="outline-3">
<h3 id="orged7547f">seteuid和setegid函数</h3>
<div class="outline-text-3" id="text-orged7547f">
<ul class="org-ul">
<li><span class="underline">seteuid</span> ： 设置 <span class="underline">有效用户ID</span></li>
<li><p>
<span class="underline">setegid</span> ：设置 <span class="underline">有效组ID</span> 
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * euid: &#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1&#65292;&#24182;&#35774;&#32622; errno</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">seteuid</span>(<span style="color: #98f5ff;">uid_t</span> <span style="color: #4eee94;">euid</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#26377;&#25928;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * egid: &#26377;&#25928;&#32452;ID</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1&#65292;&#24182;&#35774;&#32622; errno</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setegid</span>(<span style="color: #98f5ff;">gid_t</span> <span style="color: #4eee94;">egid</span>);
</pre>
</div></li>
</ul>
<p>
规则类似于 <span class="underline">setuid</span> 函数：
</p>
<ul class="org-ul">
<li><span class="underline">非特权用户</span> ：可将 <span class="underline">有效用户ID</span> 设置为 <span class="underline">实际用户ID</span> 或 <span class="underline">保存的设置-用户-ID</span></li>
<li><span class="underline">特权用户</span> ：可将 <span class="underline">有效用户ID</span> 设置为 <span class="underline">uid</span></li>
</ul>

<pre class="example">
setuid函数更改三个用户ID
</pre>
</div>
</div>

<div id="outline-container-org1b0d04c" class="outline-3">
<h3 id="org1b0d04c">总结</h3>
<div class="outline-text-3" id="text-org1b0d04c">

<div class="figure">
<p><img src="pic/uid.png" alt="uid.png" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org62c0799" class="outline-3">
<h3 id="org62c0799">组ID</h3>
<div class="outline-text-3" id="text-org62c0799">
<p>
上面描述的适用于各个组ID
</p>
<pre class="example">
     添加组ID 不受 setgid 函数的影响
</pre>
</div>
</div>
</div>

<div id="outline-container-org53fb922" class="outline-2">
<h2 id="org53fb922">解释器</h2>
<div class="outline-text-2" id="text-org53fb922">
<p>
解释器文件是 <b>文本文件</b> ，其起始行的形式是:  
</p>
<pre class="example">
#!pathname [optional-argument]

在惊叹号 和 pathname 之间的空格是可任选的。最常见的是以下列行开始:

#!/bin/sh 
</pre>

<p>
pathname通常是个 <span class="underline">绝对路径名</span> ，不需要使用PATH进行路径搜索 
</p>
<pre class="example">
    对这种文件的识别是由内核作为 exec 系统调用处理的一部分来完成的

    内核使调用exec函数的进程实际执行的文件并不是该解释器文件， 而是在该解释器文件的第一行中 pathname 所指定的程序文件！
</pre>
</div>

<div id="outline-container-org8361ad3" class="outline-3">
<h3 id="org8361ad3">exec调用解释器文件</h3>
<div class="outline-text-3" id="text-org8361ad3">
<p>
解释器文件 <span class="underline">testinterp</span> ，程序 <span class="underline">echoall</span> 回送每一个命令行参数
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">!/home/klose/bin/</span><span style="color: #00bfff; font-weight: bold;">echoall</span><span style="color: #5f9ea0; font-style: italic;"> foo</span>
</pre>
</div>

<p>
使用 <span class="underline">exec</span> 调用解释器文件 <span class="underline">testinterp</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>( (pid = fork()) &lt; 0 )
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> ( 0 == pid ) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child </span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(execl(<span style="color: #deb887;">"/home/klose/bin/testinterp"</span>, <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#35299;&#37322;&#22120;&#25991;&#20214;&#36335;&#24452;&#21517;pathname</span>
             <span style="color: #deb887;">"testinterp"</span>, <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#25191;&#34892;&#31243;&#24207;&#21517;&#65292;&#25171;&#21360;&#30340;&#26102;&#20505;&#20250;&#34987;pathname&#20195;&#26367;</span>
             <span style="color: #deb887;">"myarg1"</span>, <span style="color: #deb887;">"MY ARG2"</span>, <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#12288;&#21629;&#20196;&#34892;&#21442;&#25968;</span>
             (<span style="color: #98f5ff;">char</span> *) 0 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">NULL&#23383;&#31526;&#25351;&#38024;</span>
               ) &lt; 0 )
            err_sys(<span style="color: #deb887;">"execl error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) != pid )
        err_sys(<span style="color: #deb887;">"waitpid error"</span>);

    exit(0);

}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/interpret

argv[0]: /home/klose/bin/echoall
argv[1]: foo
argv[2]: /home/klose/bin/testinterp
argv[3]: myarg1
argv[4]: MY ARG2
<span style="color: #4eee94;">LC_PAPER</span>=en_US.UTF8
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">...</span>
=./src/process/interpret
</pre>
</div>

<p>
当内核 <span class="underline">exec</span> <b>执行</b> <span class="underline">/home/klose/bin/echoll</span> 时：
</p>
<ul class="org-ul">
<li>argv[0]= '/home/klose/bin/echoall' :  <span class="underline">执行文件</span> 的 <b>pathname</b></li>
<li>argv[1]= 'foo' :   <span class="underline">脚本文件中</span> 的 <b>可选参数</b></li>
<li>argv[2]='/home/klose/bin/testinterp' :  <span class="underline">脚本文件</span> 的 <b>pathname</b></li>
<li>argv[3]='myarg1' ：调用execl的第二个参数(argv[1])</li>
<li>argv[4]='MY ARG2' : 调用execl的第三个参数(argv[2])</li>
</ul>

<pre class="example">
注意：1. 调用execl时的argv[1] 和argv [2] 已右移了两个位置

2. 内核取 execl 中的 pathname 代替第一个参数(testinterp)，因为一般 pathname 包含了较第一个参数更多的信息
</pre>
</div>
</div>

<div id="outline-container-org03993c4" class="outline-3">
<h3 id="org03993c4">awk实例</h3>
<div class="outline-text-3" id="text-org03993c4">
<p>
在 <span class="underline">pathname</span> 后可 跟随 <span class="underline">可选参数</span> ，它们常用于为支持 <span class="underline">-f 选择项</span> 的程序指定该选择项。例如，可以用下列方式执行 <span class="underline">awk(1)</span> 程序：
</p>
<div class="org-src-container">
<pre class="src src-sh">awk -f myfile
</pre>
</div>
<p>
它告诉 <span class="underline">awk</span> 从 <span class="underline">文件myfile</span> 中 <b>读awk程序</b> ，而在脚本文件中使用 -f 选择项，可以写成:
</p>
<pre class="example">
#!awk -f 
(在脚本文件中的awk程序)
</pre>

<p>
以下awk程序打印所有的参数
</p>
<div class="org-src-container">
<pre class="src src-awk"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">!/bin/awk -f</span>

<span style="color: #00bfff; font-weight: bold;">BEGIN</span> {
    <span style="color: #00bfff; font-weight: bold;">for</span> (i = 0; i &lt; <span style="color: #4eee94;">ARGC</span>; i++)
        <span style="color: #ffd700;">printf</span> <span style="color: #deb887;">"ARGV[%d] = %s\n"</span>, i, <span style="color: #4eee94;">ARGV</span>[i]
    <span style="color: #00bfff; font-weight: bold;">exit</span>
}
</pre>
</div>
<p>
测试:
</p>
<div class="org-src-container">
<pre class="src src-C">$ ./awkexample filel FILENAME2 f3 

ARGV[0] = awk
ARGV[1] = filel
ARGV[2] = FILENAME2
ARGV[3] = f3
</pre>
</div>

<p>
最终会由 <span class="underline">/bin/awk</span> 来执行，其 <span class="underline">命令行参数</span> 是：
</p>
<pre class="example">
/bin/awk -f /home/klose/Documents/programming/c/apue/orignal/proc/awkexample file1 FILENAME2 f3
</pre>

<p>
<span class="underline">脚本文件</span> 的 <b>绝对路径名</b> <span class="underline">/home/klose/Documents/programming/c/apue/orignal/proc/awkexample</span> 会作为 <b>-f 的参数</b> 被传送给 <span class="underline">awk解释器</span> 。如果在解释器文件中 <b>删除</b>  <span class="underline">-f</span> 选择项 ，则其结果是: 
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./awkexample filel FILENAME2 f3 

awk: cmd. line:1: ./awkexample
awk: cmd. line:1: ^ syntax error
awk: cmd. line:1: ./awkexample
awk: cmd. line:1:   ^ unterminated regexp
</pre>
</div>
<p>
因为其命令行参数变成了：
</p>
<pre class="example">
/bin/awk /home/klose/Documents/programming/c/apue/orignal/proc/awkexample file1 FILENAME2 f3
</pre>
<p>
错误原因是：awk企图将 <span class="underline">字符串/usr/local/bin/awkexample</span> 解释为一个 <b>awk程序源码</b> 
</p>

<pre class="example">
     如果不能向解释器传递至少一个可选参数(在本例中是 -f )，那么这些解释器文件只有对shell才是有用的
</pre>
</div>
</div>

<div id="outline-container-org7d85c32" class="outline-3">
<h3 id="org7d85c32">解释器文件的优劣</h3>
<div class="outline-text-3" id="text-org7d85c32">
<p>
解释器文件的 <span class="underline">劣势</span> 主要在于 <b>效率</b> ，因为 <span class="underline">内核需要识别解释器文件</span> ，这会带来额外的开销。但是解释器文件还是有用的:
</p>
<ul class="org-ul">
<li>某些程序是用 <span class="underline">某种语言写的脚本</span> ，可以 <b>隐藏</b> 这一事实。例如只需使用下列命令行:</li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">$ awkexample optional-arguments
</pre>
</div>
<p>
而并不需要知道该程序实际上是一个awk脚本，否则就要以下列方式执行该程序:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ awk -f awkexample optional-arguments
</pre>
</div>
<ul class="org-ul">
<li><p>
解释器脚本在效率方面也提供了好处。再考虑一下前面的例子，如果将其放在一个shell脚本中:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">!/bin/</span><span style="color: #00bfff; font-weight: bold;">sh</span>

awk <span style="color: #deb887;">'BEGIN {</span>
<span style="color: #deb887;">for (i = 0; i &lt; ARGC; i++)</span>
<span style="color: #deb887;">printf "ARGV[%d] = %s\n", i, ARGV[i]</span>
<span style="color: #deb887;">e x i t</span>
<span style="color: #deb887;">}'</span> $<span style="color: #4eee94;">*</span>
</pre>
</div></li>
</ul>
<pre class="example">
这只会要求做更多的工作。

1. 首先shell读此命令
2. 试图execlp此文件名
3. 因为shell脚本是一个可执行文件，但却不是机器可执行的，于是返回一个错误
4. execlp就认为该文件是一个shell脚本
5. 再执行/bin/sh，并以该shell脚本的路径名作为其参数
6. shell正确地执行脚本，但是为了运行awk程序
7. 它调用fork，exec和wait
</pre>

<p>
<span class="underline">用一个shell脚本</span> 代替 <span class="underline">解释器脚本</span> 往往 <b>需要更多的开销</b> 
</p>

<ul class="org-ul">
<li><p>
使用解释器脚本 <b>可以调用 <span class="underline">除/bin/sh以外</span> 的其他shell</b> 来编写shell脚本。当 <span class="underline">execlp</span> 找到一个 <span class="underline">非机器可执行的可执行文件</span> 时，它 <b>总是调用/bin/sh</b> 来解释执行该文件。但是用解释器脚本则可编写成: 
</p>
<pre class="example">
#!/bin/csh
(在解释器文件中后随Cshell脚本)
</pre></li>
</ul>
<p>
虽然可将此放在一个 <span class="underline">/bin/sh</span> 脚本中，然后由其 <b>调用</b> <span class="underline">cshell</span> ，但同样会有 <b>更多的开销</b> 
</p>
</div>
</div>
</div>

<div id="outline-container-orga17e3ed" class="outline-2">
<h2 id="orga17e3ed">system函数</h2>
<div class="outline-text-2" id="text-orga17e3ed">
<p>
<span class="underline">system</span> ：在程序中 <b>执行</b> 一个 <b>命令字符串</b> 
</p>
<pre class="example">
    是否支持system完全依赖于操作系统
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20351;&#29992;/bin/sh&#25191;&#34892;&#25351;&#23450;&#30340;&#21629;&#20196;&#20018;&#25191;&#34892;&#26631;&#20934;&#30340;shell&#21629;&#20196;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * cmdstring: &#21629;&#20196;&#20018;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * </span><span style="color: #ffd700;">return</span><span style="color: #ffebcd;">:</span>
<span style="color: #ffebcd;"> *         1. &#22914;&#26524;fork&#22833;&#36133; &#25110;&#32773; waitpid &#36820;&#22238;&#38500; EINTR &#20043;&#22806;&#30340;&#20986;&#38169;&#65292;&#21017;system&#36820;&#22238; -1&#65292;&#32780;&#19988; errno &#20013;&#35774;&#32622;&#20102;&#38169;&#35823;&#31867;&#22411;</span>
<span style="color: #ffebcd;"> *         2. &#22914;&#26524;exec&#22833;&#36133;(&#19981;&#33021;&#25191;&#34892;shell)&#65292;&#21017;&#20854;&#36820;&#22238;&#20540;&#22914;&#21516; shell &#25191;&#34892;&#20102;exit(127)&#19968;&#26679;</span>
<span style="color: #ffebcd;"> *         3. &#25152;&#26377;&#19977;&#20010;&#20989;&#25968;(fork&#65292;exec&#21644;waitpid)&#37117;&#25104;&#21151;&#65292;&#24182;&#19988;system&#30340;&#36820;&#22238;&#20540;&#26159; shell&#30340;&#32456;&#27490;&#29366;&#24577;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">system</span>(cont <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>);
</pre>
</div>
<p>
如果 <span class="underline">cmdstring</span> 是一个 <span class="underline">空指针</span> ，则仅当 <b>system命令处理程序可用时</b> 返回 <b>非0值</b> 
</p>

<pre class="example">
    这一特征可以用来判定在一个给定的操作系统上是否支持system函数

    在UNIX中system总是可用的
</pre>

<p>
因为system在其实现中调用了fork、exec和waitpid，因此有三种返回值:
</p>
<ol class="org-ol">
<li>如果 <span class="underline">fork失败</span> 或者 <span class="underline">waitpid</span> 返回 <span class="underline">除EINTR之外的出错</span> ，则system返回 <b>-1</b> ，而且 <b>errno中设置了错误类型</b></li>
<li>如果 <span class="underline">exec失败</span> (不能执行shell)，则其返回值如同 <span class="underline">shell执行了</span> <b>exit(127)</b> 一样</li>
<li>否则：所有三个函数(fork，exec和waitpid)都成功，并且system的返回值是 <b>shell的终止状态</b> ，其格式在 <span class="underline">waitpid</span> 中说明</li>
</ol>
</div>

<div id="outline-container-org92806c7" class="outline-3">
<h3 id="org92806c7">system简单实现</h3>
<div class="outline-text-3" id="text-org92806c7">
<p>
以下程序是system的一个实现，没有考虑信号处理
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#32570;&#23569;&#20449;&#21495;&#22788;&#29702; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">mysystem</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>) 
{
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">status</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (cmdstring == <span style="color: #ffd700;">NULL</span>)
        <span style="color: #00bfff; font-weight: bold;">return</span>(1); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238;1&#34920;&#31034;&#25903;&#25345;system&#20989;&#25968;    </span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        status = -1;    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#26080;&#27861;&#20877;&#21019;&#24314;&#26032;&#30340;&#36827;&#31243;</span>
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#23376;&#36827;&#31243;</span>
        execl(<span style="color: #deb887;">"/bin/sh"</span>, <span style="color: #deb887;">"sh"</span>, <span style="color: #deb887;">"-c"</span>, cmdstring, (<span style="color: #98f5ff;">char</span> *)0);
        _exit(127);     <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#26080;&#27861;&#25191;&#34892;exec&#20989;&#25968;&#65292;&#36820;&#22238;127</span>
    } <span style="color: #00bfff; font-weight: bold;">else</span> { <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#29238;&#36827;&#31243;&#31561;&#24453;&#23376;&#36827;&#31243;&#32467;&#26463;</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (waitpid(pid, &amp;status, 0) &lt; 0) {
            <span style="color: #00bfff; font-weight: bold;">if</span> (errno != EINTR) {
                status = -1; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">waitpid&#19981;&#26159;&#36890;&#36807;&#25429;&#33719;&#20013;&#26029;&#20449;&#21495;&#32780;&#36820;&#22238;&#65292;&#20986;&#38169;&#36820;&#22238;-1 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
                <span style="color: #00bfff; font-weight: bold;">break</span>;
            }
        }
    }

    <span style="color: #00bfff; font-weight: bold;">return</span>(status); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;</span>
}
</pre>
</div>

<pre class="example">
如果不使用shell执行此命令，而是试图由我们自己去执行它，那么将相当困难

1. 必须用execlp而不是execl，像shell那样使用PATH变量
2. 必须将null符结尾的命令字符串分成各个命令行参数，以便调用execlp
3. 也不能使用任何一个shell元字符
</pre>

<p>
shell的 <span class="underline">-c</span> 选择项：shell程序读取 <span class="underline">下一个命令行参数</span> (cmdstring)作为 <b>命令输入</b> (而不是从标准输入或从一个给定的文件中读命令) 
</p>
<ul class="org-ul">
<li>shell对以 <span class="underline">null字符终止的命令字符串</span> 进行 <b>语法分析</b> ，将它们分成 <span class="underline">分隔开的命令行参数</span></li>
<li>传递给shell的实际命令串可以 <b>包含任一有效的shell命令</b> 例如：
<ul class="org-ul">
<li>可以用 <span class="underline">&lt;</span> 和 <span class="underline">&gt;</span> 对 <b>输入和输出重新定向</b></li>
</ul></li>
</ul>

<pre class="example">
      最后调用 _exit 而不是exit：这是为了防止任一标准I/O缓存(这些缓存会在fork中由父进程复制到子进程)在子进程中被刷新！
</pre>
</div>

<div id="outline-container-org1b6295e" class="outline-4">
<h4 id="org1b6295e">mysystem实例</h4>
<div class="outline-text-4" id="text-org1b6295e">
<p>
调用mystem来执行shell命令：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">mysystem</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">status</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> ((status = mysystem(<span style="color: #deb887;">"date"</span>)) &lt; 0)
        err_sys(<span style="color: #deb887;">"system() error"</span>);
    pr_exit(status);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((status = mysystem(<span style="color: #deb887;">"nosuchcommand"</span>)) &lt; 0)
        err_sys(<span style="color: #deb887;">"system() error"</span>);
    pr_exit(status);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((status = mysystem(<span style="color: #deb887;">"who; exit 44"</span>)) &lt; 0)
        err_sys(<span style="color: #deb887;">"system() error"</span>);
    pr_exit(status);

    exit(0);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/mysystest1 

Thu Mar  9 23:57:44 CST 2017
normal termination, exit status = 0 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#25104;&#21151;&#25191;&#34892;&#32456;&#27490;&#29366;&#24577;&#36820;&#22238;0</span>
sh: nosuchcommand: command not found
normal termination, exit status = 127 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#26080;&#27861;&#25191;&#34892;shell&#21629;&#20196;&#65292;&#32456;&#27490;&#29366;&#24577;&#36820;&#22238;127</span>
klose    tty1         2017-03-09 22:08
klose    pts/0        2017-03-09 22:19 (:0.0)
klose    pts/1        2017-03-09 22:29 (:0.0)
normal termination, exit status = 44 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#25163;&#21160;&#36820;&#22238;&#32456;&#27490;&#29366;&#24577;44</span>
</pre>
</div>

<p>
使用 <span class="underline">system</span> 而 <span class="underline">不直接使用fork和exec</span> 的原因是： system进行了所需的 <b>各种出错处理</b> ，以及 <b>各种信号处理</b> 
</p>

<pre class="example">
      如果一个进程正以特殊的许可权(设置-用户-ID或设置-组-ID)运行，但又想生成另一个进程执行另一个程序
      则它应当直接使用fork和exec，而且在fork之后、exec之前要改回到普通许可权

      另外：作为服务器程序时也不应使用system处理客户程序提供的字符串参数
      以避免恶意用户利用shell中的特殊操作符进行越权操作
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org71549bc" class="outline-2">
<h2 id="org71549bc">进程会计</h2>
<div class="outline-text-2" id="text-org71549bc">
<p>
很多UNIX系统提供了一个 <span class="underline">选择项</span> 以进行 <b>进程会计事务处理</b> 。当取了这种选择项后， <span class="underline">每当进程结束时</span> 内核就写一个 <span class="underline">会计记录</span> 。典型的会计记录是 <span class="underline">32字节长的二进制数据</span> ，包括 <b>命令名</b> 、 <b>所使用的CPU时间总量</b> 、 <b>用户ID</b> 和 <b>组ID</b> 、 <b>起动时间</b> 等
</p>
</div>

<div id="outline-container-orge5526cf" class="outline-3">
<h3 id="orge5526cf">acct结构</h3>
<div class="outline-text-3" id="text-orge5526cf">
<p>
会计记录结构定义在头文件 <span class="underline">&lt;sys/acct.h&gt;</span> 中，其样式如下：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">typedef</span> <span style="color: #98f5ff;">u_int16_t</span> <span style="color: #98f5ff;">comp_t</span>;

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">acct</span>
{
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">ac_flag</span>;         <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Flags.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">u_int16_t</span> <span style="color: #4eee94;">ac_uid</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Real user ID.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">u_int16_t</span> <span style="color: #4eee94;">ac_gid</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Real group ID.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">u_int16_t</span> <span style="color: #4eee94;">ac_tty</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Controlling terminal.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">u_int32_t</span> <span style="color: #4eee94;">ac_btime</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Beginning time.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_utime</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">User time.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_stime</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">System time.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_etime</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Elapsed time.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_mem</span>;        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Average memory usage.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_io</span>;         <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Chars transferred.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_rw</span>;         <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Blocks read or written.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_minflt</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Minor pagefaults.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_majflt</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Major pagefaults.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">comp_t</span> <span style="color: #4eee94;">ac_swaps</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Number of swaps.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">u_int32_t</span> <span style="color: #4eee94;">ac_exitcode</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Process exitcode.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">ac_comm</span>[ACCT_COMM+1];    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Command name.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">ac_pad</span>[10];      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Padding bytes.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>
<p>
其中ac_flag记录了进程执行期间的某些事件。这些事件见下表：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boade">
<caption class="t-above"><span class="table-number">Table 6:</span> 会计记录中的ac_flag值</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">ac_flag</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">AFORK</td>
<td class="org-left">进程是由 <span class="underline">fork</span> 产生的，但从未调用 <span class="underline">exec</span></td>
</tr>

<tr>
<td class="org-left">ASU</td>
<td class="org-left">进程使用 <span class="underline">超级用户</span> 优先权</td>
</tr>

<tr>
<td class="org-left">ACOMPAT</td>
<td class="org-left">进程使用 <span class="underline">兼容方式</span> (仅VAX)</td>
</tr>

<tr>
<td class="org-left">ACORE</td>
<td class="org-left"><span class="underline">进程转储core</span> (不在SVR4)</td>
</tr>

<tr>
<td class="org-left">AXSIG</td>
<td class="org-left">进程由 <span class="underline">信号杀死</span> (不在SVR4)</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgf5e8230" class="outline-4">
<h4 id="orgf5e8230">会记记录的缺陷</h4>
<div class="outline-text-4" id="text-orgf5e8230">
<p>
会计文件中 记录的顺序 对应于 进程终止的顺序，而 不是它们起动的顺序：
</p>
<ul class="org-ul">
<li>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核 <b>保存在进程表</b> 中</li>
<li>在一个 <span class="underline">新进程被创建时</span> <b>置初值</b> (例如fork之后在子进程中)</li>
<li><span class="underline">进程终止时</span> <b>写一个会计记录</b></li>
</ul>

<pre class="example">
      因此为了确定起动顺序，需要读全部会计文件，并按起动日历时间进行排序
</pre>

<p>
会计记录 <b>对应于进程</b> 而 <b>不是程序</b> ：
</p>
<ul class="org-ul">
<li>在 <span class="underline">fork</span> 之后 <span class="underline">内核为子进程</span>  <b>初始化一个记录</b> ，而 <b>不是在一个新程序被执行</b> 时</li>
<li><span class="underline">exec</span> 并 <span class="underline">不创建一个新的会计记录</span> ，但 <b>相应记录中的命令名改变</b> 了， <b>AFORK标志则被清除</b></li>
</ul>

<pre class="example">
      这意味着：如果一个进程顺序执行了三个程序(A exec B，B exec C，最后C exit)却只写一个会计记录

      在该记录中的命令名对应于程序C，但CPU时间是程序A、B、C之和
</pre>

<pre class="example">
      会记记录并不是POSIX标准，各个系统实现都不一样，建议谨慎使用！
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb274177" class="outline-3">
<h3 id="orgb274177">用户标识</h3>
<div class="outline-text-3" id="text-orgb274177">
<pre class="example">
     在实际的Unix系统中，uid和gid是标志一个用户的方式，但是用户以数字标志的形式管理系统不方便

     所以就有了以英文形式提供的用户标识，Unix也提供了对应的映射调用
</pre>
<p>
<span class="underline">getlogin</span> ：获取 <b>用户登录名</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#21462;&#29992;&#25143;&#30331;&#24405;&#21517;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#25351;&#21521;&#30331;&#24405;&#21517;&#23383;&#31526;&#20018;&#30340;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">getlogin</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7985474" class="outline-3">
<h3 id="org7985474">进程时间</h3>
<div class="outline-text-3" id="text-org7985474">
<p>
<span class="underline">times</span> ：获得 <span class="underline">某个进程</span> <b>各个时间</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/times.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#36827;&#31243;&#30340; &#31995;&#32479;cpu&#26102;&#38388;&#65292;&#29992;&#25143;cpu&#26102;&#38388;&#65292;&#32456;&#27490;&#23376;&#36827;&#31243;&#31995;&#32479;cpu&#26102;&#38388;&#24635;&#21644;&#65292;&#32456;&#27490;&#23376;&#36827;&#31243;&#29992;&#25143;cpu&#26102;&#38388;&#24635;&#21644;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * buffer: &#36827;&#31243;&#26102;&#38388;&#32467;&#26500;&#25351;&#38024;&#65292;&#22635;&#20889;&#36827;&#31243;&#30456;&#20851;&#26102;&#38388;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#32463;&#36807;&#30340;&#22681;&#19978;&#26102;&#38047;&#26102;&#38388;(&#21333;&#20301;:&#28404;&#31572;)&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">clock_t</span> <span style="color: #daa520; font-weight: bold;">times</span>(<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span> *<span style="color: #4eee94;">buffer</span>);
</pre>
</div>
<p>
填写由buf指向的 <span class="underline">tms</span> 结构，该结构定义如下: 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span> {
    <span style="color: #98f5ff;">clock_t</span> <span style="color: #4eee94;">tms_utime</span>; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#29992;&#25143;CPU&#26102;&#38388;</span>
    <span style="color: #98f5ff;">clock_t</span> <span style="color: #4eee94;">tms_stime</span>; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#31995;&#32479;CPU&#26102;&#38388;</span>
    <span style="color: #98f5ff;">clock_t</span> <span style="color: #4eee94;">tms_cutime</span>; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#32456;&#27490;&#30340;&#23376;&#36827;&#31243;&#29992;&#25143;CPU&#26102;&#38388;&#24635;&#21644;</span>
    <span style="color: #98f5ff;">clock_t</span> <span style="color: #4eee94;">tms_cstime</span>;<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#32456;&#27490;&#30340;&#23376;&#36827;&#31243;&#31995;&#32479;CPU&#26102;&#38388;&#24635;&#21644;</span>
};
</pre>
</div>

<pre class="example">
      注意：此结构没有包含墙上时钟时间。作为代替 times函数返回墙上时钟时间作为函数值

     此值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值

     例如调用 times 保存其返回值。在以后某个时间再次调用times，从新返回的值中减去以前返回的值，此差值就是墙上时钟时间
</pre>
</div>

<div id="outline-container-org20449b4" class="outline-4">
<h4 id="org20449b4">打印进程时间实例</h4>
<div class="outline-text-4" id="text-org20449b4">
<p>
将每个命令行参数作为shell命令串执行，对每个命令计时并打印：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/times.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_times</span>(<span style="color: #98f5ff;">clock_t</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span> *, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span> *);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">do_cmd</span>(<span style="color: #98f5ff;">char</span> *);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">i</span>;

    setbuf(stdout, <span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">for</span> (i = 1; i &lt; argc; i++)
        do_cmd(argv[i]);    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">once for each command-line arg </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">do_cmd</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmd</span>)       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">execute and time the "cmd" </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span>  <span style="color: #4eee94;">tmsstart</span>, <span style="color: #4eee94;">tmsend</span>;
    <span style="color: #98f5ff;">clock_t</span>     <span style="color: #4eee94;">start</span>, <span style="color: #4eee94;">end</span>;
    <span style="color: #98f5ff;">int</span>         <span style="color: #4eee94;">status</span>;

    printf(<span style="color: #deb887;">"\ncommand: %s\n"</span>, cmd);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((start = times(&amp;tmsstart)) == -1)   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">starting values </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        err_sys(<span style="color: #deb887;">"times error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((status = system(cmd)) &lt; 0)     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">execute command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        err_sys(<span style="color: #deb887;">"system() error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((end = times(&amp;tmsend)) == -1)       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ending values </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        err_sys(<span style="color: #deb887;">"times error"</span>);

    pr_times(end-start, &amp;tmsstart, &amp;tmsend);
    pr_exit(status);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_times</span>(<span style="color: #98f5ff;">clock_t</span> <span style="color: #4eee94;">real</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span> *<span style="color: #4eee94;">tmsstart</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">tms</span> *<span style="color: #4eee94;">tmsend</span>)
{
    <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">long</span>     <span style="color: #4eee94;">clktck</span> = 0;

    <span style="color: #00bfff; font-weight: bold;">if</span> (clktck == 0)    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">fetch clock ticks per second first time </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> ((clktck = sysconf(_SC_CLK_TCK)) &lt; 0)
            err_sys(<span style="color: #deb887;">"sysconf error"</span>);
    printf(<span style="color: #deb887;">"  real:  %7.2f\n"</span>, real / (<span style="color: #98f5ff;">double</span>) clktck);
    printf(<span style="color: #deb887;">"  user:  %7.2f\n"</span>,
           (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime) / (<span style="color: #98f5ff;">double</span>) clktck);
    printf(<span style="color: #deb887;">"  sys:   %7.2f\n"</span>,
           (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime) / (<span style="color: #98f5ff;">double</span>) clktck);
    printf(<span style="color: #deb887;">"  child user:  %7.2f\n"</span>,
           (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime) / (<span style="color: #98f5ff;">double</span>) clktck);
    printf(<span style="color: #deb887;">"  child sys:   %7.2f\n"</span>,
           (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime) / (<span style="color: #98f5ff;">double</span>) clktck);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/timesExample <span style="color: #deb887;">"cd /usr/include; grep _POSIX_SOURCE */*.h &gt;/dev/null 2&gt;/dev/null"</span>   

<span style="color: #f08080;">command</span>: cd /usr/include; grep _POSIX_SOURCE */*.h &gt;/dev/null 2&gt;/dev/null
  real:     0.04
  user:     0.00
  sys:      0.00
  child user:     0.02
  child sys:      0.01
normal termination, exit status = 2
</pre>
</div>
<p>
在 <span class="underline">child user</span> 和 <span class="underline">child sys</span> 行中显示的时间分别是 <span class="underline">执行shell</span> 和 <span class="underline">命令的子进程</span> <b>所使用的CPU时间</b> 
</p>

<p>
<a href="proc_group.html">Next：进程关系</a>
</p>

<p>
<a href="env.html">Previous：进程环境</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
