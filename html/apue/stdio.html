<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>标准IO</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="file_directory.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">标准IO</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org6891739">标准I/O</a>
<ul>
<li><a href="#orgb82d915">流和FILE对象</a></li>
<li><a href="#orge32191c">标准输入、标准输出和标准出错</a></li>
<li><a href="#org1cb2baf">缓存</a>
<ul>
<li><a href="#orgb9f1ccd">全缓存</a></li>
<li><a href="#org0a09a09">行缓存</a></li>
<li><a href="#org82826b3">不带缓存</a></li>
<li><a href="#org310ffe4">默认实现</a></li>
<li><a href="#org4a02882">setbuf和setvbuf函数</a></li>
<li><a href="#org66c6da9">fflush函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4cc61fd">流操作</a>
<ul>
<li><a href="#orgaaa9823">打开流</a>
<ul>
<li><a href="#org858c124">流读写方式</a></li>
</ul>
</li>
<li><a href="#org04b9e44">关闭流</a></li>
<li><a href="#org793ac0c">读写流</a>
<ul>
<li><a href="#orgb19b04f">单字符I/O</a>
<ul>
<li><a href="#org1b4102f">getc, fgetc, getchar函数</a></li>
<li><a href="#org08ecea1">EOF判断</a></li>
<li><a href="#org9961ad7">清除EOF标记</a></li>
<li><a href="#orga2c7a22">putc, fputc, putchar函数</a></li>
<li><a href="#org3e761d4">ungetc函数</a></li>
</ul>
</li>
<li><a href="#orgca8e9f1">行I/O</a>
<ul>
<li><a href="#orgc465cad">fgets, gets函数</a></li>
<li><a href="#org171b5f0">fputs, puts函数</a></li>
</ul>
</li>
<li><a href="#org0877090">标准I/O效率比较</a></li>
<li><a href="#org43056f0">二进制I/O</a>
<ul>
<li><a href="#org70b5a7c">读或写一个二进制数组</a></li>
<li><a href="#org4187893">读或写一个结构</a></li>
<li><a href="#org6181fc9">二进制I/O代码不可移植</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbba667b">定位流</a>
<ul>
<li><a href="#orgeedeaca">Unix</a></li>
<li><a href="#orga700cda">ANSI</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgefbaa17">格式化I/O</a>
<ul>
<li><a href="#orge1973b3">格式化输出</a>
<ul>
<li><a href="#orga0ed086">可变参数列表版本</a></li>
</ul>
</li>
<li><a href="#orgc60a279">格式化输入</a>
<ul>
<li><a href="#orga1cdc26">可变参数列表版本</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbde9e95">实现细节</a>
<ul>
<li><a href="#orgd2af1ee">fileno</a>
<ul>
<li><a href="#orgf8382f4">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4c1d451">临时文件</a>
<ul>
<li><a href="#orgc064d0e">tmpnam, tmpfile</a>
<ul>
<li><a href="#org3d74a0b">实例</a></li>
</ul>
</li>
<li><a href="#orge526f55">tempnam</a>
<ul>
<li><a href="#orgbd4189d">实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example" id="org7495edf">
本章说明标准I/O库

因为不仅在UNIX而且在很多操作系统上都实现此库，所以它由ANSIC标准说明

标准I/O库处理很多细节，例如缓存分配，以优化长度执行I/O等

标准I/O库是在系统调用函数基础上构造的 
</pre>

<div id="outline-container-org6891739" class="outline-2">
<h2 id="org6891739">标准I/O</h2>
<div class="outline-text-2" id="text-org6891739">
<pre class="example" id="org1cd09dc">
前一章中所有I/O函数都是针对文件描述符的

当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后读的I/O操作
</pre>

<p>
对于标准I/O库，它们的操作则是围绕 <span class="underline">流</span> (stream)进行的。当用标准I/O库打开或创建一个文件时已 <b>使一个流与一个文件</b> 相结合。当打开一个流时，标准I/O函数 <b>fopen</b> 返回一个 <b>指向FILE对象的指针</b> 
</p>
</div>

<div id="outline-container-orgb82d915" class="outline-3">
<h3 id="orgb82d915">流和FILE对象</h3>
<div class="outline-text-3" id="text-orgb82d915">
<ul class="org-ul">
<li>FILE对象: 通常是一个结构，包含了I/O库为 <b>管理流所需要的所有信息</b> 
<ul class="org-ul">
<li>用于实际I/O的文件描述符</li>
<li>指向流缓存的指针</li>
<li>缓存的长度</li>
<li>当前在缓存中的字符数</li>
<li>出错标志</li>
<li>&#x2026;&#x2026;</li>
</ul></li>
<li>文件指针：指向FILE对象的指针 FILE* 　</li>
</ul>

<pre class="example" id="org6e8ff27">
为了引用一个流，需将文件指针作为参数传递给每个标准I/O函数
</pre>
</div>
</div>

<div id="outline-container-orge32191c" class="outline-3">
<h3 id="orge32191c">标准输入、标准输出和标准出错</h3>
<div class="outline-text-3" id="text-orge32191c">
<p>
对一个进程预定义了三个流，它们自动地可为进程使用：
</p>
<ul class="org-ul">
<li>stdin: 标准输入流</li>
<li>stdout: 标准输出流</li>
<li>stderr: 标准出错流</li>
</ul>

<pre class="example" id="org3cc01c3">
这三个标准I/O流和文件指针同样定义在头文件 &lt;stdio.h&gt; 中
</pre>
</div>
</div>

<div id="outline-container-org1cb2baf" class="outline-3">
<h3 id="org1cb2baf">缓存</h3>
<div class="outline-text-3" id="text-org1cb2baf">
<p>
标准I/O提供缓存的目的是 <b>尽可能减少使用read和write调用的数量</b> 。它也对每个I/O流 <b>自动地进行缓存管理</b> ，简化了应用程序的实现
</p>
<pre class="example" id="org794ac62">
在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用 malloc 获得需要的缓存
</pre>
<p>
标准I/O提供了三种类型的缓存: 
</p>
<ol class="org-ol">
<li>全缓存</li>
<li>行缓存</li>
<li>无缓存</li>
</ol>
</div>

<div id="outline-container-orgb9f1ccd" class="outline-4">
<h4 id="orgb9f1ccd">全缓存</h4>
<div class="outline-text-4" id="text-orgb9f1ccd">
<p>
当 <b>填满标准I/O缓存</b> 后才进行实际I/O操作
</p>
<pre class="example" id="org28c897b">
对于驻在“磁盘上的文件”通常是由标准I/O库实施全缓存的
</pre>
</div>
</div>
<div id="outline-container-org0a09a09" class="outline-4">
<h4 id="org0a09a09">行缓存</h4>
<div class="outline-text-4" id="text-org0a09a09">
<p>
当在输入和输出中 <b>遇到新行符</b> 时，标准I/O库执行I/O操作。这允许一次输出一个字符(用标准I/O fputc函数)，但只有 <b>在写了一行之后</b> 才进行实际I/O操作
</p>

<pre class="example" id="org305f163">
当流涉及一个“终端”时(例如标准输入和标准输出)，典型地使用行缓存
</pre>

<p>
对于行缓存有两个限制：
</p>
<ol class="org-ol">
<li>因为标准I/O库用来 <b>收集每一行的缓存的长度是固定的</b> ，所以只要填满了缓存，那么 <b>即使还没有写一个新行符，也进行I/O操作</b></li>
<li>任何时候只要通过标准输入输出库要求从以下两种情况得到数据就会造成 <b>刷新所有行缓存输出流</b> 
<ul class="org-ul">
<li>一个 <span class="underline">不带缓存</span> 的流：从不带缓存的一个流中进行输入要求 <b>只能从内核得到数据</b></li>
<li>一个 <span class="underline">行缓存</span> 的流(它预先要求从内核得到数据)：所需的数据可能已在该缓存中，但 <b>并不要求内核在需要该数据时才进行该操作</b></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org82826b3" class="outline-4">
<h4 id="org82826b3">不带缓存</h4>
<div class="outline-text-4" id="text-org82826b3">
<p>
标准I/O库 <b>不对字符进行缓存</b> 。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。
</p>

<pre class="example" id="org129c8e6">
“标准出错流stderr”通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符
</pre>
</div>
</div>

<div id="outline-container-org310ffe4" class="outline-4">
<h4 id="org310ffe4">默认实现</h4>
<div class="outline-text-4" id="text-org310ffe4">
<pre class="example" id="orga224073">
ANSIC要求下列缓存特征:

1. 当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的
2. 标准出错决不会是全缓存的
</pre>

<p>
UNIX系统默认使用下列类型的缓存:
</p>
<ol class="org-ol">
<li><span class="underline">标准出错</span> 是 <span class="underline">不带缓存</span> 的</li>
<li>如若是涉及 <span class="underline">终端设备</span> 的其他流，则它们是 <span class="underline">行缓存</span> 的</li>
<li>否则是 <span class="underline">全缓存</span> 的</li>
</ol>
</div>
</div>

<div id="outline-container-org4a02882" class="outline-4">
<h4 id="org4a02882">setbuf和setvbuf函数</h4>
<div class="outline-text-4" id="text-org4a02882">
<p>
setbuf和setvbuf函数：设置文件流的缓存
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#25171;&#24320;&#25110;&#20851;&#38381;&#25991;&#20214;&#27969;&#32531;&#23384;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * buf: &#32531;&#23384;&#21306;&#25351;&#38024;&#65292;&#22914;&#26524;&#20026;NULL&#21017;&#20851;&#38381;&#32531;&#23384;&#65292;&#21453;&#20043;&#21017;&#25171;&#24320;&#32531;&#23384;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0, &#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setbuf</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">buf</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35774;&#32622;&#25991;&#20214;&#27969;&#30340;&#32531;&#23384;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * buf: &#32531;&#23384;&#21306;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * mode: &#32531;&#23384;&#31867;&#22411;&#65292;_IOFBF &#20840;&#32531;&#23384;&#65292;_IOLBF &#34892;&#32531;&#23384;, _IONBF &#19981;&#24102;&#32531;&#23384;</span>
<span style="color: #ffebcd;"> * size: &#32531;&#23384;&#21306;&#22823;&#23567;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setvbuf</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">buf</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mode</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>); 
</pre>
</div>

<p>
setbuf和setvbuf参数说明
</p>

<!-- This HTML table template is generated by emacs 29.4 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;函数&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;mode&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存及长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;缓存类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;setbuf&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;nonNULL&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      长度为BUFSIZE的用户缓存
    </td>
    <td align="left" valign="top">
      &nbsp;全缓存或行缓存&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;　　无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="5" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;setvbuf&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;_IOFBF&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;nonNULL&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;长度为size的用户缓存&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;全缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;合适长度的系统缓存&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;_IOLBF&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;nonNULL&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;长度为size的用户缓存&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;行缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;合适长度的系统缓存&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;_IONBF&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;忽略&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-org66c6da9" class="outline-4">
<h4 id="org66c6da9">fflush函数</h4>
<div class="outline-text-4" id="text-org66c6da9">
<pre class="example" id="orgb012504">
刷新(flush)：标准I/O缓存的写操作。缓存可由：

标准I/O例程自动地刷新 ：例如当填满一个缓存时，或者可以调用函数fflush刷新一个流 
</pre>

<p>
fflush：强制刷新一个流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#24378;&#21046;&#21047;&#26032;&#19968;&#20010;&#27969;&#65292;&#22914;&#26524;fp&#20026;NULL&#21017;&#21047;&#26032;&#25152;&#26377;&#36755;&#20986;&#27969;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fflush</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
此函数使该流 <span class="underline">所有未写的数据</span> 都被 <b>传递</b> 至 <span class="underline">内核</span>  
</p>
<ul class="org-ul">
<li>作为一种特殊情形如若 <span class="underline">fp是NULL</span> ，则 <b>刷新所有 <span class="underline">输出</span> 流</b></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org4cc61fd" class="outline-2">
<h2 id="org4cc61fd">流操作</h2>
<div class="outline-text-2" id="text-org4cc61fd">
</div>
<div id="outline-container-orgaaa9823" class="outline-3">
<h3 id="orgaaa9823">打开流</h3>
<div class="outline-text-3" id="text-orgaaa9823">
<p>
以下三个函数用于打开一个I/O流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26681;&#25454;&#25991;&#20214;&#36335;&#24452;&#21517;&#25171;&#24320;IO&#27969;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pathname: &#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffebcd;"> * type: &#35813;I/O&#27969;&#30340;&#35835;&#12289;&#20889;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">fopen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#22312;&#19968;&#20010;&#29305;&#23450;&#30340;&#27969;&#19978;&#25171;&#24320;&#19968;&#20010;&#25351;&#23450;&#30340;&#25991;&#20214;&#65292;&#22914;&#26524;&#27969;&#24050;&#32463;&#25171;&#24320;&#65292;&#37027;&#20808;&#20851;&#38381;&#27969;&#20877;&#25171;&#24320;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pathname: &#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffebcd;"> * type: &#35813;I/O&#27969;&#30340;&#35835;&#12289;&#20889;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> * fp: &#29305;&#23450;&#30340;&#27969;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">freopen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26681;&#25454;&#25991;&#20214;&#25551;&#36848;&#31526;&#25171;&#24320;IO&#27969;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * filedes: &#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> * type: &#35813;I/O&#27969;&#30340;&#35835;&#12289;&#20889;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">fdopen</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>);
</pre>
</div>
<ul class="org-ul">
<li>fopen打开 <span class="underline">指定路径名</span> 的一个文件</li>
<li>freopen在一个特定的流上打开一个指定的文件，如若该流 <span class="underline">已经打开</span> ，则先 <b>关闭该流</b></li>
</ul>
<pre class="example" id="orgf6a5174">
一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准出错
</pre>
<ul class="org-ul">
<li>fdopen取一个现存的 <span class="underline">文件描述符</span> ，并使一个标准的I/O流与该描述符相结合</li>
</ul>
<pre class="example" id="orgd38c694">
 常用于由创建管道和网络通信通道函数获得的插述符

因为这些特殊类型的文件不能用标准I/O的fopen函数打开，首先必须先调用设备专用函数以获得一个文件描述符
</pre>
</div>
<div id="outline-container-org858c124" class="outline-4">
<h4 id="org858c124">流读写方式</h4>
<div class="outline-text-4" id="text-org858c124">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 打开标准I/O流的type参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">r或rb</td>
<td class="org-left">为读而打开</td>
</tr>

<tr>
<td class="org-left">w或wb</td>
<td class="org-left">使文件成为0长，或为写而创建</td>
</tr>

<tr>
<td class="org-left">a或ab</td>
<td class="org-left">添加;为在文件尾写而打开，或为写而创建</td>
</tr>

<tr>
<td class="org-left">r+或r+b或rb+</td>
<td class="org-left">为读和写而打开</td>
</tr>

<tr>
<td class="org-left">w+或w+b或wb+</td>
<td class="org-left">使文件为0长，或为读和写而打开</td>
</tr>

<tr>
<td class="org-left">a+或a+b或ab+</td>
<td class="org-left">为在文件尾读和写而打开或创建</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>字符 <span class="underline">b</span> 作为type的一部分，使得标准I/O可以区分 <b>文本文件</b> 和 <b>二进制文件</b></li>
</ul>
<pre class="example" id="orgab358a8">
但是UNIX并不对这两种文件进行区分，所以无意义
</pre>
<ul class="org-ul">
<li>在使用 <span class="underline">w</span> 或 <span class="underline">a</span> 选项时，若文件 <b>不存在则自动创建</b></li>
</ul>
<pre class="example" id="org1adce75">
新建文件的访问模式只能通过进程的umask限制，而无法手动指定权限
</pre>
<ul class="org-ul">
<li>当用字符 <span class="underline">a</span> 打开一文件后，则每次写都将数据 <b>写到文件的当前尾端处</b></li>
</ul>
<pre class="example" id="org6f89c9a">
如若有多个进程用添加方式打开了同一文件，那么每个进程的数据都将正确地写到文件中
</pre>
<ul class="org-ul">
<li>当以 <span class="underline">r+</span> 或者 <span class="underline">w+</span> 时，具有下列限制: 
<ul class="org-ul">
<li>如果中间没有 <span class="underline">fflush</span> 、 <span class="underline">fseek</span> 、 <span class="underline">fsetpos</span> 或 <span class="underline">rewind</span> ，则在 <b>输出的后面不能直接跟随输入</b></li>
<li>如果中间没有 <span class="underline">fseek</span> 、 <span class="underline">fsetpos</span> 或 <span class="underline">rewind</span> 或者一个 <span class="underline">输出操作没有到达文件尾端</span> ，则在 <b>输入操作之后不能直接跟随输出</b></li>
</ul></li>
<li>对于 <span class="underline">fdopen</span> 选项 <span class="underline">w</span> <b>不能截文件为0</b> ，而由 <b>filedes的open函数决定</b></li>
</ul>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 打开标准I/O流的六种方式</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">限制</th>
<th scope="col" class="org-left">r</th>
<th scope="col" class="org-left">w</th>
<th scope="col" class="org-left">a</th>
<th scope="col" class="org-left">r+</th>
<th scope="col" class="org-left">w+</th>
<th scope="col" class="org-left">a+</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">文件必须已存在</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">文件截断为0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">流可以读</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流可以写</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流只可以在尾部写</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org04b9e44" class="outline-3">
<h3 id="org04b9e44">关闭流</h3>
<div class="outline-text-3" id="text-org04b9e44">
<p>
fclose：关闭一个打开的流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20851;&#38381;&#19968;&#20010;&#24320;&#25171;&#30340;&#27969;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fclose</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<ul class="org-ul">
<li>在文件被关闭之前， <b>刷新缓存中的输出数据</b> ， <b>缓存中的输入数据被丢弃</b></li>
<li>如果标准I/O库已经为该流自动分配了一个缓存，则 <b>释放此缓存</b></li>
</ul>

<pre class="example" id="org5960705">
当一个进程正常终止时，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭
</pre>
</div>
</div>
<div id="outline-container-org793ac0c" class="outline-3">
<h3 id="org793ac0c">读写流</h3>
<div class="outline-text-3" id="text-org793ac0c">
<p>
一旦打开了流，则可在三种不同类型的 <span class="underline">非格式化I/O</span> 中进行选择，对其进行读、写操作：
</p>
<ol class="org-ol">
<li>每次 <span class="underline">一个字符</span> 的I/O：一次 <b>读或写一个字符</b></li>
<li>每次 <span class="underline">一行</span> 的I/O：一次 <b>读或写一行</b> 。每行都以一个 <b>新行符</b> 终止</li>
<li>直接I/O或 <span class="underline">二进制</span> I/O：每次I/O操作 <b>读或写某种数量的对象</b> ，而 <b>每个对象具有指定的长度</b></li>
</ol>
</div>

<div id="outline-container-orgb19b04f" class="outline-4">
<h4 id="orgb19b04f">单字符I/O</h4>
<div class="outline-text-4" id="text-orgb19b04f">
<p>
如果 <span class="underline">流是带缓存</span> 的，则 <b>标准I/O函数处理所有缓存</b> 
</p>
</div>
<div id="outline-container-org1b4102f" class="outline-5">
<h5 id="org1b4102f">getc, fgetc, getchar函数</h5>
<div class="outline-text-5" id="text-org1b4102f">
<p>
从文件流读取单个字符
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#25991;&#20214;&#25351;&#38024;&#35835;&#21462;&#19968;&#20010;&#23383;&#31526;&#65292;&#21487;&#20197;&#23454;&#29616;&#20026;&#23439;&#65292;&#25928;&#29575;&#22909;&#20110;fgetc</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#19979;&#19968;&#20010;&#23383;&#31526;&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getc</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#25991;&#20214;&#25351;&#38024;&#35835;&#21462;&#19968;&#20010;&#23383;&#31526;&#65292;&#19981;&#33021;&#23454;&#29616;&#20026;&#23439;&#65292;&#25928;&#29575;&#27604;getc&#24046;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#19979;&#19968;&#20010;&#23383;&#31526;&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fgetc</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#26631;&#20934;&#36755;&#20837;&#35835;&#20837;&#19968;&#20010;&#23383;&#31526;&#65292;&#31561;&#20215;&#20110;getc(stdin)</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#19979;&#19968;&#20010;&#23383;&#31526;&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getchar</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
<ul class="org-ul">
<li>getc可以 <b>实现为宏</b></li>
</ul>
<pre class="example" id="orgc10ed38">
所以它的参数不应当是具有副作用的表达式
</pre>
<ul class="org-ul">
<li>调用fgetc所需时间很可能长于调用getc</li>
</ul>
<pre class="example" id="org3a082c9">
因为调用函数通常所需的时间长于调用宏
</pre>
<ul class="org-ul">
<li>因为fgetc <b>一定是个函数</b> ，可以得到其地址</li>
</ul>
<pre class="example" id="orgd7364db">
允许将fgetc的地址作为一个参数传送给另一个函数
</pre>
<ul class="org-ul">
<li>getchar()等价于 <b>getc(stdin)</b></li>
</ul>

<p>
这三个函数以 <span class="underline">unsigned char类型转换为int的方式</span> 返回下一个字符。这样就可以 <b>返回所有可能的字符值再加上一个 <span class="underline">已发生错误</span> 或 <span class="underline">已到达文件尾端</span> 的指示值</b> 
</p>

<pre class="example" id="org98f2750">
在&lt;stdio.h&gt;中的常数EOF被要求是一个负值，其值经常是 -1

所以不能返回结果是一个无符号字符，而必须是一个带符号整数
</pre>
</div>
</div>

<div id="outline-container-org08ecea1" class="outline-5">
<h5 id="org08ecea1">EOF判断</h5>
<div class="outline-text-5" id="text-org08ecea1">
<p>
不管是出错还是到达文件尾端，这三个函数都返回同样的值 <b>EOF</b>  。为了区分这两种不同的情况，必须调用 <span class="underline">ferror</span> 或 <span class="underline">feof</span> 函数：
</p>

<ul class="org-ul">
<li>ferror函数：判断读取文件 <b>是否出错</b></li>
<li>feop函数：判断读取文件 <b>是否结束</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35835;&#21462;&#25991;&#20214;&#26159;&#21542;&#20986;&#38169;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#35835;&#21462;&#20986;&#38169;&#21017;&#20026; &#38750;0(&#30495;)&#65292;&#21542;&#21017;&#20026; 0(&#20551;)</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">ferror</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#25991;&#20214;&#26159;&#21542;&#32467;&#26463;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25991;&#20214;&#32467;&#26463;&#21017;&#20026; &#38750;0(&#30495;)&#65292;&#21542;&#21017;&#20026; 0(&#20551;)</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">feof</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org9961ad7" class="outline-5">
<h5 id="org9961ad7">清除EOF标记</h5>
<div class="outline-text-5" id="text-org9961ad7">
<pre class="example" id="org9707cc7">
在大多数实现的 FILE对象 中，为每个流保持了两个标志：出错标志 和 文件结束标志 
</pre>

<p>
clearerr函数：清除这两个标志
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#28165;&#26970;&#25991;&#20214;&#20986;&#38169;&#21644;&#32467;&#23614;&#20004;&#20010;&#26631;&#24535;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * &#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">clearerr</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orga2c7a22" class="outline-5">
<h5 id="orga2c7a22">putc, fputc, putchar函数</h5>
<div class="outline-text-5" id="text-orga2c7a22">
<p>
输出单个字符到文件流     
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36755;&#20986;&#19968;&#20010;&#23383;&#31526;&#21040;&#27969;&#65292;&#21487;&#23454;&#29616;&#20026;&#23439;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * c: &#36755;&#20986;&#23383;&#31526;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">putc</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36755;&#20986;&#19968;&#20010;&#23383;&#31526;&#21040;&#27969;&#65292;&#21482;&#21487;&#23454;&#29616;&#20026;&#20989;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * c: &#36755;&#20986;&#23383;&#31526;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fputc</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36755;&#20986;&#19968;&#20010;&#23383;&#31526;&#21040;&#26631;&#20934;&#36755;&#20986;&#27969;&#65292;&#31561;&#20215;&#20110;putc(c, stdout)</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * c: &#36755;&#20986;&#23383;&#31526;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">putchar</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>);
</pre>
</div>

<ul class="org-ul">
<li>putc可以实现为 <span class="underline">宏</span></li>
<li>fputc只能实现为 <span class="underline">函数</span></li>
<li>putchar(c)等价于 <span class="underline">putc(c, stdout)</span></li>
</ul>
</div>
</div>

<div id="outline-container-org3e761d4" class="outline-5">
<h5 id="org3e761d4">ungetc函数</h5>
<div class="outline-text-5" id="text-org3e761d4">
<p>
ungetc函数：将字符压入流中
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23558;&#23383;&#31526;&#21387;&#20837;&#27969;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * c: &#21387;&#20837;&#30340;&#23383;&#31526;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">ungetc</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
<span class="underline">下次读取字符</span> 读到的就是 <b>被ungetc压入的字符</b> ：
</p>
<ul class="org-ul">
<li>回送的字符不一定必须是上一次读到的字符</li>
<li>EOF不能回送</li>
</ul>
<pre class="example" id="org3357783">
当已经到达文件尾端时仍可以回送一个字符。下次读将返回该字符，再次读则返回EOF
能这样做的原因是一次成功的ungetc调用会清除该流的文件结束指示

有时读到第一个特殊字符时候，这个字符往往暂时没有用，需要先放回去，等处理完前面读出的数据后，再开始重新读
</pre>
</div>
</div>
</div>

<div id="outline-container-orgca8e9f1" class="outline-4">
<h4 id="orgca8e9f1">行I/O</h4>
<div class="outline-text-4" id="text-orgca8e9f1">
</div>
<div id="outline-container-orgc465cad" class="outline-5">
<h5 id="orgc465cad">fgets, gets函数</h5>
<div class="outline-text-5" id="text-orgc465cad">
<p>
从文件流读取一行到缓存区
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#19968;&#20010;&#27969;&#35835;&#21462;&#19968;&#34892;&#21040;&#26368;&#22810; n-1 &#20010;&#23383;&#31526;&#21040;&#32531;&#23384;&#21306;buf&#65292;&#32531;&#23384;&#21306;&#20197; null &#23383;&#31526;&#32467;&#26463;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * buf: &#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;"> * n: &#35835;&#21462;&#23383;&#31526;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> * return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026; buf&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">fgets</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">n</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#26631;&#20934;&#36755;&#20837;&#35835;&#21462;&#19968;&#34892;&#21040;&#21040;&#32531;&#23384;&#21306;buf</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * buf: &#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; buf&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">gets</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>);
</pre>
</div>

<ul class="org-ul">
<li>fgets函数：
<ul class="org-ul">
<li><b>必须指定缓存的长度n</b> 。一直读到 <b>下一个新行符</b> 为止，但是 <b>不超过n-1个字符</b></li>
<li>读入的字符 <b>被送入缓存</b> 。该 <b>缓存以 null 字符结尾</b></li>
<li>如若 <span class="underline">该行包括最后一个新行符的字符数超过n-1</span> ，则只 <b>返回一个不完整的行</b> ，而且 <b>缓存总是以null字符结尾</b> 
<ul class="org-ul">
<li>对fgets的下一次调用会继续读该行</li>
</ul></li>
</ul></li>
<li>gets直接 <b>从标准输入流读取</b> 
<ul class="org-ul">
<li>会有验证 <span class="underline">缓存区溢出</span> 的问题</li>
<li>缓存区 <span class="underline">也不会以null字符结尾</span></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org171b5f0" class="outline-5">
<h5 id="org171b5f0">fputs, puts函数</h5>
<div class="outline-text-5" id="text-org171b5f0">
<p>
缓存区输出一行到文件流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36755;&#20986;&#19968;&#20010;&#20197; null&#32467;&#23614; &#30340;&#23383;&#31526;&#20018;&#21040;&#25991;&#20214;&#27969;&#65292;&#32456;&#27490;&#31526; null &#19981;&#36755;&#20986;&#65292;&#26032;&#34892;&#31526; \n &#38656;&#35201;&#21253;&#21547;&#22312;&#23383;&#31526;&#20018;&#20869;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * str: &#36755;&#20986;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#36755;&#20986;&#30340;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fputs</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36755;&#20986;&#19968;&#20010; null&#32467;&#23614; &#30340;&#23383;&#31526;&#20018;&#21040;&#26631;&#20934;&#36755;&#20986;&#27969;&#65292;&#32456;&#27490;&#31526; null &#19981;&#36755;&#20986;&#65292;&#33258;&#21160;&#22312;&#26368;&#21518;&#28155;&#21152;&#26032;&#34892;&#31526; \n</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * str: &#36755;&#20986;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;&#36755;&#20986;&#30340;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">puts</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>);
</pre>
</div>

<ul class="org-ul">
<li>fputs函数：将一个以 <span class="underline">null符终止</span> 的 <span class="underline">字符串</span> 写到 <span class="underline">指定的流</span> 
<ul class="org-ul">
<li><b>终止符null不写出</b></li>
<li>必须 <b>手动</b> 在字符串包含 <span class="underline">新行符\n</span></li>
</ul></li>
<li>puts函数：将一个以 <span class="underline">null符终止的字符串</span> 写到 <span class="underline">标准输出</span>
<ul class="org-ul">
<li><b>终止符null不写出</b></li>
<li><b>自动</b> 在最后将一个 <span class="underline">新行符\n</span> 写到 <span class="underline">标准输出</span></li>
</ul></li>
</ul>

<pre class="example" id="orgae3f632">
puts函数不像gets函数那么不安全，但也最好尽量避免使用
</pre>
</div>
</div>
</div>

<div id="outline-container-org0877090" class="outline-4">
<h4 id="org0877090">标准I/O效率比较</h4>
<div class="outline-text-4" id="text-org0877090">
<p>
用getc和putc将标准输入复制到标准输出
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>;
        <span style="color: #00bfff; font-weight: bold;">while</span> ( (c = getc(stdin)) != EOF)
                <span style="color: #00bfff; font-weight: bold;">if</span>((putc(c, stdout)) == EOF)
                        err_sys(<span style="color: #deb887;">"output error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(ferror(stdin))
                err_sys(<span style="color: #deb887;">"input error"</span>);

        exit(0);

}
</pre>
</div>
<p>
用fgets和fputs将标准输入复制到标准输出
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[MAXLINE];

        <span style="color: #00bfff; font-weight: bold;">while</span>(<span style="color: #ffd700;">NULL</span> != fgets(buf, MAXLINE, stdin))
                <span style="color: #00bfff; font-weight: bold;">if</span>(EOF == fputs(buf, stdout))
                        err_sys(<span style="color: #deb887;">"output error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(ferror(stdin))
                err_sys(<span style="color: #deb887;">"input error"</span>);

        exit(0);

}
</pre>
</div>

<p>
表5-3中显示了对同一文件(1.5M字节，30，000行)进行操作所得的数据
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 使用标准I/O例程得到的时间结果</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数</td>
<td class="org-right">用户CPU(秒)</td>
<td class="org-right">系统CPU(秒)</td>
<td class="org-right">时钟时间(秒)</td>
<td class="org-right">程序正文字节数</td>
</tr>

<tr>
<td class="org-left">表3.1中的最佳时间</td>
<td class="org-right">0.0</td>
<td class="org-right">0.3</td>
<td class="org-right">0.3</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">fgets,fputs</td>
<td class="org-right">2.2</td>
<td class="org-right">0.3</td>
<td class="org-right">2.6</td>
<td class="org-right">184</td>
</tr>

<tr>
<td class="org-left">getc,putc</td>
<td class="org-right">4.3</td>
<td class="org-right">0.3</td>
<td class="org-right">4.8</td>
<td class="org-right">384</td>
</tr>

<tr>
<td class="org-left">fgetc,fputc</td>
<td class="org-right">4.6</td>
<td class="org-right">0.3</td>
<td class="org-right">5.0</td>
<td class="org-right">152</td>
</tr>

<tr>
<td class="org-left">表3.1中的单字节时间</td>
<td class="org-right">23.8</td>
<td class="org-right">397.9</td>
<td class="org-right">423.4</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>对于这三个标准I/O版本的每一个，其 <b>用户CPU时间都大于表3-1中的最佳read版本</b> 
<ul class="org-ul">
<li>每次读一个字符版本中有一个要 <span class="underline">执行150万次的循环</span></li>
<li>每次读一行的版本中有一个要 <span class="underline">执行30000次的循环</span></li>
<li>在read版本中，其循环只需执行 <span class="underline">180次</span> (对于缓存长度为8192字节)</li>
</ul></li>
<li>因为系统CPU时间都相同，所以 <b>用户CPU时间差别造成了时钟时间差别</b> 
<ul class="org-ul">
<li>因为所有这些程序对 <b>内核提出的读、写请求数相同</b></li>
<li>标准IO已经选择了 <span class="underline">最佳IO长度</span> ，只需要考虑 <b>fgets时最大行长度</b></li>
</ul></li>
<li>最后一列是 <span class="underline">每个main函数的文本空间字节数</span> (由C编译产生的机器指令)
<ul class="org-ul">
<li>使用getc的版本在文本空间中作了getc和putc的宏代换 
<ul class="org-ul">
<li>所以它所需使用的 <b>指令数超过了调用fgetc和fputc函数所需指令数</b></li>
<li>但是在程序中作 <b>宏代换和调用两个函数在时间上并没有多大差别</b></li>
</ul></li>
</ul></li>
</ul>


<p>
fgetc版本较表3-1中BUFFSIZE=1的版本要快得多。两者都使用了 <span class="underline">约3百万次的函数调用</span> ，而fgetc版本的速度在用户CPU时间方面，大约是后者的5倍，而在时钟时间方面则几乎是100倍。原因是：
</p>
<ul class="org-ul">
<li>使用read的版本 <b>执行了3百万次系统调用</b></li>
<li>而对于fgetc版本，它也执行3百万次函数调用，但是这只引起 <b>360次系统调用</b></li>
</ul>

<pre class="example" id="orgb64b523">
系统调用与普通的函数调用相比是很花费时间的
</pre>

<p>
总而言之： <b>标准IO与直接内核调用比起来并不慢很多，但却可以忽略不少细节！</b> 
</p>
</div>
</div>

<div id="outline-container-org43056f0" class="outline-4">
<h4 id="org43056f0">二进制I/O</h4>
<div class="outline-text-4" id="text-org43056f0">
<pre class="example" id="org86884cf">
如果想要读写某个结构，必须使用 fgetc 或者 fputc 一次读写一个字符来遍历整个结构
因为 fputs 在遇到null 字节时就停止，而在结构中可能含有 null 字节，所以不能使用每次一行函数
类似地如果输入数据中包含有null字节或新行符，则fgets也不能正确工作

但是每次单个读写字符即不方便也不高效
</pre>
<p>
标准I/O库提供了以下两个函数来支撑面向结构化的I/O
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#25991;&#20214;&#25351;&#38024; fp &#35835;&#21462; nobj &#20010;&#35760;&#24405;&#21040; ptr &#20013;&#65292;&#20854;&#20013;&#27599;&#20010;&#35760;&#24405;&#30340;&#38271;&#24230;&#20026; size</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * ptr: &#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;"> * size: &#27599;&#26465;&#35760;&#24405;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> * nobj: &#35760;&#24405;&#20010;&#25968;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#35835;&#30340;&#23545;&#35937;&#25968;&#65292;&#22914;&#26524;&#25968;&#37327;&#23567;&#20110; nobj&#65292;&#24212;&#36890;&#36807; feof &#25110; ferror &#21028;&#26029;&#32467;&#26524;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">size_t</span> <span style="color: #daa520; font-weight: bold;">fread</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nobj</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);


<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#32531;&#23384;&#21306; ptr &#20013;&#21462; nobj &#20010;&#35760;&#24405;&#20889;&#21040; fp &#25351;&#21521;&#30340;&#25991;&#20214;&#27969;&#20013;&#65292;&#20854;&#20013;&#27599;&#20010;&#35760;&#24405;&#30340;&#38271;&#24230;&#20026; size</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * ptr: &#32531;&#23384;&#21306;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * size: &#27599;&#26465;&#35760;&#24405;&#30340;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> * nobj: &#35760;&#24405;&#30340;&#20010;&#25968;</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#20889;&#30340;&#25968;&#37327;&#65292;&#22914;&#26524;&#23567;&#20110; nobj&#65292;&#19968;&#33324;&#26159;&#20986;&#38169;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">size_t</span> <span style="color: #daa520; font-weight: bold;">fwrite</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nobj</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
fread和fwrite返回读或写的对象数：
</p>
<ul class="org-ul">
<li>对于读，如果 <span class="underline">出错</span> 或到达 <span class="underline">文件尾端</span> ，则此 <b>数字可以少于nobj</b></li>
</ul>
<pre class="example" id="org63c70b4">
在这种情况，应调用ferror或feof以判断究竟是那一种情况
</pre>
<ul class="org-ul">
<li>对于写，如果 <span class="underline">返回值少于所要求的nobj</span> ，则 <b>出错</b></li>
</ul>
</div>

<div id="outline-container-org70b5a7c" class="outline-5">
<h5 id="org70b5a7c">读或写一个二进制数组</h5>
<div class="outline-text-5" id="text-org70b5a7c">
<p>
将一个浮点数组的第 2至第 5个元素写至一个文件上
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">float</span> <span style="color: #4eee94;">data</span> [10];

<span style="color: #00bfff; font-weight: bold;">if</span>(fwrite (&amp;data[2], <span style="color: #00bfff; font-weight: bold;">sizeof</span>(<span style="color: #98f5ff;">float</span>), 4, fp) != 4)
        err_sys(<span style="color: #deb887;">"fwrite error"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4187893" class="outline-5">
<h5 id="org4187893">读或写一个结构</h5>
<div class="outline-text-5" id="text-org4187893">
<p>
读写自定义item结构
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> 
{
        <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">count</span>;
        <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">total</span>;
        <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">name</span>[NAMESIZE];
} <span style="color: #4eee94;">item</span>;

<span style="color: #00bfff; font-weight: bold;">if</span>(fwrite(&amp;item, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(item), 1, fp) != 1)
        err_sys(<span style="color: #deb887;">"fwrite error"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org6181fc9" class="outline-5">
<h5 id="org6181fc9">二进制I/O代码不可移植</h5>
<div class="outline-text-5" id="text-org6181fc9">
<pre class="example" id="org00b12e8">
二进制I/O只能用于读已写在同一系统上的数据。其原因是:

1. 在一个结构中同一成员的位移量可能随编译程序和系统的不同而异(由于不同的对准要求)
某些编译程序有一选择项允许紧密包装结构(节省存储空间，而运行性能则可能有所下降)或准确对齐(以便在运行时易于存取结构中的各成员)
这意味着即使在单系统上，一个结构的二进制存放方式也可能因编译程序的选择项而不同

2. 用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbba667b" class="outline-3">
<h3 id="orgbba667b">定位流</h3>
<div class="outline-text-3" id="text-orgbba667b">
<p>
有两种方法定位标准I/O流：
</p>
<ol class="org-ol">
<li><span class="underline">ftell</span> 和 <span class="underline">fseek</span> ：假定 <span class="underline">文件的位置</span> 可以存放在一个 <span class="underline">long变量</span> 中， <b>适用于Unix系统</b></li>
<li><b>fgetpos</b> 和 <b>fsetpos</b> ：由ANSIC引入，通过一个新的抽象数据类型 <b>fpos_t</b> 来 <b>记录文件的位置</b> 。在非UNIX系统中这种数据类型可以定义为记录一个文件的位置所需的长度</li>
</ol>

<pre class="example" id="org7c39be4">
需要移植到非UNIX系统上运行的应用程序应当使用fgetpos和fsetpos 
</pre>
</div>
<div id="outline-container-orgeedeaca" class="outline-4">
<h4 id="orgeedeaca">Unix</h4>
<div class="outline-text-4" id="text-orgeedeaca">
<ul class="org-ul">
<li><span class="underline">ftell</span> 函数： <b>返回</b> 文件流当前位置</li>
<li><span class="underline">fseek</span> 函数： <b>设置</b> 文件流当前位置</li>
<li><p>
<span class="underline">frewind</span> 函数： <b>重置</b> 文件流当前位置
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36820;&#22238;&#24403;&#21069;&#22312;&#25991;&#20214;&#27969;&#20013;&#30340;&#20301;&#32622;&#65292;&#20197; long &#20026;&#27493;&#38271;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#24403;&#21069;&#25991;&#20214;&#20301;&#32622;&#25351;&#31034;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1L</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">long</span> <span style="color: #daa520; font-weight: bold;">ftell</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20197; whence &#25351;&#23450;&#30340;&#36215;&#22987;&#20301;&#32622;&#65292;&#23558;&#24403;&#21069;&#20301;&#32622;&#37325;&#26032;&#23450;&#20301;&#22312; offset &#22788;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * offset: &#27493;&#38271;</span>
<span style="color: #ffebcd;"> * whence: &#21021;&#22987;&#20301;&#32622;(SEEK_SET&#65306;&#25991;&#20214;&#24320;&#22836;&#65292;SEEK_CUR&#65306;&#24403;&#21069;&#20301;&#32622;&#65292;SEEK_END&#65306;&#25991;&#20214;&#26411;&#23614;) </span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#36820;&#22238; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fseek</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">offset</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">whence</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#22797;&#20301;&#24403;&#21069;&#20301;&#32622;&#21040;&#25991;&#20214;&#24320;&#22836;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#26080;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rewind</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orga700cda" class="outline-4">
<h4 id="orga700cda">ANSI</h4>
<div class="outline-text-4" id="text-orga700cda">
<ul class="org-ul">
<li>fgetpos： <b>获取</b> 文件流当前位置</li>
<li>fsetpos： <b>设置</b> 文件流当前位置</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23558;&#25991;&#20214;&#27969;&#30340;&#24403;&#21069;&#20301;&#32622;&#23384;&#21040;pos&#23545;&#35937;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * pos: &#25991;&#20214;&#20301;&#32622;&#32467;&#26500;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fgetpos</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">fpos_t</span> *<span style="color: #4eee94;">pos</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23558;&#25991;&#20214;&#27969;&#24403;&#21069;&#20301;&#32622;&#35774;&#32622;&#20026;pos&#23545;&#35937;&#34920;&#36798;&#30340;&#20301;&#32622;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#27969;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * pos: &#25991;&#20214;&#20301;&#32622;&#32467;&#26500;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fsetpos</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">fpost_t</span> *<span style="color: #4eee94;">pos</span>);
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgefbaa17" class="outline-2">
<h2 id="orgefbaa17">格式化I/O</h2>
<div class="outline-text-2" id="text-orgefbaa17">
<pre class="example" id="org047143c">
可以使用的格式化标记可参考 K&amp;R 编写的The C Programming Language一书

典型的使用包括 %4d,  %3.2f , %*.3f 等...
</pre>
</div>
<div id="outline-container-orge1973b3" class="outline-3">
<h3 id="orge1973b3">格式化输出</h3>
<div class="outline-text-3" id="text-orge1973b3">
<ul class="org-ul">
<li><span class="underline">printf</span> 函数：格式化字符串输出到 <span class="underline">标准输出流</span></li>
<li><span class="underline">fprintf</span> 函数：格式化字符串输出到 <span class="underline">文件流</span></li>
<li><p>
<span class="underline">sprintf</span> 函数：格式化字符串输出到 <span class="underline">缓存区</span> 
</p>
<ul class="org-ul">
<li>在缓存区的尾端会 <b>自动加一个null字节</b> ，但该字节 <b>不包括在返回值</b> 中</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26684;&#24335;&#21270;&#23383;&#31526;&#20018;format&#36755;&#20986;&#21040;&#26631;&#20934;&#36755;&#20986;stdout</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * format: &#36755;&#20986;&#26684;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#36755;&#20986;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#36127;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">printf</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26684;&#24335;&#21270;&#23383;&#31526;&#20018;format&#36755;&#20986;&#21040;&#25991;&#20214;&#27969;fp</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * format: &#36755;&#20986;&#23383;&#31526;&#20018;&#26684;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * &#33509;&#25104;&#21151;&#21017;&#20026; &#36755;&#20986;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; &#36127;&#20540;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fprintf</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#26684;&#24335;&#21270;&#23383;&#31526;&#20018;format&#36755;&#20986;&#21040;&#32531;&#23384;&#21306;buf</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * buf: &#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;"> * format: &#36755;&#20986;&#23383;&#31526;&#20018;&#26684;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#23384;&#20837;&#25968;&#32452;&#30340;&#23383;&#31526;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sprintf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, ...);
</pre>
</div></li>
</ul>

<pre class="example" id="orgb352cf6">
注意：sprintf可能会造成由buf指向的缓存区溢出，保证该缓存有足够长度是调用者的责任！！！ 
</pre>
</div>

<div id="outline-container-orga0ed086" class="outline-4">
<h4 id="orga0ed086">可变参数列表版本</h4>
<div class="outline-text-4" id="text-orga0ed086">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span><span style="color: #deb887;">&lt;stdarg.h&gt;</span>
<span style="color: #ffd700;">#include</span><span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vprintf</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vfprintf</span>(FILEfp,*<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* format, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vsprintf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc60a279" class="outline-3">
<h3 id="orgc60a279">格式化输入</h3>
<div class="outline-text-3" id="text-orgc60a279">
<ul class="org-ul">
<li><span class="underline">scanf</span> 函数：从 <span class="underline">标准输入流</span> 读取格式化的字符串</li>
<li><span class="underline">fscanf</span> 函数：从 <span class="underline">文件流</span> 读取格式化的字符串</li>
<li><p>
<span class="underline">sscanf</span> 函数：从 <span class="underline">缓存区</span> 读取格式化的字符串
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span><span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#26631;&#20934;&#36755;&#20837;&#27969;stdin&#35835;&#21462;format&#26684;&#24335;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * format: &#36755;&#20837;&#23383;&#31526;&#20018;&#26684;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#23450;&#30340;&#36755;&#20837;&#39033;&#25968;&#65292;&#33509;&#20986;&#38169;&#25110;&#22312;&#20219;&#24847;&#21464;&#25442;&#21069;&#24050;&#33267;&#25991;&#20214;&#23614;&#31471;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">scanf</span>(<span style="color: #00bfff; font-weight: bold;">const</span>&#12288;<span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#25991;&#20214;&#27969;fp&#35835;&#21462;format&#26684;&#24335;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * format: &#36755;&#20837;&#23383;&#31526;&#20018;&#26684;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#23450;&#30340; &#36755;&#20837;&#39033;&#25968;&#65292;&#33509;&#20986;&#38169;&#25110;&#22312;&#20219;&#24847;&#21464;&#25442;&#21069;&#24050;&#33267;&#25991;&#20214;&#23614;&#31471;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fscanf</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;&#23383;&#31526;&#32531;&#23384;&#21306;buf&#35835;&#21462;format&#26684;&#24335;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * buf: &#23383;&#31526;&#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;"> * format: &#36755;&#20837;&#23383;&#31526;&#20018;&#26684;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#23450;&#30340; &#36755;&#20837;&#39033;&#25968;&#65292;&#33509;&#20986;&#38169;&#25110;&#22312;&#20219;&#24847;&#21464;&#25442;&#21069;&#24050;&#33267;&#25991;&#20214;&#23614;&#31471;&#21017;&#20026; EOF</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sscanf</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, ...);
</pre>
</div></li>
<li>使用时应 <b>输入必须和格式化的字符串</b> 匹配，否则 <b>第一个不匹配的字符后面的部分将被直接丢弃</b> ！</li>
<li><b>空白字符</b> (空格、制表符等)均归为转义符 <span class="underline">'\s'</span> ;</li>
</ul>
</div>
<div id="outline-container-orga1cdc26" class="outline-4">
<h4 id="orga1cdc26">可变参数列表版本</h4>
<div class="outline-text-4" id="text-orga1cdc26">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdarg.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vscanf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vfscanf</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>); 

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vsscanf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbde9e95" class="outline-2">
<h2 id="orgbde9e95">实现细节</h2>
<div class="outline-text-2" id="text-orgbde9e95">
<p>
想要了解所使用的系统中标准I/O库的实现，最好从头文件&lt;stdio.h&gt;开始。从中可以看到：
</p>
<ul class="org-ul">
<li><span class="underline">FILE对象</span> 是如何定义的</li>
<li>每个 <span class="underline">流标志</span> 的定义</li>
<li>定义为 <b>宏</b> 的各个 <span class="underline">标准I/O例程</span> (比如getc等)</li>
</ul>

<pre class="example" id="org2679c4c">
在UNIX中，标准I/O库最终都要调用第3章中说明的I/O例程，每个I/O流都有一个与其相关联的文件描述符
</pre>
</div>
<div id="outline-container-orgd2af1ee" class="outline-3">
<h3 id="orgd2af1ee">fileno</h3>
<div class="outline-text-3" id="text-orgd2af1ee">
<p>
fileno函数：获得 <span class="underline">某个文件流</span> 相关联的 <b>文件描述符</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#24471;&#26576;&#20010;&#25991;&#20214;&#27969;&#30456;&#20851;&#32852;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fp: &#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#19982;&#35813;&#27969;&#30456;&#20851;&#32852;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fileno</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<pre class="example" id="org319bb82">
如果要调用 dup 或 fcntl 等函数，需要 fileno 函数
</pre>
</div>
<div id="outline-container-orgf8382f4" class="outline-4">
<h4 id="orgf8382f4">实例</h4>
<div class="outline-text-4" id="text-orgf8382f4">
<p>
为三个标准流以及一个与一个普通文件相关联的流打印有关缓存状态信息
</p>
<pre class="example" id="orgda518b7">
在打印缓存状态信息之前，先对每个流执行I/O操作，因为第一个I/O操作通常就造成为该流分配缓存

结构成员_flag、_bufsiz以及常数 _IONBF 和 _IOLBF 是由所使用的系统定义的
</pre>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_stdio</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">FILE</span> *);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
        <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>;
        fputs(<span style="color: #deb887;">"enter any characters\n"</span>, stdout);
        <span style="color: #00bfff; font-weight: bold;">if</span>(EOF == getchar() )
                err_sys(<span style="color: #deb887;">"getchar error"</span>);

        fputs(<span style="color: #deb887;">"one line to standard error\n"</span>, stderr);

        pr_stdio(<span style="color: #deb887;">"stdin"</span>, stdin);
        pr_stdio(<span style="color: #deb887;">"stdout"</span>, stdout);
        pr_stdio(<span style="color: #deb887;">"stderr"</span>, stderr);

        <span style="color: #00bfff; font-weight: bold;">if</span>(<span style="color: #ffd700;">NULL</span> == (fp = fopen(<span style="color: #deb887;">"/etc/man.conf"</span>, <span style="color: #deb887;">"r"</span>)) )
                err_sys(<span style="color: #deb887;">"fopen error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span>(EOF == getc(fp) )
                err_sys(<span style="color: #deb887;">"getc error"</span>);

        pr_stdio(<span style="color: #deb887;">"/etc/man.conf"</span>, fp);

        exit(0);

}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_stdio</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>)
{
        printf(<span style="color: #deb887;">"stream= %s "</span>, name);

        <span style="color: #00bfff; font-weight: bold;">if</span>(fp-&gt;_flags &amp; _IONBF)
                printf(<span style="color: #deb887;">"unbuffered"</span>);
        <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(fp-&gt;_flags &amp; _IOLBF)
                printf(<span style="color: #deb887;">"line buffered"</span>);
        <span style="color: #00bfff; font-weight: bold;">else</span>
                printf(<span style="color: #deb887;">"fully buffered"</span>);

        printf(<span style="color: #deb887;">", buffer size = %d\n"</span>, (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base));

}
</pre>
</div>
<p>
运行程序两次，一次使三个标准流与终端相连接，另一次使它们都重定向到普通文件，则所得结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">stdin, stdout &#21644;stderr&#37117;&#36830;&#33267;&#32456;&#31471;</span>
klose@gentoo ~/Documents/programming/c/apue $ ./src/stdio/printfExample
enter any characters 
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#26032;&#34892;&#31526;&#21495;</span>
one line to standard error
<span style="color: #4eee94;">stream</span>= stdin fully buffered, buffer size = 1024
<span style="color: #4eee94;">stream</span>= stdout fully buffered, buffer size = 1024
<span style="color: #4eee94;">stream</span>= stderr unbuffered, buffer size = 1
<span style="color: #4eee94;">stream</span>= /etc/man.conf fully buffered, buffer size = 4096

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#19977;&#20010;&#27969;&#37117;&#37325;&#23450;&#21521;&#21040;&#25991;&#20214;</span>
klose@gentoo ~/Documents/programming/c/apue $ ./src/stdio/printfExample &lt; /etc/profile &gt; std.out 2&gt; std.err&#12288;
klose@gentoo ~/Documents/programming/c/apue $ ls -l std.out std.err 
-rw-r--r-- 1 klose klose  27 Feb 12 21:30 std.err
-rw-r--r-- 1 klose klose 220 Feb 12 21:30 std.out

klose@gentoo ~/Documents/programming/c/apue $ cat std.out  
enter any characters
<span style="color: #4eee94;">stream</span>= stdin fully buffered, buffer size = 4096
<span style="color: #4eee94;">stream</span>= stdout fully buffered, buffer size = 4096
<span style="color: #4eee94;">stream</span>= stderr unbuffered, buffer size = 1
<span style="color: #4eee94;">stream</span>= /etc/man.conf fully buffered, buffer size = 4096

klose@gentoo ~/Documents/programming/c/apue $ cat std.err 
one line to standard error
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org4c1d451" class="outline-2">
<h2 id="org4c1d451">临时文件</h2>
<div class="outline-text-2" id="text-org4c1d451">
</div>
<div id="outline-container-orgc064d0e" class="outline-3">
<h3 id="orgc064d0e">tmpnam, tmpfile</h3>
<div class="outline-text-3" id="text-orgc064d0e">
<p>
标准I/O库提供了以下两个函数用来创建临时文件：
</p>
<ul class="org-ul">
<li><span class="underline">tmpnam</span> ：产生 <b>临时文件名</b></li>
<li><p>
<span class="underline">tmpfile</span> ：产生 <b>临时文件</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20135;&#29983;&#19968;&#20010;&#19982;&#29616;&#22312;&#25991;&#20214;&#21517;&#19981;&#21516;&#30340;&#19968;&#20010;&#26377;&#25928;&#36335;&#24452;&#21517;&#30340;&#23383;&#31526;&#20018;&#65292;&#33509;ptr&#20026; NULL &#21017;&#23384;&#25918;&#22312;&#19968;&#20010;&#20840;&#23616;&#38745;&#24577;&#32531;&#23384;&#21306;&#65292;&#21453;&#20043;&#20445;&#23384;&#22312; ptr &#20869;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * ptr: &#23384;&#25918;&#20020;&#26102;&#25991;&#20214;&#21517;&#30340;&#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25351;&#21521;&#19968;&#21807;&#19968;&#36335;&#24452;&#21517;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">tmpnam</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21019;&#24314;&#19968;&#20010;&#20020;&#26102;&#20108;&#36827;&#21046;&#25991;&#20214;(&#31867;&#22411;wb+)&#65292;&#22312;&#20851;&#38381;&#35813;&#25991;&#20214;&#25110;&#31243;&#24207;&#32467;&#26463;&#26102;&#23558;&#33258;&#21160;&#21024;&#38500;&#36825;&#31181;&#25991;&#20214;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; &#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; NULL</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">tmpfile</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div></li>
</ul>
<ul class="org-ul">
<li>tmpnam：它都产生一个不同的路径名，最多调用次数是 <span class="underline">TMP_MAX</span> 常量
<ul class="org-ul">
<li>如果ptr是 NULL，则所产生的 <b>路径名存放在一个静态区中</b> ，指向该静态区的指针作为函数值返回
<ul class="org-ul">
<li>下一次再调用tmpnam时会重写该静态区</li>
</ul></li>
<li>如果ptr不是NULL，则认为它指向长度至少是 <span class="underline">L_tmpnam</span> 个字符的数组，所产生的 <b>路径名存放在该数组</b> 中， <b>ptr也作为函数值返回</b></li>
</ul></li>
<li>tmpfile：创建一个临时二进制文件(类型 <b>wb+</b> )，在 <span class="underline">关闭该文件</span> 或 <span class="underline">程序结束</span> 时将 <b>自动删除这种文件</b></li>
</ul>

<pre class="example" id="orgf64b1f7">
tmpfile函数的实现：

1. 先调用 tmpnam产生一个唯一的路径名
2. 立即 unlink 它
</pre>
</div>
<div id="outline-container-org3d74a0b" class="outline-4">
<h4 id="org3d74a0b">实例</h4>
<div class="outline-text-4" id="text-org3d74a0b">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
        <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">name</span>[L_tmpnam], <span style="color: #4eee94;">line</span>[MAXLINE];
        <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>;

        printf(<span style="color: #deb887;">"%s\n"</span>, tmpnam(<span style="color: #ffd700;">NULL</span>) );

        tmpnam(name);
        printf(<span style="color: #deb887;">"%s\n"</span>, name);

        <span style="color: #00bfff; font-weight: bold;">if</span>(<span style="color: #ffd700;">NULL</span> == (fp = tmpfile() ) )
                err_sys(<span style="color: #deb887;">"tempfile error"</span>);

        fputs(<span style="color: #deb887;">"Hello World\n"</span>, fp);
        rewind(fp);
        <span style="color: #00bfff; font-weight: bold;">if</span>(<span style="color: #ffd700;">NULL</span> == (fgets(line, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(line), fp) ) )
                err_sys(<span style="color: #deb887;">"fgets error"</span>);
        fputs(line, stdout);

        exit(0);

}
</pre>
</div>
<p>
测试代码：
</p>
<div class="org-src-container">
<pre class="src src-sh">klose@gentoo ~/Documents/programming/c/apue $ ./src/stdio/tempfileExample 
/tmp/fileO0xmAZ
/tmp/fileN1WvPl
Hello World
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge526f55" class="outline-3">
<h3 id="orge526f55">tempnam</h3>
<div class="outline-text-3" id="text-orge526f55">
<p>
tempnam函数：tmpnam的一个变体， 允许调用者为所产生的 <b>路径名指定目录和前缀</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20801;&#35768;&#35843;&#29992;&#32773;&#20026;&#25152;&#20135;&#29983;&#30340;&#36335;&#24452;&#21517;&#25351;&#23450;&#30446;&#24405;&#21644;&#21069;&#32512;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * directory: &#25991;&#20214;&#30446;&#24405;&#21517;</span>
<span style="color: #ffebcd;"> * prefix: &#25991;&#20214;&#21069;&#32512;&#21517;&#65292;&#26368;&#22810;&#20855;&#26377;5&#20010;&#23383;&#31526;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25351;&#21521;&#19968;&#21807;&#19968;&#36335;&#24452;&#21517;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">tempnam</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">directory</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">prefix</span>);
</pre>
</div>
<p>
对于目录有四种不同的选择，使用 <b>第一个条件为真</b> 的作为目录:
</p>
<ol class="org-ol">
<li>如果定义了 <span class="underline">环境变量TMPDIR</span> ，则用其作为目录</li>
<li>如果 <span class="underline">参数directory非NULL</span> ，则用其作为目录</li>
<li>将 <span class="underline">&lt;stdio.h&gt;</span> 中的字符串 <span class="underline">P_tmpdir</span> 用作为目录</li>
<li>将本地目录，通常是 <span class="underline">/tmp</span> ，用作为目录</li>
</ol>

<p>
如果prefix非NULL，则它应该是 <b>最多包含5个字符</b> 的字符串，用其作为文件名的头几个字符
</p>
</div>
<div id="outline-container-orgbd4189d" class="outline-4">
<h4 id="orgbd4189d">实例</h4>
<div class="outline-text-4" id="text-orgbd4189d">
<p>
根据输入目录名和前缀名打印产生的临时文件名
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
        <span style="color: #00bfff; font-weight: bold;">if</span>(argc != 3)
                err_quit(<span style="color: #deb887;">"usage tempfileName: &lt;directory&gt; &lt;prefix&gt;"</span>);

        printf(<span style="color: #deb887;">"%s\n"</span>, tempnam(argv[1][0] != <span style="color: #deb887;">' '</span> ? argv[1] : <span style="color: #ffd700;">NULL</span>,
                               argv[2][0] != <span style="color: #deb887;">' '</span> ? argv[2] : <span style="color: #ffd700;">NULL</span>));

        exit(0);
}
</pre>
</div>
<p>
测试代码:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#25351;&#23450;&#30446;&#24405;&#21644;&#21069;&#32512;</span>
$ ./src/stdio/tempfileName ~/tmp/ temp
/home/klose/tmp/tempKcMUjW

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#40664;&#35748;&#30446;&#24405;&#65306;P_tmpdir</span>
$ ./src/stdio/tempfileName <span style="color: #deb887;">" "</span> PFX
/tmp/PFXK8lxrK

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#29615;&#22659;&#21464;&#37327;&#65292;&#26080;&#21069;&#32512;</span>
$ <span style="color: #4eee94;">TMPDIR</span>=/usr/tmp ./src/stdio/tempfileName  /tmp <span style="color: #deb887;">" "</span>
/usr/tmp/file2UoOUE

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24573;&#30053;&#26080;&#25928;&#30340;&#29615;&#22659;&#21464;&#37327;</span>
$ <span style="color: #4eee94;">TMPDIR</span>=/no/such/file ./src/stdio/tempfileName  <span style="color: #deb887;">" "</span> QQQQ
/tmp/QQQQTL3shI

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24573;&#30053;&#26080;&#25928;&#30340;&#29615;&#22659;&#21464;&#37327;&#21644;&#30446;&#24405;&#35774;&#32622;</span>
$ <span style="color: #4eee94;">TMPDIR</span>=/no/such/directory ./src/stdio/tempfileName  /no/such/file QQQQ
/tmp/QQQQSSmQeI
</pre>
</div>

<p>
<a href="system_file.html">Next：系统文件</a>
</p>

<p>
<a href="file_directory.html">Previous：文件和目录</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
