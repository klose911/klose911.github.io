<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>信号</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="proc_group.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">信号</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org78dc62b">基础概念</a>
<ul>
<li><a href="#org26859b0">信号产生条件</a></li>
<li><a href="#org0158a62">信号处理</a></li>
<li><a href="#orgbb97209">常见信号</a>
<ul>
<li><a href="#org719b93d">core文件</a></li>
<li><a href="#org4e8ffb7">常用信号说明</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcc91c8e">signal函数</a>
<ul>
<li><a href="#org4e058ca">signal实例</a></li>
<li><a href="#orgf283b2a">exec启动程序</a></li>
<li><a href="#orgb05c203">fork创建进程</a></li>
</ul>
</li>
<li><a href="#org08c96cb">不可靠性</a>
<ul>
<li><a href="#org1f41deb">丢失信号</a></li>
<li><a href="#org51a3e48">无法阻塞信号</a></li>
</ul>
</li>
<li><a href="#org1e6b734">可中断的系统调用</a></li>
<li><a href="#org82deca6">可再入函数</a>
<ul>
<li><a href="#org20d226a">信号处理函数中调用不可再入函数</a></li>
</ul>
</li>
<li><a href="#orgc48ee2b">可靠信号机制</a>
<ul>
<li><a href="#orgb75ab68">术语</a>
<ul>
<li><a href="#orgf23acb8">产生(generation)</a></li>
<li><a href="#org039cfe0">递送(delivery)</a>
<ul>
<li><a href="#org60e8a4d">递送顺序(delivery order)</a></li>
</ul>
</li>
<li><a href="#orgd3f7b0e">未决(pending)</a></li>
<li><a href="#org0fd3171">阻塞(blocking)</a>
<ul>
<li><a href="#org98942ce">排队(queue)</a></li>
</ul>
</li>
<li><a href="#org541a1ed">信号屏蔽字(signal mask)</a></li>
<li><a href="#org77369fb">信号集(sigset)</a></li>
</ul>
</li>
<li><a href="#org2f59cee">发送信号</a>
<ul>
<li><a href="#org6b71ba0">kill函数</a>
<ul>
<li><a href="#org052e99f">发送权限</a></li>
<li><a href="#org42beec9">空信号</a></li>
</ul>
</li>
<li><a href="#orgc5c3e35">raise函数</a></li>
</ul>
</li>
<li><a href="#org4cfe887">alarm和pause函数</a>
<ul>
<li><a href="#orga3acd0c">alarm</a></li>
<li><a href="#org9f2f913">pause</a></li>
<li><a href="#org632ef29">sleep实现</a>
<ul>
<li><a href="#orgbfca782">sleep1</a></li>
<li><a href="#org68ee0ed">sleep2</a></li>
<li><a href="#org8602293">其他信号处理程序中调用sleep2</a></li>
</ul>
</li>
<li><a href="#org62d7847">超时限制的读操作</a>
<ul>
<li><a href="#org7bfacb7">read2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org29f857d">信号集</a>
<ul>
<li><a href="#orgf3f1bfe">BSD实现</a></li>
<li><a href="#orgf3ca6ae">sigprocmask函数</a>
<ul>
<li><a href="#org587d2ec">实例</a></li>
</ul>
</li>
<li><a href="#org3039e41">sigpending函数</a>
<ul>
<li><a href="#orgd5e1809">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3473a39">注册信号处理方式</a>
<ul>
<li><a href="#org8fdfdf4">sigaction结构</a>
<ul>
<li><a href="#orgdf16eae">sa_handler字段</a></li>
<li><a href="#org0a8ab9a">sa_mask字段</a></li>
<li><a href="#orgdab5e14">sa_flags字段</a></li>
</ul>
</li>
<li><a href="#orgdefb1bb">sigaction函数</a>
<ul>
<li><a href="#org09507c2">实现signal函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf053e05">信号处理函数中的非局部转移</a>
<ul>
<li><a href="#org491809d">实例</a>
<ul>
<li><a href="#org5d92476">setsigjmp的保护机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8afb0e0">sigsuspend函数</a>
<ul>
<li><a href="#orgc16a736">保护临界区不被信号中断</a></li>
<li><a href="#org530ee46">等待特定信号产生并处理</a></li>
<li><a href="#org29d1e33">实现父子进程之间的同步</a></li>
<li><a href="#org5c0effa">sigsuspend的局限</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org14d6115">常用函数</a>
<ul>
<li><a href="#org656e946">abort函数</a>
<ul>
<li><a href="#orgab1451a">abort实现</a></li>
</ul>
</li>
<li><a href="#orgfadc2c5">system函数</a>
<ul>
<li><a href="#orgda692cb">system函数的信号处理</a></li>
<li><a href="#org2007344">system函数实现</a></li>
<li><a href="#orgb880693">system的返回值</a></li>
</ul>
</li>
<li><a href="#orgd410449">sleep函数</a>
<ul>
<li><a href="#org6bf8032">sleep函数实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcad9eea">作业控制信号</a>
<ul>
<li><a href="#org03d302b">shell处理作业控制信号</a>
<ul>
<li><a href="#org2f2a7d1">管理终端进程实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<span class="underline">信号</span> 是 <b>软件中断</b> ，提供了一种 <b>处理异步事件</b> 的方法：例如终端用户键入中断键，则会通过信号机制停止一个程序
</p>

<pre class="example">
UNIX的早期版本，就已经有信号机制，但是这些系统所提供的信号模型并不可靠
信号可能被丢失，而且在执行临界区代码时，进程很难关闭所选择的信号

4.3BSD和SVR3对信号模型都作了更改，增加了可靠信号机制
但是这两种更改之间并不兼容。幸运的是POSIX.1对可靠信号例程进行了标准化

本章先对信号机制进行综述，并说明每种信号的一般用法
然后分析早期实现的问题，最后说明解决这些问题的方法
</pre>

<div id="outline-container-org78dc62b" class="outline-2">
<h2 id="org78dc62b">基础概念</h2>
<div class="outline-text-2" id="text-org78dc62b">
<p>
每个信号都有一个名字，这些名字都以三个字符 <span class="underline">SIG</span> 开头。例如：
</p>
<ul class="org-ul">
<li>SIGABRT是异常终止信号，当进程调用abort函数时产生这种信号</li>
<li>SIGALRM是闹钟信号，当由alarm函数设置的时间已经超过后产生此信号</li>
</ul>

<pre class="example">
SVR4和4.3+BSD均有31种不同的信号
</pre>

<p>
在头文件 <span class="underline">&lt;signal.h&gt;</span> 中，这些信号都被定义为 <b>正整数</b> ( <span class="underline">信号编号</span> )
</p>
<pre class="example">
没有一个信号其编号为0，因为信号编号0有特殊的应用

POSIX.1将此种信号编号值称为空信号
</pre>
</div>

<div id="outline-container-org26859b0" class="outline-3">
<h3 id="org26859b0">信号产生条件</h3>
<div class="outline-text-3" id="text-org26859b0">
<p>
很多条件可以产生一个信号：
</p>
<ul class="org-ul">
<li>当用户按某些 <b>特殊键</b>  时产生信号：
<ul class="org-ul">
<li>在 <span class="underline">终端</span> 上按 <span class="underline">DELETE键</span> 通常产生 <b>中断信号</b> <span class="underline">SIGINT</span> ： <b>停止</b> 一个 <span class="underline">已失去控制程序</span> 的方法</li>
</ul></li>
<li><b>硬件异常</b> 产生信号：通常由 <span class="underline">硬件检测</span> 到，并将其 <span class="underline">通知内核</span> ，然后 <span class="underline">内核</span> 为 <span class="underline">该条件发生时正在运行的进程</span> <b>产生适当的信号</b> 
<ul class="org-ul">
<li>除数为0</li>
<li>无效的存储访问：产生一个 <span class="underline">SIGSEGV</span></li>
</ul></li>
<li>进程用 <b>kill(2)系统调用</b> 可将 <span class="underline">信号</span> <b>发送给</b> <span class="underline">另一个进程或进程组</span> 。自然有些限制：
<ul class="org-ul">
<li><span class="underline">接收信号进程</span> 和 <span class="underline">发送信号进程</span> 的 <b>所有者必须相同</b></li>
<li>或 <span class="underline">发送信号进程的所有者</span> 必须是 <b>超级用户</b></li>
</ul></li>
<li>用户可用 <b>kill(1)命令</b> 将信号发送给其他进程
<ul class="org-ul">
<li>这是 <span class="underline">kill系统调用的命令</span> ，常用此命令 <b>终止</b> 一个 <b>失控的后台进程</b></li>
</ul></li>
<li>当 <b>检测</b> 到 <b>某种软件条件</b> 已经发生，并将其 <b>通知有关进程</b> 时也产生信号，例如：
<ul class="org-ul">
<li><span class="underline">SIGURG</span> : 在网络连接上传来非规定波特率的数据</li>
<li><span class="underline">SIGPIPE</span> : 在管道的读进程已终止后一个进程写此管道</li>
<li><span class="underline">SIGALRM</span> : 进程所设置的闹钟时间已经超时</li>
</ul></li>
</ul>

<pre class="example">
   这里并不是指硬件产生条件(如被0除)，而是软件条件
</pre>
</div>
</div>

<div id="outline-container-org0158a62" class="outline-3">
<h3 id="org0158a62">信号处理</h3>
<div class="outline-text-3" id="text-org0158a62">
<pre class="example">
     信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的

     进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号

     而是必须告诉内核“在此信号发生时，请执行下列操作”
</pre>
<p>
系统在某个信号出现时按照下列三种方式中的一种进行操作：
</p>
<ol class="org-ol">
<li><b>忽略</b> 此信号：大多数信号都可使用这种方式进行处理
<ul class="org-ul">
<li>但有两种信号却决不能被忽略，它们是 <span class="underline">SIGKILL</span> 和 <span class="underline">SIGSTOP</span>
<ul class="org-ul">
<li>原因：为了 <b>向 <span class="underline">超级用户</span> 提供一种使进程 <span class="underline">终止</span> 或 <span class="underline">停止</span> 的可靠方法</b></li>
</ul></li>
<li>如果忽略某些由 <span class="underline">硬件异常</span> 产生的信号(例如非法存储访问或除以0)，则 <b>进程的行为是未定义的</b></li>
</ul></li>
<li><b>捕捉</b> 信号：为了做到这一点要通知内核在某种信号发生时， <span class="underline">调用一个用户函数</span> 
<ul class="org-ul">
<li>在用户函数中，可 <span class="underline">执行用户希望对这种事件进行的处理</span> 。例如：
<ul class="org-ul">
<li>若编写一个命令解释器，当用户用键盘产生 <span class="underline">中断信号</span> 时，很可能希望 <b>返回到程序的主循环</b> ，终止系统正在为该用户执行的命令</li>
<li>如果捕捉到 <span class="underline">SIGCHLD</span> 信号，则表示子进程已经终止，所以此信号的捕捉函数可以 <b>调用waitpid</b> 以取得该子进程的进程ID以及它的终止状态</li>
<li>如果进程创建了临时文件，那么可能要为 <span class="underline">SIGTERM</span> 信号编写一个信号捕捉函数以 <b>清除临时文件</b> (kill命令传送的系统默认信号是终止信号)</li>
</ul></li>
</ul></li>
<li>执行 <b>系统默认</b> 动作：表10-1给出了对每一种信号的系统默认动作
<ul class="org-ul">
<li>注意：对大多数信号的系统默认动作是 <b>终止该进程</b></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-orgbb97209" class="outline-3">
<h3 id="orgbb97209">常见信号</h3>
<div class="outline-text-3" id="text-orgbb97209">
<p>
表10-1列出所有信号的 <span class="underline">名字</span> ， <span class="underline">说明</span> ，以及对于信号的 <span class="underline">系统默认动作</span> 
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> UNIX信号</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-left">默认</td>
<td class="org-left">支持系统</td>
</tr>

<tr>
<td class="org-left">SIGABRT</td>
<td class="org-left">异常终止(abort)</td>
<td class="org-left">终止+core</td>
<td class="org-left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="org-left">SIGALRM</td>
<td class="org-left">超时(alarm)</td>
<td class="org-left">终止</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGBUS</td>
<td class="org-left">硬件故障</td>
<td class="org-left">终止+core</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGCHLD</td>
<td class="org-left">子进程状态改变</td>
<td class="org-left">忽略</td>
<td class="org-left">作业</td>
</tr>

<tr>
<td class="org-left">SIGCONT</td>
<td class="org-left">使得暂停进程继续</td>
<td class="org-left">继续/忽略</td>
<td class="org-left">作业</td>
</tr>

<tr>
<td class="org-left">SIGEMT</td>
<td class="org-left">硬件故障</td>
<td class="org-left">终止+core</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGFPE</td>
<td class="org-left">算术异常</td>
<td class="org-left">终止+core</td>
<td class="org-left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="org-left">SIGHUP</td>
<td class="org-left">链接断开</td>
<td class="org-left">终止</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGILL</td>
<td class="org-left">非法硬件指令</td>
<td class="org-left">终止+core</td>
<td class="org-left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="org-left">SIGINT</td>
<td class="org-left">终端中断符</td>
<td class="org-left">终止</td>
<td class="org-left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="org-left">SIGIO</td>
<td class="org-left">异步IO</td>
<td class="org-left">忽略/终止</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGIOT</td>
<td class="org-left">硬件故障</td>
<td class="org-left">终止+core</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGKILL</td>
<td class="org-left">终止</td>
<td class="org-left">终止</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGPIPE</td>
<td class="org-left">写入无读进程管道</td>
<td class="org-left">终止</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGPOLL</td>
<td class="org-left">可轮询事件</td>
<td class="org-left">终止</td>
<td class="org-left">SVR4</td>
</tr>

<tr>
<td class="org-left">SIGPROF</td>
<td class="org-left">profile时间超时</td>
<td class="org-left">终止</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGPWR</td>
<td class="org-left">电源失效/重启</td>
<td class="org-left">忽略</td>
<td class="org-left">SVR4</td>
</tr>

<tr>
<td class="org-left">SIGQUIT</td>
<td class="org-left">终端退出符</td>
<td class="org-left">终止+core</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGSEGV</td>
<td class="org-left">无效内存引用</td>
<td class="org-left">终止+core</td>
<td class="org-left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="org-left">SIGSTOP</td>
<td class="org-left">停止</td>
<td class="org-left">暂停</td>
<td class="org-left">作业</td>
</tr>

<tr>
<td class="org-left">SIGSYS</td>
<td class="org-left">无效系统调用</td>
<td class="org-left">终止+core</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGTERM</td>
<td class="org-left">终止</td>
<td class="org-left">终止</td>
<td class="org-left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="org-left">SIGTRAP</td>
<td class="org-left">硬件故障</td>
<td class="org-left">终止+core</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGTSTP</td>
<td class="org-left">终端停止符</td>
<td class="org-left">暂停</td>
<td class="org-left">作业</td>
</tr>

<tr>
<td class="org-left">SIGTTIN</td>
<td class="org-left">后端读取tty</td>
<td class="org-left">暂停</td>
<td class="org-left">作业</td>
</tr>

<tr>
<td class="org-left">SIGTTOUT</td>
<td class="org-left">后端写tty</td>
<td class="org-left">暂停</td>
<td class="org-left">作业</td>
</tr>

<tr>
<td class="org-left">SIGURG</td>
<td class="org-left">紧急数据</td>
<td class="org-left">忽略</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGUSR1</td>
<td class="org-left">用户自定义1</td>
<td class="org-left">终止</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGUSR2</td>
<td class="org-left">用户自定义2</td>
<td class="org-left">终止</td>
<td class="org-left">POSIX</td>
</tr>

<tr>
<td class="org-left">SIGVTALRM</td>
<td class="org-left">虚拟时间闹钟</td>
<td class="org-left">终止</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGWINCH</td>
<td class="org-left">终端窗口大小变化</td>
<td class="org-left">忽略</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGXCPU</td>
<td class="org-left">超过CPU限制</td>
<td class="org-left">终止+core/忽略</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGXFSZ</td>
<td class="org-left">超过文件长度限制</td>
<td class="org-left">终止+core/忽略</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<pre class="example">
   作业表示这是作业控制信号(仅当支持作业控制时，才要求此种信号)
</pre>
</div>
<div id="outline-container-org719b93d" class="outline-4">
<h4 id="org719b93d">core文件</h4>
<div class="outline-text-4" id="text-org719b93d">
<p>
在系统默认动作列， <span class="underline">终止+core</span> 表示在 <span class="underline">进程当前工作目录</span> 的 <span class="underline">core文件</span> 中 <b>复制</b> 了 <b>该进程的存储图像</b> 
</p>
<pre class="example">
      大多数UNIX调试程序都使用core文件以检查进程在终止时的状态
</pre>
<p>
在下列条件下不产生core文件: 
</p>
<ul class="org-ul">
<li>进程是 <b>设置-用户-ID</b> ，而且 <span class="underline">当前用户</span> 并非 <span class="underline">程序文件的所有者</span></li>
<li>进程是 <b>设置-组-ID</b> ，而且 <span class="underline">当前用户</span> 并非 <span class="underline">该程序文件的组所有者</span></li>
<li>用户 <b>没有写</b> <span class="underline">当前工作目录</span> 的许可权</li>
<li><b>文件太大</b> <span class="underline">RLIMIT_CORE</span></li>
</ul>

<p>
core文件的许可权通常是 <span class="underline">用户读/写</span> ， <span class="underline">组读</span> 和 <span class="underline">其他读</span> (rw-r&#x2013;r&#x2013;) 
</p>
</div>
</div>

<div id="outline-container-org4e8ffb7" class="outline-4">
<h4 id="org4e8ffb7">常用信号说明</h4>
<div class="outline-text-4" id="text-org4e8ffb7">
<ul class="org-ul">
<li><span class="underline">SIGABRT</span> ：调用 <b>abort函数</b> 时产生此信号，进程 <span class="underline">异常终止</span></li>
<li><span class="underline">SIGALRM</span> ：超过用 <b>alarm函数设置的时间</b> 时产生此信号
<ul class="org-ul">
<li>若由 <span class="underline">setitimer(2)</span> 函数设置的 <span class="underline">间隔时间</span> 已经过时，那么也产生此信号</li>
</ul></li>
<li>SIGBUS：一个实现定义的硬件故障</li>
<li><b>SIGCHLD</b> ：在一个 <b>进程终止或停止</b> 时，SIGCHLD信号被 <b>送给其父进程</b> 
<ul class="org-ul">
<li>按系统 <span class="underline">默认</span> ，将 <b>忽略此信号</b></li>
<li>如果父进程希望了解其子进程的这种状态改变，则应 <b>捕捉</b> 此信号
<ul class="org-ul">
<li>信号捕捉函数中通常要 <b>调用wait函数</b> 以取得子进程ID和其终止状态</li>
</ul></li>
</ul></li>
<li><span class="underline">SIGCONT</span> ： <span class="underline">作业控制</span> 信号，送给 <b>需要继续运行的处于停止状态的进程</b> 
<ul class="org-ul">
<li>如果接收到此信号的进程处于 <span class="underline">停止状态</span> ，则系统 <span class="underline">默认</span> 动作是使 <b>该进程继续运行</b></li>
<li>否则默认动作是 <b>忽略</b> 此信号</li>
<li>例如vi编辑程序在捕捉到此信号后，重新绘制终端屏幕</li>
</ul></li>
<li>SIGEMT：一个实现定义的 <span class="underline">硬件故障</span></li>
<li>SIGFPE：一个 <span class="underline">算术运算异常</span> ，例如
<ul class="org-ul">
<li>除以0</li>
<li>浮点溢出等</li>
</ul></li>
<li>SIGHUP：如果 <span class="underline">终端</span> 界面检测到一个 <b>连接断开</b> ，则将此信号送给与 <span class="underline">该终端相关的控制进程</span> 
<ul class="org-ul">
<li>被送给 <span class="underline">session</span> 结构中 <b>s_leader</b> 字段所指向的 <span class="underline">进程</span></li>
<li>仅当终端的 <span class="underline">CLOCAL</span> 标志 <b>没有设置</b> 时，在上述条件下才产生此信号</li>
</ul></li>
</ul>

<pre class="example">
      注意：接到此信号的对话期首进程可能在后台，这区别于通常由终端产生的信号(中断、退出和挂起)，这些信号总是传递给前台进程组

      如果对话期前台进程终止，则也产生此信号。在这种情况，此信号送给前台进程组中的每一个进程

      通常用此信号“通知守护进程”以 “再读它们的配置文件”。选用SIGHUP的理由是：
      因为一个守护进程不会有一个控制终端，而且通常决不会接收到这种信号
</pre>
<ul class="org-ul">
<li>SIGILL：进程已执行一条 <span class="underline">非法硬件指令</span></li>
<li>SIGINFO：一种4.3+BSD信号，当用户按 <b>状态键</b> (一般采用 <span class="underline">Ctrl-T</span> )时， <span class="underline">终端驱动程序</span> 产生此信号并送至 <span class="underline">前台进程组中的每一个进程</span> (见图9-8)。+ 通常造成在 <b>终端上显示 <span class="underline">前台进程组中各进程</span> 的状态信息</b></li>
<li><b>SIGINT</b> ：当用户按 <b>中断键</b>  (一般采用 <span class="underline">DELETE</span> 或 <span class="underline">Ctrl-C</span> )时， <span class="underline">终端驱动程序</span>  产生此信号并送至 <span class="underline">前台进程组中的每一个进程</span> 
<ul class="org-ul">
<li>当一个 <b>进程在运行时失控</b> ，特别是它正在屏幕上产生大量不需要的输出时，常用此信号 <b>终止</b> 它</li>
</ul></li>
<li>SIGIO：一个 <span class="underline">异步I/O事件</span> 发生</li>
<li>SIGIOT：一个实现定义的 <span class="underline">硬件故障</span></li>
<li><b>SIGKILL</b> ：两个不能被捕捉或忽略信号中的一个
<ul class="org-ul">
<li>它向系统管理员提供了一种可以 <b>杀死任一进程</b> 的可靠方法</li>
</ul></li>
<li><span class="underline">SIGPIPE</span> ：
<ul class="org-ul">
<li>如果在 <span class="underline">读进程</span> <b>已终止</b> 时 <span class="underline">写管道</span> ，则产生此信号</li>
<li>当 <span class="underline">socket</span> 的一端已经 <b>终止</b> 时，若进程写该套接口也产生此信号</li>
</ul></li>
<li>SIGPOLL：SVR4信号，当在一个 <span class="underline">可轮询设备</span> 上发生一 <span class="underline">特定事件</span> 时产生此信号
<ul class="org-ul">
<li>它与4.3+BSD的SIGIO和SIGURG信号类似</li>
</ul></li>
<li>SIGPROF：当 <span class="underline">setitimer(2)</span> 函数设置的 <span class="underline">统计间隔时间</span> 已经超过时产生</li>
<li>SIGPWR：SVR4信号，它依赖于系统。它主要用于具有 <span class="underline">不间断电源(UPS)</span> 的系统上</li>
</ul>

<pre class="example">
      如果电源失效，则UPS起作用，而且通常软件会接到通知

      在这种情况下，系统依靠蓄电池电源继续运行，所以无须作任何处理

      但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，
      它在15~30秒内使系统各部分都停止运行，此时应当传递SIGPWR信号

      在大多数系统中使接到蓄电池电压过低的进程将信号SIGPWR发送给init进程，然后由init处理停机操作
      很多系统init实现在inittab文件中提供了两个记录项用于此种目的：powerfail以及powerwait 
      目前已能获得低价格的UPS系统，它用RS-232串行连接能够很容易地将蓄电池电压过低的条件通知系统，于是这种信号也就更加重要了
</pre>

<ul class="org-ul">
<li><b>SIGQUIT</b> ：当用户在 <span class="underline">终端</span> 上按 <b>退出键</b> (一般采用 <span class="underline">Ctrl-\</span> )时，产生此信号，并送至 <span class="underline">前台进程组中的所有进程</span> 
<ul class="org-ul">
<li>不仅 <span class="underline">终止前台进程组</span> (如 <span class="underline">SIGINT</span> 所做的那样)，同时 <b>产生一个core文件</b></li>
</ul></li>
<li>SIGSEGV：进程进行了一次 <span class="underline">无效的内存访问</span></li>
<li><b>SIGSTOP</b> ： <span class="underline">作业控制</span> 信号，它 <b>停止一个进程</b> 。它类似于交互停止信号( <span class="underline">SIGTSTP</span> )，两个不能被捕捉或忽略信号中的一个</li>
<li>SIGSYS：一个 <span class="underline">无效的系统调用</span> 
<ul class="org-ul">
<li>由于某种未知原因，进程执行了一条系统调用指令，但其指示 <b>系统调用类型的参数却是无效的</b></li>
</ul></li>
<li><b>SIGTERM</b> ：由 <span class="underline">kill(1)命令</span> 发送的系统 <b>默认终止信号</b></li>
<li>SIGTRAP：一个实现定义的 <span class="underline">硬件故障</span></li>
<li><b>SIGTSTP</b> ： <b>交互停止</b> 信号，当用户在终端上按 <b>挂起键</b> (一般采用 <span class="underline">Ctrl-Z</span> )时，终端驱动程序产生此信号</li>
<li><span class="underline">SIGTTIN</span> ：当一个 <span class="underline">后台进程组进程</span> 试图 <b>读</b> 其 <span class="underline">控制终端</span> 时，终端驱动程序产生此信号。在下列例外情形下 <b>不产生此信号</b> ，此时 <span class="underline">读操作</span> <b>返回出错</b> ，errno设置为 <span class="underline">EIO</span> ：
<ol class="org-ol">
<li><span class="underline">读进程</span> <b>忽略</b> 或 <b>阻塞</b> 此信号</li>
<li><span class="underline">读进程所属的进程组</span> 是 <b>孤儿进程组</b></li>
</ol></li>
<li><span class="underline">SIGTTOU</span> ：当一个 <span class="underline">后台进程组进程</span> 试图 <b>写</b> 其 <span class="underline">控制终端</span> 时产生此信号。与上面所述的SIGTTIN信号不同，一个进程可以选择为允许后台进程写控制终端。如果 <b>不允许后台进程写</b> ，在这两种情况下 <b>不产生此信号</b> ，写操作 <b>返回出错</b> ，errno设置为 <span class="underline">EIO</span> ：
<ol class="org-ol">
<li><span class="underline">写进程</span>  <b>忽略</b> 或 <b>阻塞</b> 此信号</li>
<li><span class="underline">写进程所属进程组</span> 是 <b>孤儿进程组</b></li>
</ol></li>
</ul>
<pre class="example">
      不论是否允许后台进程写，某些除写以外的下列终端操作也能产生此信号：tcsetattr，tcsendbreak，tcdrain，tcflush，tcflow以及tcsetpgrp
</pre>
<ul class="org-ul">
<li>SIGURG：通知进程已经发生一个紧急情况
<ul class="org-ul">
<li>在网络连接上，接到 <span class="underline">非规定波特率</span> 的数据时，此信号可选择地产生</li>
</ul></li>
<li><b>SIGUSR1</b> ：一个 <b>用户定义</b> 的信号，可用于应用程序</li>
<li><b>SIGUSR2</b> ：这是一个 <b>用户定义</b> 的信号，可用于应用程序</li>
<li>SIGVTALRM：当一个由 <span class="underline">setitimer(2)</span> 函数设置的 <span class="underline">虚拟间隔时间已经超过</span> 时产生此信号</li>
<li>SIGWINCH：SVR4和4.3+BSD内核保持与每个 <span class="underline">终端或伪终端</span> 相关联的 <span class="underline">窗口的大小</span> 
<ul class="org-ul">
<li>一个进程可以用 <span class="underline">ioctl</span> 函数 <b>得到或设置</b> <span class="underline">窗口的大小</span> 
<ul class="org-ul">
<li>如果一个进程用ioctl的设置-窗口-大小命令 <b>更改了窗口大小</b> ，则内核将 <span class="underline">SIGWINCH</span> 信号送至 <span class="underline">前台进程组</span></li>
</ul></li>
</ul></li>
<li>SIGXCPUS：如果 <span class="underline">进程</span> <b>超过</b> 了其 <span class="underline">软CPU时间限制</span> ，则产生此信号</li>
<li>SIGXFSZ：如果 <span class="underline">进程</span> <b>超过</b> 了其 <span class="underline">软文件长度限制</span> ，则产生此信号</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcc91c8e" class="outline-2">
<h2 id="orgcc91c8e">signal函数</h2>
<div class="outline-text-2" id="text-orgcc91c8e">
<p>
<span class="underline">signal</span> 函数：为某个 <span class="underline">特定信号</span> <b>设置处理函数</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#22768;&#26126;sighandler_t&#26159;&#19968;&#20010;&#20989;&#25968;&#25351;&#38024;&#31867;&#22411;&#65292;&#20854;&#21442;&#25968;&#26159;&#19968;&#20010;int&#65292;&#27809;&#26377;&#36820;&#22238;&#20540;&#30340;&#20989;&#25968;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">typedef</span> <span style="color: #98f5ff;">void</span> (*<span style="color: #98f5ff;">sighandler_t</span>)(<span style="color: #98f5ff;">int</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20026;&#20449;&#21495; signo &#27880;&#20876;&#19968;&#20010;&#29305;&#23450;&#30340;&#22788;&#29702;&#20989;&#25968;handler</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * signo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> * handler: &#20989;&#25968;&#25351;&#38024;&#65292;&#21442;&#25968;&#26159;&#19968;&#20010;int&#31867;&#22411;&#65292;&#26080;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;"> *                SIG_IGN&#65306;&#24573;&#30053;&#25351;&#23450;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *                SIG_DFL&#65306;&#31995;&#32479;&#40664;&#35748;&#22788;&#29702;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *                &#25110;&#32773;&#26159;&#33258;&#23450;&#20041;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#30340;&#22320;&#22336;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return&#65306;&#25104;&#21151;&#21017;&#20026; &#20043;&#21069;&#30340;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; SIG_ERR</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">sighandler_t</span> <span style="color: #daa520; font-weight: bold;">signal</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>, <span style="color: #98f5ff;">sighandler_t</span> <span style="color: #4eee94;">handler</span>);

<span style="color: #98f5ff;">void</span> (*signal(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>, <span style="color: #98f5ff;">void</span> (*<span style="color: #daa520; font-weight: bold;">handler</span>)(<span style="color: #98f5ff;">int</span>))(<span style="color: #98f5ff;">int</span>);
</pre>
</div>

<p>
signal函数要求两个 <span class="underline">参数</span> ：
</p>
<ul class="org-ul">
<li>第一个参数 <span class="underline">signo</span> ：一个 <span class="underline">整型数</span> ，表10-1中的 <b>信号名</b></li>
<li>第二个参数 <span class="underline">handler</span> ：一个 <span class="underline">函数指针</span> ，它指向的函数需要一个 <span class="underline">整型参数</span> ， <span class="underline">无返回值</span> ，其含义是指向要设置的 <b>信号处理函数的指针</b> 
<ul class="org-ul">
<li>常数 <b>SIG_IGN</b> ：内核表示 <b>忽略</b> 此信号
<ul class="org-ul">
<li><span class="underline">SIGKILL</span> 和 <span class="underline">SIGSTOP</span> <b>不能忽略</b></li>
</ul></li>
<li>常数 <b>SIG_DFL</b> ：系统 <b>默认</b> 动作</li>
<li>接到信号后要调用的函数的地址：此函数为信号处理程序或信号 <b>捕捉函数</b> ，调用此函数为捕捉信号</li>
</ul></li>
</ul>

<p>
signal的 <span class="underline">返回值</span> 也是一个 <span class="underline">函数指针</span> ，指向的函数需要一个 <span class="underline">整形参数</span> ， <span class="underline">无返回值</span> ，其含义是指向 <b>以前的信号处理函数的指针</b> 
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Fake signal functions.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIG_ERR</span> ((<span style="color: #98f5ff;">__sighandler_t</span>) -1)       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Error return.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIG_DFL</span> ((<span style="color: #98f5ff;">__sighandler_t</span>) 0)        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Default action.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIG_IGN</span> ((<span style="color: #98f5ff;">__sighandler_t</span>) 1)        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Ignore signal.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIG_ERR</span> (<span style="color: #98f5ff;">void</span> (*)()) -1
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIG_DFL</span> (<span style="color: #98f5ff;">void</span> (*)()) 0
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIG_IGN</span> (<span style="color: #98f5ff;">void</span> (*)()) 1 
</pre>
</div>

<pre class="example">
这些常数可用于表示"指向函数的指针，该函数要一个整型参数，而且无返回值"
signal的第二个参数及其返回值就可用它们表示

这些常数所使用的三个值不一定要是-1，0和1
但必须是三个决不能是任一可说明函数的地址值，大多数UNIX系统使用上面所示的值
</pre>
</div>

<div id="outline-container-org4e058ca" class="outline-3">
<h3 id="org4e058ca">signal实例</h3>
<div class="outline-text-3" id="text-org4e058ca">
<p>
捕捉 <span class="underline">两个用户定义的信号</span> 并 <span class="underline">打印信号编号</span> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#65292;&#19968;&#20010;&#20989;&#25968;&#23545;&#24212;&#20004;&#20010;&#20449;&#21495;SIGUSR1&#21644;SIGUSR2</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_usr</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27880;&#20876;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> ( SIG_ERR == signal(SIGUSR1, sig_usr))
        err_sys(<span style="color: #deb887;">"can't catch signal SIG_USR1"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>( SIG_ERR == signal(SIGUSR2, sig_usr))
        err_sys(<span style="color: #deb887;">"can't catch signal SIG_USR2"</span>);

    <span style="color: #00bfff; font-weight: bold;">for</span> (; ; )
        pause();

}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_usr</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (SIGUSR1 == signo)
        printf(<span style="color: #deb887;">"received SIGUSR1\n"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (SIGUSR2 == signo)
        printf(<span style="color: #deb887;">"received SIGUSR2\n"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span>
        err_dump(<span style="color: #deb887;">"received signal %d \n"</span>, signo);
    <span style="color: #00bfff; font-weight: bold;">return</span> ;

}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/sigusr1 &amp; <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#21518;&#21488;&#21551;&#21160;&#36827;&#31243;</span>
[1] 10225 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#25903;&#25345;&#20316;&#19994;&#25511;&#21046;shell&#25171;&#21360;&#20316;&#19994;&#21495;&#21644;&#36827;&#31243;&#21495;</span>

$ kill -USR1 10225 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21521;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;SIGUSR1 </span>
received SIGUSR1

$ kill -USR2 10225 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21521;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;SIGUSR2</span>
received SIGUSR2

$ kill 10225 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#12288;&#21521;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;SIGTERM</span>
[1]+  Terminated ./src/signal/sigusr1
</pre>
</div>

<pre class="example">
     当向该进程发送SIGTERM信号后，该进程就终止

     因为它不捕捉此信号，而对此信号的系统默认动作是终止
</pre>
</div>
</div>

<div id="outline-container-orgf283b2a" class="outline-3">
<h3 id="orgf283b2a">exec启动程序</h3>
<div class="outline-text-3" id="text-orgf283b2a">
<p>
当 <span class="underline">执行</span> 一个程序时， <span class="underline">所有信号的状态</span> 都是系统 <b>默认</b> 或 <b>忽略</b> ：
</p>
<ul class="org-ul">
<li>通常 <span class="underline">所有信号</span> 都被设置为 <span class="underline">系统默认</span> 动作</li>
<li>除非 <span class="underline">调用exec的进程</span> <b>忽略</b> 该信号</li>
</ul>

<pre class="example">
exec函数将原先设置为“要捕捉”的信号都更改为“默认动作”，其他信号的状态则不变

一个进程原先要捕捉的信号，当其执行一个新程序后，就自然地不能再捕捉了
因为“信号捕捉函数的地址”很可能在所执行的新程序文件中已无意义！！！
</pre>

<p>
对于一个非作业控制shell，当在后台执行一个进程时，例如：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cc main.c &amp;
</pre>
</div>

<pre class="example">
shell自动将”后台进程“中对中断和退出信号的处理方式设置为”忽略“，于是当按中断键时就不会影响到后台进程

如果没有这样的处理，那么当按中断键时，它不但终止前台进程，也终止所有后台进程
</pre>
<p>
很多捕捉这两个信号的交互程序具有下列形式的代码:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span>);
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_quit</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGINT, SIG_IGN) != SIG_IGN)
    <span style="color: #daa520; font-weight: bold;">signal</span>(SIGINT, sig_int);
<span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
    <span style="color: #daa520; font-weight: bold;">signal</span>(SIGQUIT, sig_quit);
</pre>
</div>
<p>
这样处理后，仅当 <span class="underline">SIGINT</span> 和 <span class="underline">SIGQUIT</span> <b>当前并不忽略，进程才捕捉它们</b> 
</p>

<pre class="example">
     从signal的这两个调用中也可以看到这种函数的限制：

     只有通过“改变信号的处理方式”才能“获得信号的当前处理方式”！！！
</pre>
</div>
</div>

<div id="outline-container-orgb05c203" class="outline-3">
<h3 id="orgb05c203">fork创建进程</h3>
<div class="outline-text-3" id="text-orgb05c203">
<p>
当一个进程调用fork时，其 <span class="underline">子进程</span> <b>继承</b> <span class="underline">父进程</span> 的 <b>信号处理方式</b> 
</p>

<pre class="example">
     因为子进程在开始时复制了父进程存储图像，所以信号捕捉函数的地址在子进程中是有意义的
</pre>
</div>
</div>
</div>

<div id="outline-container-org08c96cb" class="outline-2">
<h2 id="org08c96cb">不可靠性</h2>
<div class="outline-text-2" id="text-org08c96cb">
<pre class="example">
   在早期的UNIX版本中(例如V7)，信号是不可靠的
</pre>
<p>
不可靠：一个 <span class="underline">信号发生</span> 了，但 <b>进程却可能不知道这个信号</b> 
</p>
</div>

<div id="outline-container-org1f41deb" class="outline-3">
<h3 id="org1f41deb">丢失信号</h3>
<div class="outline-text-3" id="text-org1f41deb">
<p>
早期版本中的一个问题是在进程 <span class="underline">每次处理信号</span> 时，随即将 <b>信号动作复置为默认值</b> ，因此早期的信号处理如下：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>();
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">...</span>
<span style="color: #daa520; font-weight: bold;">signal</span>(SIGINT, sig_int);
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">...</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27492;&#26102;SIGINT&#20449;&#21495;&#22788;&#29702;&#21160;&#20316;&#24050;&#32463;&#24674;&#22797;&#25104;&#40664;&#35748;&#65292;&#24517;&#39035;&#20877;&#27425;&#27880;&#20876;sig_int&#20989;&#25968;</span>
    signal(SIGINT, sig_int);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22788;&#29702;SIGINT&#20449;&#21495;</span>
}
</pre>
</div>

<pre class="example">
     问题在于：在“信号发生”之后到“信号处理程序中调用signal函数”之间有一个时间窗口

     在此段时间中可能发生另一次同样中断信号，第二个信号会造成执行默认动作，而对中断信号则是终止该进程！
</pre>
</div>
</div>

<div id="outline-container-org51a3e48" class="outline-3">
<h3 id="org51a3e48">无法阻塞信号</h3>
<div class="outline-text-3" id="text-org51a3e48">
<p>
有时用户希望通知内核 <b>阻塞</b> 一种信号： <span class="underline">不要忽略</span> 该信号，在其发生时 <span class="underline">记住</span> 它，然后在 <span class="underline">进程作好了准备</span> 时再 <b>通知</b> 它   
</p>
<pre class="example">
那时进程对信号的控制能力也很低，它能“捕捉”信号或“忽略”它

但有些很需要的功能它却并不具备：
1. “阻塞信号”的能力当时并不具备
2. 内核也无法“关闭”某种信号，只能忽略它　
</pre>

<ul class="org-ul">
<li>主函数调用 <span class="underline">pause</span> 函数使自己 <b>睡眠</b> ，直到 <b>捕捉</b> 到一个信号</li>
<li>当 <span class="underline">信号被捕捉</span> 到后，信号处理程序将标志 <span class="underline">sig_int_flag</span> 设置为 <span class="underline">非0</span></li>
<li><p>
在 <span class="underline">信号处理程序返回</span> 之后， <span class="underline">内核</span> 将该 <b>进程唤醒</b> ，它 <span class="underline">检测</span> 到 <span class="underline">该标志为非0</span> ，然后执行它所需做的
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">sig_int_flag</span> = 0; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#25429;&#25417;&#21040;SIGINT&#20449;&#21495;&#65292;&#21017;&#38750;0</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span>);  <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">SIGINT&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>()
{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27880;&#20876;SIGINT&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>
    signal(SIGINT, sig_int);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">...</span>

    <span style="color: #00bfff; font-weight: bold;">while</span>(sig_int_flag == 0)
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#27492;&#26102;&#20449;&#21495;&#21457;&#29983;&#65292;pause&#21487;&#33021;&#19968;&#30452;&#20241;&#30496;&#19979;&#21435;&#65281;&#65281;&#65281; </span>
        pause();<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#19968;&#30452;&#30561;&#30496;&#30452;&#21040;&#26576;&#20010;&#20449;&#21495;&#21457;&#29983;</span>
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">...</span>
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20877;&#27425;&#27880;&#20876;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>
    signal(SIGINT, sig_int);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#26631;&#24535;&#21464;&#37327;&#65292;&#20351;&#24471;main&#20989;&#25968;&#31163;&#24320;while&#24490;&#29615;</span>
    sig_int_flag = 1;
}
</pre>
</div></li>
</ul>

<pre class="example">
     问题在于：如果在测试sig_int_flag之后，调用pause之前发生信号，此时sig_int_flag已经变为1，但是程序还是会调用pause

     如果以后再无此信号发生，则此进程可能会一直睡眠，因此这次发生的信号也就丢失了！   
</pre>

<p>
这种类型的程序在大多数情况下会正常工作，使得我们认为它们正确，而实际上却并不是如此
</p>
</div>
</div>
</div>
<div id="outline-container-org1e6b734" class="outline-2">
<h2 id="org1e6b734">可中断的系统调用</h2>
<div class="outline-text-2" id="text-org1e6b734">
<pre class="example">
    早期UNIX系统的一个特性是：

    如果在进程执行一个低速系统调用而阻塞期间捕捉到一个信号
    则该系统调用就被中断不再继续执行，该系统调用返回出错，其errno设置为EINTR

    这样处理的理由是因为一个信号发生了，进程捕捉到了它
    这意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用
</pre>
<p>
系统调用分成两类：
</p>
<ul class="org-ul">
<li><span class="underline">低速系统</span> 调用：可能会使 <b>进程永远阻塞</b> 的一类系统调用，它们包括：
<ul class="org-ul">
<li>在 <span class="underline">读某些类型的文件</span> 时，如果 <span class="underline">数据并不存在</span> 则可能会使调用者永远阻塞，例如：
<ul class="org-ul">
<li>管道</li>
<li>终端设备</li>
<li>网络设备</li>
</ul></li>
<li>在 <span class="underline">写这些类型的文件</span> 时，如果 <span class="underline">不能立即接受这些数据</span> ，则也可能会使调用者永远阻塞</li>
<li><span class="underline">打开文件</span> ，在某种条件发生之前也可能会使调用者阻塞。例如：
<ul class="org-ul">
<li>打开终端设备，它要等待直到所连接的调制解调器回答了电话</li>
</ul></li>
<li><b>pause</b> (调用 <span class="underline">进程睡眠</span> 直至 <span class="underline">捕捉</span> 到一个信号)和 <b>wait</b></li>
<li>某些 <span class="underline">ioctl</span> 操作</li>
<li>某些 <span class="underline">进程间通信</span> 函数</li>
</ul></li>
</ul>
<pre class="example">
    使用 中断系统 调用这种方法来处理的一种情况是：

    一个进程起动了读终端操作，而使用该终端设备的用户却离开该终端很长时间

    在这种情况下进程可能处于阻塞状态几个小时甚至数天，除非系统停机，否则一直如此
</pre>

<ul class="org-ul">
<li><span class="underline">其他系统</span> 调用</li>
</ul>
<pre class="example">
    在这些低速系统调用中一个例外是与“磁盘I/O”有关的系统调用

    虽然读、写一个磁盘文件可能暂时阻塞调用者：在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期间

    但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态
</pre>



<p>
必须用 <b>显式</b> 方法 处理 <span class="underline">可中断的系统调用</span> 带来的 <b>出错返回</b> 。假定进行一个读操作，它被中断，希望重新起动它如下列样式：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">again</span>:
<span style="color: #00bfff; font-weight: bold;">if</span> ((n = read(fd, buff, BUFFSIZE)) &lt; 0) {
    <span style="color: #00bfff; font-weight: bold;">if</span> (errno == EINTR)
        <span style="color: #00bfff; font-weight: bold;">goto</span> <span style="color: #ffd700;">again</span>;
<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">just an interrupted system call </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">handle other errors </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>

<pre class="example">
为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引进了某些被中断的系统调用的自动再起动
自动再起动的系统调用包括: ioctl、read、readv、write、writev、wait和waitpid
正如前述，其中前五个函数只有对低速设备进行操作时才会被信号中断，而wait和waitpid在捕捉到信号时总是被中断

某些应用程序并不希望这些函数被中断后再起动，因为这种自动再起动的处理方式也会带来问题
为此4.3BSD允许进程在每个信号各别处理的基础上不使用此功能

4.2BSD引进自动再起动功能的一个理由是：
有时用户并不知道所使用的输入、输出设备是否是低速设备
如果编写的程序可以用交互方式运行，则它可能读、写终端低速设备
如果在程序中捕捉信号，而系统却不提供再起动功能，则对每次读、写系统调用就要进行是否出错返回的测试
如果是被中断的，则再进行读、写
</pre>

<p>
表10-2列出了几种实现所提供的信号功能及它们的语义
</p>
<!-- This HTML table template is generated by emacs 26.3 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;系统&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;信号处理&nbsp;<br />
      &nbsp;&nbsp;函数是否<br />
      &nbsp;再包装&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;阻塞信号&nbsp;<br />
      &nbsp;&nbsp;&nbsp;的能力&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;被中断系统&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;调用的再<br />
      &nbsp;&nbsp;启动&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;V7,&nbsp;SVR2<br />
      &nbsp;&nbsp;SVR3,&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;决不&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;sigset,&nbsp;sighold,&nbsp;sigrelse,&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigignore,&nbsp;sigpause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;SVR3,&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;决不&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;signal,&nbsp;sigvec,&nbsp;sigblock,&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;sigsetmask,&nbsp;sigpause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.2BSD&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;总是&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.3BSD&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;默认&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="3" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;sigaction,&nbsp;sigprocmask,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;sigpending,&nbsp;sigsuspend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;POSIX.1&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;未说明&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;可选&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.3BSD&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;可选&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-org82deca6" class="outline-2">
<h2 id="org82deca6">可再入函数</h2>
<div class="outline-text-2" id="text-org82deca6">
<p>
进程 <span class="underline">捕捉到信号</span> 并 <span class="underline">继续执行</span> 时：
</p>
<ul class="org-ul">
<li>首先 <b>执行</b> 该 <span class="underline">信号处理程序中的指令</span></li>
<li>如果从信号处理程序 <b>正常返回</b> (例如没有调用 <span class="underline">exit</span> 或 <span class="underline">longjmp</span> )
<ul class="org-ul">
<li><b>继续执行</b> 在 <span class="underline">捕捉到信号</span> 时 <span class="underline">进程正在执行</span> 的 <b>正常指令序列</b></li>
</ul></li>
</ul>

<pre class="example">
    但在信号处理程序中，不能判断捕捉到信号时进程执行到何处

    如果进程正在执行malloc，在其堆中分配另外的存储空间
    而此时由于捕捉到信号插入”执行该信号处理程序，其中又调用malloc“，这时会发生什么？

    又比如进程正在执行getpwnam这种将其结果存放在”静态存储单元“中的函数
    而插入执行的”信号处理程序中又调用这样的函数“，这时又会发生什么呢？

    在malloc例子中，可能会对”进程造成破坏“，因为malloc通常为它所分配的存储区保持一个链接表
    而插入执行信号处理程序时，”进程可能正在更改此链接表“

    而在getpwnam的例子中，正常返回给调用者的信息可能由返回至信号处理程序的”信息覆盖“
</pre>

<p>
函数是不可再入的原因为：
</p>
<ul class="org-ul">
<li>使用 <b>静态数据结构</b></li>
<li>调用 <b>malloc</b> 或 <b>free</b> 函数</li>
<li><b>标准I/O</b> 函数，标准I/O库的很多实现都以不可再入方式使用全局数据结构</li>
</ul>

<pre class="example">
    信号处理程序中即使调用了POSIX定义的可再入的函数，但因为每个进程只有一个errno变量，所以仍可能修改了其原先的值

    一个信号处理程序，它恰好在main刚设置errno之后被调用
    如果该信号处理程序调用read，则它可能更改errno的值，从而取代了刚由main设置的值
</pre>
<p>
因此，作为一个通用的规则，应当在 <b>信号处理程序前保存，而在其后恢复errno</b> 
</p>
</div>

<div id="outline-container-org20d226a" class="outline-3">
<h3 id="org20d226a">信号处理函数中调用不可再入函数</h3>
<div class="outline-text-3" id="text-org20d226a">
<p>
信号处理程序my_alarm调用不可再入函数getpwnam，而my_alarm每秒钟被调用一次：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;pwd.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_alarm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">passwd</span> *<span style="color: #4eee94;">rootptr</span>;

    printf(<span style="color: #deb887;">"in signal handler\n"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> ((rootptr = getpwnam(<span style="color: #deb887;">"root"</span>)) == <span style="color: #ffd700;">NULL</span>)
        err_sys(<span style="color: #deb887;">"getpwnam(root) error"</span>);
    alarm(1);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">passwd</span>   *<span style="color: #4eee94;">ptr</span>;

    signal(SIGALRM, my_alarm);
    alarm(1);
    <span style="color: #00bfff; font-weight: bold;">for</span> ( ; ; ) {
        <span style="color: #00bfff; font-weight: bold;">if</span> ((ptr = getpwnam(<span style="color: #deb887;">"sar"</span>)) == <span style="color: #ffd700;">NULL</span>)
            err_sys(<span style="color: #deb887;">"getpwnam error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> (strcmp(ptr-&gt;pw_name, <span style="color: #deb887;">"sar"</span>) != 0)
            printf(<span style="color: #deb887;">"return value corrupted!, pw_name = %s\n"</span>,
                   ptr-&gt;pw_name);
    }
}
</pre>
</div>

<pre class="example">
     运行此程序时，其结果具有随意性：

     通常在信号处理程序第一次返回时，该程序将由SIGSEGV信号终止

     检查core文件，从中可以看到main函数已调用getpwnam，而且当信号处理程序调用此同一函数时，某些内部指针出了问题
     偶然，此程序会运行若干秒，然后因产生SIGSEGV信号而终止
     在捕捉到信号后，若main函数仍正确运行，其返回值却有时错误，有时正确
     有时在信号处理程序中调用 getpwnam 会出错返回，其出错值为EBADF(无效文件描述符)
</pre>
<p>
从此实例中可以看出：若在 <span class="underline">信号处理程序</span> 中 <b>调用</b> 一个 <span class="underline">不可再入函数</span> ，则其 <b>结果是不可预见的</b> 
</p>
</div>
</div>
</div>

<div id="outline-container-orgc48ee2b" class="outline-2">
<h2 id="orgc48ee2b">可靠信号机制</h2>
<div class="outline-text-2" id="text-orgc48ee2b">
</div>
<div id="outline-container-orgb75ab68" class="outline-3">
<h3 id="orgb75ab68">术语</h3>
<div class="outline-text-3" id="text-orgb75ab68">
</div>
<div id="outline-container-orgf23acb8" class="outline-4">
<h4 id="orgf23acb8">产生(generation)</h4>
<div class="outline-text-4" id="text-orgf23acb8">
<p>
造成信号的 <span class="underline">某个事件发生</span> ，向 <span class="underline">某个进程</span> <b>发送</b> 一个信号
</p>
<ol class="org-ol">
<li><span class="underline">硬件</span> 异常：例如除以0</li>
<li><span class="underline">软件</span> 条件：例如闹钟时间超过</li>
<li><span class="underline">终端特殊键</span></li>
<li>调用 <span class="underline">kill</span> 函数</li>
</ol>
</div>
</div>

<div id="outline-container-org039cfe0" class="outline-4">
<h4 id="org039cfe0">递送(delivery)</h4>
<div class="outline-text-4" id="text-org039cfe0">
<p>
<span class="underline">内核</span> 在 <span class="underline">进程表</span> 中 <b>设置</b> 某种形式的一个 <span class="underline">标志</span> ，这被称为向一个进程 <b>递送</b> 信号
</p>
</div>

<div id="outline-container-org60e8a4d" class="outline-5">
<h5 id="org60e8a4d">递送顺序(delivery order)</h5>
<div class="outline-text-5" id="text-org60e8a4d">
<pre class="example">
       如果有多个信号要递送给一个进程，POSIX.1并没有规定这些信号的递送顺序

       但是与进程当前状态有关的信号一般会被优先递送，例如SIGSEGV
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd3f7b0e" class="outline-4">
<h4 id="orgd3f7b0e">未决(pending)</h4>
<div class="outline-text-4" id="text-orgd3f7b0e">
<p>
信号 <span class="underline">产生</span> 和 <span class="underline">递送</span> 之间的 <b>时间间隔</b> 
</p>
</div>
</div>

<div id="outline-container-org0fd3171" class="outline-4">
<h4 id="org0fd3171">阻塞(blocking)</h4>
<div class="outline-text-4" id="text-org0fd3171">
<p>
进程可以为 <span class="underline">某个信号</span> 设置为 <b>阻塞</b> ：如果对该信号的动作是 <span class="underline">系统默认</span> 或 <span class="underline">捕捉</span> 该信号，则该进程将对此信号 <b>一直保持</b> 为 <b>未决</b> 状态，直到该进程
</p>
<ol class="org-ol">
<li>对此信号 <b>解除了阻塞</b></li>
<li>对此信号的动作 <b>更改为忽略</b></li>
</ol>

<pre class="example">
      内核是在“递送信号”给进程的时候“决定”它的“处理动作”

      而不是在“信号发生”时候，因此进程在信号递送前仍然可以改变对它的处理动作
</pre>

<p>
进程调用 <span class="underline">sigpending</span> 函数将指定的信号设置为 <b>阻塞</b> 和 <b>未决</b> 
</p>
</div>
<div id="outline-container-org98942ce" class="outline-5">
<h5 id="org98942ce">排队(queue)</h5>
<div class="outline-text-5" id="text-org98942ce">
<pre class="example">
如果在进程解除对某个信号的阻塞之前，这种信号发生了多次

POSIX.1允许系统递送该信号一次或多次。如果递送该信号多次，则称这些信号排了队

大多数UNIX并不对信号排队，虽然发生多次，但内核最终只递送这种信号一次
</pre>
</div>
</div>
</div>

<div id="outline-container-org541a1ed" class="outline-4">
<h4 id="org541a1ed">信号屏蔽字(signal mask)</h4>
<div class="outline-text-4" id="text-org541a1ed">
<p>
<span class="underline">信号屏蔽字</span> 规定了 <b>当前要阻塞递送</b> 到该进程的 <span class="underline">信号集</span> 
</p>

<pre class="example">
      对于每种可能的信号，该“屏蔽字中都有一位”与之对应

      对于某种信号，若其对应位已设置，则它当前是被阻塞的
</pre>

<p>
进程可以调用 <span class="underline">sigprocmask</span> 来 <b>检测</b> 和 <b>更改</b> 其当前 <span class="underline">信号屏蔽字</span> 
</p>
</div>
</div>
<div id="outline-container-org77369fb" class="outline-4">
<h4 id="org77369fb">信号集(sigset)</h4>
<div class="outline-text-4" id="text-org77369fb">
<pre class="example">
      信号数可能会超过一个 ”整型数” 所包含的“二进制位数” 
</pre>

<p>
POSIX.1定义了一个新数据类型 <b>sigset_t</b> ，它保持一个 <span class="underline">信号集</span> 
</p>

<pre class="example">
    例如，信号屏蔽字就保存在这些信号集的一个中
</pre>
</div>
</div>
</div>

<div id="outline-container-org2f59cee" class="outline-3">
<h3 id="org2f59cee">发送信号</h3>
<div class="outline-text-3" id="text-org2f59cee">
</div>
<div id="outline-container-org6b71ba0" class="outline-4">
<h4 id="org6b71ba0">kill函数</h4>
<div class="outline-text-4" id="text-org6b71ba0">
<p>
kill：将 <span class="underline">信号</span> <b>发送</b> 给 <span class="underline">进程或进程组</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23558;&#20449;&#21495;&#21457;&#36865;&#32473;&#36827;&#31243;&#25110;&#36827;&#31243;&#32452;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * pid: &#36827;&#31243;ID&#25110;&#36827;&#31243;&#32452;ID</span>
<span style="color: #ffebcd;"> * signo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">kill</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>);
</pre>
</div>
<p>
pid参数有四种不同的情况: 
</p>
<ul class="org-ul">
<li><span class="underline">pid&gt;0</span> ：将信号发送给 <b>进程ID为pid</b> 的进程</li>
<li><span class="underline">pid==0</span> ：将信号发送给其 <b>进程组ID等于发送进程的进程组ID</b> 
<ul class="org-ul">
<li>发送进程有 <b>许可权</b> 向其 <span class="underline">发送信号的所有进程</span> ，所有进程并不包括 <span class="underline">系统进程集</span> 中的进程</li>
</ul></li>
<li><span class="underline">pid&lt;0</span> ：将信号发送给其 <b>进程组ID等于pid绝对值</b> 
<ul class="org-ul">
<li>发送进程有 <b>许可权</b> 向其 <span class="underline">发送信号的所有进程</span> ，所有进程并不包括 <span class="underline">系统进程集</span> 中的进程</li>
</ul></li>
<li><span class="underline">pid==-1</span> ：将信号发送给 <b>所有进程</b></li>
</ul>

<p>
如果调用kill为调用进程产生信号，而且此信号是 <b>不被阻塞</b> 的，那么在 <span class="underline">kill返回之前</span> ， <span class="underline">signo或者某个其他未决的、非阻塞信号</span> 被 <b>递送</b> 至 <span class="underline">该进程</span> 
</p>
</div>

<div id="outline-container-org052e99f" class="outline-5">
<h5 id="org052e99f">发送权限</h5>
<div class="outline-text-5" id="text-org052e99f">
<p>
进程将信号发送给其他进程需要权限：
</p>
<ul class="org-ul">
<li><b>超级用户</b> 可将信号发送给另一个进程</li>
<li>对于非超级用户，其基本规则是 <span class="underline">发送者的实际或有效用户ID</span> 必须 <b>等于</b> <span class="underline">接收者的实际或有效用户ID</span></li>
</ul>

<pre class="example">
       如果实现支持_POSIX_SAVED_IDS，则用保存的设置-用户-ID代替有效用户ID

       特例：如果被发送的信号是SIGCONT，则进程可将它发送给属于同一对话期的任一其他进程
</pre>
</div>
</div>

<div id="outline-container-org42beec9" class="outline-5">
<h5 id="org42beec9">空信号</h5>
<div class="outline-text-5" id="text-org42beec9">
<p>
POSIX.1将 <span class="underline">信号编号0</span> 定义为 <span class="underline">空信号</span> 。如果signo参数是0，则kill仍 <b>执行</b> <span class="underline">正常的错误检查</span> ，但 <b>不发送信号</b> 
</p>
<pre class="example">
       这常被用来确定一个“特定进程”是否仍旧“存在”

       如果向一个并不存在的进程发送空信号，则kill返回 -1，errno则被设置为ESRCH
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc5c3e35" class="outline-4">
<h4 id="orgc5c3e35">raise函数</h4>
<div class="outline-text-4" id="text-orgc5c3e35">
<p>
raise：向当前进程发送信号
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21521;&#24403;&#21069;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * singo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#36820;&#22238; 0&#65292;&#33509;&#22833;&#36133;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">raise</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
</pre>
</div>

<p>
等价于：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #daa520; font-weight: bold;">kill</span>(<span style="color: #98f5ff;">getpid</span>(), signo);
</pre>
</div>

<pre class="example">
raise的用法类似于面向对象中的"throw Exception"
</pre>
</div>
</div>
</div>

<div id="outline-container-org4cfe887" class="outline-3">
<h3 id="org4cfe887">alarm和pause函数</h3>
<div class="outline-text-3" id="text-org4cfe887">
</div>
<div id="outline-container-orga3acd0c" class="outline-4">
<h4 id="orga3acd0c">alarm</h4>
<div class="outline-text-4" id="text-orga3acd0c">
<p>
<span class="underline">alarm</span> ：设置一个时间值，在将来的某个时刻该时间值会被超过，产生 <b>SIGALRM</b> 信号，默认动作是 <b>终止该进程</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20197;&#31186;&#20026;&#21333;&#20301;&#35774;&#32622;&#36827;&#31243;&#30340;&#38393;&#38047;&#23450;&#26102;&#22120;&#65292;&#36229;&#36807;&#26102;&#20869;&#26680;&#23558;&#20135;&#29983;SIGALARM&#20449;&#21495;&#24182;&#21457;&#36865;&#21040;&#35843;&#29992;&#36827;&#31243;</span>
<span style="color: #ffebcd;"> * &#35813;&#20449;&#21495;&#30340;&#40664;&#35748;&#21160;&#20316;&#26159;&#32456;&#27490;&#36827;&#31243;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * seconds: &#31186;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return&#65306;0 &#25110; &#20197;&#21069;&#35774;&#32622;&#30340;&#38393;&#38047;&#26102;&#38388;&#30340;&#20313;&#30041;&#31186;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">alarm</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">seconds</span>);
</pre>
</div>
<p>
参数 <span class="underline">seconds</span> 的值是 <span class="underline">秒数</span> ，经过了指定的seconds秒后会 <b>产生信号</b> <span class="underline">SIGALRM</span> 
</p>
<ul class="org-ul">
<li>信号由内核产生，由于 <span class="underline">进程调度的延迟</span> ，进程得到控制能够处理该信号还需一段时间</li>
<li>每个进程 <b>只能有一个</b> <span class="underline">闹钟时间</span> 
<ul class="org-ul">
<li>如果在 <span class="underline">调用alarm前</span> 已为该进程 <span class="underline">设置过闹钟时间</span> ，而且它还 <span class="underline">没有超时</span> 
<ul class="org-ul">
<li><span class="underline">以前闹钟时间的余留值</span> 作为本次alarm函数 <span class="underline">调用的值</span> 返回</li>
<li>以前登记的 <b>闹钟时间则被新值</b> 代换</li>
</ul></li>
</ul></li>
<li>如果有 <span class="underline">以前登记</span> 的 <span class="underline">尚未超过</span> 的闹钟时间，而且 <span class="underline">seconds值是0</span> 
<ul class="org-ul">
<li><b>取消</b> 以前的闹钟时间</li>
<li><span class="underline">余留值</span> 仍作为函数的返回值</li>
</ul></li>
</ul>

<pre class="example">
      虽然SIGALRM的默认动作是终止进程

      但是大多数使用闹钟的进程捕捉此信号，例如执行定时的清除操作等
</pre>
</div>
</div>
<div id="outline-container-org9f2f913" class="outline-4">
<h4 id="org9f2f913">pause</h4>
<div class="outline-text-4" id="text-org9f2f913">
<p>
<span class="underline">pause</span> ：使 <span class="underline">调用进程</span> <b>挂起</b> 直至 <span class="underline">捕捉到一个信号</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20351;&#36827;&#31243;&#22312;&#35843;&#29992;&#22788;&#36827;&#20837;&#25346;&#36215;&#29366;&#24577;&#31561;&#24453;&#35813;&#36827;&#31243;&#22788;&#29702;&#19968;&#20010;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: -1&#65292;&#24182;&#19988; errno &#35774;&#32622;&#20026; EINTR</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pause</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
<p>
只有 <b>执行了一个信号处理程序</b> 并 <b>从其返回</b> 后， <b>pause才返回</b> 
</p>
<ul class="org-ul">
<li>在这种情况下，pause返回 <span class="underline">-1</span> ，而且 <span class="underline">errno</span> 被设置为 <span class="underline">EINTR</span></li>
</ul>
</div>
</div>
<div id="outline-container-org632ef29" class="outline-4">
<h4 id="org632ef29">sleep实现</h4>
<div class="outline-text-4" id="text-org632ef29">
</div>
<div id="outline-container-orgbfca782" class="outline-5">
<h5 id="orgbfca782">sleep1</h5>
<div class="outline-text-5" id="text-orgbfca782">
<p>
使用alarm和pause实现sleep1，进程可使自己睡眠一段指定的时间：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">nothing to do, just return to wake up the pause </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sleep1</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nsecs</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
    <span style="color: #00bfff; font-weight: bold;">return</span>(nsecs);
    alarm(nsecs);       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">start the timer </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    pause();            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">next caught signal wakes us up </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>(alarm(0));   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">turn off timer, return unslept time </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
sleep1实现有下列问题：
</p>

<pre class="example">
       如果调用者已设置了闹钟，则它被sleep1函数中的第一次alarm调用擦去
</pre>

<p>
修正方法： <b>检查</b> <span class="underline">第一次</span> 调用 <span class="underline">alarm的返回值</span> ：
</p>
<ul class="org-ul">
<li>如其 <b>小于</b> 本次调用alarm的参数值，只应等到 <span class="underline">前次设置的闹钟时间</span> 超时</li>
<li>如果 <b>大于</b> 本次设置值，则在 <span class="underline">sleep1函数返回之前</span> ， <b>再次设置</b> 闹钟时间，使其在预定时间再发生超时</li>
</ul>


<pre class="example">
       该程序中修改了对SIGALRM的配置

       如果编写了一个函数供其他函数调用，则在该函数被调用时先要保存原配置，在该函数返回前再恢复原配置
</pre>

<p>
修正方法： <b>保存</b>  <span class="underline">signal</span> 函数的 <span class="underline">返回值</span> ，在 <span class="underline">返回前</span> <b>恢复</b> 设置 <span class="underline">原配置</span> 
</p>

<pre class="example">
       在调用alarm和pause之间有一个竞态条件：

       在一个繁忙的系统中，可能“alarm”在 “调用pause之前”超时，并 “调用了信号处理程序”

       如果发生了这种情况，则在调用pause后，如果没有捕捉到其他信号，则调用者将永远被挂起
</pre>

<p>
有两种修正方法：
</p>
<ol class="org-ol">
<li>使用 <span class="underline">setjmp</span> ，以下会说明</li>
<li>使用 <span class="underline">sigprocmask</span> 和 <span class="underline">sigsuspend</span></li>
</ol>
</div>
</div>
<div id="outline-container-org68ee0ed" class="outline-5">
<h5 id="org68ee0ed">sleep2</h5>
<div class="outline-text-5" id="text-org68ee0ed">
<p>
即使pause从未执行，在发生SIGALRM时，sleep2函数也返回 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;setjmp.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">jmp_buf</span>  <span style="color: #4eee94;">env_alrm</span>;

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    longjmp(env_alrm, 1);
}

<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sleep2</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nsecs</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
        <span style="color: #00bfff; font-weight: bold;">return</span>(nsecs);
    <span style="color: #00bfff; font-weight: bold;">if</span> (setjmp(env_alrm) == 0) {
        alarm(nsecs);       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">start the timer </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        pause();            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">next caught signal wakes us up </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    }
    <span style="color: #00bfff; font-weight: bold;">return</span>(alarm(0));       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">turn off timer, return unslept time </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>

<pre class="example">
       但是sleep2函数中却有另一个难于察觉的问题，它涉及到与其他信号的相互作用

       如果 SIGALRM 中断了某个其他信号处理程序，则调用 longjmp 会提早终止该信号处理程序
</pre>
</div>
</div>

<div id="outline-container-org8602293" class="outline-5">
<h5 id="org8602293">其他信号处理程序中调用sleep2</h5>
<div class="outline-text-5" id="text-org8602293">
<ul class="org-ul">
<li>故意使 <span class="underline">SIGINT处理程序</span> 中的 <span class="underline">for循环语句</span> 的 <b>执行时间超过5秒钟</b> ，也就是大于sleep2的参数值</li>
<li><p>
整型变量 j 声明为 <span class="underline">volatile</span> ，这样就 <b>阻止了优化</b> 编译程序除去循环语句
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>);
<span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sleep2</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nsecs</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">unslept</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (SIG_ERR == (signal(SIGINT, sig_int)) )
        err_sys(<span style="color: #deb887;">"signal(SIGINT) error"</span>);

    unslept = sleep2(5);

    printf(<span style="color: #deb887;">"sleep2 returned: %u\n"</span>, unslept);

    exit(0);

}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) 
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">j</span>;

    printf(<span style="color: #deb887;">"\n sig_int starting \n"</span>);

    <span style="color: #00bfff; font-weight: bold;">for</span>(i = 0; i &lt; 200000; i++) {
        j += i * i;
        printf(<span style="color: #deb887;">"i is %d, j is %d\n"</span>, i, j);
    }


    printf(<span style="color: #deb887;">"sig_int finished\n"</span>);

    <span style="color: #00bfff; font-weight: bold;">return</span>;
}
</pre>
</div>

<p>
测试结果：sleep2中的longjmp终止了sig_int的程序运行
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/sleep2
&#710;? <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#20013;&#26029;&#23383;&#31526;</span>
sig_int starting
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">...</span>

i is 166016, j is -143706370i is 166016, j is -143706370
sleep2 returned: 0
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org62d7847" class="outline-4">
<h4 id="org62d7847">超时限制的读操作</h4>
<div class="outline-text-4" id="text-org62d7847">
<pre class="example">
alarm还常用于对“可能阻塞的操作”设置一个“时间上限值”
</pre>

<ol class="org-ol">
<li>在一段时间内从 <span class="underline">标准输入</span> 读一行</li>
<li>将其写到 <span class="underline">标准输出</span> 上</li>
<li><p>
通过 <span class="underline">SIGALRM</span> 信号来 <b>打断read操作</b> 以避免read一直阻塞
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
    err_sys(<span style="color: #deb887;">"signal(SIGALRM) error"</span>);

    alarm(10); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">start timer </span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &lt; 0)
    err_sys(<span style="color: #deb887;">"read error"</span>);

    alarm(0); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">stop alarm </span>

    write(STDOUT_FILENO, line, n);
    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">nothing to do, just return to interrupt the read </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div></li>
</ol>

<pre class="example">
但是这程序依然有两个问题:

1. 在第一次alarm调用和read调用之间有一个竞态条件：
   如果内核在read 和 write调用之间 使进程不能占用CPU运行，而其时间长度又超过闹钟时间，则read可能永远阻塞

2. 如果系统调用是自动再起动的：
   当从SIGALRM信号处理程序返回时，read并不被终止。在这种情形下，设置时间限制不会起作用
</pre>
</div>

<div id="outline-container-org7bfacb7" class="outline-5">
<h5 id="org7bfacb7">read2</h5>
<div class="outline-text-5" id="text-org7bfacb7">
<p>
用 <span class="underline">longjmp</span> 来避免竞态条件：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span>     <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">jmp_buf</span>  <span style="color: #4eee94;">env_alrm</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
        err_sys(<span style="color: #deb887;">"signal(SIGALRM) error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (setjmp(env_alrm) != 0)
        err_quit(<span style="color: #deb887;">"read timeout"</span>);

    alarm(10);
    <span style="color: #00bfff; font-weight: bold;">if</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"read error"</span>);
    alarm(0);

    write(STDOUT_FILENO, line, n);
    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    longjmp(env_alrm, 1);
}
</pre>
</div>

<pre class="example">
       不管是否自动重新启动系统调用，也都会如所预期的那样工作，但是仍旧会有与其他信号处理程序相互作用的问题 
</pre>

<p>
另一种更好地选择是使用 <span class="underline">select</span> 或 <span class="underline">poll</span> 函数
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org29f857d" class="outline-3">
<h3 id="org29f857d">信号集</h3>
<div class="outline-text-3" id="text-org29f857d">
<p>
POSIX.1定义数据类型 <b>sigset_t</b> 以包含一个 <span class="underline">信号集</span> ，并且定义了下列五个 <b>处理信号集</b> 的函数:
</p>
<ul class="org-ul">
<li><span class="underline">sigemptyset</span> ： <b>初始化</b> 由set指向的信号集，使 <b>排除</b> 其中所有信号</li>
<li><span class="underline">sigfillset</span> ： <b>初始化</b> 由set指向的信号集，使其 <b>包括</b> 所有信号</li>
<li><span class="underline">sigaddset</span> ：将一个 <b>信号添加</b> 到现存集中</li>
<li><span class="underline">sigdelset</span> ：从信号集中 <b>删除一个信号</b></li>
<li><span class="underline">sigismember</span> ： <b>测试</b> 信号是否在信号集中</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#21021;&#22987;&#21270;&#30001;set&#25351;&#21521;&#30340;&#20449;&#21495;&#38598;&#65292;&#20351;&#25490;&#38500;&#20854;&#20013;&#25152;&#26377;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * set: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#36820;&#22238; 0&#65292;&#22833;&#36133;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigemptyset</span>(<span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#22635;&#28385;&#25351;&#23450;&#30340;&#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * set: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#36820;&#22238; 0&#65292;&#22833;&#36133;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigfillset</span>(<span style="color: #98f5ff;">siget_t</span> *<span style="color: #4eee94;">set</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20026;&#20449;&#21495;&#38598;&#20013;&#22686;&#21152;&#19968;&#20010;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * set: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> * signo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#36820;&#22238; 0&#65292;&#22833;&#36133;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigaddset</span>(<span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20026;&#20449;&#21495;&#38598;&#20013;&#21024;&#38500;&#19968;&#20010;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * set: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> * signo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#25104;&#21151;&#36820;&#22238; 0&#65292;&#22833;&#36133;&#36820;&#22238; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigdelset</span>(<span style="color: #98f5ff;">setset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#27979;&#35797;&#20449;&#21495;&#26159;&#21542;&#22312;&#20449;&#21495;&#38598;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * set: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> * signo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#30495;&#21017;&#20026; 1&#65292;&#33509;&#20551;&#21017;&#20026; 0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigismember</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>);
</pre>
</div>

<pre class="example">
     所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次

     主要是因为C编译程序将不赋初值的外部和静态度量都初始化为0，而这是否与给定系统上信号集的实现相对应并不清楚
</pre>

<p>
一旦已经初始化了一个信号集就可在该信号集中增、删特定的信号
</p>
</div>

<div id="outline-container-orgf3f1bfe" class="outline-4">
<h4 id="orgf3f1bfe">BSD实现</h4>
<div class="outline-text-4" id="text-orgf3f1bfe">
<p>
如果 <span class="underline">实现的信号数目</span> <b>少于</b> <span class="underline">一个整型量所包含的位数</span> ，则可用 <b>一位代表一个信号</b> 的方法实现信号集
</p>

<pre class="example">
例如，大多数4.3+BSD实现中有31种信号和32位整型

sigemptyset和sigfillset这两个函数可以在&lt;signal.h&gt;头文件中实现为宏
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">sigemptyset</span>(<span style="color: #4eee94;">ptr</span>) ( *(ptr) = 0 )
<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27880;&#24847;&#65306;&#38500;&#20102;&#35774;&#32622;&#23545;&#24212;&#20449;&#21495;&#38598;&#20013;&#21508;&#20449;&#21495;&#30340;&#20301;&#22806;&#65292;sigfillset&#24517;&#39035;&#36820;&#22238;0&#65292;&#25152;&#20197;&#20351;&#29992;&#36887;&#21495;&#31639;&#31526;&#65292;&#23558;&#20043;&#21518;&#30340;&#20540;&#20316;&#20026;&#34920;&#36798;&#24335;&#30340;&#20540;&#36820;&#22238;</span>
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">sigfillset</span>(<span style="color: #4eee94;">ptr</span>) ( *(ptr) =  ~(<span style="color: #98f5ff;">sigset_t</span>)0, 0 )
</pre>
</div>

<p>
使用这种形式表达的信号集：
</p>
<ul class="org-ul">
<li>sigaddset: 设置对应信号位为1</li>
<li>sigdelset: 设置对应信号位为0</li>
<li>sigismember: 测试一指定信号位</li>
</ul>

<pre class="example">
      因为没有信号编号值为0，所以从 信号编号中减1 以得到要处理的位的位编号数
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;errno.h&gt;</span>

<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&lt;signal.h&gt; usually defines NSIG to include signal number 0 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">SIGBAD</span>(<span style="color: #4eee94;">signo</span>)   ((signo) &lt;= 0 || (signo) &gt;= NSIG)

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigaddset</span>(<span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (SIGBAD(signo)) { errno = EINVAL; <span style="color: #00bfff; font-weight: bold;">return</span>(-1); }

    <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">001111001110001011111111101010011 | 0000000000000001000000000000000</span>
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">= 001111001110001111111111101010011</span>
    *set |= 1 &lt;&lt; (signo - 1);       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">turn bit on </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>(0);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigdelset</span>(<span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (SIGBAD(signo)) { errno = EINVAL; <span style="color: #00bfff; font-weight: bold;">return</span>(-1); }
    <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">001111001110001011111111101010011 &amp; 1111111111111101111111111111111</span>
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">= 001111001110000011111111101010011</span>
    *set &amp;= ~(1 &lt;&lt; (signo - 1));    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">turn bit off </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>(0);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigismember</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (SIGBAD(signo)) { errno = EINVAL; <span style="color: #00bfff; font-weight: bold;">return</span>(-1); }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">001111001110001011111111101010011 &amp; 0000000000000001000000000000000 = 0</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">001111001110001111111111101010011 &amp; 0000000000000001000000000000000</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">= 0000000000000001000000000000000</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>((*set &amp; (1 &lt;&lt; (signo - 1))) != 0);
}
</pre>
</div>

<pre class="example">
      也可将这三个函数在实现为各一行的宏

      但是POSIX.1要求检查信号编号参数的有效性，如果无效则设置errno，而在宏中实现这一点比函数要难
</pre>
</div>
</div>

<div id="outline-container-orgf3ca6ae" class="outline-4">
<h4 id="orgf3ca6ae">sigprocmask函数</h4>
<div class="outline-text-4" id="text-orgf3ca6ae">
<p>
<span class="underline">sigprocmask</span> ： <b>检测</b> 或 <b>更改</b> <span class="underline">进程的信号屏蔽字</span> 
</p>
<ul class="org-ul">
<li>如果在 <b>调用sigprocmask后</b> 有任何 <b>未决的、不再阻塞的信号</b> ，则在 <b>sigprocmask返回前</b> ，至少将 <b>其中之一递送给该进程</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20197;how&#25351;&#23450;&#30340;&#26041;&#24335;&#23558;&#20449;&#21495;&#38598;set&#35774;&#32622;&#20026;&#35843;&#29992;&#36827;&#31243;&#30340;&#20449;&#21495;&#23631;&#34109;&#23383;</span>
<span style="color: #ffebcd;"> * &#21516;&#26102;&#25226;&#21407;&#20449;&#21495;&#23631;&#34109;&#23383;&#21462;&#20540;&#20445;&#23384;&#21040;oset&#20013;&#20316;&#20026;&#22791;&#20221;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * how&#65306;&#26356;&#25913;&#24403;&#21069;&#20449;&#21495;&#23631;&#34109;&#23383;&#30340;&#26041;&#27861;</span>
<span style="color: #ffebcd;"> * set&#65306;&#35201;&#35774;&#32622;&#30340;&#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> * oset&#65306;&#21407;&#20449;&#21495;&#23631;&#34109;&#23383;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigprocmask</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">how</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>, <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">oset</span>);
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">oset</span> 是 <span class="underline">非空</span> 指针： <span class="underline">进程的当前信号屏蔽字</span> 通过oset <b>返回</b></li>
<li><span class="underline">set</span> 是一个 <span class="underline">非空</span> 指针，参数 <span class="underline">how</span> 指示如何 <b>修改</b> 当前 <span class="underline">信号屏蔽字</span> ：
<ol class="org-ol">
<li><span class="underline">SIG_BLOCK</span> ： <b>屏蔽</b></li>
<li><span class="underline">SIG_UNBLOCK</span> ： <b>解除屏蔽</b></li>
<li><span class="underline">SIG_SETMASK</span> ： <b>赋值</b></li>
</ol></li>
</ul>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 用sigprocmask更改当前信号屏蔽字的方法</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">how</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">SIG_BLOCK</td>
<td class="org-left">该进程新的信号屏蔽字是其 <b>当前信号屏蔽字和set指向信号集的并集</b> 。set包含了希望阻塞的附加信号</td>
</tr>

<tr>
<td class="org-left">SIG_UNBLOCK</td>
<td class="org-left">该进程新的信号屏蔽字是其 <b>当前信号屏蔽字和set所指向信号集的交集</b> 。set包含了希望解除阻塞的信号</td>
</tr>

<tr>
<td class="org-left">SIG_SETMASK</td>
<td class="org-left">该进程新的 <b>信号屏蔽是set指向的值</b></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><span class="underline">set</span> 是个 <span class="underline">空</span> 指针，则 <b>不改变该进程的信号屏蔽字</b> ，how的值也无意义，只是 <b>通过oset返回</b> 当前信号屏蔽字</li>
</ul>
</div>

<div id="outline-container-org587d2ec" class="outline-5">
<h5 id="org587d2ec">实例</h5>
<div class="outline-text-5" id="text-org587d2ec">
<p>
打印调用进程的信号屏蔽字所阻塞信号的名称：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_mask</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>) 
{
    <span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">sigset</span>;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">error_save</span>;

    error_save = errno; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">save errno we can be called by signal handler</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> (sigpromask(0, <span style="color: #ffd700;">NULL</span>, &amp;sigset) &lt; 0 )
        err_sys(<span style="color: #deb887;">"sigpromask error"</span>);

    printf(<span style="color: #deb887;">"%s"</span>, str);

    <span style="color: #00bfff; font-weight: bold;">if</span>(sigismemeber(&amp;sigset, SIGINT))
        printf(<span style="color: #deb887;">"SIGINT "</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigismemeber(&amp;sigset, SIGQUIT))
        printf(<span style="color: #deb887;">"SIGQUIT "</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigismemeber(&amp;sigset, SIGUSR1))
        printf(<span style="color: #deb887;">"SIGUSR1 "</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigismemeber(&amp;sigset, SIGALRM))
        printf(<span style="color: #deb887;">"SIGALRM "</span>);

    printf(<span style="color: #deb887;">'\n'</span>);

    errno = error_save;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3039e41" class="outline-4">
<h4 id="org3039e41">sigpending函数</h4>
<div class="outline-text-4" id="text-org3039e41">
<p>
<span class="underline">sigpending</span> ：返回对于 <span class="underline">调用进程</span> <b>被阻塞不能递送</b> 和 <b>当前未决</b> 的 <span class="underline">信号集</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#33719;&#21462;&#24403;&#21069;&#22240;&#38459;&#22622;&#32780;&#26410;&#20915;&#30340;&#20449;&#21495;&#38598;&#21040;&#25351;&#23450;&#30340;&#25351;&#38024;set&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * set: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigpending</span>(<span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">set</span>);
</pre>
</div>
</div>

<div id="outline-container-orgd5e1809" class="outline-5">
<h5 id="orgd5e1809">实例</h5>
<div class="outline-text-5" id="text-orgd5e1809">
<ol class="org-ol">
<li>进程 <b>阻塞</b> 了 <span class="underline">SIGQUIT</span> 信号
<ul class="org-ul">
<li><b>保存</b> 了 <span class="underline">当前信号屏蔽字</span> 以便以后恢复</li>
</ul></li>
<li><span class="underline">睡眠</span> 5秒钟
<ul class="org-ul">
<li>在此期间所产生的 <span class="underline">退出信号</span> 都被 <b>阻塞</b> ， <span class="underline">不递送至该进程</span> ，直到该信号不再被阻塞</li>
</ul></li>
<li>在5秒睡眠结束后， <b>检查</b> 是否有 <span class="underline">信号未决</span></li>
<li><p>
<span class="underline">SIGQUIT</span> 设置为 <b>不再阻塞</b> 
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_quit</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_quit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) 
{
    printf(<span style="color: #deb887;">"caught SIGQUIT\n"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGQUIT, SIG_DFL)) )
        err_sys(<span style="color: #deb887;">"can't reset SIGQUIT"</span>);

    <span style="color: #00bfff; font-weight: bold;">return</span>;
}


<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">newmask</span>, <span style="color: #4eee94;">oldmask</span>, <span style="color: #4eee94;">pendmask</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGQUIT, sig_quit))) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27979;&#35797;&#26159;&#21542;&#33021;&#35774;&#32622;&#20449;&#21495;&#22788;&#29702;&#26041;&#24335;</span>
        err_sys(<span style="color: #deb887;">"can't catch SIGQUIT"</span>);

    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask, SIGQUIT); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20449;&#21495;&#23631;&#34109;&#23383;&#20013;&#22686;&#21152;SIGQUIT&#20449;&#21495;</span>

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">block SIGQUIT and save current signal mask</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0 )  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;newmask&#20026;&#24403;&#21069;&#20449;&#21495;&#23631;&#34109;&#23383;&#65292;&#20445;&#23384;&#32769;&#30340;&#20449;&#21495;&#23631;&#34109;&#23383;&#21040; oldmask</span>
        err_sys(<span style="color: #deb887;">"SIG_BLOCK error"</span>);

    sleep(5); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">SIGQUIT remain pending</span>

    <span style="color: #00bfff; font-weight: bold;">if</span>(sigpending(&amp;pendmask) &lt; 0 ) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26816;&#26597;&#26159;&#21542;&#26377;&#20449;&#21495;&#26410;&#20915;</span>
        err_sys(<span style="color: #deb887;">"sigpending error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigismember(&amp;pendmask, SIGQUIT))
        printf(<span style="color: #deb887;">"\nSIGQUIT pending\n"</span>);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">reset signal mask which unblocks SIGQUIT</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>) &lt; 0) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24674;&#22797;&#20449;&#21495;&#23631;&#34109;&#23383;</span>
        err_sys(<span style="color: #deb887;">"SIG_SETMASK error"</span>);

    printf(<span style="color: #deb887;">"SIGQUIT unblocked\n"</span>);

    sleep(5);

    exit(0);
}
</pre>
</div></li>
</ol>

<pre class="example">
       在设置SIGQUIT为阻塞前，保存了老的屏蔽字

       为了解除对该信号的阻塞，用老的屏蔽字重新设置了进程信号屏蔽字(SIG_SETMASK)

       另一种方法是用SIG_UNBLOCK使阻塞的信号不再阻塞

       但是如果编写一个可能由其他人使用的函数，而且需要在函数中阻塞一个信号，则不能用SIG_UNBLOCK解除对此信号的阻塞

       这是因为此函数的调用者在调用本函数之前可能也阻塞了此信号，在这种情况下必须使用SIG_SETMASK将信号屏蔽字恢复为原先值！
</pre>

<p>
测试代码：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/sigprocmaskExample 
^<span style="color: #deb887;">\ </span><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;&#20449;&#21495;&#19968;&#27425;(&#22312;5&#31186;&#20043;&#20869;)</span>
SIGQUIT pending <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20174;sleep&#36820;&#22238;</span>
caught SIGQUIT <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20449;&#21495;&#22788;&#29702;&#31243;&#24207;</span>
SIGQUIT unblocked <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20174;sigprocmask&#36820;&#22238;&#21518;</span>
^\Quit <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20877;&#27425;&#36882;&#36865;&#20449;&#21495;&#65292;&#40664;&#35748;&#21160;&#20316;&#22788;&#29702;</span>

$ ./src/signal/sigprocmaskExample 
^<span style="color: #deb887;">\^\^\^\^\^\^\^\^\ </span><span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;&#22810;&#27425;&#20449;&#21495;(&#22312;5&#31186;&#20043;&#20869;)</span>
SIGQUIT pending
caught SIGQUIT <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21482;&#36882;&#36865;&#20449;&#21495;&#19968;&#27425;</span>
SIGQUIT unblocked
^\Quit
</pre>
</div>

<ul class="org-ul">
<li>在 <span class="underline">第一次睡眠期间</span> 如果产生了 <span class="underline">退出信号</span> ，此时该信号是 <b>阻塞的</b></li>
<li>在  <span class="underline">sigprocmask</span> （恢复信号屏蔽字）后， 这个信号是 <b>未决的，但不再阻塞的</b> 
<ul class="org-ul">
<li>在这个 <span class="underline">sigprocmask返回之前</span> 这个信号会被 <b>递送到本进程</b> 
<ul class="org-ul">
<li>SIGQUIT处理程序(sig_quit)中的printf语句先执行</li>
<li>再执行sigprocmask之后的printf语句</li>
</ul></li>
</ul></li>
<li>进程再睡眠5秒钟。如果在此期间 <span class="underline">再产生退出信号</span> ，那么它就会 <b>使该进程终止</b> 
<ul class="org-ul">
<li>因为在上次捕捉到该信号时，已将其 <span class="underline">处理方式</span> 设置为 <b>默认动作</b></li>
</ul></li>
<li>第二次运行该程序时，在进程睡眠期间使SIGQUIT信号产生了多次次，但是解除了对该信号的阻塞后， <b>只向进程传送一次SIGQUIT</b> 
<ul class="org-ul">
<li>可以看出linux系统没有将信号进行排队</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org3473a39" class="outline-3">
<h3 id="org3473a39">注册信号处理方式</h3>
<div class="outline-text-3" id="text-org3473a39">
<pre class="example">
sigaction函数取代了UNIX早期版本使用的signal函数
</pre>
</div>

<div id="outline-container-org8fdfdf4" class="outline-4">
<h4 id="org8fdfdf4">sigaction结构</h4>
<div class="outline-text-4" id="text-org8fdfdf4">
<p>
更全面地定义了信号处理的方式
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> *  &#20449;&#21495;&#22788;&#29702;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> * </span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span> {
    <span style="color: #98f5ff;">void</span> (*sa_handler)(<span style="color: #98f5ff;">int</span>); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#25351;&#38024;&#65292;SIG_IGN&#65292;SIG_DFL&#65292;&#33258;&#23450;&#20041;&#20989;&#25968;</span>
    <span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">sa_mask</span>; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20449;&#21495;&#23631;&#34109;&#23383;</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">sa_flags</span>; <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20449;&#21495;&#22788;&#29702;&#36873;&#39033;</span>
}
</pre>
</div>
</div>

<div id="outline-container-orgdf16eae" class="outline-5">
<h5 id="orgdf16eae">sa_handler字段</h5>
<div class="outline-text-5" id="text-orgdf16eae">
<p>
类似于signal函数中的 <b>信号处理函数指针</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">SIG_IGN</span> ： <b>忽略</b> 信号</li>
<li><span class="underline">SIG_DFL</span> ：信号 <b>默认</b> 处理动作</li>
<li>用户自定义函数</li>
</ul>
</div>
</div>

<div id="outline-container-org0a8ab9a" class="outline-5">
<h5 id="org0a8ab9a">sa_mask字段</h5>
<div class="outline-text-5" id="text-org0a8ab9a">
<p>
当 <span class="underline">更改信号动作</span> 时，如果 <b>sa_handler</b> 指向一个 <span class="underline">信号捕捉函数</span> (不是常数SIG_IGN或SIG_DFL)，则 <b>sa_mask</b> 字段代表了一个 <span class="underline">信号集</span> ：
</p>
<ul class="org-ul">
<li><span class="underline">注册后</span> 将加到 <span class="underline">进程原先的信号屏蔽字</span> 中</li>
<li>在 <span class="underline">信号捕捉函数被调用</span> 时，还将 <b>隐式的加上</b> <span class="underline">所处理的信号</span></li>
<li>在 <span class="underline">信号捕捉函数结束后</span> 再 <b>隐式的恢复</b>  <span class="underline">调用前的阻塞状态</span></li>
</ul>
</div>
</div>

<div id="outline-container-orgdab5e14" class="outline-5">
<h5 id="orgdab5e14">sa_flags字段</h5>
<div class="outline-text-5" id="text-orgdab5e14">
<p>
<b>sa_flags</b> 字段包含了对 <span class="underline">信号进行处理的各个选择项</span> ，下表详细列出了这些可选项的意义：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 信号处理的选择项标志 (sa_flags)</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sa_flags</td>
<td class="org-left">POSIX</td>
<td class="org-left">SVR4</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">SA_NOCLDSTOP</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">若signo是 <span class="underline">SIGCHLD</span> ，当一子进程 <b>停止</b> 时(作业控制)， <b>不产生此信号</b> 。当一子进程终止时，仍旧产生此信</td>
</tr>

<tr>
<td class="org-left">SA_RESTART</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">由此信号中断的 <b>系统调用自动再起动</b></td>
</tr>

<tr>
<td class="org-left">SA_ONSTACK</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">若用sigaltstack(2)已说明了一替换栈，则此信号递送给替换栈上的进程</td>
</tr>

<tr>
<td class="org-left">SA_NOCLDWAIT</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">若signo是 <span class="underline">SIGCHLD</span> ，则当调用进程的 <span class="underline">子进程终止</span> 时， <b>不创建僵死进程</b> 。若调用进程在后面调用wait，则阻塞到它所有子进程都终止，此时返回-1，errno设置为ECHILD</td>
</tr>

<tr>
<td class="org-left">SA_NODEFER</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">若当捕捉到此信号时，在 <span class="underline">执行其信号捕捉函数时</span> ，系统 <b>不自动阻塞此信号</b> 。注意：此种类型的操作对应于早期的不可靠信号</td>
</tr>

<tr>
<td class="org-left">SA_RESETHAND</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">若对此信号的处理方式在 <span class="underline">此信号捕捉函数的入口处</span> <b>复置为SIG_DFL</b> 。注意：此种类型的信号对应于早期的不可靠信号</td>
</tr>

<tr>
<td class="org-left">SA_SIGINFO</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">若此选项对信号处理程序提供了附加信息</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgdefb1bb" class="outline-4">
<h4 id="orgdefb1bb">sigaction函数</h4>
<div class="outline-text-4" id="text-orgdefb1bb">
<p>
<span class="underline">sigaction</span> 函数： <b>检查</b> 或 <b>修改</b> 与 <span class="underline">指定信号</span> 相关联的 <span class="underline">处理方式</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#27880;&#20876;&#20449;&#21495;&#22788;&#29702;&#30340;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * signo: &#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffebcd;"> * act: &#35201;&#35774;&#32622;&#30340;&#20449;&#21495;&#22788;&#29702;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> * oact: &#21407;&#26469;&#30340;&#20449;&#21495;&#22788;&#29702;&#26041;&#24335;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigaction</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span> *<span style="color: #4eee94;">act</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span> *<span style="color: #4eee94;">oact</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数 <span class="underline">signo</span> ：检测或修改具体动作的 <b>信号的编号数</b></li>
<li>若 <span class="underline">act</span> 指针 <span class="underline">非空</span> ：则要 <b>修改</b> 其 <span class="underline">处理方式</span></li>
<li>若 <span class="underline">oact</span> 指针 <span class="underline">非空</span> ：则系统 <b>返回</b> 该信号的 <span class="underline">原先处理方式</span></li>
</ul>

<pre class="example">
      一旦对给定的信号设置了一个动作，那么在用sigaction改变它之前，该设置就一直有效

      这与早期的不可靠信号机制不同，早期的signal注册的处理动作再捕捉一个信号后会恢复成默认动作
</pre>
</div>

<div id="outline-container-org09507c2" class="outline-5">
<h5 id="org09507c2">实现signal函数</h5>
<div class="outline-text-5" id="text-org09507c2">
<p>
用 <span class="underline">sigaction</span> 实现 <span class="underline">signal</span> 函数：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">Sigfunc</span> *<span style="color: #daa520; font-weight: bold;">signal</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>, <span style="color: #98f5ff;">Sigfunc</span> *<span style="color: #4eee94;">func</span>) 
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span> <span style="color: #4eee94;">act</span>, <span style="color: #4eee94;">oact</span>;

    act.sa_handler = func;
    sigemptyset(&amp;act.sa_mask);
    act.sa_flags = 0;
    <span style="color: #00bfff; font-weight: bold;">if</span> (SIGALRM == signo) {
<span style="color: #ffd700;">#ifdef</span> SA_INTERRUPT
        act.sa_flags |= SA_INTERRUPT;
<span style="color: #ffd700;">#endif</span>
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
<span style="color: #ffd700;">#ifdef</span> SA_RESTART
        act.sa_flags |= SA_RESTART;
<span style="color: #ffd700;">#endif</span>
    }
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigaction(signo, &amp;act, &amp;oact) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span> SIG_ERR;

    <span style="color: #00bfff; font-weight: bold;">return</span> oact.sa_handler;
}
</pre>
</div>

<ul class="org-ul">
<li>必须用 <span class="underline">sigemptyset</span> 函数 <b>初始化act结构的成员</b></li>
<li><span class="underline">除SIGALRM以外的所有信号</span> 都企图 <b>设置SA_RESTART标志</b> ，于是被这些信号中断的 <b>系统调用都能再起动</b></li>
</ul>

<pre class="example">
       不希望再起动由SIGALRM信号中断的系统调用的原因：可以对I/O操作可以设置时间限制

       某些系统(如SunOS)定义了SA_INTERRUPT标志，这些系统的默认方式是重新起动被中断的系统调用，而指定此标志则使系统调用被中断后不再重起动
</pre>

<p>
下面这个signal_intr <b>禁止系统中断再启动</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">Sigfunc</span> *<span style="color: #daa520; font-weight: bold;">signal_intr</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>, <span style="color: #98f5ff;">Sigfunc</span> *<span style="color: #4eee94;">func</span>) 
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span> <span style="color: #4eee94;">act</span>, <span style="color: #4eee94;">oact</span>;

    act.sa_handler = func;
    sigemptyset(&amp;act.sa_mask);
    act.sa_flags = 0;
<span style="color: #ffd700;">#ifdef</span> SA_INTERRUPT
    act.sa_flags |= SA_INTERRUPT;
<span style="color: #ffd700;">#endif</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigaction(signo, &amp;act, &amp;oact) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span> SIG_ERR;

    <span style="color: #00bfff; font-weight: bold;">return</span>(oact.sa_handler);
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf053e05" class="outline-3">
<h3 id="orgf053e05">信号处理函数中的非局部转移</h3>
<div class="outline-text-3" id="text-orgf053e05">
<pre class="example">
当捕捉到一个信号时，进入信号捕捉函数后，此时当前信号被自动地加到进程的信号屏蔽字中

这阻止了后来产生的这种信号中断此信号处理程序

但如果用longjmp跳出此信号处理程序，无法保证恢复当前进程的信号屏蔽字

POSIX.1并没有说明setjmp和longjmp对信号屏蔽字的作用
</pre>
<p>
<span class="underline">信号处理程序</span> 中作 <b>非局部转移</b> 时应当使用这两个函数：
</p>
<ul class="org-ul">
<li><span class="underline">sigsetjmp</span> ：保存函数跳转点， 支持 <b>保存当前信号屏蔽字</b></li>
<li><span class="underline">siglongjmp</span> ：跳转到保存的函数跳转点，支持 <b>恢复以前保存的信号屏蔽字</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20445;&#23384;&#20989;&#25968;&#36339;&#36716;&#28857;&#65292;&#25903;&#25345;&#21516;&#26102;&#20445;&#23384;&#24403;&#21069;&#20449;&#21495;&#23631;&#34109;&#23383;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * env: &#36339;&#36716;&#28857;</span>
<span style="color: #ffebcd;"> * savemask: &#22914;&#26524;&#20540;&#26159;&#38750;0&#30340;&#26102;&#20505;&#23558;&#22791;&#20221;&#35843;&#29992;&#26102;&#36827;&#31243;&#30340;&#20449;&#21495;&#23631;&#34109;&#23383;&#65292;&#22312;&#35843;&#29992;siglongjmp&#21518;&#20250;&#24674;&#22797;&#24674;&#22797;&#21040;&#35813;&#22791;&#20221;&#30340;&#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#33509;&#30452;&#25509;&#35843;&#29992;&#21017;&#20026;0&#65292;&#33509;&#20174; siglongjmp &#35843;&#29992;&#36820;&#22238;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigsetjmp</span>(<span style="color: #98f5ff;">sigjmp_buf</span> <span style="color: #4eee94;">env</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">savemask</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#36339;&#36716;&#21040;&#20445;&#23384;&#30340;&#36339;&#36716;&#28857;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * env: &#20445;&#23384;&#30340;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#36339;&#36716;&#28857;</span>
<span style="color: #ffebcd;"> * val: &#36820;&#22238;&#32473;sigsetjmp&#30340;&#20540;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">siglongjmp</span>(<span style="color: #98f5ff;">sigjmp_buf</span> <span style="color: #4eee94;">env</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">val</span>);
</pre>
</div>
</div>

<div id="outline-container-org491809d" class="outline-4">
<h4 id="org491809d">实例</h4>
<div class="outline-text-4" id="text-org491809d">
<p>
下面程序展示了在 <span class="underline">信号处理程序被调用时</span> 和 <span class="underline">调用后</span> 进程 <b>信号屏蔽字的自动变化</b> 以及如何使用 <span class="underline">sigsetjmp</span> 和 <span class="underline">siglongjmp</span> 函数：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;time.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_usr1</span>(<span style="color: #98f5ff;">int</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">jmpbuf</span>;
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">sig_atomic_t</span> <span style="color: #4eee94;">canjump</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGUSR1, sig_usr1)) )
        err_sys(<span style="color: #deb887;">"signal(SIGUSR1) error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGALRM, sig_alrm)) )
        err_sys(<span style="color: #deb887;">"signal(SIGALRM) error"</span>);

    pr_mask(<span style="color: #deb887;">"starting main: "</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span>(sigsetjmp(jmpbuf, 1)) {
        pr_mask(<span style="color: #deb887;">"ending main: "</span>);
        exit(0);
    }

    canjump = 1;<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">now sigsetjmp() is OK</span>

    <span style="color: #00bfff; font-weight: bold;">for</span>(; ;)
        pause();
}


<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_usr1</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) 
{
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">starttime</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>(0 == canjump)
        <span style="color: #00bfff; font-weight: bold;">return</span>;

    pr_mask(<span style="color: #deb887;">"starting sig_usr1:"</span>);

    alarm(3); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">SIG_ALRM in 3 seconds</span>

    starttime = time(<span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">for</span>(; ;) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">busy wait for 5 seconds </span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(time(<span style="color: #ffd700;">NULL</span>) &gt; starttime + 5)
            <span style="color: #00bfff; font-weight: bold;">break</span>;

    pr_mask(<span style="color: #deb887;">"finishing sig_usr1: "</span>); 

    canjump = 0;

    siglongjmp(jmpbuf, 1); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">jump back to main, do not return </span>
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) 
{
    pr_mask(<span style="color: #deb887;">"in sig_alrm: "</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>;
}
</pre>
</div>

<p>
图10-1显示了此程序的执行时间顺序。将图10-1分成三部分:
</p>
<ul class="org-ul">
<li>左面部分 main : 信号屏蔽字是 <span class="underline">0</span> (没有信号是阻塞的)</li>
<li>中间部分 sig_usr1 : 其信号屏蔽字是 <span class="underline">SIGUSR1</span></li>
<li><p>
右面部分 sig_alrm : 信号屏蔽字是 <span class="underline">SIGUSR1 | SIGALRM</span> 
</p>

<p width="90%">
<img src="pic/sigsetjmp.png" alt="sigsetjmp.png" width="90%" />]]
</p>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/sigjmpExample &amp; 
[1] 32531

$ starting main: <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#24320;&#22987;&#36816;&#34892;&#20027;&#31243;&#24207;&#30340;&#26102;&#20505;&#27809;&#26377;&#23631;&#34109;&#20219;&#20309;&#30340;&#20449;&#21495;&#65292;sigsetjmp&#30340;&#26102;&#20505;&#20250;&#20445;&#23384;</span>
starting sig_usr1:SIGUSR1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24320;&#22987;&#22788;&#29702;SIGUSR1&#20449;&#21495;&#21518;&#65292;&#33258;&#21160;&#23631;&#34109;&#35843;SIGUSR1</span>
<span style="color: #00bfff; font-weight: bold;">in</span> sig_alrm: SIGUSR1 SIGALRM <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#24320;&#22987;&#22788;&#29702;SIGALRM&#20449;&#21495;&#21518;&#65292;&#32487;&#32493;&#22686;&#21152;&#23545;SIGALRM&#20449;&#21495;&#30340;&#23631;&#34109;</span>
finishing sig_usr1: SIGUSR1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#22788;&#29702;&#23436;SIGALRM&#20449;&#21495;&#65292;&#33258;&#21160;&#35299;&#38500;&#23545;SIGALRM&#20449;&#21495;&#30340;&#23631;&#34109;</span>
ending main: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">SIGUSR1&#20449;&#21495;&#24050;&#32463;&#20174;&#20449;&#21495;&#23631;&#34109;&#23383;&#34987;&#31227;&#38500;&#20102;&#65292;&#36825;&#26159;&#22240;&#20026;&#20174;siglongjmp&#36339;&#36716;&#22238;&#26469;&#26102;&#20250;&#24674;&#22797;&#20026;sigsetjmp&#26102;&#30340;&#20449;&#21495;&#23631;&#34109;&#23383;</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#22238;&#36710;</span>
[1]+  Done                    ./src/signal/sigjmpExample
</pre>
</div>

<p>
如果使用 <span class="underline">setjmp</span> 和 <span class="underline">longjmp</span> 替换 sigsetjmp 和 siglongjmp的测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/longjmpExample &amp; 
[1] 32159

$ starting main: 
starting sig_usr1:SIGUSR1 
<span style="color: #00bfff; font-weight: bold;">in</span> sig_alrm: SIGUSR1 SIGALRM 
finishing sig_usr1: SIGUSR1 
ending main: SIGUSR1 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20381;&#26087;&#20445;&#30041;&#22914;&#21516;&#22788;&#29702;SIGUSR1&#26102;&#20505;&#30340;&#20449;&#21495;&#23631;&#34109;&#23383;&#65281;&#65281;&#65281;</span>

[1]+  Done                    ./src/signal/longjmpExample
</pre>
</div></li>
</ul>

<pre class="example">
       这表示在调用 setjmp之后执行 main 函数时，其SIGUSR1是阻塞的，这多半不是所希望的
</pre>
</div>

<div id="outline-container-org5d92476" class="outline-5">
<h5 id="org5d92476">setsigjmp的保护机制</h5>
<div class="outline-text-5" id="text-org5d92476">
<pre class="example">
	在调用sigsetjmp之后将变量 canjump 设置为非0，在信号处理程序中检测此变量，仅当它为非0值时才调用siglongjmp

       这提供了一种保护机制：如果在jmpbuf尚未被sigsetjmp初始化前，一旦捕捉到该处理信号，则不执行处理动作就返回

       在一般的C代码中(不是信号处理程序)，对于longjmp并不需要这种保护措施

       但是因为信号可能在任何时候发生，所以在信号处理程序中，必须要这种保护措施！！！
</pre>

<p>
canjump必须被声明为数据类型 <b>sig_atomic_t</b> ，这是由ANSIC定义的在 <b>写时不会被中断</b> 的变量类型
</p>
<ul class="org-ul">
<li>这种变量在 <b>具有虚存的系统上不会跨越页的边界</b> ，可以用 <b>一条机器指令对其进行存取</b></li>
<li>这种类型的变量总是修饰符 <span class="underline">volatile</span> ： <b>该变量将由两个不同的控制线</b> （ <span class="underline">main函数</span> 和 <span class="underline">异步执行的信号处理程序</span> ） <b>存取</b></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org8afb0e0" class="outline-3">
<h3 id="org8afb0e0">sigsuspend函数</h3>
<div class="outline-text-3" id="text-org8afb0e0">
<pre class="example">
     更改进程的信号屏蔽字可以阻塞或解除阻塞所选择的信号

     使用这种技术可以保护不希望由信号中断的代码临界区

     如果希望对一个信号“解除阻塞”，然后pause以等待”以前被阻塞的信号发生“，则又将如何呢？
</pre>

<p>
假定信号是 <span class="underline">SIGINT</span> ，可能的实现代码如下：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">newmask</span>, <span style="color: #4eee94;">oldmask</span>;

sigemptyset(&amp;newmask);
sigaddset(&amp;newmask, SIGINT);

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">block SIGINT and save current sigmask</span>
<span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0)
    err_sys(<span style="color: #deb887;">"SIG_BLOCK error"</span>);

<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">critical region code </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">reset signal mask, which unblocks SIGINT</span>
<span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>) &lt; 0)
    err_sys(<span style="color: #deb887;">"SIG_SETMASK error"</span>);

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">wait for signal occurs</span>
<span style="color: #daa520; font-weight: bold;">pause</span>();

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">continue processing...</span>
</pre>
</div>

<pre class="example">
     问题在于：如果在“解除对SIGINT的阻塞”和“pause”之间发生了SIGINT信号，则此信号被丢失
</pre>
<p>
为了修正这个问题提供了下面的函数：
</p>

<ul class="org-ul">
<li><span class="underline">sigsuspend</span> ： <b>恢复</b> 信号屏蔽字，然后使 <b>进程睡眠</b> 的 <b>原子</b> 操作</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23454;&#29616;&#20102;sigprocmask + pause&#30340;&#21407;&#23376;&#25805;&#20316;</span>
<span style="color: #ffebcd;"> * &#20351;&#36827;&#31243;&#25346;&#36215;&#24182;&#31561;&#24453;&#20449;&#21495;&#65292;&#24182;&#20351;&#29992;&#25351;&#23450;&#30340;&#20449;&#21495;&#38598; sigmask &#20915;&#23450;&#26159;&#21542;&#38459;&#22622;&#36824;&#26159;&#22788;&#29702;&#30456;&#20851;&#20449;&#21495;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * sigmask: &#20449;&#21495;&#38598;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: -1&#65292;&#24182;&#19988; errno &#35774;&#32622;&#20026; EINTR</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sigsuspend</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">sigmask</span>);
</pre>
</div>
<p>
<span class="underline">进程的信号屏蔽字</span> 设置为由 <span class="underline">sigmask指向的值</span> ：
</p>
<ul class="org-ul">
<li>在 <span class="underline">捕捉到一个信号</span> 或发生了 <span class="underline">一个会终止该进程的信号</span> 之前，该进程被 <b>挂起</b> 
<ul class="org-ul">
<li>如果 <span class="underline">捕捉到一个信号</span> 而且 <span class="underline">从该信号处理程序返回</span> ，则 <b>sigsuspend返回</b> ，并且 <span class="underline">该进程的信号屏蔽字</span> <b>恢复</b> 为 <span class="underline">调用sigsuspend之前的值</span></li>
</ul></li>
<li>此函数 <b>没有成功返回值</b> ：如果它返回到调用者，则总是返回 <span class="underline">-1</span> ，并且 <span class="underline">errno</span> 设置为 <span class="underline">EINTR</span> (表示一个被中断的系统调用)</li>
</ul>
</div>

<div id="outline-container-orgc16a736" class="outline-4">
<h4 id="orgc16a736">保护临界区不被信号中断</h4>
<div class="outline-text-4" id="text-orgc16a736">
<p>
以下程序显示了保护临界区，使其不被指定的信号中断的正确方法：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">newmask</span>, <span style="color: #4eee94;">oldmask</span>, <span style="color: #4eee94;">zeromask</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGINT, sig_int)))
        err_sys(<span style="color: #deb887;">"signal(SIGINT) error"</span>);

    sigemptyset(&amp;zeromask);

    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask, SIGINT);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">block SIGINT and save current signal mask</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0)
        err_sys(<span style="color: #deb887;">"SIG_BLOCK error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">critical region of code</span>
    pr_mask(<span style="color: #deb887;">"in critical region: "</span>);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">allow all signals and pause </span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigsuspend(&amp;zeromask) != -1)
        err_sys(<span style="color: #deb887;">"sigsuspend error"</span>);
    pr_mask(<span style="color: #deb887;">"after return from sigsuspend"</span>);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">reset signal mask which unblocks SIGINT</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>) &lt; 0)
        err_sys(<span style="color: #deb887;">"SIG_SETMASK error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">continue processing</span>

    exit(0);


}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) 
{
    pr_mask(<span style="color: #deb887;">"\n in sig_int: "</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>;
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/criticalRegion 

<span style="color: #00bfff; font-weight: bold;">in</span> critical region: SIGINT <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#25191;&#34892;pr_mask&#26399;&#38388;&#38459;&#22622;SIGINT </span>
^C <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#25191;&#34892;sigsuspend&#65292;&#35299;&#38500;&#20102;&#23545;SIGINT&#30340;&#38459;&#22622;&#65292;&#24182;&#19968;&#30452;&#25346;&#36215;&#30452;&#21040;&#19968;&#20010;&#20449;&#21495;&#20135;&#29983;</span>
 <span style="color: #00bfff; font-weight: bold;">in</span> sig_int: SIGINT <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#25191;&#34892;SIGINT&#22788;&#29702;&#31243;&#24207;&#65292;&#22312;&#27492;&#26399;&#38388;&#20381;&#26087;&#20250;&#33258;&#21160;&#23631;&#34109;SIGINT</span>
after return from sigsuspend: SIGINT <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20174;sigsuspend&#36820;&#22238;&#21518;&#65292;&#24674;&#22797;&#20102;&#26368;&#21021;&#30340;&#20449;&#21495;&#23631;&#34109;&#23383;&#65292;&#22240;&#27492;&#20381;&#26087;&#38459;&#22622;SIGINT</span>
</pre>
</div>

<pre class="example">
      当sigsuspend返回时，它将信号屏蔽字设置为调用它之前的值，SIGINT信号仍然将被阻塞

      所以最后仍然必须将信号屏蔽复置为早先保存的值(oldmask)
</pre>
</div>
</div>

<div id="outline-container-org530ee46" class="outline-4">
<h4 id="org530ee46">等待特定信号产生并处理</h4>
<div class="outline-text-4" id="text-org530ee46">
<p>
下面程序会捕捉 <span class="underline">中断信号</span> 和 <span class="underline">退出信号</span> ，但是希望 <b>只有在捕捉到退出信号</b> 时再 <span class="underline">继续执行main程序</span> ：
</p>
<ol class="org-ol">
<li>用 <span class="underline">sigprocmask</span> <b>阻塞</b> <span class="underline">SIGQUIT</span> 信号，以 <b>防止该信号丢失</b></li>
<li>使用 <span class="underline">全局变量quitflag</span> 的校验和 <span class="underline">suspend函数</span> 来 <b>保证</b> 只有已经捕获了 <span class="underline">SIGQUIT</span></li>
<li>只有 <span class="underline">SIGQUIT的处理函数</span> 中才 <b>修改</b> <span class="underline">全局变量quitflag</span> 的值，以此来退出main函数的循环</li>
<li>最后必须 <b>恢复</b> 早先 <span class="underline">对SIGQUIT信号的阻塞</span></li>
</ol>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span>);
<span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">sig_atomic_t</span> <span style="color: #4eee94;">quitflag</span>;


<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">newmask</span>, <span style="color: #4eee94;">oldmask</span>, <span style="color: #4eee94;">zeromask</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGINT, sig_int)))
        err_sys(<span style="color: #deb887;">"signal(SIGINT) error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(SIG_ERR == (signal(SIGQUIT, sig_int)))
        err_sys(<span style="color: #deb887;">"signal(SIGQUIT) error"</span>);

    sigemptyset(&amp;zeromask);

    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask, SIGQUIT);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">block SIGQUIT and save current signal mask</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0)
        err_sys(<span style="color: #deb887;">"SIG_BLOCK error"</span>);

    <span style="color: #00bfff; font-weight: bold;">while</span>(0 == quitflag) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21482;&#26377;&#22312;&#25429;&#33719;&#21040; SIGQUIT &#20449;&#21495;&#30340;&#26102;&#20505;&#65292;&#25165;&#20462;&#25913;quitflag&#26469;&#36864;&#20986;&#24490;&#29615;</span>
        sigsuspend(&amp;zeromask);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">SIGQUIT is now caught and is now blocked; do whatever</span>
    quitflag = 0;

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">reset signal mask which unblocks SIGQUIT</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>) &lt; 0)
        err_sys(<span style="color: #deb887;">"SIG_SETMASK error"</span>);

    exit(0);        
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">one signal handler for SIGINT and SIGQUIT</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) 
{
    <span style="color: #00bfff; font-weight: bold;">if</span>(SIGINT == signo)
        printf(<span style="color: #deb887;">"\ninterupt\n"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(SIGQUIT == signo) {
        printf(<span style="color: #deb887;">"\nquit\n"</span>);
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">set flag for main loop</span>
        quitflag = 1;
    }
    <span style="color: #00bfff; font-weight: bold;">return</span>;
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/globalVariable 
^C <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;SIGINT&#20449;&#21495;</span>
interupt <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">sig_int&#34987;&#35843;&#29992;&#65292;&#20294;&#19981;&#25913;&#21464;quitflag&#30340;&#20540;</span>
^C <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;SIGINT&#20449;&#21495;</span>
interupt
^C <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;SIGINT&#20449;&#21495;</span>
interupt 
^<span style="color: #deb887;">\ </span><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20135;&#29983;SIGQUIT&#20449;&#21495;</span>
quit <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">sig_int&#34987;&#35843;&#29992;&#65292;&#32780;&#19988;&#25913;&#21464;&#20102;quitflag&#30340;&#20540;&#65292;&#23548;&#33268;&#36864;&#20986;&#20102;main&#20989;&#25968;&#30340;&#24490;&#29615;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org29d1e33" class="outline-4">
<h4 id="org29d1e33">实现父子进程之间的同步</h4>
<div class="outline-text-4" id="text-org29d1e33">
<p>
下面程序实现了以前提到的五个例程 <span class="underline">TELL_WAIT</span> 、 <span class="underline">TELL_PARENT</span> 、 <span class="underline">TELL_CHILD</span> 、 <span class="underline">WAIT_PARENT</span> 和 <span class="underline">WAIT_CHILD</span> 。其中使用了两个用户定义的信号 <span class="underline">SIGUSR1</span> 和 <span class="underline">SIGUSR2</span> ：
</p>
<ul class="org-ul">
<li><b>sig_usr</b> ：
<ul class="org-ul">
<li><b>捕获</b> SIGUSR1或SIGUSR2信号后 <b>设置</b> <span class="underline">全局变量sig_flag</span> 为 <span class="underline">1</span></li>
</ul></li>
<li><b>TELL_WAIT</b> : 
<ul class="org-ul">
<li><b>设置</b> SIGUSR1和SIGUSR2的 <span class="underline">信号处理函数</span> 为 <span class="underline">sig_usr</span></li>
<li><b>保存</b> 当前 <span class="underline">信号屏蔽字</span></li>
<li><b>阻塞</b> SIGUSR1和SIGUSR2信号</li>
</ul></li>
<li><b>WAIT_PARENT</b> ：
<ul class="org-ul">
<li>子进程 <b>循环校验</b> <span class="underline">sig_flag</span> <b>是否为1</b> 
<ul class="org-ul">
<li>循环中 <span class="underline">调用suspend</span> <b>解除</b> 对所有信号的阻塞 <b>等待SIGUSR1信号</b> 发生</li>
</ul></li>
<li>离开循环后 <b>恢复</b> <span class="underline">sig_flag</span> 为 <span class="underline">0</span></li>
<li><b>恢复</b> 早前 <span class="underline">保存的信号屏蔽字</span></li>
</ul></li>
<li><b>TELL_CHILD</b> ： 
<ul class="org-ul">
<li><span class="underline">父进程</span> 向 <span class="underline">子进程</span> <b>发送信号SIGUSR1</b> ：使得 <span class="underline">子进程</span> <b>离开WAIT_PARENT的循环校验</b></li>
</ul></li>
<li><b>WAIT_CHILD</b> ：
<ul class="org-ul">
<li>父进程 <b>循环校验</b> <span class="underline">sig_flag</span> 是否为 <span class="underline">1</span> 
<ul class="org-ul">
<li>循环中 <span class="underline">调用suspend</span> <b>解除</b> 对所有信号的阻塞 <b>等待信号SIGUSR2</b> 发生</li>
</ul></li>
<li>离开循环后 <b>恢复</b> <span class="underline">sig_flag</span> 为 <span class="underline">0</span></li>
<li><b>恢复</b> 早前 <span class="underline">保存的信号屏蔽字</span></li>
</ul></li>
<li><p>
<b>TELL_PARENT</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">子进程</span> 向 <span class="underline">父进程</span> <b>发送信号SIGUSR2</b> ，使得 <span class="underline">父进程</span> <b>离开WAIT_CHILD的循环校验</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">sig_atomic_t</span> <span style="color: #4eee94;">sigflag</span> = 0; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">set nonzero by sig handler </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">sigset_t</span> <span style="color: #4eee94;">newmask</span>, <span style="color: #4eee94;">oldmask</span>, <span style="color: #4eee94;">zeromask</span>;

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_usr</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">one signal handler for SIGUSR1 and SIGUSR2 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    sigflag = 1;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_WAIT</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR)
    err_sys(<span style="color: #deb887;">"signal(SIGUSR1) error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR)
    err_sys(<span style="color: #deb887;">"signal(SIGUSR2) error"</span>);
    sigemptyset(&amp;zeromask);
    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask, SIGUSR1);
    sigaddset(&amp;newmask, SIGUSR2);

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Block SIGUSR1 and SIGUSR2, and save current signal mask.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; 0)
    err_sys(<span style="color: #deb887;">"SIG_BLOCK error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_PARENT</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>)
{
    kill(pid, SIGUSR2);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">tell parent we're done </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">WAIT_PARENT</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">while</span> (sigflag == 0)
    sigsuspend(&amp;zeromask);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">and wait for parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigflag = 0;

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Reset signal mask to original value.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>) &lt; 0)
    err_sys(<span style="color: #deb887;">"SIG_SETMASK error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_CHILD</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>)
{
    kill(pid, SIGUSR1);         <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">tell child we're done </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">WAIT_CHILD</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">while</span> (sigflag == 0)
    sigsuspend(&amp;zeromask);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">and wait for child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigflag = 0;

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Reset signal mask to original value.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>) &lt; 0)
    err_sys(<span style="color: #deb887;">"SIG_SETMASK error"</span>);
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org5c0effa" class="outline-4">
<h4 id="org5c0effa">sigsuspend的局限</h4>
<div class="outline-text-4" id="text-org5c0effa">
<pre class="example">
       需要捕捉 SIGINT 和 SIGALRM 这两种信号，在信号发生时，这两个信号处理程序都各自设置一个全局变量

      用signal_intr函数设置这两个信号处理程序，使得它们中断一个”被阻塞的慢速系统调用“
</pre>

<p>
当阻塞在 <span class="underline">select</span> 函数调用，等待慢速设备的输入时 <b>很可能发生这两种信号</b> (设置闹钟以阻止永远等待输入)。能尽力做到的是：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">if</span>(intr_flag) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">flag set by our SIGINT handler</span>
    <span style="color: #daa520; font-weight: bold;">handle_intr</span>();

<span style="color: #00bfff; font-weight: bold;">if</span>(alrm_flag) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">flag set by our SIGALRM handler</span>
    <span style="color: #daa520; font-weight: bold;">handle_alrm</span>();

<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">signal occurs here are lost </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">while</span>( select(...) &lt; 0 ) {
    <span style="color: #00bfff; font-weight: bold;">if</span>(errno == EINTR) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(alrm_flag)
            handle_alrm();
        <span style="color: #00bfff; font-weight: bold;">if</span>(intr_flag)
            handle_intr();
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">some other error</span>
    }        
}
</pre>
</div>

<pre class="example">
1. 在调用select之前测试各全局标志
2. 如果select返回一个中断的系统调用错误，则再次进行测试

但如果在这两步之间捕捉到两个信号中的任意一个，此处发生的信号会丢失了

因为即使调用了相应的信号处理程序，它们设置了相应的全局变量
但是除非某些数据已准备好可读，select绝不会返回

这意味着循环中的测试有可能因为select不返回而无法被执行到
</pre>

<p>
希望的执行序列是：
</p>
<ol class="org-ol">
<li>阻塞SIGINT和SIGALRM</li>
<li>测试两个全局变量以判别是否发生了一个信号，如果已发生则处理此条件</li>
<li><b>调用select</b> (或任何其他系统调用，例如read)并 <b>解除对这两个信号的阻塞</b> ，这 <b>两个操作要作为一个原子操作</b></li>
</ol>

<pre class="example">
      只有当第三步的调用是pause的时候，也就说希望在睡眠的时候等待信号，则sigsuspend函数可以满足此种要求

      但是如果在调用select的时候等待信号，sigsuspend函数则无能为力！
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org14d6115" class="outline-2">
<h2 id="org14d6115">常用函数</h2>
<div class="outline-text-2" id="text-org14d6115">
</div>
<div id="outline-container-org656e946" class="outline-3">
<h3 id="org656e946">abort函数</h3>
<div class="outline-text-3" id="text-org656e946">
<p>
<span class="underline">abort</span> ：使得进程 <b>异常终止</b> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20351;&#31243;&#24207;&#24322;&#24120;&#32456;&#27490;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#26080;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">abort</span>(<span style="color: #98f5ff;">void</span>)
</pre>
</div>
<p>
将 <span class="underline">SIGABRT</span> 信号 <b>发送</b> 给 <span class="underline">调用进程</span> ，进程 <b>不应忽略此信号</b> 
</p>

<pre class="example">
ANSIC要求若捕捉到此信号而且相应信号处理程序返回，abort仍不会返回到其调用者

如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、longjmp或siglongjmp

POSIX.1也说明abort覆盖了进程对此信号的阻塞和忽略

</pre>
<p>
让进程捕捉SIGABRT的意图是：在 <span class="underline">进程终止之前</span> 由其 <b>执行所需的 <span class="underline">清除</span> 操作</b> 
</p>

<pre class="example">
如果进程并不在信号处理程序中终止自己，POSIX.1说明当信号处理程序返回时，abort终止该进程

ANSIC对此函数的规格说明将这一问题留由实现决定，而不管“输出流是否刷新”以及不管“临时文件是否删除”

POSIX.1的要求则进了一步：

如果abort调用终止进程，则它应该有对所有打开的标准I/O流调用fclose的效果
但是如果abort调用并不终止进程，则它对打开流也不应有影响
</pre>
</div>

<div id="outline-container-orgab1451a" class="outline-4">
<h4 id="orgab1451a">abort实现</h4>
<div class="outline-text-4" id="text-orgab1451a">
<p>
以下程序实现了POSIX标准的abort函数，对处理打开的标准I/O流的要求是难于实现的：
</p>
<ol class="org-ol">
<li>如果对于 <span class="underline">SIGABRT</span> 信号是 <b>忽略</b> ，则 <b>设置</b> 为执行了 <b>默认</b> 动作</li>
<li>如果对于 <span class="underline">SIGABRT</span> 信号是 <b>默认</b> 动作，则 <b>刷新所有标准I/O流</b> 
<ul class="org-ul">
<li>但 <b>不是关闭</b> 它们，只有当 <span class="underline">进程终止</span> 时，内核会 <b>自动关闭所有打开文件</b> ，相当于fclose的效果</li>
</ul></li>
<li>确保 <b>解除</b> 对 <span class="underline">SIGABRT</span> 信号的 <b>屏蔽</b></li>
<li><b>发送</b> <span class="underline">SIGABRT</span> 信号给当前进程</li>
<li>如果对于SIGABRT信号处理是 <b>用户自定义</b> 函数：
<ul class="org-ul">
<li>如果进程 <span class="underline">捕捉此信号</span> 并 <b>返回</b> :
<ul class="org-ul">
<li><b>刷新所有的流</b></li>
<li><b>设置</b> 为 <span class="underline">SIGABRT</span> 的处理方式为 <b>默认</b> 动作</li>
<li><b>重新发送</b> <span class="underline">SIGABRT</span> 信号给 <span class="underline">当前进程</span></li>
</ul></li>
<li><p>
如果进程 <span class="underline">捕捉此信号</span> 并且 <b>不返回</b> ，则 <b>不会触及</b> <span class="underline">标准I/O流</span> 
</p>
<ul class="org-ul">
<li>在自定义信号处理函数可以 <b>手动调用_exit</b> 来结束进程，这时候 <b>不希望缓存被刷新</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">abort</span>(<span style="color: #98f5ff;">void</span>)            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">POSIX-style abort() function </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    <span style="color: #98f5ff;">sigset_t</span>            <span style="color: #4eee94;">mask</span>;
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span>    <span style="color: #4eee94;">action</span>;

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Caller can't ignore SIGABRT, if so reset to default.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigaction(SIGABRT, <span style="color: #ffd700;">NULL</span>, &amp;action);
    <span style="color: #00bfff; font-weight: bold;">if</span> (action.sa_handler == SIG_IGN) {
    action.sa_handler = SIG_DFL;
    sigaction(SIGABRT, &amp;action, <span style="color: #ffd700;">NULL</span>);
    }
    <span style="color: #00bfff; font-weight: bold;">if</span> (action.sa_handler == SIG_DFL)
    fflush(<span style="color: #ffd700;">NULL</span>);           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">flush all open stdio streams </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Caller can't block SIGABRT; make sure it's unblocked.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigfillset(&amp;mask);
    sigdelset(&amp;mask, SIGABRT);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">mask has only SIGABRT turned off </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigprocmask(SIG_SETMASK, &amp;mask, <span style="color: #ffd700;">NULL</span>);
    kill(getpid(), SIGABRT);    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">send the signal </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * If we're here, process caught SIGABRT and returned.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    fflush(<span style="color: #ffd700;">NULL</span>);               <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">flush all open stdio streams </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    action.sa_handler = SIG_DFL;
    sigaction(SIGABRT, &amp;action, <span style="color: #ffd700;">NULL</span>);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">reset to default </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigprocmask(SIG_SETMASK, &amp;mask, <span style="color: #ffd700;">NULL</span>);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">just in case ... </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    kill(getpid(), SIGABRT);                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">and one more time </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    exit(1);    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">this should never be executed ... </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div></li>
</ul></li>
</ol>

<pre class="example">
      如果调用 kill 使其为调用者产生信号，并且如果该信号是不被阻塞的，则在kill返回前该信号就被传送给了该进程

      这样就可确知如果对kill的调用返回了，则该进程一定已捕捉到该信号，并且也从该信号处理程序返回
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfadc2c5" class="outline-3">
<h3 id="orgfadc2c5">system函数</h3>
<div class="outline-text-3" id="text-orgfadc2c5">
<pre class="example">
在进程控制那章已经有了一个system函数的实现，但是该版本并不做任何信号处理

POSIX要求system忽略SIGINT和SIGQUIT，阻塞SIGCHLD
</pre>
</div>

<div id="outline-container-orgda692cb" class="outline-4">
<h4 id="orgda692cb">system函数的信号处理</h4>
<div class="outline-text-4" id="text-orgda692cb">
<p>
使用以前的system版本来调用ed(1)编辑程序。使用它的原因是：它是一个 <b>交互式的捕捉</b> <span class="underline">中断</span> 和 <span class="underline">退出</span> 信号的程序
</p>

<pre class="example">
      若从shell调用ed，并键入中断字符，则它捕捉中断信号并打印问号

      它也对退出符的处理方式设置为忽略
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_int</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    printf(<span style="color: #deb887;">"caught SIGINT\n"</span>);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_chld</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    printf(<span style="color: #deb887;">"caught SIGCHLD\n"</span>);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGINT, sig_int) == SIG_ERR)
    err_sys(<span style="color: #deb887;">"signal(SIGINT) error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGCHLD, sig_chld) == SIG_ERR)
    err_sys(<span style="color: #deb887;">"signal(SIGCHLD) error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (mysystem(<span style="color: #deb887;">"/bin/ed"</span>) &lt; 0)
    err_sys(<span style="color: #deb887;">"system() error"</span>);
    exit(0);
}
</pre>
</div>
<p>
图10-2显示了编辑程序正在进行时的进程安排：
</p>

<div class="figure">
<p><img src="pic/system-process-group.png" alt="system-process-group.png" width="90%" />
</p>
</div>

<p>
测试SIGCHLD信号：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/a.out 
a <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#27491;&#25991;&#28155;&#21152;&#33267;&#32534;&#36753;&#22120;&#32531;&#23384;</span>
Here is one line of text
and another
<span style="color: #f08080;">.</span> <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20572;&#27490;&#28155;&#21152;&#26041;&#24335;</span>
1, $<span style="color: #4eee94;">p</span> <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#25171;&#21360;&#31532;1&#34892;&#33267;&#26368;&#21518;1&#34892;,&#20197;&#20415;&#35266;&#23519;&#32531;&#23384;&#20013;&#30340;&#20869;&#23481;</span>
Here is one line of text
and another
w temp.foo <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#32531;&#23384;&#20889;&#33267;&#19968;&#25991;&#20214;</span>
37 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#32534;&#36753;&#22120;&#31216;&#20889;&#20102;37&#20010;&#23383;&#33410;</span>
q <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#31163;&#24320;&#32534;&#36753;&#22120;</span>
caught SIGCHLD <span style="color: #5f9ea0; font-style: italic;">#</span>
</pre>
</div>

<p>
当ed程序终止时，产生SIGCHLD信号，a.out进程捕捉它，执行其处理程序，然后从其返回
</p>
<pre class="example">
      如果不阻塞SIGCHLD，在a.out中安装了处理SIGCHLD信号的话

      那么system执行子进程返回的话，首先会通知a.out中的信号捕获程序

      如果a.out中的SIGCHLD捕获程序里面调用了wait的话，那么system的wait就会一直阻塞住了

      因此在执行system的时候，父进程中SIGCHLD信号的递送应当被阻塞
</pre>

<p>
测试SIGINT信号：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/process/a.out  
a
hello, world
<span style="color: #f08080;">.</span>
w etmp.foo
13
^C <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#20013;&#26029;&#31526;</span>
? <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">ed&#31243;&#24207;&#25429;&#25417;&#21040;SIGINT&#20449;&#21495;&#65292;&#25171;&#21360;&#38382;&#21495;</span>
caught SIGINT <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">a.out&#36827;&#31243;&#25429;&#25417;&#21040;SIGINT&#20449;&#21495;</span>
q
caught SIGCHLD
</pre>
</div>

<p>
键入中断字符可使 <span class="underline">中断信号</span> 传送给 <span class="underline">前台进程组中的所有进程</span> ，所以SIGINT信号会被送给三个前台进程：
</p>
<ul class="org-ul">
<li><span class="underline">shell</span> 进程 ：忽略此信号</li>
<li><span class="underline">a.out</span> 进程： 捕获该信号</li>
<li><span class="underline">ed</span> 进程：捕捉该信号</li>
</ul>

<pre class="example">
      但是当用system运行另一个程序时，不应使父、子进程两者都捕捉终端产生的SIGINT和SIGQUIT信号

      这两个信号只应送给正在运行的程序，也就是子进程，所以system的调用者就不应接收这两个终端产生的信号
</pre>
</div>
</div>

<div id="outline-container-org2007344" class="outline-4">
<h4 id="org2007344">system函数实现</h4>
<div class="outline-text-4" id="text-org2007344">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">system</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>)   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">with appropriate signal handling </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    <span style="color: #98f5ff;">pid_t</span>               <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">int</span>                 <span style="color: #4eee94;">status</span>;
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span>    <span style="color: #4eee94;">ignore</span>, <span style="color: #4eee94;">saveintr</span>, <span style="color: #4eee94;">savequit</span>;
    <span style="color: #98f5ff;">sigset_t</span>            <span style="color: #4eee94;">chldmask</span>, <span style="color: #4eee94;">savemask</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (cmdstring == <span style="color: #ffd700;">NULL</span>)
        <span style="color: #00bfff; font-weight: bold;">return</span>(1);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">always a command processor with UNIX </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    ignore.sa_handler = SIG_IGN;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ignore SIGINT and SIGQUIT </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigemptyset(&amp;ignore.sa_mask);
    ignore.sa_flags = 0;
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigaction(SIGINT, &amp;ignore, &amp;saveintr) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigaction(SIGQUIT, &amp;ignore, &amp;savequit) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);
    sigemptyset(&amp;chldmask);         <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">now block SIGCHLD </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigaddset(&amp;chldmask, SIGCHLD);
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigprocmask(SIG_BLOCK, &amp;chldmask, &amp;savemask) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        status = -1;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">probably out of processes </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) {          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">restore previous signal actions &amp; reset signal mask </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        sigaction(SIGINT, &amp;saveintr, <span style="color: #ffd700;">NULL</span>);
        sigaction(SIGQUIT, &amp;savequit, <span style="color: #ffd700;">NULL</span>);
        sigprocmask(SIG_SETMASK, &amp;savemask, <span style="color: #ffd700;">NULL</span>);

        execl(<span style="color: #deb887;">"/bin/sh"</span>, <span style="color: #deb887;">"sh"</span>, <span style="color: #deb887;">"-c"</span>, cmdstring, (<span style="color: #98f5ff;">char</span> *)0);
        _exit(127);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">exec error </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (waitpid(pid, &amp;status, 0) &lt; 0)
            <span style="color: #00bfff; font-weight: bold;">if</span> (errno != EINTR) {
                status = -1; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">error other than EINTR from waitpid() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
                <span style="color: #00bfff; font-weight: bold;">break</span>;
            }
    }

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">restore previous signal actions &amp; reset signal mask </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigaction(SIGINT, &amp;saveintr, <span style="color: #ffd700;">NULL</span>) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigaction(SIGQUIT, &amp;savequit, <span style="color: #ffd700;">NULL</span>) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);
    <span style="color: #00bfff; font-weight: bold;">if</span> (sigprocmask(SIG_SETMASK, &amp;savemask, <span style="color: #ffd700;">NULL</span>) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);

    <span style="color: #00bfff; font-weight: bold;">return</span>(status);
}
</pre>
</div>

<ol class="org-ol">
<li>在 <span class="underline">fork进程前</span> ，就必须 <b>更改信号的处理方式</b></li>
<li><span class="underline">子进程</span> 在 <span class="underline">调用execl之前</span> 要先 <b>恢复这两个信号的配置</b> 
<ul class="org-ul">
<li>允许在调用者配置的基础上，execl可将它们的配置更改为默认值</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgb880693" class="outline-4">
<h4 id="orgb880693">system的返回值</h4>
<div class="outline-text-4" id="text-orgb880693">
<ul class="org-ul">
<li>如果 <span class="underline">/bin/sh</span> <b>没有正常执行</b> 的话，那么返回 <span class="underline">127</span></li>
<li>如果命令 <b>正常执行</b> 的话，那么返回 <span class="underline">命令退出状态</span></li>
<li>如果 <span class="underline">/bin/sh</span> 因为 <b>信号退出</b> 的话，那么 <span class="underline">退出状态时128+信号编号</span></li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">$ sh -c <span style="color: #deb887;">'sleep 30'</span>
^C <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#20013;&#26029;&#38190;&#36864;&#20986;</span>
$ echo $<span style="color: #4eee94;">?</span> <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#25171;&#21360;&#36864;&#20986;&#29366;&#24577;</span>
130 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">128 + 2(SIGINT)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd410449" class="outline-3">
<h3 id="orgd410449">sleep函数</h3>
<div class="outline-text-3" id="text-orgd410449">
<p>
<span class="underline">sleep</span> ： 尝试使进程 <b>睡眠</b> 若干秒
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23581;&#35797;&#20351;&#31243;&#24207;&#30561;&#30496; seconds &#31186;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: 0 &#25110; &#26410;&#30561;&#30340;&#31186;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sleep</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">seconds</span>)
</pre>
</div>
<p>
使 <span class="underline">调用进程</span> 被 <b>挂起</b> 直到：
</p>
<ol class="org-ol">
<li>已经 <span class="underline">过了seconds</span> 所指定的墙上时钟时间，返回值是 <span class="underline">0</span></li>
<li>该进程 <span class="underline">捕捉到一个信号</span> 并从 <span class="underline">信号处理程序返回</span> ，返回值是 <span class="underline">未睡的秒数</span></li>
</ol>

<pre class="example">
     如同alarm信号一样，如果系统负荷过重，实际返回时间比所要求的会迟一些
</pre>
</div>

<div id="outline-container-org6bf8032" class="outline-4">
<h4 id="org6bf8032">sleep函数实现</h4>
<div class="outline-text-4" id="text-org6bf8032">
<p>
下面程序使用alarm函数实现sleep，但这并不是必需的：
</p>
<ol class="org-ol">
<li><b>注册</b> <span class="underline">SIGALRM处理方式</span></li>
<li><b>屏蔽</b> <span class="underline">SIGALRM信号</span></li>
<li>调用 <span class="underline">alarm</span> <b>启动</b> 闹钟 
<ul class="org-ul">
<li>到时间 <b>自动产生SIGALRM信号</b></li>
</ul></li>
<li>调用 <span class="underline">sigsuspend</span> 来 <b>等待任意信号发生</b></li>
<li><span class="underline">捕获任意信号</span> (包括捕获的SIGALRM信号)后
<ul class="org-ul">
<li><b>取消</b> 闹钟</li>
<li>获得 <span class="underline">未睡眠的秒数</span></li>
</ul></li>
<li><b>恢复</b> <span class="underline">SIGALRM的处理方式</span></li>
<li><b>重置</b> <span class="underline">信号屏蔽字</span></li>
<li>返回 <span class="underline">未睡的秒数</span></li>
</ol>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_alrm</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">nothing to do, just returning wakes up sigsuspend() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sleep</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nsecs</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sigaction</span>    <span style="color: #4eee94;">newact</span>, <span style="color: #4eee94;">oldact</span>;
    <span style="color: #98f5ff;">sigset_t</span>            <span style="color: #4eee94;">newmask</span>, <span style="color: #4eee94;">oldmask</span>, <span style="color: #4eee94;">suspmask</span>;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span>        <span style="color: #4eee94;">unslept</span>;

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">set our handler, save previous information </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    newact.sa_handler = sig_alrm;
    sigemptyset(&amp;newact.sa_mask);
    newact.sa_flags = 0;
    sigaction(SIGALRM, &amp;newact, &amp;oldact);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">block SIGALRM and save current signal mask </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask, SIGALRM);
    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);

    alarm(nsecs);

    suspmask = oldmask;
    sigdelset(&amp;suspmask, SIGALRM);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">make sure SIGALRM isn't blocked </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigsuspend(&amp;suspmask);          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">wait for any signal to be caught </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">some signal has been caught, SIGALRM is now blocked </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    unslept = alarm(0);
    sigaction(SIGALRM, &amp;oldact, <span style="color: #ffd700;">NULL</span>);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">reset previous action </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">reset signal mask, which unblocks SIGALRM </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigprocmask(SIG_SETMASK, &amp;oldmask, <span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>(unslept);
}
</pre>
</div>

<pre class="example">
由于没有使用longjmp来避免竟态条件，所以在处理SIGALRM信号期间可能执行的其他信号处理程序

例如，若先调用alarm(10)，过了3秒后又调用sleep(5)，那么将如何呢？

sleep将在5秒后返回(假定在这段时间内没有捕捉到另一个信号)，但是否在2秒后又产生另一个SIGALRM信号呢？

这些细节并没有考虑在内
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcad9eea" class="outline-2">
<h2 id="orgcad9eea">作业控制信号</h2>
<div class="outline-text-2" id="text-orgcad9eea">
<p>
POSIX.1中有六个被认为是与作业控制有关的信号：
</p>
<ul class="org-ul">
<li><span class="underline">SIGCHLD</span> ： <b>子进程已停止或终止</b></li>
<li><span class="underline">SIGCONT</span> ：如果 <span class="underline">进程已停止</span> ，则使其 <b>继续运行</b></li>
<li><span class="underline">SIGSTOP</span> ： <b>停止</b> 信号， <b>不能被捕捉或忽略</b></li>
<li><span class="underline">SIGTSTP</span> ： <b>交互停止</b> 信号</li>
<li><span class="underline">SIGTTIN</span> ： <span class="underline">后台进程组</span> 的成员 <b>读</b> <span class="underline">控制终端</span> 
<ul class="org-ul">
<li>默认方式会使得 <b>后台进程停止</b> ，并 <b>等待通过fg</b> 命令变为前台进程</li>
</ul></li>
<li><span class="underline">SIGTTOU</span> ： <span class="underline">后台进程组</span> 的成员 <b>写</b> <span class="underline">控制终端</span> 
<ul class="org-ul">
<li><b>禁止</b> 或者 <b>允许</b> 可以通过 <span class="underline">stty</span> 命令设置</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org03d302b" class="outline-3">
<h3 id="org03d302b">shell处理作业控制信号</h3>
<div class="outline-text-3" id="text-org03d302b">
<p>
大多数应用程序并不处理这些信号，交互式shell通常做处理这些信号的所有工作：
</p>
<ul class="org-ul">
<li>当 <b>键入挂起字符</b> ( <span class="underline">Ctrl-Z</span> )时， <span class="underline">SIGTSTP</span> 被 <b>送至</b> <span class="underline">后台进程组的所有进程</span></li>
<li>当 <b>通知shell</b> 在 <span class="underline">前台或后台</span> <b>恢复一个作业</b> 时，shell向 <span class="underline">作业中的所有进程</span> <b>发送</b> <span class="underline">SIGCONT</span> 信号</li>
<li>如果向一个进程 <b>递送</b> 了 <span class="underline">SIGTTIN</span> 或 <span class="underline">SIGTTOU</span> 信号，则根据系统默认，此 <b>进程停止</b> ，作业控制 <span class="underline">shell</span> 了解到这一点后 <b>再通知</b></li>
<li>如果 <span class="underline">进程是停止的</span> ， <span class="underline">SIGCONT</span> 的 <b>默认</b> 动作是 <span class="underline">继续一个进程</span> ，否则 <span class="underline">忽略</span> 此信号</li>
</ul>
<pre class="example">
     通常对该信号无需做任何事情

     当对一个停止的进程产生一个SIGCONT信号时，该进程就继续，即使该信号是被阻塞或忽略的也是这样
</pre>
<ul class="org-ul">
<li>在作业控制信号间有某种相互作用：
<ul class="org-ul">
<li>当对一个进程产生四种停止信号( <span class="underline">SIGTSTP</span> ,  <span class="underline">SIGSTOP</span> ,  <span class="underline">SIGTTIN</span> 或 <span class="underline">SIGTTOU</span> )中的任意一种时，对 <span class="underline">该进程的任一未决的SIGCONT信号</span> 就被 <b>丢弃</b></li>
<li>当对一个进程产生 <span class="underline">SIGCONT</span> 信号时，对同一进程的 <span class="underline">任一未决的停止信号</span> 被 <b>丢弃</b></li>
</ul></li>
</ul>
</div>

<div id="outline-container-org2f2a7d1" class="outline-4">
<h4 id="org2f2a7d1">管理终端进程实例</h4>
<div class="outline-text-4" id="text-org2f2a7d1">
<pre class="example">
      管理终端的进程，例如vi编辑程序，当用户要挂起它时，它需要能了解到这一点，这样才能将终端状态恢复到vi起动时的情况

      另外当在前台恢复它时，它需要将终端状态设置回所希望的状态，并需要重新绘制终端屏幕
</pre>

<p>
以下程序展示了在管理终端的进程中如何对作业控制信号进行处理：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">BUFFSIZE</span>    1024

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_tstp</span>(<span style="color: #98f5ff;">int</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">buf</span>[BUFFSIZE];

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Only catch SIGTSTP if we're running with a job-control shell.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGTSTP, SIG_IGN) == SIG_DFL)
        signal(SIGTSTP, sig_tstp);

    <span style="color: #00bfff; font-weight: bold;">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)
        <span style="color: #00bfff; font-weight: bold;">if</span> (write(STDOUT_FILENO, buf, n) != n)
            err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (n &lt; 0)
        err_sys(<span style="color: #deb887;">"read error"</span>);

    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_tstp</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>) <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">signal handler for SIGTSTP </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    <span style="color: #98f5ff;">sigset_t</span>    <span style="color: #4eee94;">mask</span>;
    pr_mask(<span style="color: #deb887;">"start process SIG_STOP"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">... move cursor to lower left corner, reset tty mode ... </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Unblock SIGTSTP, since it's blocked while we're handling it.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    sigemptyset(&amp;mask);
    sigaddset(&amp;mask, SIGTSTP);
    sigprocmask(SIG_UNBLOCK, &amp;mask, <span style="color: #ffd700;">NULL</span>);

    signal(SIGTSTP, SIG_DFL);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">reset disposition to default </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    pr_mask(<span style="color: #deb887;">"unblock SIGSTOP"</span>);

    kill(getpid(), SIGTSTP);    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">and send the signal to ourself </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    pr_mask(<span style="color: #deb887;">"resend SIGSTOP signal"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">we won't return from the kill until we're continued </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    signal(SIGTSTP, sig_tstp);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">reestablish signal handler </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    pr_mask(<span style="color: #deb887;">"reestablish signal handler"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">... reset tty mode, redraw screen ... </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>

<pre class="example">
      虽然主程序只是将其 标准输入 复制到其 标准输出

      但是在信号处理程序中以注释形式给出了 管理屏幕的程序所执行的典型操作
</pre>

<p>
当键入挂起字符时，进程接到SIGTSTP信号，然后该信号处理被调用：
</p>
<ol class="org-ol">
<li>首先 <b>进行与终端有关</b> 的处理：比如将 <span class="underline">光标移到左下角</span> ，恢复终端工作方式等等</li>
<li>在将 <span class="underline">SIGTSTP</span> <b>重新设置</b> 为 <span class="underline">默认值</span> <b>停止该进程</b></li>
<li>因为 <span class="underline">正在处理SIGTSTP信号</span> ，而在 <span class="underline">捕捉到该信号期间系统</span> <b>自动地阻塞</b> 它，所以应当 <b>解除对此信号的阻塞</b></li>
<li>进程 <span class="underline">调用kill</span> 函数 <span class="underline">向自己</span>  <b>发送</b> <span class="underline">同一信号SIGTSTP</span> 
<ul class="org-ul">
<li>因为这时候 <span class="underline">SIGTSTP信号的处理</span> 已经变成了 <span class="underline">默认</span> 方式，这意味着 <b>自动停止该程序运行</b> ，所以这个 <b>kill调用不会返回</b></li>
</ul></li>
<li>直到通过 <span class="underline">终端</span> 向这个 <span class="underline">进程</span> <b>发送</b> <span class="underline">SIGCONT</span> 信号，该 <b>进程才得以继续</b> ，此时该程序才会 <b>从kill函数返回</b></li>
<li>将 <span class="underline">SIGTSTP</span> 信号再 <b>设置</b> 为 <span class="underline">捕捉</span></li>
<li>再次 <b>对终端进行处理</b> ，例如 <span class="underline">重新绘制屏幕</span></li>
</ol>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/signal/sigtstop 
hello world <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#35835;&#21462;&#32456;&#31471;&#36755;&#20837;&#65292;&#36755;&#20986;&#21040;&#32456;&#31471;</span>
hello world
^Z <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#25353;&#20837;&#20572;&#27490;&#38190;</span>
start process SIG_STOP <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#24320;&#22987;&#35843;&#29992;sig_stop&#20989;&#25968;</span>
unblock SIGSTOP <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#37325;&#26032;&#24674;&#22797;SIGTSTP&#20026;&#40664;&#35748;&#22788;&#29702;&#26041;&#24335;&#65292;&#21457;&#36865;SIGTSTP&#20449;&#21495;&#32473;&#33258;&#36523;&#65292;kill&#35843;&#29992;&#31561;&#24453;&#36820;&#22238;</span>

[1]+  Stopped                 ./src/signal/sigtstop&#12288;

$ fg 1 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#24674;&#22797;&#21407;&#26469;&#36827;&#31243;&#65292;&#21457;&#36865;SIGCONT&#20449;&#21495;&#32473;&#20316;&#19994;1</span>
./src/signal/sigtstop 
resend SIGSTOP signal <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20174;kill&#20989;&#25968;&#35843;&#29992;&#36820;&#22238;</span>
reestablish signal handler <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20877;&#27425;&#35774;&#32622;SIGTSTP&#35843;&#29992;</span>
<span style="color: #f08080;">test</span> sigtstp <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#35835;&#21462;&#32456;&#31471;&#36755;&#20837;&#65292;&#36755;&#20986;&#21040;&#32456;&#31471;</span>
<span style="color: #f08080;">test</span> sigtstp 
^C <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#36865;SIGINT&#32473;&#36827;&#31243;&#65292;&#32456;&#27490;&#36827;&#31243;</span>
</pre>
</div>

<pre class="example">
      仅当SIGTSTP信号的配置是SIG_DFL，它才会捕捉该信号

      因为当此程序由不支持作业控制的shell所起动时，此信号的配置应当设置为SIG_IGN

      实际上shell并不显式地忽略此信号，而是init将这三个作业控制信号SIGTSTP、SIGTTIN和SIGTTOU设置为SIG_IGN，这种配置由所有登录shell继承

      只有作业控制shell才应将这三个信号重新设置为SIG_DFL
</pre>

<p>
<a href="advanced_io.html">Next：高级IO</a>
</p>

<p>
<a href="proc_group.html">Previous：进程关系</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
