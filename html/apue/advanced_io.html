<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>高级IO</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="signal.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">高级IO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7d33eb4">非阻塞IO</a>
<ul>
<li><a href="#orgd0f9424">轮询</a></li>
</ul>
</li>
<li><a href="#org282352d">流机制</a></li>
<li><a href="#org5856b81">I/O多路转接</a>
<ul>
<li><a href="#orgcb1b323">读和写各使用一个进程</a></li>
<li><a href="#org2cebd5e">使用非阻塞IO</a></li>
<li><a href="#org6402ab3">多路转接</a>
<ul>
<li><a href="#orgf29d759">select函数</a>
<ul>
<li><a href="#org4f24e6e">fd_set数据类型</a></li>
<li><a href="#orgcb83e8d">maxfdp1参数</a></li>
<li><a href="#org366bd5e">timeval结构</a></li>
<li><a href="#org423cb95">返回值</a></li>
<li><a href="#orgcb82286">pselect函数</a></li>
</ul>
</li>
<li><a href="#orgf69359c">poll函数</a>
<ul>
<li><a href="#org2fb3155">pollfd结构</a></li>
<li><a href="#orgc3f1302">nfds参数</a></li>
<li><a href="#org94f3144">timeout参数</a></li>
<li><a href="#orgcc00b25">返回值</a></li>
</ul>
</li>
<li><a href="#org889deac">中断性</a></li>
</ul>
</li>
<li><a href="#org6cc2248">异步IO</a>
<ul>
<li><a href="#orgb8cc244">BSD实现</a>
<ul>
<li><a href="#orgb906916">实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0ec69ee">readv和writev</a>
<ul>
<li><a href="#orgbaa773b">iovec结构</a></li>
<li><a href="#orgafdc549">性能测试</a></li>
</ul>
</li>
<li><a href="#orgc7e4c79">存储映射IO</a>
<ul>
<li><a href="#org63ae2ad">mmap函数</a>
<ul>
<li><a href="#org7ca1c19">参数说明</a>
<ul>
<li><a href="#orgc1631f9">prot参数</a></li>
<li><a href="#org5cb022b">flag参数</a></li>
<li><a href="#org6867949">off和addr参数限制</a></li>
</ul>
</li>
<li><a href="#orgf736e09">信号和进程</a></li>
</ul>
</li>
<li><a href="#org023b0f8">munmap函数</a></li>
<li><a href="#org88a567c">msync函数</a></li>
<li><a href="#orgfd20dc0">使用内存映射拷贝文件</a></li>
</ul>
</li>
<li><a href="#orgee22243">记录锁</a>
<ul>
<li><a href="#org7ec038e">历史</a></li>
<li><a href="#orgd0d695f">fcntl记录锁</a>
<ul>
<li><a href="#org6fc9db4">flock结构</a>
<ul>
<li><a href="#org47c7236">锁类型</a></li>
<li><a href="#org5bdb988">锁区域</a></li>
</ul>
</li>
<li><a href="#org79a6ad9">cmd命令</a>
<ul>
<li><a href="#org873a41a">要求和释放一把锁</a></li>
<li><a href="#org9a57c8f">测试一把锁</a></li>
</ul>
</li>
<li><a href="#orgbb6c698">死锁</a>
<ul>
<li><a href="#org3961f2d">死锁实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc53d72f">锁的隐含继承和释放</a></li>
<li><a href="#org8badd92">BSD的实现</a>
<ul>
<li><a href="#orgd71438a">守护进程号加锁</a></li>
<li><a href="#org95d7192">文件末尾加锁</a></li>
</ul>
</li>
<li><a href="#orgdda2f7e">建议性锁和强制性锁</a>
<ul>
<li><a href="#orgfc81a0b">校验系统是否支持强制性锁</a></li>
<li><a href="#org0ac10f4">两人编辑同一文件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章内容包括：
</p>
<ul class="org-ul">
<li>非阻塞IO</li>
<li>IO多路转接(select和poll函数)</li>
<li>readv和writev函数</li>
<li>存储映照I/O(mmap)</li>
<li>记录锁</li>
</ul>

<pre class="example">
  接下来的进程间通信(IPC)要使用这里所述的很多概念和函数
</pre>

<div id="outline-container-org7d33eb4" class="outline-2">
<h2 id="org7d33eb4">非阻塞IO</h2>
<div class="outline-text-2" id="text-org7d33eb4">
<pre class="example">
    上一章曾将系统调用分成两类： 低速系统调用和其他

    低速系统调用：可能会使进程永远阻塞的一类系统调用，比如读写未准备好的伪终端，网络，管道等

    虽然读、写磁盘文件会使调用在短暂时间内阻塞，但并不能将它们视为“低速”
</pre>
<p>
<span class="underline">非阻塞</span> I/O：使调用 <b>不会永远阻塞</b> 的I/O操作
</p>
<ul class="org-ul">
<li><p>
如果这种操作不能完成，则立即出错返回，表示该操作如继续执行将继续阻塞下去
</p>

<p>
对于一个给定的 <span class="underline">描述符</span> 有两种方法对其指定非阻塞I/O: 
</p></li>
<li>调用 <span class="underline">open</span> 以获得该描述符，则可指定 <b>O_NONBLOCK</b> 标志</li>
<li><span class="underline">已经打开</span> 的一个描述符，则可调用 <b>fcntl</b> 打开 <b>O_NONBLOCK</b> 文件状态标志</li>
</ul>

<pre class="example">
    对于一个非阻塞的文件描述符，如果没有数据可读写，则read和write将直接返回-1，并设置errno为EAGAIN
</pre>
</div>
<div id="outline-container-orgd0f9424" class="outline-3">
<h3 id="orgd0f9424">轮询</h3>
<div class="outline-text-3" id="text-orgd0f9424">
<p>
下面程序从 <span class="underline">标准输入</span> 读 <span class="underline">100000</span> 字节，并试图将它们写到 <span class="underline">标准输出</span> 上：
</p>
<ol class="org-ol">
<li>将 <span class="underline">标准输出</span> 设置为 <b>非阻塞</b> 的</li>
<li>用 <b>轮询</b> 进行输出</li>
<li><p>
每次写的结果都在 <span class="underline">标准出错</span> 上打印
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[100000];

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ntowrite</span>, <span style="color: #4eee94;">nwrite</span>;
    <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>;

    ntowrite = read(STDIN_FILENO, buf, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(buf));
    fprintf(stderr, <span style="color: #deb887;">"read %d bytes\n"</span>, ntowrite);

    set_fl(STDOUT_FILENO, O_NONBLOCK);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">set nonblocking </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    ptr = buf;
    <span style="color: #00bfff; font-weight: bold;">while</span> (ntowrite &gt; 0) {
        errno = 0;
        nwrite = write(STDOUT_FILENO, ptr, ntowrite);
        fprintf(stderr, <span style="color: #deb887;">"nwrite = %d, errno = %d\n"</span>, nwrite, errno);

        <span style="color: #00bfff; font-weight: bold;">if</span> (nwrite &gt; 0) {
            ptr += nwrite;
            ntowrite -= nwrite;
        }
    }

    clr_fl(STDOUT_FILENO, O_NONBLOCK);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">clear nonblocking </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    exit(0);
}
</pre>
</div></li>
</ol>

<pre class="example">
     在linux上的测试结果显示并没有如想象中的调用多次非阻塞写操作，而是只有一次写操作

     虽然关于非阻塞IO内容可能已经过时，但是程序中出现的轮询却还一直被用在各种非阻塞操作中

     轮询往往会导致”浪费CPU时间“，一种更加有效的方法是使用“非阻塞描述符”的”I/O多路转接“
</pre>
</div>
</div>
</div>
<div id="outline-container-org282352d" class="outline-2">
<h2 id="org282352d">流机制</h2>
<div class="outline-text-2" id="text-org282352d">
<pre class="example">
    除了SVR4及其后代如Solaris之外流机制并不是很常用，现在更多被使用的是BSD的socket机制
</pre>
</div>
</div>
<div id="outline-container-org5856b81" class="outline-2">
<h2 id="org5856b81">I/O多路转接</h2>
<div class="outline-text-2" id="text-org5856b81">
<p>
当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞I/O：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">while</span> ( (n = read(STDIN_FILENO, buf, BUFSIZ)) &gt; 0 )
    <span style="color: #00bfff; font-weight: bold;">if</span>( write(STDOUT_FILENO, buf, n) != n)
        err_sys(<span style="color: #deb887;">"write error"</span>);
</pre>
</div>

<pre class="example">
    这种形式的阻塞I/O到处可见，但是如果必须读两个描述符又将如何呢？　

    如果仍旧使用阻塞I/O，那么就可能长时间阻塞在一个描述符上，而另一个描述符虽有很多数据却不能得到及时处理

    所以为了处理这种情况显然需要另一种不同的技术
</pre>
<p>
观察下面的工作情况：
</p>
<ol class="org-ol">
<li><span class="underline">telent</span> 程序 <b>读</b> <span class="underline">终端</span> (标准输入)</li>
<li>所得数据 <b>写</b> 到 <span class="underline">telnetd</span> 上</li>
<li><b>读</b> <span class="underline">telentd</span></li>
<li><p>
所得数据 <b>写</b> 到 <span class="underline">终端上</span> (标准输出) 
</p>

<div class="figure">
<p><img src="pic/modem-dialer.gif" alt="modem-dialer.gif" width="90%" /> 
</p>
</div></li>
</ol>
</div>

<div id="outline-container-orgcb1b323" class="outline-3">
<h3 id="orgcb1b323">读和写各使用一个进程</h3>
<div class="outline-text-3" id="text-orgcb1b323">
<p>
处理这种特殊问题的一种方法是 <b>设置两个进程</b> ，每个进程处理一条数据通路。图12-2中显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/modem-processes.gif" alt="modem-processes.gif" width="90%" /> 
</p>
</div>

<pre class="example">
如果使用两个进程，则可使每个进程都执行阻塞read

但是也产生了这两个进程间相互配合问题：
1. 如果子进程接收到文件结束符(由于电话线的一端已经挂断，使调制解调器也挂断)，那么该子进程终止，然后父进程接收到SIGCHLD信号
2. 若父进程终止(用户在终端上键入了文件结束符)，那么父进程应通知子进程停止工作。为此可以使用一个信号(例如SIGUSR1)

这使程序变得更加复杂
</pre>
</div>
</div>

<div id="outline-container-org2cebd5e" class="outline-3">
<h3 id="org2cebd5e">使用非阻塞IO</h3>
<div class="outline-text-3" id="text-org2cebd5e">
<p>
另一个方式是仍旧 <span class="underline">使用一个进程</span> 执行该程序，但调用 <span class="underline">非阻塞I/O</span> 读取数据，其基本思想是：
</p>
<ul class="org-ul">
<li>将 <span class="underline">两个输入描述符</span> 都设置为 <b>非阻塞</b> 的
<ul class="org-ul">
<li>对第一个描述符发一个 <span class="underline">read</span> 
<ul class="org-ul">
<li>如果该输入上有数据，则读数据并处理它</li>
<li>如果无数据可读，则read立即返回</li>
</ul></li>
<li>对第二个描述符发一个 <span class="underline">read</span> 并作用样的处理</li>
</ul></li>
<li>在此之后， <b>等待</b> <span class="underline">若干秒</span> <b>再读</b> 第一个描述符</li>
</ul>

<pre class="example">
这种方法的不足之处是浪费CPU时间：

1. 大多数时间实际上是无数据可读，但是仍不断反复执行read，这浪费了CPU时间
2. 在每次循环后要等多长时间再执行下一轮循环也很难确定

轮询技术在支持非阻塞I/O的系统上都可使用，但是在多任务系统中应当避免使用
</pre>
</div>
</div>

<div id="outline-container-org6402ab3" class="outline-3">
<h3 id="org6402ab3">多路转接</h3>
<div class="outline-text-3" id="text-org6402ab3">
<pre class="example">
一种比较好的技术是使用“I/O多路转接”，其基本思想是：

1. 构造一张有关描述符的表

2. 调用一个函数，它要到这些描述符中的一个已准备好进行I/O时才返回

3. 返回时它告诉进程哪一个描述符已准备好可以进行I/O
</pre>
</div>
<div id="outline-container-orgf29d759" class="outline-4">
<h4 id="orgf29d759">select函数</h4>
<div class="outline-text-4" id="text-orgf29d759">
<pre class="example">
select函数可以在SVR4和4.3+BSD之下可以执行I/O多路转接
</pre>

<p>
调用者传向select的 <span class="underline">参数</span> 告诉内核:
</p>
<ul class="org-ul">
<li>所 <b>关心的描述符</b></li>
<li>对于每个描述符所 <b>关心的条件</b> ：
<ul class="org-ul">
<li>是否 <span class="underline">读</span> 一个给定的描述符</li>
<li>是否想 <span class="underline">写</span> 一个给定的描述符</li>
<li>是否关心一个描述符的 <span class="underline">异常条件</span></li>
<li>&#x2026;&#x2026;</li>
</ul></li>
<li>希望 <b>等待多长时间</b> ：
<ul class="org-ul">
<li>永远等待</li>
<li>等待一个固定量时间</li>
<li>完全不等待</li>
</ul></li>
</ul>

<pre class="example">
      一个描述符阻塞与否并不影响select是否阻塞，也就是说如果希望读一个非阻塞描述符，并且以超时值为5秒调用select，则select最多阻塞5秒

      相类似如果指定一个无限的超时值，则select阻塞到对该描述符数据准备好，或捕捉到一个信号
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/select.h&gt;</span> 

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20351;&#29992;select&#20989;&#25968;&#36827;&#34892;IO&#22810;&#36335;&#36716;&#25509;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * maxfdp1: readfds, writefds, exceptfds&#19977;&#20010;&#25551;&#36848;&#31526;&#20013;&#22823;&#30340;fd&#20540;&#21152;1</span>
<span style="color: #ffebcd;"> * readfds: &#25351;&#21521;&#35835;&#25991;&#20214;&#25551;&#36848;&#31526;&#38598;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * writefds: &#25351;&#21521;&#20889;&#25991;&#20214;&#25551;&#36848;&#31526;&#38598;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * exceptfds: &#25351;&#21521;&#24322;&#24120;&#25991;&#20214;&#25551;&#36848;&#31526;&#38598;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> * tvptr: &#25351;&#21521;&#31561;&#24453;&#26102;&#38388;&#32467;&#26500;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#20934;&#22791;&#23601;&#32490;&#30340;&#25551;&#36848;&#31526;&#25968;&#37327;&#65292;&#33509;&#36229;&#26102;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">select</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">maxfdp1</span>,
       <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">readfds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">write_fds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">exceptfds</span>,
       <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">timeval</span> *<span style="color: #4eee94;">tvptr</span>);
</pre>
</div>

<p>
从select <span class="underline">返回</span> 时，内核告诉调用者：
</p>
<ul class="org-ul">
<li>已 <span class="underline">准备好的描述符</span> 的 <b>数量</b></li>
<li><b>哪一个描述符</b> 已准备好 <span class="underline">读</span> 、 <span class="underline">写</span> 或 <span class="underline">异常</span> 条件</li>
</ul>

<p>
使用这种返回值，就可 <b>调用</b> 相应的I/O函数(一般是 <span class="underline">read</span> 或 <span class="underline">write</span> )，并且 <b>确知该函数不会阻塞</b> 
</p>
</div>

<div id="outline-container-org4f24e6e" class="outline-5">
<h5 id="org4f24e6e">fd_set数据类型</h5>
<div class="outline-text-5" id="text-org4f24e6e">
<p>
指向 <span class="underline">描述符集</span> 的指针：
</p>
<ul class="org-ul">
<li><span class="underline">readfds</span> ：关心的 <b>可读的各个描述符</b></li>
<li><span class="underline">writefds</span> ：关心的 <b>可写描述符号</b></li>
<li><span class="underline">exceptfds</span> ：关心的处于 <b>异常条件的各个描述符</b></li>
</ul>

<p>
每个描述符集存放在一个 <b>fd_set</b> 数据类型中，这种数据类型的实现可见图12-9，它为 <b>每一可能的描述符保持了一位</b> ：
</p>

<div class="figure">
<p><img src="pic/fd-set.jpg" alt="fd-set.jpg" width="90%" /> 
</p>
</div>

<p>
操作fd_set这种类型的变量使用下列四个 <span class="underline">宏</span> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">FD_ISSET</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27979;&#35797;&#26576;&#25991;&#20214;&#25551;&#36848;&#31526;&#23545;&#24212;&#30340;&#20301;&#26159;&#21542;&#34987;&#35774;&#32622;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">FD_SET</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#26576;&#25991;&#20214;&#25551;&#36848;&#31526;&#23545;&#24212;&#30340;&#20301;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">FD_CLR</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#38500;&#26576;&#25991;&#20214;&#25551;&#36848;&#31526;&#23545;&#24212;&#30340;&#20301;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">FD_ZERO</span>(<span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#38500;&#20854;&#25152;&#26377;&#20301;</span>
</pre>
</div>

<p>
select中间三个参数中的任意一个(或全部)可以是 <span class="underline">空指针</span> ，这表示对 <b>相应条件并不关心</b> 
</p>
<pre class="example">
       如果所有三个指针都是空指针，则select提供了较sleep更精确的计时器
</pre>
</div>
</div>

<div id="outline-container-orgcb83e8d" class="outline-5">
<h5 id="orgcb83e8d">maxfdp1参数</h5>
<div class="outline-text-5" id="text-orgcb83e8d">
<p>
第一个参数maxfdp1的意思是 <b>最大fd加1</b> ，在三个描述符集中找出最高描述符编号值，然后加1
</p>

<pre class="example">
       可将第一个参数设置为FD_SETSIZE，它说明了最大的描述符数(经常是256或1024)

       但是对大多数应用程序而言此值太大了，大多数应用程序只使用3~10个描述符

       如果将第三个参数设置为最高描述符编号值加1，内核就只需在此范围内寻找打开的位，而不必在数百位的大范围内搜索
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">fd_set</span> <span style="color: #4eee94;">readset</span>, <span style="color: #4eee94;">writeset</span>;
FD_ZERO(&amp;readset);
FD_ZERO(&amp;writeset);

FD_SET(0, &amp;readset);
FD_SET(3, &amp;readset);
FD_SET(1, &amp;writeset);
FD_SET(2, &amp;writeset);

select(4, &amp;readset, &amp;writeset, <span style="color: #ffd700;">NULL</span>, <span style="color: #ffd700;">NULL</span>);
</pre>
</div>

<p>
图12-10显示了这两个描述符集的情况：
</p>

<div class="figure">
<p><img src="pic/fd-set-sample.jpg" alt="fd-set-sample.jpg" width="90%" /> 
</p>
</div>

<pre class="example">
       因为描述符编号从0开始，所以要在最大描述符编号值上加1，实际上是“要检查的描述符数量”
</pre>
</div>
</div>

<div id="outline-container-org366bd5e" class="outline-5">
<h5 id="org366bd5e">timeval结构</h5>
<div class="outline-text-5" id="text-org366bd5e">
<p>
最后一个参数 <span class="underline">tvptr</span> 是一个指向 <span class="underline">timeval</span> 结构的指针，它指定 <b>愿意等待的时间</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">timeval</span>{
    <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">tv_sec</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">seconds </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">tv_usec</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">and microseconds </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>

<p>
有以下三种情况：
</p>
<ul class="org-ul">
<li><span class="underline">tvptr = NULL</span> :  <b>永远</b> 等待</li>
</ul>
<pre class="example">
	 当所指定的“描述符中的一个已准备好”或“捕捉到一个信号“则返回，否则无限期等待
</pre>
<ul class="org-ul">
<li><span class="underline">tvptr-&gt;tv_sec = 0 &amp;&amp; tvptr-&gt;tv_usec = 0</span>  :  <b>完全</b> 不等待</li>
</ul>
<pre class="example">
       测试所有指定的描述符并立即返回

       这是得到多个描述符的状态而不阻塞select函数的轮询方法
</pre>
<ul class="org-ul">
<li><span class="underline">tvptr-&gt;tv_sec !=0 || tvptr-&gt;tv_usec != 0</span> :  <b>等待</b> 指定的 <span class="underline">秒数</span> 和 <span class="underline">微秒数</span></li>
</ul>
<pre class="example">
       当指定的描述符之一已准备好，或当“指定的时间值已经超过”时立即返回

       与第一种情况一样，等待可被捕捉到的信号中断
</pre>
</div>
</div>


<div id="outline-container-org423cb95" class="outline-5">
<h5 id="org423cb95">返回值</h5>
<div class="outline-text-5" id="text-org423cb95">
<p>
select有三个可能的返回值：
</p>
<ul class="org-ul">
<li><span class="underline">-1</span> ： <b>出错</b> 
<ul class="org-ul">
<li>在所指定的描述符都没有准备好时 <span class="underline">捕捉到一个信号</span> ，并且errno设置为EINTR</li>
</ul></li>
<li>0： <b>超时</b> 
<ul class="org-ul">
<li><span class="underline">没有描述符准备好</span> ，而且 <span class="underline">指定的时间已经超过</span></li>
</ul></li>
<li>&gt;0：已经 <b>准备好的描述符数</b> 
<ul class="org-ul">
<li><span class="underline">三个描述符集</span> 中 <b>仍旧打开的位</b> 是对应于 <b>已准备好的描述符位</b></li>
</ul></li>
</ul>

<p>
对于 <span class="underline">准备好</span> 的意思要作一些更具体的说明：
</p>
<ul class="org-ul">
<li>若对 <span class="underline">读集</span> 中的 <b>一个描述符的read不会阻塞</b> ，则此描述符是准备好的</li>
<li>若对 <span class="underline">写集</span> 中的 <b>一个描述符的write不会阻塞</b> ，则此描述符是准备好的</li>
<li>若对异常条件集中的一个描述符有一个 <b>未决异常条件</b> ，则此描述符是准备好的
<ul class="org-ul">
<li>在 <span class="underline">网络连接</span> 上到达 <span class="underline">指定波特率外</span> 的数据</li>
<li>在处于数据包方式的 <span class="underline">伪终端</span> 上发生了 <span class="underline">某些条件</span></li>
</ul></li>
</ul>

<pre class="example">
       如果在一个描述符上碰到了文件结束，则select认为该描述符是可读的，
       然后调用read，它返回0，这是UNIX指示到达文件结尾处的方法

       很多人错误地认为，当到达文件结尾处时，select会指示一个异常条件
</pre>
</div>
</div>

<div id="outline-container-orgcb82286" class="outline-5">
<h5 id="orgcb82286">pselect函数</h5>
<div class="outline-text-5" id="text-orgcb82286">
<p>
<span class="underline">pselect</span> 函数是select的变体：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/select.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pselect</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nfds</span>,
        <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">readfds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">writefds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">exceptfds</span>,
        <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">timespec</span> *<span style="color: #4eee94;">timeout</span>,
        <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">sigmask</span>);
</pre>
</div>
<p>
主要区别：
</p>
<ul class="org-ul">
<li>定时采用了 <span class="underline">纳秒级</span> 的timespec结构</li>
<li>timespec参数声明为 <span class="underline">const</span></li>
<li>使用 <span class="underline">信号集</span> <b>屏蔽</b> 不需要的信号</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf69359c" class="outline-4">
<h4 id="orgf69359c">poll函数</h4>
<div class="outline-text-4" id="text-orgf69359c">
<pre class="example">
SVR4的poll函数类似于select，但是其调用形式则有所不同
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;poll.h&gt;</span>

<span style="color: #ffebcd;">/**</span>

<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">poll</span>(<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">pollfd</span> *<span style="color: #4eee94;">fds</span>, <span style="color: #98f5ff;">nfds_t</span> <span style="color: #4eee94;">nfds</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">timeout</span>);
</pre>
</div>
</div>
<div id="outline-container-org2fb3155" class="outline-5">
<h5 id="org2fb3155">pollfd结构</h5>
<div class="outline-text-5" id="text-org2fb3155">
<p>
与select不同，poll不是为每个条件构造一个描述符集，而是构造一个 <span class="underline">pollfd结构数组</span> ，每个数组元素指定 <span class="underline">一个描述符编号</span> 以及对其所 <span class="underline">关心的条件</span> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">pollfd</span>
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25991;&#20214;&#25551;&#36848;&#31526;&#21495;&#25110;&lt;0&#34920;&#31034;&#24573;&#30053;</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">events</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#20851;&#24515;&#30340;&#20107;&#20214;,&#30001;&#29992;&#25143;&#31243;&#24207;&#35774;&#32622; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">revents</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#24050;&#32463;&#21457;&#29983;&#30340;&#20107;&#20214;,&#30001;&#31995;&#32479;&#35774;&#32622; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">events</span> 成员应该被设置为下表中所示值的一个或几个：告诉 <span class="underline">内核</span> 对该 <span class="underline">描述符</span>  <b>关心</b> 的是什么</li>
<li><p>
返回时， <span class="underline">内核</span> 设置 <span class="underline">revents</span> 成员：说明对该 <span class="underline">描述符</span> <b>发生</b> 了什么事件
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> poll的events和revents标志</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名称</td>
<td class="org-left">从events得到的输入</td>
<td class="org-left">从revents得到的结果</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">POLLIN</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取出 <span class="underline">高优先级之外</span> 的数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLRDNORM</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取 <span class="underline">普通数据</span> (优先级为0)，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLRDBAND</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取 <span class="underline">非0优先级</span> 波段数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLPRI</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取 <span class="underline">高优先级</span> 数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLOUT</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">写普通数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLWRNORM</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">和POLLOUT相同</td>
</tr>

<tr>
<td class="org-left">POLLWRBAND</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">写非0优先级数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLERR</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">已经 <span class="underline">出错</span></td>
</tr>

<tr>
<td class="org-left">POLLHUP</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">已经 <span class="underline">挂断</span></td>
</tr>

<tr>
<td class="org-left">POLLNVAL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">描述符 <span class="underline">无效</span></td>
</tr>
</tbody>
</table></li>

<li>头四行 <span class="underline">测试</span> <b>可读性</b></li>
<li>接着三行 <span class="underline">测试</span> <b>可写性</b></li>
<li>最后三行则是 <b>异常条件</b> ：由内核在返回时设置的
<ul class="org-ul">
<li>即使在events字段中没有指定这三个值，如果相应条件发生，则在revents中也返回它们</li>
<li>当一个描述符被 <b>挂断</b> 后 <span class="underline">POLLHUP</span> ，就 <b>不能再写</b> 向该描述符。但是 <b>仍可能从该描述符读取</b> 到数据</li>
</ul></li>
</ul>

<pre class="example">
       注意：poll“没有更改”events成员

       这与select不同，select“修改其参数”以指示哪一个描述符已准备好了
</pre>
</div>
</div>

<div id="outline-container-orgc3f1302" class="outline-5">
<h5 id="orgc3f1302">nfds参数</h5>
<div class="outline-text-5" id="text-orgc3f1302">
<p>
<span class="underline">nfds</span> 参数：表明 <b>fds数组的元素数目</b> 
</p>
</div>
</div>
<div id="outline-container-org94f3144" class="outline-5">
<h5 id="org94f3144">timeout参数</h5>
<div class="outline-text-5" id="text-org94f3144">
<p>
<span class="underline">timeout</span> 参数：想要等待多少时间。有三种不同的情形: 
</p>

<ul class="org-ul">
<li><p>
<span class="underline">timeout = INFTIM</span> : <b>永远</b> 等待
</p>
<pre class="example">
	 常数INFTIM定义在&lt;stropts.h&gt;，其值通常是-1。当所指定的描述符中的一个已准备好，或捕捉到一个信号则返回
</pre></li>

<li><span class="underline">timeout = 0</span>  :  <b>不</b> 等待</li>
</ul>

<pre class="example">
       测试所有描述符并立即返回。这是得到很多个描述符的状态而不阻塞poll函数的轮询方法
</pre>

<ul class="org-ul">
<li><span class="underline">timeout &gt; 0</span>  : 等待 <b>timeout毫秒</b></li>
</ul>
<p>
当指定的描述符之一已准备好或指定的时间值已超过时立即返回。同样 <b>可以被一个信号中断</b> 
</p>

<pre class="example">
       不论一个描述符是否阻塞,并不影响poll是否阻塞
</pre>
</div>
</div>

<div id="outline-container-orgcc00b25" class="outline-5">
<h5 id="orgcc00b25">返回值</h5>
<div class="outline-text-5" id="text-orgcc00b25">
<p>
poll也有三个可能的返回值：
</p>
<ul class="org-ul">
<li><span class="underline">-1</span> ： <b>出错</b> 
<ul class="org-ul">
<li>在所指定的描述符都没有准备好时 <span class="underline">捕捉到一个信号</span> ，并且errno设置为EINTR</li>
</ul></li>
<li>0： <b>超时</b> 
<ul class="org-ul">
<li><span class="underline">没有描述符准备好</span> ，而且 <span class="underline">指定的时间已经超过</span></li>
</ul></li>
<li>&gt;0：已经 <b>准备好的描述符数</b></li>
</ul>

<pre class="example">
       文件结束与挂断之间的区别：

       如果正在终端输入数据，并键入文件结束字符，POLLIN被打开，于是就可读文件结束指示(read返回0)，POLLHUP在revents中没有打开

       如果读调制解调器，并且电话线已挂断，则在revents中将接到POLLHUP
</pre>
</div>
</div>
</div>

<div id="outline-container-org889deac" class="outline-4">
<h4 id="org889deac">中断性</h4>
<div class="outline-text-4" id="text-org889deac">
<pre class="example">
      中断的系统调用的自动再起动是由4.2+BSD引进的，但当时select函数是“不再起动的”

      这种特性延续到4.3+BSD，即使指定了SA_RESTART也是为此

      但是，在SVR4之下，如果指定了SA_RESTART，那么select和poll也是自动再起动的

      为了将软件移植到SVR4时阻止这一点，如果信号可能中断select或poll，则总是使用signal_intr函数
</pre>
</div>
</div>
</div>

<div id="outline-container-org6cc2248" class="outline-3">
<h3 id="org6cc2248">异步IO</h3>
<div class="outline-text-3" id="text-org6cc2248">
<p>
还有一种技术称之为 <span class="underline">异步I/O</span> ，基本思想是进程告诉内核， <span class="underline">当一个描述符已准备好</span> 可以进行I/O时，用一个 <b>信号通知进程</b> 
</p>

<pre class="example">
这种技术有两个问题：

1. 并非所有系统都支持这种机制，现在它还不是POSIX的组成部分
SVR4为此技术提供SIGPOLL信号，但是仅当描述符引用流设备时才能工作
4.3+BSD有一个类似的信号SIGIO，但是仅当描述符引用终端设备或网络时才能工作

2. 这种信号对每个进程而言只有1个
如果使该信号对两个描述符都起作用，那么在接到此信号时进程无法判别是哪一个描述符已准备好可以进行I/O
为了确定是哪一个描述符已准备好，仍需将这两个描述符都设置为非阻塞的，并顺序尝试执行I/O

系统只是告诉某个事件发生在文件描述符，但并不告诉关于文件描述符状态变化的任何信息，仍然需要主动地使用select或poll来查询描述符状态
</pre>
</div>

<div id="outline-container-orgb8cc244" class="outline-4">
<h4 id="orgb8cc244">BSD实现</h4>
<div class="outline-text-4" id="text-orgb8cc244">
<p>
BSD实现异步IO使用的信号是 <span class="underline">SIGIO</span> 和 <span class="underline">SIGURG</span> 
</p>
<ul class="org-ul">
<li>SIGIO： <b>通用</b> 异步信号</li>
<li>SIGURG： <b>通知</b> 进程在 <b>网络连接</b> 上有非规定波特率数据</li>
</ul>

<pre class="example">
      对于SIGURG只需要设置下面的前两个步骤，信号仅仅是用于支持“非规定波特率”数据的“网络连接描述符”产生的
</pre>

<p>
为了使用 <span class="underline">SIGIO</span> 的话，需要执行下面三个步骤：
</p>
<ol class="org-ol">
<li>调用signal为SIGIO建立 <b>处理</b> 函数</li>
<li>使用 <b>F_SETOWN</b> 为 <span class="underline">fd</span> 设置 <span class="underline">进程</span> 和 <span class="underline">进程组</span> 
<ul class="org-ul">
<li>因为一旦fd触发信号的话，系统是要决定 <span class="underline">信号</span> <b>投递</b> 到哪个 <span class="underline">进程</span> 和 <span class="underline">进程组</span> 的</li>
</ul></li>
<li>使用 <b>F_SETFL</b> 来设置 <b>O_ASYNC</b> 文件状态标志，仅仅用于 <span class="underline">终端</span> 或者是 <span class="underline">网络</span> 的描述符</li>
</ol>
</div>

<div id="outline-container-orgb906916" class="outline-5">
<h5 id="orgb906916">实例</h5>
<div class="outline-text-5" id="text-orgb906916">
<p>
使用 <span class="underline">SIGIO</span> 信号实现 <span class="underline">异步IO</span> 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">id</span> = 0;

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_handler</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>){
    printf(<span style="color: #deb887;">"%d received(%d)\n"</span>,strsignal(signo),id);
    id++;
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(){
    signal(SIGIO,sig_handler);
    fcntl(0,F_SETOWN,getpid());
    fcntl(0,F_SETFL,fcntl(0,F_GETFL) | O_ASYNC);
    pause();
    <span style="color: #00bfff; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org0ec69ee" class="outline-2">
<h2 id="org0ec69ee">readv和writev</h2>
<div class="outline-text-2" id="text-org0ec69ee">
<p>
<span class="underline">readv</span> 和 <span class="underline">writev</span> 函数用于在 <span class="underline">一个函数调用</span> 中 <span class="underline">读、写</span> <b>多个 <span class="underline">非连续</span> 内存</b> 
</p>
<ul class="org-ul">
<li><span class="underline">readv</span> ： <b>散布读</b></li>
<li><span class="underline">writev</span> ： <b>聚集写</b></li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span> 
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/uio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20174;fileds&#20013;&#35835;&#20837;&#30340;&#25968;&#25454;&#25353;&#39034;&#24207;&#36880;&#22359;&#20998;&#25955;&#23384;&#20648;&#22312;iov&#25351;&#21521;&#30340;iovcnt&#20010;&#32531;&#20914;&#21306;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fileds: &#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> * iov: &#25351;&#21521;&#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;</span>
<span style="color: #ffebcd;"> * iovcnt: &#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#20803;&#32032;&#25968;&#30446;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#24050;&#35835;&#21462;&#30340;&#23383;&#33410;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520; font-weight: bold;">readv</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">iovec</span> *<span style="color: #4eee94;">iov</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">iovcnt</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23558; iovcnt &#20010;&#32531;&#20914;&#21306;&#30340;&#25968;&#25454;&#25353;&#39034;&#24207;&#36880;&#22359;&#36830;&#32493;&#30340;&#20889;&#20837;fileds</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * fileds: &#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> * iov: &#25351;&#21521;&#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;</span>
<span style="color: #ffebcd;"> * iovcnt: &#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#20803;&#32032;&#25968;&#30446;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return: &#24050;&#20889;&#20986;&#30340;&#23383;&#33410;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520; font-weight: bold;">writev</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">iovec</span> *<span style="color: #4eee94;">iov</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">iovcnt</span>);
</pre>
</div>
</div>

<div id="outline-container-orgbaa773b" class="outline-3">
<h3 id="orgbaa773b">iovec结构</h3>
<div class="outline-text-3" id="text-orgbaa773b">
<p>
<span class="underline">iovec结构</span> 用来说明 <b>缓存区</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">iovec</span>
{
    <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">iov_base</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#32531;&#20914;&#21306;&#36215;&#22987;&#22320;&#22336; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">iov_len</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#32531;&#20914;&#21306;&#38271;&#24230; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
下图显示了readv和writev的参数和iovec结构之间的关系：
</p>


<div class="figure">
<p><img src="pic/iovec.png" alt="iovec.png" width="90%" /> 
</p>
</div>

<ul class="org-ul">
<li>writev:  <b>顺序</b> <span class="underline">iov[0]</span> ， <span class="underline">iov[1]</span> 至 <span class="underline">iov[iovcnt-1]</span> 从 <span class="underline">缓存</span> 中 <b>聚集</b> 输出数据
+返回： <span class="underline">输出的字节总数</span> ，等于 <b>各个缓存长度之和</b></li>
<li>readv: 将 <span class="underline">读入的数据</span> 按上述同样 <b>顺序</b> <b>散布</b> 到 <span class="underline">缓存</span> 中
<ul class="org-ul">
<li>总是先填满一个缓存，然后再填写下一个</li>
<li>返回：读得的 <span class="underline">总字节数</span> 
<ul class="org-ul">
<li>如果遇到 <b>文件结尾</b> ，已无数据可读，则返回 <span class="underline">0</span></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgafdc549" class="outline-3">
<h3 id="orgafdc549">性能测试</h3>
<div class="outline-text-3" id="text-orgafdc549">
<p>
有三种方法可以实现从两个缓存区写入一个文件:
</p>
<ol class="org-ol">
<li>调用 <span class="underline">write两次</span>  ，一次一个缓存</li>
<li><span class="underline">分配</span> 一个大到 <span class="underline">足以包含两个缓存的新缓存</span> 。将两个缓存的内容 <b>复制到新缓存中</b> 。然后对该缓存调用wrtre一次</li>
<li>调用 <span class="underline">writev</span> 输出两缓存</li>
</ol>

<pre class="example">
     测试结果显示：

     调用两次write几乎是另外两种方法的2倍时间

     采用缓存复制后用一个write与采用一个writev所用CPU时间几乎一样
     但一般说来，因为前者还需要分配一个临时缓存用于存储及复制，所以后者更复杂
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc7e4c79" class="outline-2">
<h2 id="orgc7e4c79">存储映射IO</h2>
<div class="outline-text-2" id="text-orgc7e4c79">
<p>
<span class="underline">存储映射</span> I/O：使一个 <span class="underline">磁盘文件</span> 与 <span class="underline">存储空间中的一个缓存</span> 相 <b>映射</b> 
</p>

<pre class="example">
    当从缓存中取数据就相当于读文件中的相应字节，而将数据存入缓存，则相应字节就自动地写入文件

    这样就可以在不使用read和write的情况下执行I/O
</pre>
</div>

<div id="outline-container-org63ae2ad" class="outline-3">
<h3 id="org63ae2ad">mmap函数</h3>
<div class="outline-text-3" id="text-org63ae2ad">
<p>
<span class="underline">mmap</span> 函数：*告诉* <span class="underline">内核</span> 将一个给定的 <span class="underline">文件</span> <b>映射</b> 到一个 <span class="underline">存储区域</span> 中
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#30913;&#30424;&#25991;&#20214;&#26144;&#23556;&#21040;&#20869;&#23384;&#20013;&#30340;&#32531;&#20914;&#21306;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * addr: &#32531;&#23384;&#21306;&#30340;&#39318;&#22320;&#22336;&#65292;&#19968;&#33324;&#20026;NULL&#65292;&#34920;&#31034;&#31995;&#32479;&#33258;&#24049;&#20998;&#37197;&#65292;&#24212;&#20026;&#31995;&#32479;&#8220;&#34394;&#25311;&#20869;&#23384;&#39029;&#30340;&#25972;&#25968;&#20493;&#8221;</span>
<span style="color: #ffebcd;"> * len: &#32531;&#23384;&#21306;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> * prot: &#25991;&#20214;&#20445;&#25252;&#27169;&#24335;&#65292;PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC&#30340;&#20219;&#24847;&#25110;&#36923;&#36753;&#30340;&#32452;&#21512;</span>
<span style="color: #ffebcd;"> * flag: MAP_FIXED &#35201;&#27714;&#31995;&#32479;&#20351;&#29992;&#25351;&#23450;&#30340; addr,&#19981;&#24314;&#35758;&#20351;&#29992;&#27492;&#26631;&#24535;</span>
<span style="color: #ffebcd;"> *       MAP_SHARED &#20462;&#25913;&#32531;&#20914;&#21306;&#21363;&#20026;&#30452;&#25509;&#20462;&#25913;&#25991;&#20214;</span>
<span style="color: #ffebcd;"> *       MAP_PRIVATE(&#32531;&#20914;&#21306;&#20165;&#20165;&#26159;&#25991;&#20214;&#30340;&#21103;&#26412;</span>
<span style="color: #ffebcd;"> * filedes: &#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> * off: &#25991;&#20214;&#20013;&#30340;&#36215;&#22987;&#20301;&#32622;&#65292;&#24212;&#20026;&#31995;&#32479;&#8220;&#34394;&#25311;&#20869;&#23384;&#39029;&#30340;&#25972;&#25968;&#20493;&#8221;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return&#65306;&#33509;&#25104;&#21151;&#21017;&#36820;&#22238;&#8220;&#26144;&#23556;&#21306;&#30340;&#36215;&#22987;&#22320;&#22336;&#8221;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">mmap</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">prot</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">off</span>);
</pre>
</div>
</div>
<div id="outline-container-org7ca1c19" class="outline-4">
<h4 id="org7ca1c19">参数说明</h4>
<div class="outline-text-4" id="text-org7ca1c19">
<ul class="org-ul">
<li><span class="underline">addr</span> :  <span class="underline">映射存储区</span> 的 <b>起始地址</b> 
<ul class="org-ul">
<li>通常将其设置为 <span class="underline">NULL</span> ：由 <b>系统选择</b> 该映射区的起始地址</li>
</ul></li>
<li><span class="underline">filedes</span> :  <span class="underline">被映射文件</span> 的 <b>描述符</b> 
<ul class="org-ul">
<li>在映射该文件到一个地址空间之前， <b>先要打开</b> 该文件</li>
</ul></li>
<li><span class="underline">len</span> : 映射的 <b>字节数</b></li>
<li><span class="underline">off</span> : 要映射字节在 <b>文件中的起始位移量</b></li>
</ul>
</div>

<div id="outline-container-orgc1631f9" class="outline-5">
<h5 id="orgc1631f9">prot参数</h5>
<div class="outline-text-5" id="text-orgc1631f9">
<p>
<span class="underline">prot</span> 参数：映射存储区的 <b>保护要求</b> 
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 存储映射区的保护</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">prot</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">PROT_READ</td>
<td class="org-left">区域 <b>可读</b></td>
</tr>

<tr>
<td class="org-left">PROT_WRITE</td>
<td class="org-left">区域 <b>可写</b></td>
</tr>

<tr>
<td class="org-left">PROT_EXEC</td>
<td class="org-left">区域 <b>可执行</b></td>
</tr>

<tr>
<td class="org-left">PROT_NONE</td>
<td class="org-left">区域 <b>可存取</b> (BSD无此选项)</td>
</tr>
</tbody>
</table>

<pre class="example">
       对于“映射存储区所指定的保护要求”必须与“文件的open方法”匹配

       例如，若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE 
</pre>
</div>
</div>
<div id="outline-container-org5cb022b" class="outline-5">
<h5 id="org5cb022b">flag参数</h5>
<div class="outline-text-5" id="text-org5cb022b">
<p>
<span class="underline">flag</span> 参数：影响 <b>映射存储区的多种属性</b> 
</p>
<ul class="org-ul">
<li><span class="underline">MAP_FIXED</span> ： <span class="underline">返回值</span> <b>必须等于</b> <span class="underline">addr</span></li>
</ul>
<pre class="example">
       因为这不利于可移植性，所以不鼓励使用此标志

       如果未指定此标志，而且addr非0，则内核只把addr视为何处设置映射区的一种建议

       通过将addr指定为NULL可获得最大可移植性
</pre>
<ul class="org-ul">
<li><span class="underline">MAP_SHARED</span> ： <span class="underline">本进程</span> 对 <span class="underline">映射区</span> 所进行的 <b>存储操作</b> 
<ul class="org-ul">
<li>这意味着 <span class="underline">存储操作</span> 相当于对该文件 <span class="underline">write</span></li>
</ul></li>
<li><span class="underline">MAP_PRIVATE</span> ：对映射区的 <span class="underline">存储操作</span> 导致 <b>创建</b> 该 <span class="underline">映射文件的一个副本</span> 
<ul class="org-ul">
<li>所有后来对该映射区的存访都是 <b>存访该副本</b> ，而不是原始文件</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6867949" class="outline-5">
<h5 id="org6867949">off和addr参数限制</h5>
<div class="outline-text-5" id="text-org6867949">
<p>
下图显示了一个存储映射文件：
</p>

<div class="figure">
<p><img src="pic/mmap.png" alt="mmap.png" width="90%" /> 
</p>
</div>

<p>
<span class="underline">off</span> 和 <span class="underline">addr</span> 的值通常应当是 <b>系统虚存页长度的倍数</b> ，一般这2个值都是 <span class="underline">NULL</span> 或 <span class="underline">0</span> 
</p>

<pre class="example">
       因为映射文件的起动位移量受系统虚存页长度的限制，那么如果映射区的长度不是页长度的整数倍时，将如何呢？

       假定文件长12字节，系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设为0

       可以修改这500字节，但任何变动都不会在文件中反映出来
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf736e09" class="outline-4">
<h4 id="orgf736e09">信号和进程</h4>
<div class="outline-text-4" id="text-orgf736e09">
<p>
与映射存储区相关有两个信号：
</p>
<ul class="org-ul">
<li><span class="underline">SIGSEGV</span> ：用于指示 <span class="underline">进程</span> <b>试图存取</b> 它 <b>不能存取</b> 的 <span class="underline">存储区</span> 
<ul class="org-ul">
<li>如果进程企图 <b>存数据</b> 到用mmap指定为 <b>只读的</b> 映射存储区 ，那么也产生此信号</li>
</ul></li>
<li><span class="underline">SIGBUS</span> ：如果存取映射区的某个部分，而在 <b>存储时这一部分已不存在</b> ，则产生此信号</li>
</ul>
<pre class="example">
      例如用文件长度映射一个文件

      但在存访该映射区之前，另一个进程已将该文件截短

      此时如果进程企图存取对应于该文件尾端部分的映射区，则接收到SIGBUS信号
</pre>

<p>
进程在fork和exec后：
</p>
<ul class="org-ul">
<li>fork： <span class="underline">子进程</span> <b>继承</b> <span class="underline">存储映射区</span> 
<ul class="org-ul">
<li>这是因为 <span class="underline">子进程</span> <b>复制</b> <span class="underline">父进程地址空间</span> ，而 <b>存储映射区是该地址空间中的一部分</b></li>
</ul></li>
<li>exec： <span class="underline">新程序</span> 则 <b>不继承</b> 此存储映射区</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org023b0f8" class="outline-3">
<h3 id="org023b0f8">munmap函数</h3>
<div class="outline-text-3" id="text-org023b0f8">
<p>
<span class="underline">munmap</span> 函数： <b>解除</b> 内存映射
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#35299;&#38500;&#23384;&#20648;&#26144;&#23556;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * addr : &#32531;&#23384;&#21306;&#39318;&#22320;&#22336;</span>
<span style="color: #ffebcd;"> * len : &#32531;&#23384;&#21306;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return : &#33509;&#25104;&#21151;&#21017;&#20026; 0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026; -1</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">munmap</span>(<span style="color: #98f5ff;">caddr_t</span> <span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>);
</pre>
</div>
<p>
<span class="underline">进程终止</span> 时或 <span class="underline">调用了munmap</span> 之后， <span class="underline">存储映射区</span> 就被 <b>自动去除</b> 
</p>

<pre class="example">
      注意：“关闭文件描述符”filedes并不“解除映射区”
</pre>
</div>
</div>

<div id="outline-container-org88a567c" class="outline-3">
<h3 id="org88a567c">msync函数</h3>
<div class="outline-text-3" id="text-org88a567c">
<pre class="example">
     调用munmap并不使映射区的内容写到磁盘文件上
</pre>
<p>
调用 <span class="underline">msync</span> 函数才使 <span class="underline">修改后的数据</span> <b>反应到</b> 映射的 <span class="underline">磁盘文件</span> 中　
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#20351;&#20462;&#25913;&#21518;&#30340;&#25968;&#25454;&#26356;&#26032;&#21040;&#26144;&#23556;&#30340;&#30913;&#30424;&#25991;&#20214;&#20013;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * addr : &#26144;&#23556;&#32531;&#23384;&#21306;&#39318;&#22320;&#22336;</span>
<span style="color: #ffebcd;"> * len : &#26144;&#23556;&#32531;&#23384;&#21306;&#38271;&#24230;</span>
<span style="color: #ffebcd;"> * flags : &#26356;&#26032;&#26041;&#24335; MS_ASYNC(&#24322;&#27493;&#26356;&#26032;&#65292;&#31435;&#21363;&#36820;&#22238;)&#65292;MS_SYNC(&#21516;&#27493;&#26356;&#26032;&#65292;&#26356;&#26032;&#23436;&#25104;&#21518;&#25165;&#36820;&#22238;)</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">msync</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flags</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd20dc0" class="outline-3">
<h3 id="orgfd20dc0">使用内存映射拷贝文件</h3>
<div class="outline-text-3" id="text-orgfd20dc0">
<p>
下面程序用 <span class="underline">存储映射</span> I/O <b>复制</b> 一个 <span class="underline">文件</span> ：
</p>
<ol class="org-ol">
<li><span class="underline">打开</span> 两个文件</li>
<li>调用 <span class="underline">fstat</span> 得到 <span class="underline">输入文件的长度</span></li>
<li>调用 <span class="underline">lseek</span> ，然后 <span class="underline">写一个字节</span> 以 <b>设置</b> <span class="underline">输出文件的长度</span> 
<ul class="org-ul">
<li>如果不设置输出文件的长度，则对输出文件调用mmap也可以，但是 <span class="underline">对相关存储区的第一次存访</span> 会 <b>产生</b> <span class="underline">SIGBUS</span></li>
</ul></li>
<li>对每个文件调用 <span class="underline">mmap</span> ，将文件 <b>映射</b> 到存储区</li>
<li>调用 <span class="underline">memcpy</span> 将 <span class="underline">输入缓存的内容</span> <b>复制</b> 到 <span class="underline">输出缓存</span> 
<ul class="org-ul">
<li>在从 <span class="underline">输入缓存</span> <b>取</b> 数据字节时， <span class="underline">内核</span> <b>自动读</b> <span class="underline">输入文件</span></li>
<li>在将 <span class="underline">数据</span> <b>存入</b> <span class="underline">输出缓存</span> 时， <span class="underline">内核</span> <b>自动将数据写</b> 到 <span class="underline">输出文件</span> 中</li>
</ul></li>
</ol>

<pre class="example">
     也可使用'ftruncate'函数来设置输出文件的长度，但是并非所有系统都支持该函数扩充文件长度
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>         <span style="color: #4eee94;">fdin</span>, <span style="color: #4eee94;">fdout</span>;
    <span style="color: #98f5ff;">void</span>        *<span style="color: #4eee94;">src</span>, *<span style="color: #4eee94;">dst</span>;
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">stat</span> <span style="color: #4eee94;">statbuf</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 3)
        err_quit(<span style="color: #deb887;">"usage: %s &lt;fromfile&gt; &lt;tofile&gt;"</span>, argv[0]);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fdin = open(argv[1], O_RDONLY)) &lt; 0)
        err_sys(<span style="color: #deb887;">"can't open %s for reading"</span>, argv[1]);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fdout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC,
              FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"can't creat %s for writing"</span>, argv[2]);

    <span style="color: #00bfff; font-weight: bold;">if</span> (fstat(fdin, &amp;statbuf) &lt; 0)  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">need size of input file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        err_sys(<span style="color: #deb887;">"fstat error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">set size of output file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (lseek(fdout, statbuf.st_size - 1, SEEK_SET) == -1)
        err_sys(<span style="color: #deb887;">"lseek error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(fdout, <span style="color: #deb887;">""</span>, 1) != 1)
        err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((src = mmap(0, statbuf.st_size, PROT_READ, MAP_SHARED,
            fdin, 0)) == MAP_FAILED)
        err_sys(<span style="color: #deb887;">"mmap error for input"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((dst = mmap(0, statbuf.st_size, PROT_READ | PROT_WRITE,
            MAP_SHARED, fdout, 0)) == MAP_FAILED)
        err_sys(<span style="color: #deb887;">"mmap error for output"</span>);

    memcpy(dst, src, statbuf.st_size);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">does the file copy </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    exit(0);
}
</pre>
</div>

<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;cp&#21644;mmap&#25335;&#36125;&#19968;&#20010;1.2G&#38271;&#24230;&#30340;&#25991;&#20214;</span>
$ time cp ~/Movie/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land.mkv ./ 

real    0m23.824s
user    0m0.010s
sys     0m2.170s

$ time ./mcopy ~/Movie/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land.mkv ./a.mkv

real    0m16.796s
user    0m0.186s
sys     0m1.079s
</pre>
</div>

<pre class="example">
     测试结果显示：将一个普通文件复制到另一个普通文件中时，存储映射I/O比较快

     但是有一些限制，如不能用在某些设备之间(例如网络设备或终端设备)进行复制
     并且对被复制的文件进行映射后，也要注意该文件的长度是否改变

     尽管如此有很多应用程序会从存储映射I/O得到好处
     因为它处理的是内存而不是读、写一个文件，所以常常可以“简化算法”
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee22243" class="outline-2">
<h2 id="orgee22243">记录锁</h2>
<div class="outline-text-2" id="text-orgee22243">
<pre class="example">
    当两个人同时编辑一个文件时，其后果将如何呢？

    在很多UNIX系统中，该文件的最后状态取决于写该文件的最后一个进程

    但是对于有些应用程序，例如数据库，有时进程需要确保它正在单独写一个文件

    为了向进程提供这种功能，较新的UNIX系统提供了记录锁机制
</pre>
<p>
<span class="underline">记录锁</span> 的功能是： <span class="underline">一个进程</span> 正在 <b>读</b> 或 <b>修改</b> 文件的 <span class="underline">某个部分</span> 时，可以 <b>阻止</b> <span class="underline">其他进程</span> <b>修改</b> 同一文件区
</p>

<pre class="example">
    对于UNIX“记录”这个定语也是误用，因为UNIX内核根本没有使用文件记录这种概念

    一个更适合的术语可能是“区域锁”，因为它锁定的只是文件的一个区域(也可能是整个文件)
</pre>
</div>

<div id="outline-container-org7ec038e" class="outline-3">
<h3 id="org7ec038e">历史</h3>
<div class="outline-text-3" id="text-org7ec038e">
<p>
下面表列出了各种UNIX系统提供的不同形式的记录锁：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 各种UNIX系统支持的记录锁形式</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">系统</td>
<td class="org-left">建议性</td>
<td class="org-left">强制性</td>
<td class="org-left">fcntl</td>
<td class="org-left">lockf</td>
<td class="org-left">flock</td>
</tr>

<tr>
<td class="org-left">POSIX.1</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">XPG3</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SVR2</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SVR3,SVR4</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4.3BSD</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">4.3BSD Reno</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>
</tbody>
</table>


<pre class="example">
POSIX.1选择了以 fcntl 函数为基础的 系统V风格 的 记录锁，  这种风格也得到4.3BSDReno版本的支持： 

fcntl函数可以锁 文件中的任一区域 ，大至整个文件，小至单个字节
早期的伯克利版只支持 flock 函数，此函数只 锁整个文件，而不锁文件中的一个区域
系统V的 lockf 函数只是 fcntl 函数的一个接口
</pre>
</div>
</div>
<div id="outline-container-orgd0d695f" class="outline-3">
<h3 id="orgd0d695f">fcntl记录锁</h3>
<div class="outline-text-3" id="text-orgd0d695f">
<pre class="example">
     前面已经给出了fcntl函数的原型
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#25913;&#21464;&#24050;&#32463;&#25171;&#24320;&#25991;&#20214;&#30340;&#24615;&#36136;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * filedes : &#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;"> * cmd : &#21151;&#33021;</span>
<span style="color: #ffebcd;"> * args : &#21487;&#36873;&#21442;&#25968;</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> * return : &#25104;&#21151;&#20381;&#36182;&#20110; cmd&#65292;&#22833;&#36133; -1</span>
<span style="color: #ffebcd;"> *</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fcntl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, ...<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">int arg</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
</pre>
</div>
<p>
对于记录锁：
</p>
<ul class="org-ul">
<li><span class="underline">cmd</span> ：
<ol class="org-ol">
<li><b>F_GETLK</b></li>
<li><b>F_SETLK</b></li>
<li><b>F_SETLKW</b></li>
</ol></li>
<li>第三个参数 <span class="underline">flockptr</span> ：一个指向 <b>flock结构</b> 的指针</li>
</ul>
</div>

<div id="outline-container-org6fc9db4" class="outline-4">
<h4 id="org6fc9db4">flock结构</h4>
<div class="outline-text-4" id="text-org6fc9db4">
<p>
记录锁结构：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">flock</span> {
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">l_type</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#25324; F_RDLOCK, F_WRLOCK, F_UNLOCK </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">l_start</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#38145;&#30340;&#36215;&#28857; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">l_whence</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#25324; SEEK_SET, SEEK_CUR, SEEK_END </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">l_len</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#20026; 0 &#26102;,&#34920;&#31034;&#20174;&#36215;&#28857;&#21040; EOF </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">l_pid</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25317;&#26377;&#27492;&#38145;&#30340;&#36827;&#31243; PID </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
</div>

<div id="outline-container-org47c7236" class="outline-5">
<h5 id="org47c7236">锁类型</h5>
<div class="outline-text-5" id="text-org47c7236">
<p>
锁类型：
</p>
<ol class="org-ol">
<li><span class="underline">F_RDLCK</span> ： <b>共享读</b> 锁</li>
<li><span class="underline">F_WRLCK</span> ： <b>独占性写</b> 锁</li>
<li><span class="underline">F_UNLCK</span> ： <b>解锁</b> 一个区域</li>
</ol>

<!-- This HTML table template is generated by emacs 26.3 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;区域当前&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;读锁&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;写锁&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;无锁&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;允许&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;允许&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      一至多把读
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;允许&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;拒绝&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;一把写锁&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;拒绝&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;拒绝&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<ul class="org-ul">
<li><span class="underline">多个进程</span> 在一个给定的字节上可以有一把 <b>共享的读锁</b> 
<ul class="org-ul">
<li>如果在一个给定字节上 <span class="underline">已经有一把或多把读锁</span> ，则 <b>不能在该字节上再加写锁</b></li>
</ul></li>
<li>在一个给定字节上的 <span class="underline">写锁</span> 则 <b>只能由一个进程独用</b>
<ul class="org-ul">
<li>如果在一个字节上已经 <span class="underline">有一把独占性的写锁</span> ，则 <b>不能再对它加任何锁</b></li>
</ul></li>
</ul>


<pre class="example">
       加读锁时，该文件描述符必须是读打开

       加写锁时，该文件描述符必须是写打开
</pre>
</div>
</div>

<div id="outline-container-org5bdb988" class="outline-5">
<h5 id="org5bdb988">锁区域</h5>
<div class="outline-text-5" id="text-org5bdb988">
<ul class="org-ul">
<li>要 <span class="underline">加锁</span> 或 <span class="underline">解锁</span> 的 <b>区域的起始地址</b> 由 <span class="underline">l_start</span> 和 <span class="underline">l_whence</span> 两者决定：
<ol class="org-ol">
<li><span class="underline">l_start</span> ： <b>相对位移量</b> (字节)</li>
<li><span class="underline">l_whence</span>  : <b>相对位移量的起点</b></li>
</ol></li>
<li><span class="underline">l_len</span>  : <b>区域的长度</b></li>
</ul>

<pre class="example">
该区域可以在“当前文件尾端处开始”或”越过其尾端处开始“，但是不能在“文件起始位置之前开始“或”越过该起始位置“

如果 l_len 为0： 锁的区域从其“起点”开始直至 ”最大可能位置“为止。不管添写到该文件中多少数据，都处于锁的范围

为了锁 整个文件 ：
1.  l_start 设置为 0
2. l_whence 设置为 SEEK_SET
3. l_len 设置为 0
</pre>
</div>
</div>
</div>

<div id="outline-container-org79a6ad9" class="outline-4">
<h4 id="org79a6ad9">cmd命令</h4>
<div class="outline-text-4" id="text-org79a6ad9">
<p>
以下说明fcntl函数的三种命令：
</p>
<ol class="org-ol">
<li><span class="underline">F_GETLK</span> ： <b>测试</b> 由flockptr所描述的锁是否被 <span class="underline">另外一把锁</span> 所 <b>排斥</b> (阻塞)
<ul class="org-ul">
<li>如果存在一把锁，它 <span class="underline">阻止</span> 创建由flockptr所描述的锁，则这把 <span class="underline">现存的锁的信息</span> <b>写到</b> <span class="underline">flockptr指向的结构</span> 中</li>
<li>如果不存在这种情况，则除了将 <span class="underline">l_type</span> 设置为 <b>F_UNLCK</b> 之外， <span class="underline">flockptr</span> 所指向结构中的 <b>其他信息保持不变</b></li>
</ul></li>
<li><span class="underline">F_SETLK</span> ： <b>设置</b> 由flockptr所描述的锁
<ul class="org-ul">
<li>如果试图建立一把按上述兼容性规则并 <span class="underline">不允许的锁</span> ，则 <span class="underline">fcntl</span> 立即 <b>出错返回</b> ，此时 <span class="underline">errno</span> 设置为 <span class="underline">EACCES</span> 或 <span class="underline">EAGAIN</span></li>
<li><span class="underline">l_type</span> 为 <span class="underline">F_UNLCK</span> ： <b>清除</b> 由flockptr说明的锁l_type为F_UNLCK)</li>
</ul></li>
<li><span class="underline">F_SETLKW</span> ：F_SETLK的 <b>阻塞</b> 版本
<ul class="org-ul">
<li>如果由于存在其他锁，那么按兼容性规则由flockptr所要求的锁不能被创建，则 <b>调用</b> 进程 <span class="underline">睡眠</span> ，如果捕捉到信号则睡眠中断</li>
</ul></li>
</ol>

<pre class="example">
使用过程中要注意：

用F_GETLK测试能否建立一把锁，然后用F_SETLK和F_SETLKW企图建立一把锁，这两者不是一个原子操作
在这两个操作之间可能会有另一个进程插入并建立一把相关的锁，使原来测试到的情况发生变化

如果不希望在建立锁时可能产生的长期阻塞，则应使用F_SETLK，并对返回结果进行测试，以判别是否成功地建立了所要求的锁

在设置或释放文件上的一把锁时，系统按需组合或裂开相邻区：

1. 若对字节0~99设置一把读锁，然后对字节0~49设置一把写锁
则有两个加锁区:0~49字节(写锁)及50~99(读锁)

2. 若100~199字节是加锁的区，需解锁第150字节
则内核将维持两把锁，一把用于100~149字节，另一把用于151~199字节
</pre>
</div>

<div id="outline-container-org873a41a" class="outline-5">
<h5 id="org873a41a">要求和释放一把锁</h5>
<div class="outline-text-5" id="text-org873a41a">
<p>
为了避免每次 <b>分配</b> flock结构，然后又填入各项信息，可以用函数 <span class="underline">lock_reg</span> 来处理这些细节：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">lock_reg</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">type</span>,
         <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">offset</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">whence</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">len</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">flock</span>    <span style="color: #4eee94;">lock</span>;

    lock.l_type = type;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">F_RDLCK, F_WRLCK, F_UNLCK </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_start = offset;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">byte offset, relative to l_whence </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_whence = whence; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">SEEK_SET, SEEK_CUR, SEEK_END </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_len = len;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">#bytes (0 means to EOF) </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">return</span>(fcntl(fd, cmd, &amp;lock));
}
</pre>
</div>
<p>
使用下面五个宏来简化调用：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">read_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                          \
    lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">readw_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                             \
    lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">write_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                         \
    lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">writew_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                            \
    lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">un_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                            \
    lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))
</pre>
</div>
<p>
用与lseek函数同样的顺序定义这些宏中的三个参数
</p>
</div>
</div>

<div id="outline-container-org9a57c8f" class="outline-5">
<h5 id="org9a57c8f">测试一把锁</h5>
<div class="outline-text-5" id="text-org9a57c8f">
<p>
<span class="underline">lock_test</span> 函数： <b>测试</b> 一把锁：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">lock_test</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">offset</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">whence</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">len</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">flock</span>    <span style="color: #4eee94;">lock</span>;

    lock.l_type = type;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">F_RDLCK or F_WRLCK </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_start = offset;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">byte offset, relative to l_whence </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_whence = whence; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">SEEK_SET, SEEK_CUR, SEEK_END </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_len = len;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">#bytes (0 means to EOF) </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> (fcntl(fd, F_GETLK, &amp;lock) &lt; 0)
        err_sys(<span style="color: #deb887;">"fcntl error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (lock.l_type == F_UNLCK)
        <span style="color: #00bfff; font-weight: bold;">return</span>(0);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">false, region isn't locked by another proc </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>(lock.l_pid); <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">true, return pid of lock owner </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
如果 <span class="underline">存在一把锁</span> <b>阻止</b> 由 <span class="underline">参数说明的锁</span> ，则此函数返回 <span class="underline">持有这把现存锁</span> 的 <span class="underline">进程的ID</span> ，否则此函数返回 <span class="underline">0</span> 。通常用下面两个宏来调用此函数：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">is_read_lockable</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                   \
    (lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">is_write_lockable</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                  \
    (lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbb6c698" class="outline-4">
<h4 id="orgbb6c698">死锁</h4>
<div class="outline-text-4" id="text-orgbb6c698">
<p>
如果 <span class="underline">两个进程</span> <b>相互等待</b> <span class="underline">对方持有</span> 并且 <span class="underline">不释放</span> (锁定)的资源时，则这两个进程就处于 <span class="underline">死锁</span> 状态
</p>

<pre class="example">
      如果一个进程已经控制了文件中的一个加锁区域，然后它又试图对另一个进程控制的区域加锁，则它就会睡眠

      在这种情况下，有发生死锁的可能性
</pre>
</div>
<div id="outline-container-org3961f2d" class="outline-5">
<h5 id="org3961f2d">死锁实例</h5>
<div class="outline-text-5" id="text-org3961f2d">
<pre class="example">
	子进程锁字节0，父进程锁字节1。然后它们中的每一个又试图锁对方已经加锁的字节
</pre>

<p>
在该程序中使用了 <span class="underline">父子进程同步</span> 方法(TELL_xxx和WAIT_xxx)，使得对方都能建立第一把锁：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">lockabyte</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (writew_lock(fd, offset, SEEK_SET, 1) &lt; 0)
        err_sys(<span style="color: #deb887;">"%s: writew_lock error"</span>, name);
    printf(<span style="color: #deb887;">"%s: got the lock, byte %ld\n"</span>, name, offset);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>;
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Create a file and write two bytes to it.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> ((fd = creat(<span style="color: #deb887;">"templock"</span>, FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"creat error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd, <span style="color: #deb887;">"ab"</span>, 2) != 2)
        err_sys(<span style="color: #deb887;">"write error"</span>);

    TELL_WAIT();
    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) {          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        lockabyte(<span style="color: #deb887;">"child"</span>, fd, 0);
        TELL_PARENT(getppid()); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#29238;&#36827;&#31243;</span>
        WAIT_PARENT();
        lockabyte(<span style="color: #deb887;">"child"</span>, fd, 1);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        lockabyte(<span style="color: #deb887;">"parent"</span>, fd, 1);
        TELL_CHILD(pid); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#23376;&#36827;&#31243;</span>
        WAIT_CHILD();
        lockabyte(<span style="color: #deb887;">"parent"</span>, fd, 0);
    }
    exit(0);
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./deadlock 
parent: got the lock, byte 1
child: got the lock, byte 0
parent: writew_lock error: Resource deadlock avoided 
child: got the lock, byte 1

</pre>
</div>
<p>
<span class="underline">检测到死锁</span> 时， <span class="underline">内核</span> 必须 <b>选择一个进程</b> 收到 <span class="underline">出错返回</span> 
</p>

<pre class="example">
       在本例中，选择了父进程，这是一个实现细节

       当此程序在另一个系统上运行时有可能是子进程接到出错信息
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc53d72f" class="outline-3">
<h3 id="orgc53d72f">锁的隐含继承和释放</h3>
<div class="outline-text-3" id="text-orgc53d72f">
<p>
关于记录锁的 <span class="underline">自动继承</span> 和 <span class="underline">释放</span> 有三条规则:
</p>
<ul class="org-ul">
<li><span class="underline">锁</span> 与 <span class="underline">进程</span> 、 <span class="underline">文件</span> 两方面有关：
<ol class="org-ol">
<li>当一个 <span class="underline">进程终止</span> 时，它所建立的 <b>锁全部释放</b></li>
<li>任何时候 <span class="underline">关闭一个描述符</span> 时，则 <span class="underline">该进程</span> 通过这个 <span class="underline">描述符可以存访的文件</span> 上的 <span class="underline">任何一把锁</span> 都被 <b>释放</b> (这些锁都是该进程设置的)</li>
</ol></li>
</ul>

<p>
如果执行下列四步:
</p>
<div class="org-src-container">
<pre class="src src-C">fd1 = open(pathname <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #daa520; font-weight: bold;">read_lock</span>(fd1 <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
fd2 = dup(fd1) ;
<span style="color: #daa520; font-weight: bold;">close</span>(fd2) ;
</pre>
</div>
<p>
则在close(fd2)后，在fd1上设置的锁被释放。如果将dup代换为open，其效果也一样:
</p>
<div class="org-src-container">
<pre class="src src-C">fd1 = open(pathname <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #daa520; font-weight: bold;">read_lock</span>(fd1 <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
fd2 = open(fd1) ;
<span style="color: #daa520; font-weight: bold;">close</span>(fd2) ;
</pre>
</div>

<ul class="org-ul">
<li>由 <span class="underline">fork</span> 产生的 <span class="underline">子程序</span> <b>不继承</b> <span class="underline">父进程</span> 所设置的锁</li>
</ul>
<pre class="example">
     若一个进程得到一把锁，然后调用fork，那么对于父进程获得的锁而言，子进程被视为另一个进程

     对于从父进程处继承过来的任一描述符，子进程要调用fcntl以获得它自己的锁

     如果子进程继承父进程的锁，则父、子进程就可以同时写同一个文件，而锁的作用就是为了阻止多个进程同时写同一个文件(或同一文件区域)
</pre>

<ul class="org-ul">
<li>在执行 <span class="underline">exec</span> 后， <span class="underline">新程序</span> 可以 <b>继承</b> <span class="underline">原执行程序的锁</span></li>
</ul>
</div>
</div>

<div id="outline-container-org8badd92" class="outline-3">
<h3 id="org8badd92">BSD的实现</h3>
<div class="outline-text-3" id="text-org8badd92">
<p>
考虑一个进程，它执行下列语句(忽略出错返回)：
</p>
<div class="org-src-container">
<pre class="src src-C">fd1 = open(pathname<span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">,...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #daa520; font-weight: bold;">write_lock</span>(fd1, 0, SEEK_SET, 1); <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">parent write locks byte 0</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">if</span>(fork() &gt; 0) { <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">parent</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    fd2 = dup(fd1);
    fd3 = open(pathname<span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">,...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
    pause();
} <span style="color: #00bfff; font-weight: bold;">else</span> {
    read_lock(fd1, 1, SEEK_SET, 1); <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">child read locks byte 1</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    pause();
}
</pre>
</div>
<p>
图12-1显示了父、子进程暂停(执行pause())后的数据结构情况：
</p>

<div class="figure">
<p><img src="pic/flock.png" alt="flock.png" width="90%" /> 
</p>
</div>

<p>
有了记录锁后，在原来的这些图上 <b>新加</b> 了 <span class="underline">flock结构</span> ，它们由 <span class="underline">i节点结构</span> 开始 <b>相互连接</b> 起来
</p>
<pre class="example">
     注意：每个flock结构说明了一个给定进程的一个加锁区域
</pre>

<p>
图中显示了两个 <span class="underline">flock</span> 结构，每一个结构都 <b>包含</b> 了相应 <span class="underline">进程ID</span> ：
</p>
<ul class="org-ul">
<li>由 <span class="underline">父进程</span> 调用 <b>write_lock</b> 形成的</li>
<li>由 <span class="underline">子进程</span> 调用 <b>read_lock</b> 形成的</li>
</ul>

<pre class="example">
       在父进程中关闭fd1、fd2和fd3中的”任意一个“都将释放由”父进程设置的写锁“

       在关闭这三个描述符中的”任意一个“时，内核会从该描述符所关连的i节点开始逐个检查flock连接表中各项，并释放由调用进程持有的各把锁

       内核并不清楚也不关心“父进程是用哪一个描述符”来设置“这把锁“
</pre>
</div>

<div id="outline-container-orgd71438a" class="outline-4">
<h4 id="orgd71438a">守护进程号加锁</h4>
<div class="outline-text-4" id="text-orgd71438a">
<p>
<span class="underline">守护进程</span> 使用 <span class="underline">建议性锁</span> 以 <b>保证该守护进程只有一个副本在运行</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">起动</span> 时很多守护进程都把它们的 <span class="underline">进程ID</span> 写到一个 <b>各自专用的PID文件</b> 上</li>
<li>系统 <span class="underline">停机</span> 时从这些 <span class="underline">文件中</span>  <b>取用</b> 这些 <span class="underline">守护进程的进程ID</span></li>
<li><p>
防止一个守护进程有多份副本同时运行的方法是：在守护进程 <span class="underline">开始运行</span> 时，在它的 <span class="underline">进程ID文件</span> 上 <b>设置一把写锁</b> 
</p>
<ul class="org-ul">
<li><p>
如果在它 <span class="underline">运行</span> 时 <b>一直保持这把锁</b> ，则不可能再起动它的其他副本：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;syslog.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;string.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/stat.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">LOCKFILE</span> <span style="color: #deb887;">"/var/run/deamon.pid"</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">LOCKMODE</span> (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">already_running</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>; 
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[16];

    fd = open(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);

    <span style="color: #00bfff; font-weight: bold;">if</span>(fd &lt; 0) {
        err_sys(<span style="color: #deb887;">"open error"</span>);
        exit(1);
    }   

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">try and set write lock </span>
    <span style="color: #00bfff; font-weight: bold;">if</span>( write_lock(fd, 0, SEEK_SET, 0) &lt; 0) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(errno == EACCES || errno == EAGAIN) {
            close(fd); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">daemon is already running</span>
            <span style="color: #00bfff; font-weight: bold;">return</span> (1);
        }                        

        err_sys(<span style="color: #deb887;">"write lock error"</span>);
        exit(1);
    }   

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">we have the lock now, truncate the file length to zero</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>( ftruncate(fd, 0) &lt; 0)
        err_sys(<span style="color: #deb887;">"ftruncate error"</span>);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">write our process id</span>
    sprintf(buf, <span style="color: #deb887;">"%ld"</span>, (<span style="color: #98f5ff;">long</span>)getpid());
    <span style="color: #00bfff; font-weight: bold;">if</span>( write(fd, buf, strlen(buf)) != strlen(buf))
        err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #00bfff; font-weight: bold;">return</span> (0);
}

</pre>
</div></li>
</ul>
<p>
因为 <span class="underline">进程ID文件</span> 可能 <b>包含</b> <span class="underline">以前的守护进程ID</span> ，而且其 <b>长度可能长于当前进程的ID</b> ，  所以在写该文件时，先将其截短为0
</p></li>
</ul>
<pre class="example">
      例如：该文件中以前的内容可能是12345\n，而现在的进程ID是654

      希望该文件现在只包含654\n，而不是654\n5\n

      注意： 要在设置了锁之后再调用截短文件长度的函数ftruncate

      在调用open时不能指定O_TRUNC：否则当同一个服务的第二个守护进程启动时，虽然最终无法获得写锁，但是ID文件却已经被截断！
</pre>
</div>
</div>

<div id="outline-container-org95d7192" class="outline-4">
<h4 id="org95d7192">文件末尾加锁</h4>
<div class="outline-text-4" id="text-org95d7192">
<p>
在 <b>相对文件尾端</b>  <span class="underline">加锁</span> 或 <span class="underline">解锁</span> 时 <b>需要特别小心</b> 
</p>

<pre class="example">
      大多数实现按照 l_whence 的 SEEK_CUR 或 SEEK_END值

      用文件当前位置或当前长度以及 l_start 得到“绝对的文件位移量”

      但是，通常需要“相对于文件的当前位置”或“当前长度”指定一把锁
</pre>

<p>
下面程序写一个大文件，一次一个字节。在每次循环中，从文件当前尾端开始处加锁直到将来可能扩充到的尾端为止(最后一个参数，长度指定为0)，并写1个字节。然后解除这把锁，写另一个字节。如果系统用 <span class="underline">从当前尾端开始，直到将来可能扩充的尾端</span> 这种记法来跟踪锁，那么这段程序能够正常工作。但是如果系统将相对位移量变换成 <b>绝对位移量就会有问题</b> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">fd</span>;


    <span style="color: #00bfff; font-weight: bold;">if</span>( (fd = open(<span style="color: #deb887;">"temp.lock"</span>, O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"open error"</span>);

    <span style="color: #00bfff; font-weight: bold;">for</span>(i = 0; i &lt; 1000000; i++) {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">lock from current EOF to EOF</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(writew_lock(fd, 0, SEEK_END, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"write lock error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(write(fd, &amp;fd, 1) != 1)
            err_sys(<span style="color: #deb887;">"write error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(un_lock(fd, 0, SEEK_END, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"unlock error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(write(fd, &amp;fd, 1) != 1)
            err_sys(<span style="color: #deb887;">"write error"</span>);
    }

    exit(0);
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./lockeof

writew_lock error: No record locks available
</pre>
</div>

<ol class="org-ol">
<li>第一次调用 <span class="underline">writew_lock</span> 指定 <span class="underline">直至将来可能扩充到尾端</span> ： 图中 <span class="underline">锁定区域</span> <b>超过了</b> <span class="underline">所写的第一个字节</span></li>
<li>调用 <span class="underline">un_lock</span> : 从 <span class="underline">当前尾端处</span> 开始直至 <span class="underline">将来可能扩充到的尾端为止</span> 解锁， <span class="underline">箭头的右端</span> <b>缩回</b> 到 <span class="underline">第一字节位置端部</span></li>
<li><p>
将第二个字节写到文件中：
</p>
<p width="90%">
<img src="pic/flock-eof.jpg" alt="flock-eof.jpg" width="90%" />]]
</p></li>
</ol>

<pre class="example">
      这样每次循环，都会分配一个新的flock结构，这种情况不断重复，直至内核为该进程用完了锁结构，此时fcntl出错返回，errno设置为ENOLCK

      这个程序中每次写的字节数是已知的，所以可将 un_lock 的第二个参数(l_start)改换成所写字节数的负值(-1)：这就使得un_lock去除上次加的锁
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdda2f7e" class="outline-3">
<h3 id="orgdda2f7e">建议性锁和强制性锁</h3>
<div class="outline-text-3" id="text-orgdda2f7e">
<pre class="example">
     考虑数据库存取例程序：

     如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数存取数据库的任何进程集为“合作进程”

     如果这些函数是唯一的用来存取数据库的函数，那么它们使用“建议性锁”是可行的

     但是建议性锁并不能阻止对数据库文件有写许可权的任何其他进程写数据库文件

     不使用协同一致的方法来存取数据库的进程是一个非合作进程
</pre>

<p>
<span class="underline">强制性锁</span> 机制中， <span class="underline">内核</span> 对每一个 <span class="underline">open</span> 、 <span class="underline">read</span> 和 <span class="underline">write</span> 都要 <b>检查</b> 调用进程对 <span class="underline">正在存取的文件</span> <b>是否违背</b> 了某一把锁的作用
</p>

<pre class="example">
SVR4实现中：

对一个特定文件打开其“设置-组-ID位，关闭其组-执行位”则对该文件“启动了强制性锁”机制

因为当组-执行位关闭时，设置-组-ID位不再有意义，所以设计者借用两者的这种组合来指定对一个文件的锁是强制性的而非建议性的
</pre>

<p>
如果一个进程试图 <span class="underline">读</span> 、 <span class="underline">写</span> 一个 <b>强制性锁</b> 起作用的文件，而欲读、写的部分又由其他进程加上了读、写锁，此时会发生什么呢？这一问题的回答取决于三方面的因素:
</p>
<ul class="org-ul">
<li><span class="underline">操作类型</span> ：read或write</li>
<li>其他进程保有的 <span class="underline">锁的类型</span> ：读锁或写锁</li>
<li><p>
有关 <span class="underline">描述符</span> 是 <span class="underline">阻塞</span> 还是 <span class="underline">非阻塞</span> 的
</p>
<!-- This HTML table template is generated by emacs 26.3 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      区域上的锁<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阻塞描述符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非阻塞描述符&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;读&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;写&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;读&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;写&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      强制性读锁
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可以&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;阻塞&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可以&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;EAGAIN&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      强制性写锁
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;阻塞&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;阻塞&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;EAGAIN&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;EAGAIN&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table></li>
</ul>

<p>
除了表中的read，write函数，其他进程的强制性锁也会对 <span class="underline">open</span> 函数产生影响。通常即使正在打开的文件具有强制性记录锁，该打开操作也会成功，接下来的read或write依从于中所示的规则
</p>

<pre class="example">
     但是如果欲打开的文件具有强制性锁(读锁或写锁)，而且open调用中的flag为O_TRUNC或O_CREAT
     则不论是否指定O_NONBLOCK，open都立即出错返回，errno设置为EAGAIN

     对O_TRUNC情况出错返回是有意义的，因为其他进程对该文件持有读、写锁，所以不能将其截短为0

     对O_CREAT情况在返回时也设置errno则无意义，因为该标志的意义是如果该文件不存在则创建
     由于其他进程对该文件持有记录锁，因而该文件肯定是存在的

</pre>

<p>
这种处理方式可能导致令人惊异的结果
</p>

<pre class="example">
例如 某个程序 打开一个文件，其模式指定为 强制性锁 ，然后对 该文件的整体 设置 一把读锁

然后进入 睡眠 一段时间。在这段睡眠时间内，用某些常规的UNIX程序和操作符对该文件进行处理，发现下列情况:

可用 ed 编辑程序对该文件进行 编辑 操作，而且编辑 结果可以写回磁盘 。对ed操作进行跟踪分析发现：
1. ed将新内容写到一个临时文件中
2. 删除原文件
3. 将临时文件名改名为原文件名
因此强制性锁机制对unlink函数没有影响

不能用 _vi_ 编辑程序编辑该文件。vi可以读该文件，但是如果试图将新的数据写到该文件中，则出错返回(EAGAIN)
如果试图将新数据添加到该文件中，则write阻塞。vi的这种行为与所希望的一样

使用KornShell的 '&gt;' 和 '&gt;&gt;' 运算符重写或添写到该文件中，产生出错信息 'cannotcreat' 
在Bourneshell下使用 '&gt;' 运算符出错，但是使用 '&gt;&gt;' 算符则“阻塞”，在删除了强制性锁后再继续进行处理

执行添加操作所产生的区别是因为:
KornShell以O_CREAT和O_APPEND标志打开文件，而上面已提及指定O_CREAT会产生出错返回
Bourneshell在该文件已存在时并不指定O_CREAT，所以open成功，而下一个write则阻塞
</pre>

<p>
使用强制性锁的时候必须小心谨慎
</p>
<pre class="example">
     一个别有用心的用户可以对大家都可读的文件加一把读锁(强制性)，这样就能阻止任何其他人写该文件

     当然该文件应当是强制性锁机制起作用的，这可能要求该用户能够更改该文件的许可权位
</pre>
</div>

<div id="outline-container-orgfc81a0b" class="outline-4">
<h4 id="orgfc81a0b">校验系统是否支持强制性锁</h4>
<div class="outline-text-4" id="text-orgfc81a0b">
<p>
下面程序 <b>检查</b> 当前系统是否 <span class="underline">支持强制性锁</span> ：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>             <span style="color: #4eee94;">fd</span>;
    <span style="color: #98f5ff;">pid_t</span>           <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">char</span>            <span style="color: #4eee94;">buf</span>[5];
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">stat</span>     <span style="color: #4eee94;">statbuf</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 2) {
        fprintf(stderr, <span style="color: #deb887;">"usage: %s filename\n"</span>, argv[0]);
        exit(1);
    }
    <span style="color: #00bfff; font-weight: bold;">if</span> ((fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"open error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd, <span style="color: #deb887;">"abcdef"</span>, 6) != 6)
        err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">turn on set-group-ID and turn off group-execute </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (fstat(fd, &amp;statbuf) &lt; 0)
        err_sys(<span style="color: #deb887;">"fstat error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (fchmod(fd, (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt; 0)
        err_sys(<span style="color: #deb887;">"fchmod error"</span>);

    TELL_WAIT();

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">write lock entire file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (write_lock(fd, 0, SEEK_SET, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"write_lock error"</span>);

        TELL_CHILD(pid);

        <span style="color: #00bfff; font-weight: bold;">if</span> (waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"waitpid error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        WAIT_PARENT();      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">wait for parent to set lock </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

        set_fl(fd, O_NONBLOCK);

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">first let's see what error we get if region is locked </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (read_lock(fd, 0, SEEK_SET, 0) != -1)    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">no wait </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
            err_sys(<span style="color: #deb887;">"child: read_lock succeeded"</span>);
        printf(<span style="color: #deb887;">"read_lock of already-locked region returns %d\n"</span>,
               errno);

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">now try to read the mandatory locked file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (lseek(fd, 0, SEEK_SET) == -1)
            err_sys(<span style="color: #deb887;">"lseek error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> (read(fd, buf, 2) &lt; 0)
            err_ret(<span style="color: #deb887;">"read failed (mandatory locking works)"</span>);
        <span style="color: #00bfff; font-weight: bold;">else</span>
            printf(<span style="color: #deb887;">"read OK (no mandatory locking), buf = %2.2s\n"</span>,
                   buf);
    }
    exit(0);
}
</pre>
</div>

<ol class="org-ol">
<li>创建一个文件，并使强制性锁机制对其起作用</li>
<li>fork一个子进程</li>
<li>父进程对整个文件设置一把写锁</li>
<li>子进程则将该文件的描述符设置为非阻塞的
<ul class="org-ul">
<li>对该文件设置一把读锁，期望这会出错返回，并希望看到系统返回值是EACCES或EAGAIN</li>
<li>子进程将文件读、写位置调整到文件起点，并试图读该文件
<ul class="org-ul">
<li>如果系统提供强制性锁机制，则read应返回EACCES或EAGAIN(因为该描述符是非阻塞的)</li>
<li><p>
否则read返回所读的数据
</p>

<p>
测试结果显示linux并不支持强制锁
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/aio/mandatory temp.lock

read_lock of already-locked region returns 11 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">EAGAIN</span>
<span style="color: #f08080;">read</span> OK (no mandatory locking), buf = ab
</pre>
</div></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org0ac10f4" class="outline-4">
<h4 id="org0ac10f4">两人编辑同一文件</h4>
<div class="outline-text-4" id="text-org0ac10f4">
<pre class="example">
      当两个人同时编辑同一个文件将会怎样呢？

      一般的UNIX文本编辑器并不使用记录锁，所以对此问题的回答仍然是：

      该文件的最后结果取决于写该文件的最后一个进程

      即使在一个编辑器，例如vi中使用了建议性锁，可是这把锁并不能阻止其他用户使用另一个没有使用建议性记录锁的编辑器
</pre>
<p>
若系统提供强制性记录锁，那么可以修改常用的编辑器。如没有该编辑器的源代码，那么可以试一试下述方法：
</p>
<ol class="org-ol">
<li>编写一个vi的前端程序</li>
<li>该程序立即调用 <span class="underline">fork</span> 
<ul class="org-ul">
<li><span class="underline">父进程</span> <b>等待</b> <span class="underline">子进程</span> <b>终止</b></li>
<li><span class="underline">子进程</span> 
<ul class="org-ul">
<li><b>打开</b> 在命令行中指定的 <span class="underline">文件</span> ，使 <b>强制性锁</b> 起作用</li>
<li>对 <span class="underline">整个文件</span> <b>设置</b> 一把 <span class="underline">写锁</span></li>
<li>运行vi：该文件是加了写锁的，所以其他用户不能修改它</li>
</ul></li>
</ul></li>
<li>当 <span class="underline">vi结束</span> 时， <span class="underline">父进程</span> 从 <span class="underline">wait</span> 返回，此时 <span class="underline">自编的前端程序</span> 也就 <b>结束</b></li>
</ol>

<pre class="example">
      本例中假定锁能跨越exec，这正是前面所说的SVR4的情况(SVR4是提供强制性锁的唯一系统)

      这种类型的前端程序是可以编写的，但却往往不能起作用

      问题出在大多数编辑器读它们的输入文件，然后关闭它

      只要引用被编辑文件的描述符关闭了，那么加在该文件上的锁就被释放了

      这意味着在编辑器读了该文件的内容，然后关闭了它，那么锁也就不存在了

      前端程序中没有任何方法可以阻止这一点
</pre>
<p>
<a href="daemon.html">Next：守护进程</a>
</p>

<p>
<a href="signal.html">Previous：信号</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
