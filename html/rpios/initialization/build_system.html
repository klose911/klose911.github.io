<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>内核构建系统</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./linux.html"> UP </a>
 |
 <a accesskey="H" href="./initialization.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">内核构建系统</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org18cf4a0">一些基本的kbuild概念</a></li>
<li><a href="#orgb0f0286">构建内核</a>
<ul>
<li><a href="#org128b77f">链接阶段</a></li>
<li><a href="#org50d5352">编译阶段</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example" id="org585e662">
Linux也使用make实用程序来构建内核, 尽管Linux makefile要复杂得多
</pre>
<p>
在看makefile之前, 先学习一些有关Linux构建系统的重要概念 <span class="underline">Kbuild</span> 
</p>
<div id="outline-container-org18cf4a0" class="outline-2">
<h2 id="org18cf4a0">一些基本的kbuild概念</h2>
<div class="outline-text-2" id="text-org18cf4a0">
<p>
可以使用kbuild中的变量自定义构建过程。这些变量在 <a href="https://github.com/torvalds/linux/tree/v4.14/arch/arm64/Kconfig">Kconfig</a> 文件中定义
</p>
<ul class="org-ul">
<li>在这里, 可以定义变量本身及其默认值
<ul class="org-ul">
<li>变量可以具有不同的类型, 包括字符串, 布尔值和整数</li>
</ul></li>
<li><p>
在Kconfig文件中, 还可以定义变量之间的依赖关系
</p>
<pre class="example" id="org3708286">
例如, 如果选择了变量X, 则可以隐式选择变量Y

也可以看一下 arm64 Kconfig文件. 该文件定义了所有变量, 特定于arm64体系结构
</pre></li>
<li>Kconfig功能不是标准make的一部分, 而是在Linux makefile中实现的</li>
<li>在 Kconfig 中定义的变量在 <span class="underline">内核源代码</span> 以及 <span class="underline">嵌套的makefile</span> 中都 <b>可见</b></li>
<li><p>
可以在内核配置的步骤中设置变量值
</p>
<pre class="example" id="org4232906">
例如, 如果键入make menuconfig, 则会显示一个控制台GUI

它允许自定义所有内核变量的值并将这些值存储在 .config中 

help 命令以查看所有可能的选项来配置内核
</pre></li>
</ul>

<p>
Linux使用递归构建：这意味着Linux内核的每个子文件夹都可以定义它自己的Makefile和Kconfig. 大多数嵌套Makefile文件都非常简单, 只是定义文件需要编译什么对象
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">obj-$(</span><span style="color: #4eee94;">SOME_CONFIG_VARIABLE</span><span style="color: #4eee94;">)</span> += some_file.o
</pre>
</div>

<p>
这意味着 <span class="underline">some_file.c</span> 只会在 <b>设置</b> <span class="underline">SOME_CONFIG_VARIABLE</span> 的情况下编译并链接到内核. 如果要无条件编译和链接文件, 则需要更改以前的定义, 如下所示.
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">obj-y</span> += some_file.o
</pre>
</div>

<p>
在继续前进之前, 需要了解基本make规则的结构并熟悉make术语。下图说明了通用规则 <span class="underline">结构</span> ：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #daa520; font-weight: bold;">targets</span> : prerequisites
recipe
&#8230;
</pre>
</div>
<ul class="org-ul">
<li><span class="underline">targets</span> : 文件名, 用 <span class="underline">空格</span> 分隔，执行规则后将生成 <b>目标</b> 文件。通常, 每个规则只有一个目标</li>
<li><span class="underline">prerequisites</span> : make <span class="underline">跟踪</span> 的文件, 以查看是否需要 <b>更新</b> 目标文件</li>
<li><p>
<span class="underline">recipe</span> :  一个bash脚本，在某些prerequisites更新后进行调用。recipe负责 <b>生成</b> 目标文件
</p>

<pre class="example" id="orgd7768dc">
targets 和 Prerequsites 都可以包含通配符(％)

使用通配符时, 将分别对每个已匹配的prerequisites执行recipe，可以使用$&lt; 和 $@变量来引用 recipe中的 prerequisites 和 targets
</pre>

<p>
<span class="underline">make</span> 可以很好地检测是否已更改任何prerequisites, 并且仅更新需要重建的目标文件. 但是, 如果recipe是动态更新的, 则 make 将无法检测到此更改
</p></li>
</ul>
<pre class="example" id="org8d88982">
一个很好的例子是, 当更改一些配置变量时, 这会导致在recipe中添加一个附加选项

默认情况下, make将不会重新编译以前生成的目标文件, 因为它们的prerequisites没有改变, 只是recipe已更新
</pre>

<p>
为了解决此问题, Linux引入了 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/Kbuild.include#L264">if_changed</a>  函数。要查看其工作原理, 请考虑以下示例：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">cmd_compile</span> = gcc $(<span style="color: #4eee94;">flags</span>) -o <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> $<span style="color: #ffd700;">&lt;</span>

<span style="color: #daa520; font-weight: bold;">%.o</span>: %.c FORCE
$(<span style="color: #4eee94;">call</span> if_changed,compile)
</pre>
</div>

<p>
在这里对于每个.c文件, 通过使用带有compile参数的if_changed函数来构建相应的.o文件。if_changed查找 <span class="underline">cmd_compile</span> 变量(在第一个参数后添加cmd_前缀), 并检查此变量自上次执行以来是否已更新, 或者任何prerequisites已更改：
</p>
<ul class="org-ul">
<li>如果是, 则执行 cmd_compile 命令并重新生成目标文件</li>
</ul>

<p>
上面示例中的规则有两个prerequisites源 <span class="underline">.c文件</span> 和 <span class="underline">FORCE</span> 
</p>
<ul class="org-ul">
<li><p>
FORCE 是一个特殊的prerequisites, 它强制每次调用 make 命令时都调用recipe
</p>
<pre class="example" id="org0395b84">
没有FORCE, 只有在 .c 文件被更改的情况下才会调用 recipe 
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orgb0f0286" class="outline-2">
<h2 id="orgb0f0286">构建内核</h2>
<div class="outline-text-2" id="text-orgb0f0286">
<p>
现在, 当我们了解了有关Linux构建系统的一些重要概念时, 尝试弄清楚在键入make命令后到底发生了什么。这个过程非常复杂, 并且包含很多细节, 将跳过其中的大多数细节. 主要目标是回答2个问题：
</p>
<ol class="org-ol">
<li>源文件如何精确地编译为目标文件？</li>
<li>目标文件如何链接到OS映像中？</li>
</ol>

<p>
首先来解决第二个问题
</p>
</div>
<div id="outline-container-org128b77f" class="outline-3">
<h3 id="org128b77f">链接阶段</h3>
<div class="outline-text-3" id="text-org128b77f">
<p>
从make help命令的输出中看到, 负责构建内核的默认目标称为 <a href="https://github.com/torvalds/linux/blob/v4.14/Makefile#L1004">vmlinux</a> 并且看起来像这样
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">cmd_link-vmlinux</span> =                                                 \
$(<span style="color: #4eee94;">CONFIG_SHELL</span>) $<span style="color: #ffd700;">&lt;</span> $(<span style="color: #4eee94;">LD</span>) $(<span style="color: #4eee94;">LDFLAGS</span>) $(<span style="color: #4eee94;">LDFLAGS_vmlinux</span>) ;    \
$(<span style="color: #4eee94;">if</span> $(<span style="color: #4eee94;">ARCH_POSTLINK</span>), $(<span style="color: #4eee94;">MAKE</span>) -f $(<span style="color: #4eee94;">ARCH_POSTLINK</span>) <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>, true)

<span style="color: #daa520; font-weight: bold;">vmlinux</span>: scripts/link-vmlinux.sh vmlinux_prereq $(<span style="color: #4eee94;">vmlinux-deps</span>) FORCE
+$(<span style="color: #4eee94;">call</span> if_changed,link-vmlinux)
</pre>
</div>

<p>
这个目标使用了已经熟悉的 if_changed 函数。每当某些先决条件被更新时, 就执行 cmd_link-vmlinux 命令。 此命令执行 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh">scripts/link-vmlinux.sh</a> 脚本
</p>

<pre class="example" id="org47d2c64">
注意 $&lt; 为 cmd_link-vmlinux 命令中的自动变量

它还执行特定于体系结构的 postlink脚本, 但我们对此并不十分感兴趣
</pre>

<p>
执行 scripts /link-vmlinux.sh 时, 它假定所有必需的目标文件均已构建并且它们的位置存储在3个变量中：
</p>
<ul class="org-ul">
<li><span class="underline">KBUILD_VMLINUX_INIT</span></li>
<li><span class="underline">KBUILD_VMLINUX_MAIN</span></li>
<li><span class="underline">KBUILD_VMLINUX_LIBS</span></li>
</ul>

<p>
<span class="underline">link-vmlinux.sh</span> 脚本首先从所有可用的目标文件里创建 thin archive。thin archive 是一个特殊的对象, 其中包含对一组 <b>目标文件</b> 及其组合 <b>符号表</b> 的引用. 这是在 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh#L56">archive_builtin</a> 函数内部完成的。使用 <a href="https://sourceware.org/binutils/docs/binutils/ar.html">ar</a> 工具来创建thin archive。 产生的 thin archive 被储存在 <span class="underline">built-in.o</span> 文件中并具有链接器可以理解的格式, 因此它可以用作任何其他普通目标文件
</p>


<p>
接下来 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh#L69">modpost_link</a> 被调用. 该函数调用 <span class="underline">链接器</span> 并 <b>生成</b> <span class="underline">vmlinux.o</span> 目标文件
</p>
<pre class="example" id="org891080a">
需要这个vmlinux.o 目标文件来执行断面失配分析

该分析由 modpost 程序组成
</pre>

<p>
接下来生成 <span class="underline">内核符号表</span> . 它包含有关所有 <span class="underline">函数</span> 和 <span class="underline">全局变量</span> 的信息, 以及它们在vmlinux二进制文件中的位置. 主要工作在 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/link-vmlinux.sh#L146">kallsyms</a>  函数内部完成。该函数： 
</p>
<ol class="org-ol">
<li>首先使用 <a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm</a> 从 vmlinux 二进制文件中提取所有符号</li>
<li>然后使用  <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/kallsyms.c">scripts/kallsyms</a> 脚本生成一个特殊的汇编器文件, 其中包含所有特殊的符号（可以被Linux内核理解的格式）</li>
<li><p>
接着将编译此汇编器文件并将其与原始二进制文件链接在一起。来自内核符号表的信息用于在运行时生成 <span class="underline">/proc/kallsyms</span> 文件
</p>
<pre class="example" id="orgde0c354">
因为某些符号的最终链接地址可能会被修改多次, 所以此过程也需要重复了多次
</pre></li>
</ol>

<p>
Finally <span class="underline">vmlinux</span> binary is ready and <span class="underline">System.map</span> is build. System.map contains the same information as <span class="underline">/proc/kallsyms</span> but this is <b>static</b> file and unlike /proc/kallsyms it is not generated at runtime. System.map is mostly used to <b>resolve</b> <span class="underline">addresses</span> to <span class="underline">symbol names</span> during <a href="https://en.wikipedia.org/wiki/Linux_kernel_oops">kernel oops</a>. The same <b>nm</b> utility is used to build System.map
</p>

<p>
最后, <span class="underline">vmlinux</span> 二进制文件已经准备好, 并且 <span class="underline">System.map</span> 已经构建
</p>

<pre class="example" id="org4e38d77">
System.map 包含与 /proc/kallsyms 相同的信息, 但这是 静态 文件与 /proc/kallsyms 的不同, 它不是在运行时生成的
</pre>

<p>
System.map主要用于在 <a href="https://en.wikipedia.org/wiki/Linux_kernel_oops">kernel oops</a> 期间将 <span class="underline">地址</span> <b>解析</b> 为 <span class="underline">符号名称</span> 。相同的 <a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm</a> 程序用于构建System.map
</p>
</div>
</div>

<div id="outline-container-org50d5352" class="outline-3">
<h3 id="org50d5352">编译阶段</h3>
<div class="outline-text-3" id="text-org50d5352">
<p>
现在向后退一步, 检查源代码文件如何编译为目标文件. 可能还记得, vmlinux目标的先决条件之一是 <span class="underline">$(vmlinux-deps)</span> 变量. 现在, 从Linux 主makefile 中复制一些相关的行, 以演示如何构建此变量：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">init-y</span>        := init/
<span style="color: #4eee94;">drivers-y</span>    := drivers/ sound/ firmware/
<span style="color: #4eee94;">net-y</span>        := net/
<span style="color: #4eee94;">libs-y</span>        := lib/
<span style="color: #4eee94;">core-y</span>        := usr/

<span style="color: #4eee94;">core-y</span>        += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/

<span style="color: #4eee94;">init-y</span>        := $(<span style="color: #4eee94;">patsubst</span> %/, %/built-in.o, $(<span style="color: #4eee94;">init-y</span>))
<span style="color: #4eee94;">core-y</span>        := $(<span style="color: #4eee94;">patsubst</span> %/, %/built-in.o, $(<span style="color: #4eee94;">core-y</span>))
<span style="color: #4eee94;">drivers-y</span>    := $(<span style="color: #4eee94;">patsubst</span> %/, %/built-in.o, $(<span style="color: #4eee94;">drivers-y</span>))
<span style="color: #4eee94;">net-y</span>        := $(<span style="color: #4eee94;">patsubst</span> %/, %/built-in.o, $(<span style="color: #4eee94;">net-y</span>))

export <span style="color: #4eee94;">KBUILD_VMLINUX_INIT</span> := $(<span style="color: #4eee94;">head-y</span>) $(<span style="color: #4eee94;">init-y</span>)
export <span style="color: #4eee94;">KBUILD_VMLINUX_MAIN</span> := $(<span style="color: #4eee94;">core-y</span>) $(<span style="color: #4eee94;">libs-y2</span>) $(<span style="color: #4eee94;">drivers-y</span>) $(<span style="color: #4eee94;">net-y</span>) $(<span style="color: #4eee94;">virt-y</span>)
export <span style="color: #4eee94;">KBUILD_VMLINUX_LIBS</span> := $(<span style="color: #4eee94;">libs-y1</span>)
export <span style="color: #4eee94;">KBUILD_LDS</span>          := arch/$(<span style="color: #4eee94;">SRCARCH</span>)/kernel/vmlinux.lds

<span style="color: #4eee94;">vmlinux-deps</span> := $(<span style="color: #4eee94;">KBUILD_LDS</span>) $(<span style="color: #4eee94;">KBUILD_VMLINUX_INIT</span>) $(<span style="color: #4eee94;">KBUILD_VMLINUX_MAIN</span>) $(<span style="color: #4eee94;">KBUILD_VMLINUX_LIBS</span>)
</pre>
</div>

<p>
所有这些都以变量 <span class="underline">init-y</span> , <span class="underline">core-y</span> 等开头. 它们组合在一起, 包含Linux内核的所有子文件夹, 这些子文件夹包含可构建的源代码. 然后, 在所有子文件夹名称后附加 <span class="underline">built-in.o</span> 
</p>
<pre class="example" id="orgdbbfbc2">
例如, drivers/ 成为 drivers/built-in.o. 然后, vmlinux-deps会汇总所有结果值

这解释了vmlinux最终如何依赖于所有build-in.o文件
</pre>

<p>
下一个问题是如何创建所有 built-in.o 对象？再一次, 复制所有相关的行, 并说明其工作原理：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">sort</span><span style="color: #daa520; font-weight: bold;"> $(</span><span style="color: #daa520; font-weight: bold;">vmlinux-deps</span><span style="color: #daa520; font-weight: bold;">))</span>: $(<span style="color: #4eee94;">vmlinux-dirs</span>) ;

<span style="color: #4eee94;">vmlinux-dirs</span>    := $(<span style="color: #4eee94;">patsubst</span> %/,%,$(<span style="color: #4eee94;">filter</span> %/, $(<span style="color: #4eee94;">init-y</span>) $(<span style="color: #4eee94;">init-m</span>) \
$(<span style="color: #4eee94;">core-y</span>) $(<span style="color: #4eee94;">core-m</span>) $(<span style="color: #4eee94;">drivers-y</span>) $(<span style="color: #4eee94;">drivers-m</span>) \
$(<span style="color: #4eee94;">net-y</span>) $(<span style="color: #4eee94;">net-m</span>) $(<span style="color: #4eee94;">libs-y</span>) $(<span style="color: #4eee94;">libs-m</span>) $(<span style="color: #4eee94;">virt-y</span>)))

<span style="color: #4eee94;">build</span> := -f $(<span style="color: #4eee94;">srctree</span>)/scripts/Makefile.build obj               <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">Copied from `scripts/Kbuild.include`</span>

<span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">vmlinux-dirs</span><span style="color: #daa520; font-weight: bold;">)</span>: prepare scripts
$(<span style="color: #4eee94;">Q</span>)$(<span style="color: #4eee94;">MAKE</span>) $(<span style="color: #4eee94;">build</span>)=<span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>

</pre>
</div>


<p>
第一行说明 <span class="underline">vmlinux-deps</span> 依赖于 <span class="underline">vmlinux-dirs</span> . 接下来, 可以看到 vmlinux-dirs 是一个 <b>变量</b> , 它包含所有直接的根子文件夹, 末尾没有 <span class="underline">/</span> 字符。最重要的一行是构建 <span class="underline">$(vmlinux-dirs)</span> 目标的方法. 替换所有变量后, 此配方如下所示
</p>

<div class="org-src-container">
<pre class="src src-sh">make -f scripts/Makefile.build <span style="color: #4eee94;">obj</span>=drivers
</pre>
</div>

<p>
这行仅调用另一个makefile <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build">scripts/Makefile.build</a> 并传递 obj变量, 该变量包含要编译的文件夹
</p>

<pre class="example" id="org290bae8">
这里以drivers文件夹为例, 但是将对所有根子文件夹执行此规则
</pre>

<p>
接下来的逻辑步骤是执行 <span class="underline">scripts/Makefile.build</span> 。第一件事是 <b>定义</b> 包括当前目录中定义的Makefile或Kbuild文件中的所有变量. 当前目录是指 <span class="underline">obj变量引用的目录</span> 。包含在以下 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build#L43-L45">下面三行</a> ：
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">kbuild-dir</span> := $(<span style="color: #4eee94;">if</span> $(<span style="color: #4eee94;">filter</span> /%,$(<span style="color: #4eee94;">src</span>)),$(<span style="color: #4eee94;">src</span>),$(<span style="color: #4eee94;">srctree</span>)/$(<span style="color: #4eee94;">src</span>))
<span style="color: #4eee94;">kbuild-file</span> := $(<span style="color: #4eee94;">if</span> $(<span style="color: #4eee94;">wildcard</span> $(<span style="color: #4eee94;">kbuild-dir</span>)/Kbuild),$(<span style="color: #4eee94;">kbuild-dir</span>)/Kbuild,$(<span style="color: #4eee94;">kbuild-dir</span>)/Makefile)
<span style="color: #00bfff; font-weight: bold;">include</span> $(<span style="color: #4eee94;">kbuild-file</span>)
</pre>
</div>

<p>
嵌套的makefile主要负责初始化诸如 <span class="underline">obj-y</span> 之类的变量：
</p>
<ul class="org-ul">
<li>obj-y变量应包含位于当前目录中的所有源代码文件的列表</li>
<li><p>
初始化的另一个重要变量是 <span class="underline">subdir-y</span> ：此变量包含在构建curent目录中的源代码之前需要访问的所有子文件夹的列表
</p>
<pre class="example" id="orgc79e505">
subdir-y用于实现递归到最终的子文件夹
</pre></li>
</ul>

<p>
在不指定目标的情况下调用 make 时(例如在执行 scripts/Makefile.build 的情况下), 它将使用第一个目标。scripts /Makefile.build 的第一个目标称为 <b>__build</b> 
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #daa520; font-weight: bold;">__build</span>: $(<span style="color: #4eee94;">if</span> $(<span style="color: #4eee94;">KBUILD_BUILTIN</span>),$(<span style="color: #4eee94;">builtin-target</span>) $(<span style="color: #4eee94;">lib-target</span>) $(<span style="color: #4eee94;">extra-y</span>)) \
$(<span style="color: #4eee94;">if</span> $(<span style="color: #4eee94;">KBUILD_MODULES</span>),$(<span style="color: #4eee94;">obj-m</span>) $(<span style="color: #4eee94;">modorder-target</span>)) \
$(<span style="color: #4eee94;">subdir-ym</span>) $(<span style="color: #4eee94;">always</span>)
<span style="color: #daa520; font-weight: bold;">@</span>:
</pre>
</div>

<p>
, <span class="underline">_build 目标没有receipe, 只取决于其他目标. 只对 _$(builtin-target)</span> 感兴趣
</p>

<pre class="example" id="org20ed7fa">
${builtin-target} 负责创建 built-in.o文件 和 $(subdir-ym)
</pre>

<p>
而 <span class="underline">${subdir-ym)</span> ：负责继续进入到字目录，此变量初始化 <span class="underline">subdir-y</span> 和 <span class="underline">subdir-m</span> 个变量
</p>

<pre class="example" id="orgf8bbb0e">
subdir-m 变量类似于 subdir-y, 但它定义了子文件夹需要包含在单独的kernel模块中

现在跳过讨论模块, 以保持专注
</pre>

<p>
subdir-ym 应该看起来很熟悉：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">subdir-ym</span><span style="color: #daa520; font-weight: bold;">)</span>:
$(<span style="color: #4eee94;">Q</span>)$(<span style="color: #4eee94;">MAKE</span>) $(<span style="color: #4eee94;">build</span>)=<span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
</pre>
</div>

<pre class="example" id="orgb1cf65e">
这个目标只是触发嵌套子文件夹中的 scripts/Makefile.build 的执行
</pre>

<p>
现在是时候观察 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build#L467">builtin-target</a> 了，再次在这里只复制相关行：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">cmd_make_builtin</span> = rm -f <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>; $(<span style="color: #4eee94;">AR</span>) rcSTP$(<span style="color: #4eee94;">KBUILD_ARFLAGS</span>)
<span style="color: #4eee94;">cmd_make_empty_builtin</span> = rm -f <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>; $(<span style="color: #4eee94;">AR</span>) rcSTP$(<span style="color: #4eee94;">KBUILD_ARFLAGS</span>)

<span style="color: #4eee94;">cmd_link_o_target</span> = $(<span style="color: #4eee94;">if</span> $(<span style="color: #4eee94;">strip</span> $(<span style="color: #4eee94;">obj-y</span>)),\
$(<span style="color: #4eee94;">cmd_make_builtin</span>) <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> $(<span style="color: #4eee94;">filter</span> $(<span style="color: #4eee94;">obj-y</span>), $<span style="color: #ffd700;">^</span>) \
$(<span style="color: #4eee94;">cmd_secanalysis</span>),\
$(<span style="color: #4eee94;">cmd_make_empty_builtin</span>) <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>)

<span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">builtin-target</span><span style="color: #daa520; font-weight: bold;">)</span>: $(<span style="color: #4eee94;">obj-y</span>) FORCE
$(<span style="color: #4eee94;">call</span> if_changed,link_o_target)
</pre>
</div>

<p>
该目标取决于 <span class="underline">$(obj-y)</span> 目标, 而obj-y是需要在当前文件夹中构建的所有目标文件的列表。这些文件准备就绪后, 将执行 <span class="underline">cmd_link_o_target</span> 命令：
</p>
<ul class="org-ul">
<li>如果 <span class="underline">obj-y</span> 变量为 <b>空</b> , 则调用 <span class="underline">cmd_make_empty_builtin</span> , 直到创建一个空的 <span class="underline">built-in.o</span></li>
<li>否则, 执行 <span class="underline">cmd_make_builtin</span> 命令；它使用熟悉的 <span class="underline">ar</span> 工具创建 <span class="underline">built-in.o</span> thin archive</li>
</ul>

<p>
最终到了需要编译一些东西的地步
</p>
<pre class="example" id="orgadacbd8">
最后一个没有查看过的依赖项是 $(obj-y) ，但是 不幸的是 obj-y 只是一份目标文件列表
</pre>

<p>
因此在 <a href="https://github.com/torvalds/linux/blob/v4.14/scripts/Makefile.build#L467">这里</a> 定义了如何从相应的 .c 文件编译对应的二进制文件. 来看下对应的所有行：
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">cmd_cc_o_c</span> = $(<span style="color: #4eee94;">CC</span>) $(<span style="color: #4eee94;">c_flags</span>) -c -o <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> $<span style="color: #ffd700;">&lt;</span>

define rule_cc_o_c
$(<span style="color: #4eee94;">call</span> echo-cmd,checksrc) $(<span style="color: #4eee94;">cmd_checksrc</span>)              \
$(<span style="color: #4eee94;">call</span> cmd_and_fixdep,cc_o_c)                      \
$(<span style="color: #4eee94;">cmd_modversions_c</span>)                          \
$(<span style="color: #4eee94;">call</span> echo-cmd,objtool) $(<span style="color: #4eee94;">cmd_objtool</span>)                  \
$(<span style="color: #4eee94;">call</span> echo-cmd,record_mcount) $(<span style="color: #4eee94;">cmd_record_mcount</span>)
endef

<span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">obj</span><span style="color: #daa520; font-weight: bold;">)/%.o</span>: $(<span style="color: #4eee94;">src</span>)/%.c $(<span style="color: #4eee94;">recordmcount_source</span>) $(<span style="color: #4eee94;">objtool_dep</span>) FORCE
$(<span style="color: #4eee94;">call</span> cmd,force_checksrc)
$(<span style="color: #4eee94;">call</span> if_changed_rule,cc_o_c)
</pre>
</div>

<p>
在此 recipe 内部, 此 target 称为 <span class="underline">rule_cc_o_c</span> 。 这个规则负责很多事情：
</p>
<ul class="org-ul">
<li>检查源代码中的一些常见错误 <span class="underline">cmd_checksrc</span></li>
<li>为导出的模块符号启用版本控制  <span class="underline">cmd_modversions_c</span></li>
<li>使用  <a href="https://github.com/torvalds/linux/tree/v4.14/tools/objtool">objtool</a> 验证生成的二进制目标文件</li>
<li>构建对mcount函数的调用列表以便  <a href="https://github.com/torvalds/linux/blob/v4.14/Documentation/trace/ftrace.txt">ftrace</a> 可以很快找到他们</li>
<li>&#x2026;.</li>
</ul>

<p>
但是最重​​要的是, 它调用 <span class="underline">cmd_cc_o_c</span> 命令, 实际上是该命令将所有.c文件编译为二进制文件
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="startup.html">Next: 引导流程</a></td>
<td class="org-left"><a href="linux.html">Previous: 项目结构</a></td>
<td class="org-left"><a href="initialization.html">Home: 内核初始化</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
