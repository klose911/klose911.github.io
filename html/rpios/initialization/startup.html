<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux 引导流程</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./build_system.html"> UP </a>
 |
 <a accesskey="H" href="./initialization.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Linux 引导流程</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgada6d78">搜索入口点</a></li>
<li><a href="#orgf6b5dd8">Linux引导程序和引导协议</a>
<ul>
<li><a href="#orgb8cc242">UEFI 启动</a></li>
<li><a href="#org6e8a96f">设备树</a></li>
</ul>
</li>
<li><a href="#org635e542">结论</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgada6d78" class="outline-2">
<h2 id="orgada6d78">搜索入口点</h2>
<div class="outline-text-2" id="text-orgada6d78">
<pre class="example" id="orgb8f77b0">
看完Linux项目结构并研究了如何构建之后, 下一个步骤就是找到程序入口点

对于许多程序而言, 此步骤可能是微不足道的, 但对于Linux内核而言却并非如此
</pre>

<p>
要做的第一件事是看一下 <a href="https:/github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/vmlinux.lds.S">arm64链接描述文件</a>
</p>

<pre class="example" id="org82bf9cc">
前面已经看到了链接脚本是如何在 主 makefile中使用

因此可以轻松推断出这里能够找到特定体系结构的链接脚本的位置
</pre>

<p>
应该提到的是, 将要检查的文件不是实际的链接描述文件, 而是一个模板
</p>

<pre class="example" id="org742d9fb">
通过使用一些模板的实际值替换一些宏, 可以从中构建实际的链接描述文件

正因为该文件主要由宏组成, 所以读取和在不同体系结构之间移植变得更加容易
</pre>

<p>
在链接描述文件中可以找到的第一部分称为 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/vmlinux.lds.S#L96">.head.text</a> ，这非常重要, 因为应该在本节中定义入口点
</p>

<pre class="example" id="org13dca20">
如果仔细考虑一下, 那么一切都很合理：在加载内核之后, 将二进制映像的内容复制到某个内存区域, 然后从该区域的开头开始执行

这意味着仅仅通过搜索谁使用.head.text 一节, 就可以找到入口点
</pre>

<p>
实际上, arm64 架构只有一个文件 head.S, 该文件会使用  <a href="https://github.com/torvalds/linux/blob/v4.14/include/linux/init.h#L90">__HEAD macro</a> , _HEAD 宏在编译前的预处理阶段会被替换为 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S">head.S</a> 
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00bfff; font-weight: bold;">.section</span> <span style="color: #deb887;">".head.text"</span>,<span style="color: #deb887;">"ax"</span>
</pre>
</div>

<p>
在head.S文件中找到的第一行可执行文件是  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S#L85">这里</a> ，使用 arm 的 <span class="underline">b(branch)</span> 指令指示处理器跳转到 <span class="underline">stext</span> 函数. 这是启动内核后执行的第一个函数 
</p>

<pre class="example" id="org90a5c31">
逻辑上, 下一步应该继续探索 stext 函数内部正在发生的事情，但是我们现在还没有准备好

首先, 我们必须在RPi OS中实现类似的功能, 这将在接下来的几课中介绍

现在要做的是研究一些与内核引导有关的关键概念
</pre>
</div>
</div>

<div id="outline-container-orgf6b5dd8" class="outline-2">
<h2 id="orgf6b5dd8">Linux引导程序和引导协议</h2>
<div class="outline-text-2" id="text-orgf6b5dd8">
<p>
当linux内核启动时, 它假定机器硬件已准备成某种 <b>既定状态</b> . 定义此状态的规则集称为 <span class="underline">启动协议</span> , 对于 arm64 体系结构, 此文档记录在  <a href="https://github.com/torvalds/linux/blob/v4.14/Documentation/arm64/booting.txt">这里</a>。它定义了：
</p>
<ul class="org-ul">
<li>执行只能在主CPU上开始,</li>
<li>必须关闭内存映射单元,</li>
<li>并且必须禁用所有中断</li>
<li>&#x2026;&#x2026;</li>
</ul>

<pre class="example" id="org952a9df">
但是由谁负责使计算机进入这个状态？
</pre>

<p>
通常, 有一个特殊的程序在内核之前运行并执行所有初始化. 这个程序叫做 <span class="underline">引导程序</span> (bootloader)
</p>
<pre class="example" id="org63045cd">
Bootloader 的代码都是与计算机硬件相匹配的特定代码
</pre>

<p>
Raspberry PI也有自己特定的 bootloader 代码，并且内置在主板中. 我们只能使用  <a href="https://www.raspberrypi.com/documentation/computers/configuration.html">config.txt</a> 文件来自定义某些行为
</p>
</div>

<div id="outline-container-orgb8cc242" class="outline-3">
<h3 id="orgb8cc242">UEFI 启动</h3>
<div class="outline-text-3" id="text-orgb8cc242">
<pre class="example" id="orga192624">
除了 Bootloader 外, 还可以在内核映像中内置一个引导加载程序
</pre>

<p>
此引导加载程序只能在支持 <a href="https://en.wikipedia.org/wiki/UEFI">Unified Extensible Firmware Interface (UEFI)</a> 的平台上使用。支持UEFI的设备为正在运行的软件提供了一组标准化服务, 这些服务可用于找出有关机器本身及其功能的所有必要信息. UEFI 还要求计算机固件应能够以 <a href="https://en.wikipedia.org/wiki/Portable_Executable">Portable Executable (PE)</a> 格式运行可执行文件。 Linux 内核的 UEFI 引导加载程序就利用了此功能：它在 Linux 内核映像的开头注入 <span class="underline">PE 标准头部格式信息</span> , 以便计算机固件认为该映像是普通的 PE 文件。 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-header.S">efi-header.S</a> 文件中就完成了这个操作，该文件定义了  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-header.S#L13">__EFI_PE_HEADER</a> 宏, 该宏在 <span class="underline">head.S</span> 内部使用
</p>

<p>
在 <b>__EFI_PE_HEADER</b> 内部定义的一项重要属性是用于说明 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-header.S#L33">UEFI入口点</a> 和入口点本身可以在 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-entry.S#L32">efi-entry.S</a> 中找到
</p>


<pre class="example" id="org12e4aac">
从此位置开始, 可以遵循源代码并检查 UEFI 引导加载程序到底在做什么(源代码本身实际上相当直接)

但是我们将在此处停止, 因为本节的目的不是详细检查 UEFI 引导程序, 而是大致了解 UEFI 是什么以及 Linux 内核如何使用它 
</pre>
</div>
</div>

<div id="outline-container-org6e8a96f" class="outline-3">
<h3 id="org6e8a96f">设备树</h3>
<div class="outline-text-3" id="text-org6e8a96f">
<pre class="example" id="org100df70">
当我开始研究 Linux 内核的启动代码时, 发现了很多关于设备树(device tree) 的内容

它似乎是一个必不可少的概念, 所以我认为有必要对其进行讨论
</pre>

<p>
当在开发 Raspberry PI OS 内核时, 通常从 <a href="https://github.com/raspberrypi/documentation/files/1888662/BCM2837-ARM-Peripherals.-.Revised.-.V2-1.pdf">BCM2837 ARM Peripherals 手册</a>  中找出了一个特定的内存映射寄存器在物理内存上的确切偏移量
</p>


<pre class="example" id="org248b4cd">
显然每个主板的偏移量信息都是不同的, 我们很幸运, 只需要支持 BCM2873 这一个

但是, 如果我们需要支持数百个不同的主板怎么办？

如果我们尝试在内核代码中硬编码每个主板的信息, 那将是一团乱麻

即使我们设法做到这一点, 我们又如何确定当前使用的是哪种主板？ 例如, BCM2837 没有提供任何将此类信息传递给正在运行的内核的方法
</pre>


<p>
<span class="underline">设备树</span> 提供了解决上述问题的方法。设备树一种特殊格式, 可用于描述计算机硬件。可以在  <a href="https://www.devicetree.org/">这个网站</a> 中找到设备树规范。在执行内核之前,  <span class="underline">引导程序</span> 会选择 <span class="underline">适当的设备树文件</span> , 并将其作为 <span class="underline">参数</span> <b>传递</b> 给 <span class="underline">内核</span> 。如果查看 Raspberry PI SD 卡的引导分区(boot分区)中的文件, 会找到很多 <span class="underline">.dtb</span> 文件
</p>
<pre class="example" id="orgdf92a92">
.dtb是编译之后的设备树文件

可以在 config.txt 中配置来启用或禁用 Raspberry PI 的硬件

Raspberry PI官方文档 中更详细地描述了此过程
</pre>

<p>
好的, 现在该看一下实际的设备树的文件了
</p>
<pre class="example" id="orgd9a11ce">
作为快速练习, 尝试为Raspberry PI 3 Model B查找设备树
</pre>

<p>
从 文档 中, 可以得出结论：Raspberry PI 3 Model B 使用的芯片名为 <b>BCM2837</b> 。如果搜索此名称, 则可以找到  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/boot/dts/broadcom/bcm2837-rpi-3-b.dts">/arch/arm64/boot/dts/broadcom/bcm2837-rpi-3-b.dts</a> 文件
</p>

<pre class="example" id="org98c57c3">
如您所见, 它只是包含了arm 体系下的相同文件

这很合理, 因为 ARM.v8 处理器也支持32位模式
</pre>

<p>
接下来, 可以发现  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837-rpi-3-b.dts">bcm2837-rpi-3-b.dts</a> 属于 <a href="https://github.com/torvalds/linux/tree/v4.14/arch/arm">arm</a> 架构
</p>
<pre class="example" id="org2dfe379">
我们已经看到设备树文件可以包含在另一个文件中

bcm2837-rpi-3-b.dts 就是这种情况：它仅包含特定于 BCM2837的那些定义, 并重用其他所有内容

例如, bcm2837-rpi-3-b.dts 指定设备应该具有 1GB 的内存

</pre>

<p>
正如之前提到的, BCM2837 和 BCM2835 具有相同的外围硬件。并且, 如果沿着包含文件链条, 还是可以发现 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi">bcm283x.dtsi</a> 实际上定义了大多数这类硬件
</p>

<p>
设备树由彼此嵌套的块组成：
</p>
<ul class="org-ul">
<li>在顶层, 通常可以找到诸如  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L30">cpus</a> 或 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837-rpi-3-b.dts#L17">memory</a> , 含义通过块的节点名称也能看出</li>
<li>可以在 bcm283x.dtsi 中找到的另一个有趣的顶级节点是  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L52">SoC</a> (<a href="https://en.wikipedia.org/wiki/System_on_a_chip">System on a chip</a>)
<ul class="org-ul">
<li>所有外围设备都通过 <b>内存映射</b> 把 <span class="underline">寄存器</span> 直接映射到某个 <span class="underline">内存区域</span>
<ul class="org-ul">
<li>soc 节点用作所有外围设备的父节点
<ul class="org-ul">
<li>它的子节点之一是 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L147">gpio</a> 节点，此节点定义 <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L149">reg = &lt;0x7e200000 0xb4&gt;</a> 属性, 该属性告诉我们 GPIO 的内存映射寄存器位于 <b>0x7e200000 ~ 0x7e2000b4</b> 区域
<ul class="org-ul">
<li><p>
gpio 节点的子节点之一具有  <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L474">以下定义</a>：
</p>
<div class="org-src-container">
<pre class="src src-sh">uart1_gpio14: uart1_gpio14 {
    brcm,pins = &lt;14 15&gt;;
    brcm,<span style="color: #00bfff; font-weight: bold;">function</span> = &lt;BCM2835_FSEL_ALT5&gt;;
};
</pre>
</div></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<pre class="example" id="org9a0a6dd">
这个定义告诉我们, 如果为引脚14和15选择了替代功能5, 则这些引脚将连接到 uart1 设备

可以很容易地猜出 uart1 设备就是已经使用过的Mini UART
</pre>


<p>
需要了解的有关设备树的另外重要的一件事是：设备树格式是 <b>可扩展</b> 的。每个设备可以定义自己的属性和嵌套块，这些属性透明地传递给设备驱动程序, 解释它们是驱动程序的职责
</p>

<pre class="example" id="orgc59b953">
但是内核如何找出设备树中的配置与正确的驱动程序之间的对应关系？
</pre>

<p>
内核使用 <b>compatible</b> 属性来做到这一点。例如, 对于 <span class="underline">uart1</span> 设备,  <span class="underline">compatible</span> 属性是这样指定的：
</p>
<div class="org-src-container">
<pre class="src src-sh">compatible = <span style="color: #deb887;">"brcm,bcm2835-aux-uart"</span>;
</pre>
</div>


<p>
实际上, 如果在Linux源代码中搜索 <span class="underline">bcm2835-aux-uart</span> , 则可以找到匹配的驱动程序, 该驱动程序定义在 <a href="https://github.com/torvalds/linux/blob/v4.14/drivers/tty/serial/8250/8250_bcm2835aux.c">8250_bcm2835aux.c</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org635e542" class="outline-2">
<h2 id="org635e542">结论</h2>
<div class="outline-text-2" id="text-org635e542">
<pre class="example" id="org1045634">
可以考虑将本章作为阅读 arm64 引导代码的准备

在没有了解刚刚探讨的概念的情况下, 将很难学习它.

在下一课中, 将返回到 stext 函数, 并详细研究其工作方式
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="build_system.html">Previous: 内核构建系统</a></td>
<td class="org-left"><a href="initialization.html">Home: 内核初始化</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
