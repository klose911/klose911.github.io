<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux startup sequence</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./build_system.html"> UP </a>
 |
 <a accesskey="H" href="./initialization.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Linux startup sequence</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2b05bd8">Searching for the entry point</a></li>
<li><a href="#org0e0527d">Linux bootloader and boot protocol</a></li>
<li><a href="#org3f1db31">UEFI boot</a></li>
<li><a href="#orgb89dbd6">Device Tree</a></li>
<li><a href="#orgf5025e7">Conclusion</a></li>
</ul>
</div>
</div>
<div id="outline-container-org2b05bd8" class="outline-2">
<h2 id="org2b05bd8">Searching for the entry point</h2>
<div class="outline-text-2" id="text-org2b05bd8">
<pre class="example" id="org30bc17a">
After taking a look at the Linux project structure and examining how it can be built, next logical step is to find the program entry point

This step might be trivial for a lot of programs, but not for the Linux kernel
</pre>
<p>
The first thing we are going to do is to take a look at <a href="https:/github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/vmlinux.lds.S">arm linker script</a> . We have already seen how the linker script is used in the <a href="https://github.com/torvalds/linux/blob/v4.14/Makefile#L970">main Makefile</a>
</p>

<pre class="example" id="org2b0c4c5">
From this line, we can easily infer, where the linker script for a particular architecture can be found
</pre>


<p>
It should be mentioned that the file we are going to examine is not an actual linker script
</p>

<pre class="example" id="org7715a3e">
it is a template, from which the actual linker script is built by substituting some macros with their actual values

But precisely because this file consists mostly of macros it becomes much easier to read and to port between different architectures
</pre>

<p>
The first section that we can find in the linker script is called <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/vmlinux.lds.S#L96">.head.text</a> . This is very important for us because the entry point should be defined in this section
</p>

<pre class="example" id="org16f0277">
If you think a little about it, it makes a perfect sense: after the kernel is loaded, the content of the binary image is copied into some memory area and execution is started from the beginning of that area

This means that just by searching who is using .head.text section we should be able to find the entry point
</pre>

<p>
And indeed, arm64 architecture has a single file that uses <a href="https://github.com/torvalds/linux/blob/v4.14/include/linux/init.h#L90">__HEAD macro</a>, which is expanded to the file <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S">head.S</a> 
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00bfff; font-weight: bold;">.section</span> <span style="color: #deb887;">".head.text"</span>,<span style="color: #deb887;">"ax"</span>
</pre>
</div>

<p>
The first executable line, that we can find in <span class="underline">head.S</span> file is <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/head.S#L85">this one</a>. Here we use arm assembler b of branch instruction to jump to the <span class="underline">stext</span> function. And this is the first function that is executed after you boot the kernel.
</p>

<pre class="example" id="orgb261328">
Next logical step is to explore what is going on inside the stext function - but we are not ready yet

First, we have to implement similar functionality in the RPi OS, and that is something we will cover in the next few lessons

What we are going to do right now is to examine a few critical concepts, related to kernel boot
</pre>
</div>
</div>
<div id="outline-container-org0e0527d" class="outline-2">
<h2 id="org0e0527d">Linux bootloader and boot protocol</h2>
<div class="outline-text-2" id="text-org0e0527d">
<p>
When linux kernel boots it assumes that the machine hardware is prepared in some <b>known state</b>. The set of rules that defines this state is called <span class="underline">boot protocol</span>, and for arm64 architecture it is documented <a href="https://github.com/torvalds/linux/blob/v4.14/Documentation/arm64/booting.txt">here</a>. Among other things, it defines, for example:
</p>
<ul class="org-ul">
<li>the execution must start only on primary CPU</li>
<li>Memory Mapping Unit must be turned off</li>
<li>all interrupts must be disabled</li>
</ul>

<pre class="example" id="orgf680657">
Ok, but who is responsible for bringing a machine into that known state?
</pre>
<p>
Usually, there is a special program that runs before the kernel and performs all initializations. This program is called <span class="underline">bootloader</span>
</p>

<pre class="example" id="org4fdc37b">
Bootloader code may be very machine specific, and this is the case, with Raspberry PI
</pre>

<p>
Raspberry PI has a bootloader that is is built into the board. We can only use <a href="https://www.raspberrypi.com/documentation/computers/configuration.html">config.txt</a> file to customize its behavior
</p>
</div>
</div>
<div id="outline-container-org3f1db31" class="outline-2">
<h2 id="org3f1db31">UEFI boot</h2>
<div class="outline-text-2" id="text-org3f1db31">
<pre class="example" id="org80b5330">
However, there is one boot loader that can be built into the kernel image itself
</pre>
<p>
This bootloader can be used only on the platforms that support <a href="https://en.wikipedia.org/wiki/UEFI">Unified Extensible Firmware Interface (UEFI)</a>. Devices that support UEFI provide a set of standardized services to the running software and those services can be used to figure out all necessary information about the machine itself and its capabilities. UEFI also requires that computer firmware should be capable of running executable files in <a href="https://en.wikipedia.org/wiki/Portable_Executable">Portable Executable (PE)</a> format. Linux kernel UEFI bootloader makes use of this feature: it <b>injects</b> <span class="underline">PE header</span> at the beginning of the Linux kernel image so that computer firmware think that the image is a normal PE file. This is done in <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-header.S">efi-header.S</a> file. This file defines <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-header.S#L13">__EFI_PE_HEADER</a> macro, which is used inside <span class="underline">head.S</span>
</p>

<p>
One important property that is defined inside <b>__EFI_PE_HEADER</b> is the one that tells about <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-header.S#L33">the location of the UEFI entry point</a> and the entry point itself can be found in <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/kernel/efi-entry.S#L32">efi-entry.S</a>
</p>

<pre class="example" id="org0d8601b">
Starting from this location, you can follow the source code and examine what exactly UEFI bootloader is doing (the source code itself is more or less straightforward)

But we are going to stop here because the purpose of this section is not to examine UEFI bootloader in details, but instead, give you a general idea what UEFI is and how Linux kernel uses it
</pre>
</div>
</div>

<div id="outline-container-orgb89dbd6" class="outline-2">
<h2 id="orgb89dbd6">Device Tree</h2>
<div class="outline-text-2" id="text-orgb89dbd6">
<pre class="example" id="orgf4270e7">
When I started to examine the startup code of the Linux kernel, I found a lot of mentions of Device Trees

It appears to be an essential concept, and I consider it necessary to discuss it
</pre>

<p>
When we were working on Raspberry PI OS kernel, we used <a href="https://github.com/raspberrypi/documentation/files/1888662/BCM2837-ARM-Peripherals.-.Revised.-.V2-1.pdf">BCM2837 ARM Peripherals manual</a> to figure out what is the exact offset at which a particular memory mapped register is located
</p>

<pre class="example" id="org17f4f71">
This information obviously is different for each board, and we are lucky that we have to support only one of them

But what if we need to support hundreds of different boards?

It would be a total mess if we try to hardcode information about each board in the kernel code

And even if we manage to do so, how would we figure out what board we are using right now?

BCM2837, for example, doesn't provide any means of communicating such information to the running kernel
</pre>

<p>
<b>Device tree</b> provides us with the solution to the problem, mentioned above. It is a special format that can be used to describe computer hardware. Device tree specification can be found <a href="https://www.devicetree.org/">here</a>. Before the kernel is executed, <span class="underline">bootloader</span> selects <span class="underline">proper device tree file</span> and passes it as an <span class="underline">argument</span> to the kernel. If you take a look at the files in the boot partition on a Raspberry PI SD card, you can find a lot of <span class="underline">.dtb</span> files here
</p>

<pre class="example" id="org5892bff">
.dtb are compiled device tree files

You can select some of them in the config.txt to enable or disable some Raspberry PI hardware

This process is described in more details in the Raspberry PI official documentation
</pre>

<p>
Ok, now it is time to take a look at how an actual device tree looks like. As a quick exercise, let's try to find a device tree for <a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/">Raspberry PI 3 Model B</a>. From the <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2837/README.md">documentation</a> we can figure out that Raspberry PI 3 Model B uses a chip that is called <b>BCM2837</b>. If you search for this name you can find <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm64/boot/dts/broadcom/bcm2837-rpi-3-b.dts">/arch/arm64/boot/dts/broadcom/bcm2837-rpi-3-b.dts</a> file
</p>

<pre class="example" id="org2a91909">
As you might see it just includes the same file from arm architecture

This makes a perfect sense because ARM.v8 processor supports 32-bit mode as well
</pre>

<p>
Next, we can find <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837-rpi-3-b.dts">bcm2837-rpi-3-b.dts</a> belonging to the <a href="https://github.com/torvalds/linux/tree/v4.14/arch/arm">arm</a> architecture
</p>

<pre class="example" id="org68908d5">
We already saw that device tree files could include on another
</pre>

<p>
This is the case with the <span class="underline">bcm2837-rpi-3-b.dts</span> : it only contains those definitions, that are specific for <span class="underline">BCM2837</span> and reuses everything else. For example, bcm2837-rpi-3-b.dts specifies that <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837-rpi-3-b.dts#L18">the device now have 1GB of memory</a>
</p>

<pre class="example" id="org53d6613">
As I mentioned previously, BCM2837 and BCM2835 have an identical peripheral hardware
</pre>

<p>
if you follow the chain of includes, you can find <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi">bcm283x.dtsi</a> that actually defines most of this hardware
</p>

<p>
A device tree definition consists of the blocks nested one in another:
</p>
<ul class="org-ul">
<li>At the top level we usually can find such blocks as <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837.dtsi#L30">cpus</a> or <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm2837-rpi-3-b.dts#L17">memory</a>. The meaning of those blocks should be quite self-explanatory</li>
<li><p>
Another interesting top-level element that we can find in the <span class="underline">bcm283x.dtsi</span> is <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L52">SoC</a> that means <a href="https://en.wikipedia.org/wiki/System_on_a_chip">System on a chip</a>
</p>
<ul class="org-ul">
<li>It tells us that all peripheral devices are directly mapped to some memory area via memory mapped registers</li>
<li><span class="underline">soc</span> element serves as a parent element for all peripheral devices
<ul class="org-ul">
<li>One of its children is <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L147">gpio</a> element
<ul class="org-ul">
<li>This element defines <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L149">reg = &lt;0x7e200000 0xb4&gt;</a> property that tells us that GPIO memory mapped registers are located in the <b>[0x7e200000 : 0x7e2000b4]</b> region
<ul class="org-ul">
<li>One of the childern of gpio element has the <a href="https://github.com/torvalds/linux/blob/v4.14/arch/arm/boot/dts/bcm283x.dtsi#L474">following definition</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">uart1_gpio14: uart1_gpio14 {
    brcm,pins = &lt;14 15&gt;;
    brcm,<span style="color: #00bfff; font-weight: bold;">function</span> = &lt;BCM2835_FSEL_ALT5&gt;;
};
</pre>
</div></li>
</ul>

<pre class="example" id="org0bcbf49">
This definition tells us that if alternative function 5 is selected for pins 14 and 15 those pins will be connection to uart1 device

You can easily gues that uart1 device is the Mini UART that we have used already
</pre>

<p>
One important thing that you need to know about device trees is that the <span class="underline">format</span> is <b>extendable</b> . Each device can define its own properties and nested blocks. Those properties are transparently passed to the device driver, and it is <span class="underline">driver</span> responsibility to interpret them
</p>

<pre class="example" id="org1a2992f">
But how can the kernel figure out the correspondence between a block in a device tree and the right driver?
</pre>

<p>
It uses <b>compatible</b> property to do this. For example, for <span class="underline">uart1</span> device <span class="underline">compatible</span> property is specified like this:
</p>

<div class="org-src-container">
<pre class="src src-sh">compatible = <span style="color: #deb887;">"brcm,bcm2835-aux-uart"</span>;
</pre>
</div>

<p>
And indeed, if you search for <span class="underline">bcm2835-aux-uart</span> in the Linux source code, you can find a matching driver, it is defined in <a href="https://github.com/torvalds/linux/blob/v4.14/drivers/tty/serial/8250/8250_bcm2835aux.c">8250_bcm2835aux.c</a>
</p>
</div>
</div>

<div id="outline-container-orgf5025e7" class="outline-2">
<h2 id="orgf5025e7">Conclusion</h2>
<div class="outline-text-2" id="text-orgf5025e7">
<pre class="example" id="orgfade0b8">
You can think about this chapter as a preparation for reading arm64 boot code

without understanding the concepts that we've just explored you would have a hard time learning it

In the next lesson, we will go back to the stext function and examine in details how it works
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="build_system.html">Previous: Kernel Build System</a></td>
<td class="org-left"><a href="initialization.html">Home: Kernel Initialization</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
