<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RPi OS 入门：裸机 “Hello, World!”</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="./initialization.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">RPi OS 入门：裸机 “Hello, World!”</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgfafb4e5">项目结构</a></li>
<li><a href="#orgcdb8261">Makefile</a></li>
<li><a href="#org431a8f2">链接器脚本</a></li>
<li><a href="#org5191b46">引导内核</a>
<ul>
<li><a href="#orgcdea281">assembler instructions</a></li>
</ul>
</li>
<li><a href="#org8e0458c">kernel_main 函数</a>
<ul>
<li><a href="#orgd26d045">Raspberry Pi devices</a>
<ul>
<li><a href="#orgbd761a1">GPIO</a></li>
</ul>
</li>
<li><a href="#org9f761b7">初始化 Mini UART</a>
<ul>
<li><a href="#orgd515f33">GPIO 功能选择</a></li>
<li><a href="#orge6cc327">GPIO pull-up/down</a></li>
<li><a href="#org8e27924">初始化Mini UART</a></li>
</ul>
</li>
<li><a href="#orgfa63a8a">使用Mini UART</a></li>
</ul>
</li>
<li><a href="#orgab03da8">Raspberry Pi 配置</a></li>
<li><a href="#org6f55ed9">内核测试</a></li>
</ul>
</div>
</div>
<p>
通过编写一个小的裸机 <span class="underline">Hello, World</span> 应用程序开始我们的OS开发之旅
</p>

<pre class="example" id="orga119ace">
.假设您已通过Prerequisites并已准备就绪. 如果没有, 现在是时候这样做了
</pre>

<div id="outline-container-orgfafb4e5" class="outline-2">
<h2 id="orgfafb4e5">项目结构</h2>
<div class="outline-text-2" id="text-orgfafb4e5">
<p>
简要描述此文件夹的主要组件：
</p>
<ol class="org-ol">
<li><span class="underline">Makefile</span> ：将使用 <a href="http://www.math.tau.ac.il/~danha/courses/software1/make-intro.html">make</a> 实用程序来构建内核. make的行为由Makefile配置, 该文件包含有关如何编译和链接源代码的说明</li>
<li><span class="underline">build.sh</span> or _build.bat_： 如果要使用Docker构建内核, 则需要这些文件. 您无需在笔记本电脑上安装make实用程序或编译器工具链</li>
<li><span class="underline">src</span> ： 此文件夹包含所有源代码</li>
<li><span class="underline">include</span> ：所有的头文件都放在这里</li>
</ol>
</div>
</div>
<div id="outline-container-orgcdb8261" class="outline-2">
<h2 id="orgcdb8261">Makefile</h2>
<div class="outline-text-2" id="text-orgcdb8261">
<p>
现在, 来仔细看看项目Makefile
</p>

<pre class="example" id="orgef40d2e">
make程序的主要目的是自动确定需要重新编译什么程序的片段, 并发出命令来重新译编
</pre>

<p>
下面列出了整个Makefile：
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">ARMGNU</span> ?= aarch64-linux-gnu

<span style="color: #4eee94;">COPS</span> = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
<span style="color: #4eee94;">ASMOPS</span> = -Iinclude 

<span style="color: #4eee94;">BUILD_DIR</span> = build
<span style="color: #4eee94;">SRC_DIR</span> = src

<span style="color: #daa520; font-weight: bold;">all</span> : kernel8.img

<span style="color: #daa520; font-weight: bold;">clean</span> :
rm -rf $(<span style="color: #4eee94;">BUILD_DIR</span>) *.img 

<span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">BUILD_DIR</span><span style="color: #daa520; font-weight: bold;">)/%_c.o</span>: $(<span style="color: #4eee94;">SRC_DIR</span>)/%.c
mkdir -p $(<span style="color: #4eee94;">@D</span>)
$(<span style="color: #4eee94;">ARMGNU</span>)-gcc $(<span style="color: #4eee94;">COPS</span>) -MMD -c $<span style="color: #ffd700;">&lt;</span> -o <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>

<span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">BUILD_DIR</span><span style="color: #daa520; font-weight: bold;">)/%_s.o</span>: $(<span style="color: #4eee94;">SRC_DIR</span>)/%.S
$(<span style="color: #4eee94;">ARMGNU</span>)-gcc $(<span style="color: #4eee94;">ASMOPS</span>) -MMD -c $<span style="color: #ffd700;">&lt;</span> -o <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>

<span style="color: #4eee94;">C_FILES</span> = $(<span style="color: #4eee94;">wildcard</span> $(<span style="color: #4eee94;">SRC_DIR</span>)/*.c)
<span style="color: #4eee94;">ASM_FILES</span> = $(<span style="color: #4eee94;">wildcard</span> $(<span style="color: #4eee94;">SRC_DIR</span>)/*.S)
<span style="color: #4eee94;">OBJ_FILES</span> = $(<span style="color: #4eee94;">C_FILES</span>:<span style="color: #4eee94;">$(</span><span style="color: #4eee94;">SRC_DIR</span><span style="color: #4eee94;">)/%.c</span>=$(<span style="color: #4eee94;">BUILD_DIR</span>)/%_c.o)
<span style="color: #4eee94;">OBJ_FILES</span> += $(<span style="color: #4eee94;">ASM_FILES</span>:<span style="color: #4eee94;">$(</span><span style="color: #4eee94;">SRC_DIR</span><span style="color: #4eee94;">)/%.S</span>=$(<span style="color: #4eee94;">BUILD_DIR</span>)/%_s.o)

<span style="color: #4eee94;">DEP_FILES</span> = $(<span style="color: #4eee94;">OBJ_FILES</span>:<span style="color: #4eee94;">%.o</span>=%.d)
-include $(<span style="color: #4eee94;">DEP_FILES</span>)

<span style="color: #daa520; font-weight: bold;">kernel8.img</span>: $(<span style="color: #4eee94;">SRC_DIR</span>)/linker.ld $(<span style="color: #4eee94;">OBJ_FILES</span>)
$(<span style="color: #4eee94;">ARMGNU</span>)-ld -T $(<span style="color: #4eee94;">SRC_DIR</span>)/linker.ld -o $(<span style="color: #4eee94;">BUILD_DIR</span>)/kernel8.elf  $(<span style="color: #4eee94;">OBJ_FILES</span>)
$(<span style="color: #4eee94;">ARMGNU</span>)-objcopy $(<span style="color: #4eee94;">BUILD_DIR</span>)/kernel8.elf -O binary kernel8.img
</pre>
</div>

<p>
现在, 来详细阐述该文件：
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">ARMGNU</span> ?= aarch64-linux-gnu
</pre>
</div>

<p>
Makefile以变量定义开头. <span class="underline">ARMGNU</span> 是交叉编译器前缀. 因为正在x86计算机上编译arm64体系结构的源代码, 我们需要 <a href="https://en.wikipedia.org/wiki/Cross_compiler">交叉编译</a>. 因此, 将使用 <span class="underline">aarch64-linux-gnu-gcc</span> 代替 gcc
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">COPS</span> = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
<span style="color: #4eee94;">ASMOPS</span> = -Iinclude 
</pre>
</div>

<p>
<span class="underline">COPS</span> 和 <span class="underline">ASMOPS</span> 是在编译C和汇编代码时分别传递给编译器的选项.这些选项的简短说明：
</p>
<ul class="org-ul">
<li><span class="underline">-Wall</span> : 显示所有警告</li>
<li><p>
<span class="underline">-nostdlib</span> : 不使用C的标准库
</p>
<pre class="example" id="orgb628883">
C标准库中的大多数函数调用最终都会与操作系统交互

我们正在编写一个裸机程序, 并且没有任何底层操作系统, 因此C标准库无论如何都无法工作
</pre></li>
<li><p>
<span class="underline">-nostartfiles</span> 不要使用标准的启动文件
</p>
<pre class="example" id="orgcce8c88">
启动文件负责设置初始堆栈指针, 初始化静态数据以及跳转到主入口点

这里需要我们自己完成所有这一切
</pre></li>
<li><p>
<span class="underline">-ffreestanding</span> <span class="underline">独立环境</span> (ffreestanding)是标准库不存在的环境, 并且程序启动入口不是主要的
</p>
<pre class="example" id="orgb0e0052">
选项-ffreestanding指示编译器不需要定义标准函数具有其通常的意义
</pre></li>
<li><span class="underline">-Iinclude</span> : 在 <span class="underline">include</span> 文件夹中搜索头文件</li>
<li><p>
<span class="underline">-mgeneral-regs-only</span> : 仅使用通用寄存器. ARM处理器还具有 <a href="https://developer.arm.com/technologies/neon">NEON</a> 寄存器
</p>
<pre class="example" id="org98adbb8">
不希望编译器使用它们, 因为它们会增加额外的复杂性

例如, 因为需要在上下文切换期间存储寄存器
</pre>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">BUILD_DIR</span> = build
<span style="color: #4eee94;">SRC_DIR</span> = src
</pre>
</div></li>
</ul>

<p>
<span class="underline">SRC_DIR</span> 和 <span class="underline">BUILD_DIR</span> 是分别包含源代码和编译后Object文件的目录 
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #daa520; font-weight: bold;">all</span> : kernel8.img

<span style="color: #daa520; font-weight: bold;">clean</span> :
rm -rf $(<span style="color: #4eee94;">BUILD_DIR</span>) *.img 
</pre>
</div>

<p>
接下来, 定义make目标. 前两个参数非常简单:
</p>
<ul class="org-ul">
<li><p>
<span class="underline">all</span> 参数是 <b>默认</b> 目标, 每当输入不带任何参数的make时, 它就会执行
</p>
<pre class="example" id="orgdc68f36">
make 始终使用第一个参数作为默认参数

这个参数只是将所有工作重定向到另一个参数, kernel8.img
</pre></li>
<li><span class="underline">clean</span> 参数负责删除所有编译附加文件和已编译内核映像</li>
</ul>


<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">BUILD_DIR</span><span style="color: #daa520; font-weight: bold;">)/%_c.o</span>: $(<span style="color: #4eee94;">SRC_DIR</span>)/%.c
mkdir -p $(<span style="color: #4eee94;">@D</span>)
$(<span style="color: #4eee94;">ARMGNU</span>)-gcc $(<span style="color: #4eee94;">COPS</span>) -MMD -c $<span style="color: #ffd700;">&lt;</span> -o <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>

<span style="color: #daa520; font-weight: bold;">$(</span><span style="color: #daa520; font-weight: bold;">BUILD_DIR</span><span style="color: #daa520; font-weight: bold;">)/%_s.o</span>: $(<span style="color: #4eee94;">SRC_DIR</span>)/%.S
$(<span style="color: #4eee94;">ARMGNU</span>)-gcc $(<span style="color: #4eee94;">ASMOPS</span>) -MMD -c $<span style="color: #ffd700;">&lt;</span> -o <span style="color: #daa520; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
</pre>
</div>

<p>
接下来的两个参数负责编译C和汇编文件
</p>
<pre class="example" id="orgcc42af7">
 例如, 如果在 src 文件夹中有 foo.c 和 foo.S 文件

他们将会分别被编译为 build/foo_c.o 和 build/foo_s.o
</pre>

<p>
<span class="underline">$&lt;</span> 和 <span class="underline">$@</span> 在运行时将被替换成 <b>输入</b> 文件名和 <b>输出</b> 文件名 (foo.c and foo_c.o). 在编译C文件之前, 还创建了一个 <span class="underline">build</span> 目录, 以防该目录不存在 
</p>


<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">C_FILES</span> = $(<span style="color: #4eee94;">wildcard</span> $(<span style="color: #4eee94;">SRC_DIR</span>)/*.c)
<span style="color: #4eee94;">ASM_FILES</span> = $(<span style="color: #4eee94;">wildcard</span> $(<span style="color: #4eee94;">SRC_DIR</span>)/*.S)
<span style="color: #4eee94;">OBJ_FILES</span> = $(<span style="color: #4eee94;">C_FILES</span>:<span style="color: #4eee94;">$(</span><span style="color: #4eee94;">SRC_DIR</span><span style="color: #4eee94;">)/%.c</span>=$(<span style="color: #4eee94;">BUILD_DIR</span>)/%_c.o)
<span style="color: #4eee94;">OBJ_FILES</span> += $(<span style="color: #4eee94;">ASM_FILES</span>:<span style="color: #4eee94;">$(</span><span style="color: #4eee94;">SRC_DIR</span><span style="color: #4eee94;">)/%.S</span>=$(<span style="color: #4eee94;">BUILD_DIR</span>)/%_s.o)
</pre>
</div>


<p>
在这里, 正在构建一个由C和汇编源文件的串联创建的目标文件 <span class="underline">OBJ_FILES</span> 的数组
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">DEP_FILES</span> = $(<span style="color: #4eee94;">OBJ_FILES</span>:<span style="color: #4eee94;">%.o</span>=%.d)
-include $(<span style="color: #4eee94;">DEP_FILES</span>)
</pre>
</div>

<p>
接下来的两行有些棘手. 如果看一下如何为C和汇编源文件定义编译目标, 会注意到我们使用了 <span class="underline">-MMD</span> 参数. 这个参数指示gcc编译器为每个生成的目标文件创建一个 <b>依赖文件</b> 。依赖性文件定义了特定源文件的所有依赖性. 这些依赖项通常包含所有包含的头文件的列表. 需要包括所有生成的依赖文件, 以便在头文件更改时知道要重新编译的内容
</p>

<div class="org-src-container">
<pre class="src src-makefile">$(<span style="color: #4eee94;">ARMGNU</span>)-ld -T $(<span style="color: #4eee94;">SRC_DIR</span>)/linker.ld -o kernel8.elf  $(<span style="color: #4eee94;">OBJ_FILES</span>)
</pre>
</div>

<p>
使用链接器脚本 <span class="underline">src /linker.ld</span> 定义生成的 <b>可执行映像的基本布局</b> 
</p>

<div class="org-src-container">
<pre class="src src-makefile">$(<span style="color: #4eee94;">ARMGNU</span>)-objcopy kernel8.elf -O binary kernel8.img
</pre>
</div>

<p>
<span class="underline">kernel8.elf</span> 遵循 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> 格式
</p>

<pre class="example" id="orge7a37f9">
问题是ELF文件设计为由操作系统执行
</pre>

<p>
要编写裸机程序, 需要从ELF文件中提取所有可执行文件和数据段, 然后将它们放入 kernel8.img 中
</p>
<pre class="example" id="orgef85d3a">
尾部的 8 表示ARMv8, 它是64位体系结构. 该文件名告诉固件将处理器引导到64位模式

也可以使用config.txt文件中的arm_control = 0x200标志以64位模式引导CPU

RPi OS以前使用此方法, 仍然可以在一些练习答案中找到它. 然而, arm_control标志没有文档, 最好使用kernel8.img命名约定
</pre>
</div>
</div>

<div id="outline-container-org431a8f2" class="outline-2">
<h2 id="org431a8f2">链接器脚本</h2>
<div class="outline-text-2" id="text-org431a8f2">
<p>
链接描述文件的主要目的是描述如何将输入目标文件 <span class="underline">(_c.o和_s.o)</span> 中的 <span class="underline">段</span> <b>映射</b> 到 <span class="underline">输出文件(.elf)</span> 中
</p>


<pre class="example" id="org64c748a">
这里可以找到有关链接描述文件的更多信息: https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts
</pre>

<p>
现在看一下RPi OS链接器脚本:
</p>

<div class="org-src-container">
<pre class="src src-elf">SECTIONS
{
    .text.boot : { *(.text.boot) }
    .text :  { *(.text) }
    .rodata : { *(.rodata) }
    .data : { *(.data) }
    . = ALIGN(0x8);
    bss_begin = .;
    .bss : { *(.bss*) } 
    bss_end = .;
}
</pre>
</div>

<ol class="org-ol">
<li><p>
启动后, Raspberry Pi将 <span class="underline">kernel8.img</span> 加载到内存中, 并从文件开头开始执行
</p>
<pre class="example" id="org4b56667">
这就是为什么.text.boot部分必须放在第一的原因

也因此操作系统引导代码将被放到这里
</pre></li>
<li><span class="underline">.text</span>,  <span class="underline">.rodata</span> , 和 <span class="underline">.data</span> 部分分别包含内核编译的 <span class="underline">代码段</span> ,  <span class="underline">只读数据段</span> , 和 <span class="underline">一般数据段</span></li>
<li><span class="underline">.bss</span> 部分包含 应 <b>初始化</b> 为 <span class="underline">0</span> 的数据
<ul class="org-ul">
<li><p>
通过将此类数据放在单独的段中, 编译器可以在ELF二进制文件中节省一些空间
</p>
<pre class="example" id="orge77a667">
只有段大小存储在ELF标头中, 但段本身被省略
</pre></li>
<li><p>
将img加载到内存后, 必须手动将 <span class="underline">.bss</span> 部分初始化为0; 
</p>
<pre class="example" id="orgb3a9dbe">
这就是为什么需要记录本段的开始和结束

也就是bss_begin和bss_end符号
</pre></li>
<li><p>
对齐该段, 使其以 <span class="underline">8</span> 的倍数开头的地址开始
</p>
<pre class="example" id="orgc1fee6d">
如果该部分未对齐, 使用str指令在bss节的开头存储0会更加困难

因为str指令只能与8字节对齐的地址一起使用
</pre></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org5191b46" class="outline-2">
<h2 id="org5191b46">引导内核</h2>
<div class="outline-text-2" id="text-org5191b46">
<p>
现在是时候看看 <span class="underline">boot.S</span> 文件了. 此文件包含内核启动代码：
</p>

<div class="org-src-container">
<pre class="src src-asm">        #include <span style="color: #deb887;">"mm.h"</span>

        <span style="color: #00bfff; font-weight: bold;">.section</span> <span style="color: #deb887;">".text.boot"</span>

        <span style="color: #00bfff; font-weight: bold;">.globl</span> _start
<span style="color: #daa520; font-weight: bold;">_start</span>:
        <span style="color: #00bfff; font-weight: bold;">mrs</span>    x0, mpidr_el1        
        <span style="color: #00bfff; font-weight: bold;">and</span>    x0, x0,#0xFF        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Check processor id</span>
        <span style="color: #00bfff; font-weight: bold;">cbz</span>    x0, master        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Hang for all non-primary CPU</span>
        <span style="color: #00bfff; font-weight: bold;">b</span>    proc_hang

<span style="color: #daa520; font-weight: bold;">proc_hang</span>: 
        <span style="color: #00bfff; font-weight: bold;">b</span> proc_hang

<span style="color: #daa520; font-weight: bold;">master</span>:
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x0, bss_begin
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x1, bss_end
        <span style="color: #00bfff; font-weight: bold;">sub</span>    x1, x1, x0
        <span style="color: #00bfff; font-weight: bold;">bl</span>     memzero

        <span style="color: #00bfff; font-weight: bold;">mov</span>    sp, #LOW_MEMORY
        <span style="color: #00bfff; font-weight: bold;">bl</span>    kernel_main
</pre>
</div>

<p>
让我们详细查看该文件：
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00bfff; font-weight: bold;">.section</span> <span style="color: #deb887;">".text.boot"</span>
</pre>
</div>

<p>
首先, 指定在boot.S中的所有内容都应在 <span class="underline">.text.boot</span> 部分中. 前面已经看到, 该节通过链接描述文件放置在内核映像的开头。因此, 当内核启动时, 执行从 <span class="underline">start</span> 函数开始：
</p>

<div class="org-src-container">
<pre class="src src-asm">        <span style="color: #00bfff; font-weight: bold;">.globl</span> _start
<span style="color: #daa520; font-weight: bold;">_start</span>:
        <span style="color: #00bfff; font-weight: bold;">mrs</span>    x0, mpidr_el1        
        <span style="color: #00bfff; font-weight: bold;">and</span>    x0, x0,#0xFF        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Check processor id</span>
        <span style="color: #00bfff; font-weight: bold;">cbz</span>    x0, master        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Hang for all non-primary CPU</span>
        <span style="color: #00bfff; font-weight: bold;">b</span>    proc_hang
</pre>
</div>

<p>
这个函数做的第一件事就是检查 <span class="underline">processor id</span> . Raspberry Pi 3 有四个核心, 设备开启之后, 每个核心处理相同的代码
</p>


<pre class="example" id="orgb81ce2b">
然而, 现在不需要四个核心都工作; 希望只是用第一个核心并且将其他核心放到尾部的无穷循环中
</pre>

<p>
这就是 <b>_start</b> 函数的做的事情. 从 <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500g/BABHBJCI.html">mpidr_el1</a> 系统寄存器获取 processor ID. 如果当前 process ID 是 0, 之后执行跳转到 <span class="underline">master</span> 函数:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">master</span>:
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x0, bss_begin
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x1, bss_end
        <span style="color: #00bfff; font-weight: bold;">sub</span>    x1, x1, x0
        <span style="color: #00bfff; font-weight: bold;">bl</span>     memzero
</pre>
</div>

<p>
在这里, 通过调用 <span class="underline">memzero</span> 来清理 <span class="underline">.bss段</span> 
</p>

<pre class="example" id="org303a431">
稍后将定义 memzero 函数

在ARMv8架构中, 按照惯例, 前七个参数通过寄存器 x0 – x6 传递给调用的函数

memzero 函数仅接受两个参数: 起始地址 (bss_begin) 以及需要清理的部分的大小 (bss_end - bss_begin) 
</pre>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">mov</span>    <span style="color: #00bfff; font-weight: bold;">sp</span>, #LOW_MEMORY
<span style="color: #daa520; font-weight: bold;">bl</span>    <span style="color: #00bfff; font-weight: bold;">kernel</span>_main
</pre>
</div>

<p>
清理 <span class="underline">.bss段</span> 后, 接着 <b>初始化</b> <span class="underline">堆栈指针</span> 并将 <span class="underline">执行</span> <b>传递</b> 给 <span class="underline">kernel_main</span> 函数
</p>

<pre class="example" id="org10af326">
Raspberry Pi在地址0加载内核，这就是为什么可以将初始堆栈指针设置到足够高的任何位置的原因

即使当堆栈映像变得足够大时, 堆栈不会覆盖内核映像
</pre>

<p>
<span class="underline">LOW_MEMORY</span> 在 <span class="underline">mm.h</span> 中定义等于 <b>4MB</b> 
</p>

<pre class="example" id="orgbd9bc61">
我们的内核堆栈不会变得很大, 并且img本身很小, 因此4MB已经绰绰有余
</pre>
</div>

<div id="outline-container-orgcdea281" class="outline-3">
<h3 id="orgcdea281">assembler instructions</h3>
<div class="outline-text-3" id="text-orgcdea281">
<p>
对于那些不熟悉ARM汇编器语法的人, 快速总结一下已经使用的指令：
</p>

<ul class="org-ul">
<li><b>mrs</b> : 将值从系统寄存器加载到通用寄存器 <span class="underline">x0</span> – <span class="underline">x30</span></li>
<li><p>
<b>and</b> : 执行逻辑与运算
</p>
<pre class="example" id="org4aa0a85">
使用此命令从 mpidr_el1 寄存器中将获得的值剥离最后一个字节
</pre></li>
<li><b>cbz</b> : 比较之前执行的操作的结果, 并且如果比较结果为真, 就跳转 (在ARM术语中也叫做 <span class="underline">branch</span>) 到提供的标签</li>
<li><b>b</b> : 无条件跳转到某个标签(branch)</li>
<li><p>
<b>adr</b> : 将标签的相对地址加载到目标寄存器中
</p>
<pre class="example" id="org6e4a882">
在这种情况下, 需要指向.bss区域开始和结束的指针
</pre></li>
<li><b>sub</b> : 从两个寄存器取值互减.</li>
<li><b>bl</b> : 执行无条件分支并将返回地址存储在 <span class="underline">x30</span> 中(链接寄存器). 子程序完成后, 使用ret指令跳回到调用人地址.</li>
<li><b>mov</b> : 在寄存器之间移动一个值 或者 从常量移动到寄存器</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8e0458c" class="outline-2">
<h2 id="org8e0458c">kernel_main 函数</h2>
<div class="outline-text-2" id="text-org8e0458c">
<p>
已经看到引导代码最终将控制权传递给了 <span class="underline">kernel_main</span> 函数：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"mini_uart.h"</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">kernel_main</span>(<span style="color: #98f5ff;">void</span>)
{
    uart_init();
    uart_send_string(<span style="color: #deb887;">"Hello, world!\r\n"</span>);

    <span style="color: #00bfff; font-weight: bold;">while</span> (1) {
        uart_send(uart_recv());
    }
}
</pre>
</div>

<p>
此函数是内核中最简单的函数之一. 它与 <span class="underline">Mini UART</span> 设备 打印到屏幕并读取用户输入. 内核只是打印 Hello, world! 然后进入无限循环, 此循环从用户读取字符并将其发送回屏幕
</p>
</div>


<div id="outline-container-orgd26d045" class="outline-3">
<h3 id="orgd26d045">Raspberry Pi devices</h3>
<div class="outline-text-3" id="text-orgd26d045">
<p>
现在, 将深入研究Raspberry Pi的特定功能
</p>


<pre class="example" id="org0fdac6a">
开始之前, 建议下载BCM2837 ARM Peripherals manual
</pre>

<p>
<span class="underline">BCM2837</span> 是 Raspberry Pi 3 Model B 和 B+ 使用的芯片
</p>

<pre class="example" id="org5567e3a">
在讨论中, 有时还将提到 BCM2835 和 BCM2836 - 这些是旧版Raspberry Pi中使用的芯片的名称
</pre>

<p>
在进行到细节之前, 想分享一些有关如何使用 <span class="underline">内存映射设备</span> 的基本概念. BCM2837 是一个简单的 <a href="https://en.wikipedia.org/wiki/System_on_a_chip">SOC (System on a chip 系统)</a> 芯片. 在这样的芯片上, 通过映射到内存的寄存器访问设备. Raspberry Pi 3 保留比 <span class="underline">0x3F000000</span> 高位的地址用于 <b>设备</b> . 去启用或者配置一个特定设备, 需要写入到设备的一个寄存器中一些数据. 一个设备的寄存器在内存中占据 <span class="underline">32位</span> 。 BCM2837 ARM Peripherals 手册中描述了寄存器中每一位的作用
</p>

<pre class="example" id="org24e1f51">
在手册中看一下 1.2.3节 ARM 的物理地址和有关更多为什么用 0x3F000000 作为基地址的背景信息

即使在整个手册中使用  0x7E000000 
</pre>

<p>
从 kernel_main 函数, 可以想到将使用 Mini UART设备. UART代表  <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">Universal asynchronous receiver-transmitter</a> （通用异步收发器）。该设备能够将存储在其存储器映射寄存器之一中的值转换为 <span class="underline">高电压</span> 和 <span class="underline">低电压</span> <b>序列</b> . 该序列通过 <span class="underline">TTL转串口电缆</span> 传递到计算机, 并由 <span class="underline">终端仿真器</span> <b>解释</b> 
</p>

<pre class="example" id="org83916ca">
我们将使用Mini UART来促进与Raspberry Pi的通信

如果要查看Mini UART寄存器的规范, 请阅读 BCM2837 ARM Peripherals手册
</pre>

<p>
Raspberry Pi具有两个UART： <span class="underline">MINI UART</span> 和 <span class="underline">PL011 UART</span> 
</p>

<pre class="example" id="org420062e">
在本教程中, 我们将仅使用第一个教程, 因为它更简单

但是, 有一个可选的exercise显示了如何使用PL011 UART
</pre>
</div>
<div id="outline-container-orgbd761a1" class="outline-4">
<h4 id="orgbd761a1">GPIO</h4>
<div class="outline-text-4" id="text-orgbd761a1">
<p>
需要熟悉的另一个设备是 <b>GPIO</b>  <a href="https://en.wikipedia.org/wiki/General-purpose_input/output">General-purpose input/output</a> （通用输入/输出）。GPIO负责控制GPIO引脚. 应该能够在下图中轻松识别它们：
</p>


<div id="org6b1088e" class="figure">
<p><img src="../pic/gpio-pins.jpg" alt="gpio-pins.jpg" width="70%" />
</p>
</div>

<p>
GPIO可用于配置不同GPIO引脚的行为. 例如, 为了能够使用Mini UART, 需要 <b>激活</b> <span class="underline">引脚14</span> 和 <span class="underline">15</span> 并将其设置为使用此设备。下图说明了如何将数字分配给GPIO引脚：
</p>

<div id="org51f4fdc" class="figure">
<p><img src="../pic/gpio-numbers.png " alt="gpio-numbers.png " width="70%" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9f761b7" class="outline-3">
<h3 id="org9f761b7">初始化 Mini UART</h3>
<div class="outline-text-3" id="text-org9f761b7">
<p>
现在看一下如何初始化 MINI UART。该代码在 <span class="underline">mini_uart.c</span> :
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uart_init</span> ( <span style="color: #98f5ff;">void</span> )
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">selector</span>;

    selector = get32(GPFSEL1);
    selector &amp;= ~(7&lt;&lt;12);                   <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#25226; gpio14 &#28165;&#38500;</span>
    selector |= 2&lt;&lt;12;                      <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#25226; gpio14 &#35774;&#32622;&#20026; &#27169;&#24335;5 (alt5) </span>
                                selector &amp;= ~(7&lt;&lt;15);                   <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#25226; gpio15 &#28165;&#38500;</span>
    selector |= 2&lt;&lt;15;                      <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#25226; gpio15 &#35774;&#32622;&#20026; &#27169;&#24335;5 (alt5)</span>
    put32(GPFSEL1,selector);

    put32(GPPUD,0);
    delay(150);
    put32(GPPUDCLK0,(1&lt;&lt;14)|(1&lt;&lt;15));
    delay(150);
    put32(GPPUDCLK0,0);

    put32(AUX_ENABLES,1);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160; mini uart (&#21516;&#26102;&#20801;&#35768;&#20889;&#20837;&#23427;&#30340;&#23492;&#23384;&#22120;) </span>
                               put32(AUX_MU_CNTL_REG,0);               <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#29992;&#33258;&#21160;&#27969;&#25511;, &#25509;&#25910;&#22120;&#20197;&#21450;&#21457;&#23556;&#22120; (&#36825;&#26159;&#26242;&#26102;&#30340;) </span>
                                                          put32(AUX_MU_IER_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#29992;&#25509;&#21463;&#21644;&#21457;&#36865;&#20013;&#26029;</span>
    put32(AUX_MU_LCR_REG,3);                <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#29992; 8bit &#27169;&#24335;</span>
    put32(AUX_MU_MCR_REG,0);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25226; RTS line &#35774;&#32622;&#20026;&#27704;&#36828;&#39640;&#30005;&#24179;</span>
    put32(AUX_MU_BAUD_REG,270);             <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#27604;&#29305;&#29575;&#20026; 115200</span>

    put32(AUX_MU_CNTL_REG,3);               <span style="color: #5f9ea0; font-style: italic;">//   </span><span style="color: #5f9ea0; font-style: italic;">&#26368;&#21518;, &#21551;&#29992;&#21457;&#23556;&#22120;&#21644;&#25509;&#25910;&#22120;</span>
}
</pre>
</div>

<p>
在这里, 我们使用两个函数 <span class="underline">put32</span> 和 <span class="underline">get32</span> . 这些功能非常简单; 它们允许在32位寄存器中读写数据
</p>
<pre class="example" id="orgf61651e">
这两个函 utils.S 中实现

uart_init 是本课中最复杂, 最重要的功能之一, 在接下来的三个小节里继续进行研究
</pre>
</div>
<div id="outline-container-orgd515f33" class="outline-4">
<h4 id="orgd515f33">GPIO 功能选择</h4>
<div class="outline-text-4" id="text-orgd515f33">
<p>
首先, 需要 <b>激活</b> <span class="underline">GPIO引脚</span> . 大多数引脚可以与不同的设备一起使用, 所以在使用特定的引脚之前, 需要设置引脚的 <span class="underline">替代功能</span> (alternative function). 替代功能可以为每个引脚设置的0到5之间的数字, 并配置将哪个设备连接到该引脚。在下图中可以看到所有可用的GPIO替代功能的列表：
</p>

<div id="org6ce78a7" class="figure">
<p><img src="../pic/alt.png" alt="alt.png" width="70%" />
</p>
</div>

<p>
在这里可以看到 引脚 <span class="underline">14</span> 和 <span class="underline">15</span> 具有 <span class="underline">TXD1</span> 和 <span class="underline">RXD1</span> 替代功能. 这意味着如果为引脚14和15选择替代功能编号 <span class="underline">5</span> , 它们将分别用作 <b>Mini UART发送数据引脚</b> 和 <b>Mini UART接收数据引脚</b> 。 <span class="underline">GPFSEL1</span> 寄存器用于控制引脚 <span class="underline">10-19</span> 的替代功能 
</p>


<div id="orge82e113" class="figure">
<p><img src="../pic/gpfsel1.png" alt="gpfsel1.png" width="70%" />
</p>
</div>

<p>
下面这些代码用于配置GPIO引脚14和15以与Mini UART器件配合使用：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">selector</span>;

selector = get32(GPFSEL1);
selector &amp;= ~(7&lt;&lt;12);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558; gpio14 &#28165;&#38500;</span>
selector |= 2&lt;&lt;12;                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558; gpio14 &#35774;&#32622;&#20026; 5 (alt5)</span>
selector &amp;= ~(7&lt;&lt;15);                   <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#23558; gpio15 &#28165;&#38500;</span>
selector |= 2&lt;&lt;15;                      <span style="color: #5f9ea0; font-style: italic;">//  </span><span style="color: #5f9ea0; font-style: italic;">&#25226; gpio15 &#35774;&#32622;&#20026;5 (alt 5) </span>
    <span style="color: #daa520; font-weight: bold;">put32</span>(GPFSEL1, selector);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6cc327" class="outline-4">
<h4 id="orge6cc327">GPIO pull-up/down</h4>
<div class="outline-text-4" id="text-orge6cc327">
<pre class="example" id="orgbfad0e9">
当使用Raspberry Pi GPIO引脚时, 经常会遇到诸如上拉/下拉等术语. 这些概念的详细解释在 https://grantwinney.com/using-pullup-and-pulldown-resistors-on-the-raspberry-pi/ 这篇 文章中.

对于那些懒于阅读整篇文章的人, 简要解释上拉/下拉概念
</pre>

<p>
如果使用特定的引脚作为输入, 并且不将该引脚连接任何东西, 则将无法识别该引脚的值是1还是0. 实际上, 设备将报告为随机值.  <span class="underline">上拉</span> / <span class="underline">下拉</span> 机制可解决此问题. 如果将引脚设置为上拉状态, 但没有任何连接, 则引脚将始终报告 <span class="underline">1</span> (对于下拉状态, 该值始终为0)
</p>

<pre class="example" id="org06148d7">
就我们而言, 既不需要上拉状态也不需要下拉状态, 因为 14 和 15 引脚将一直保持连接状态

即使重新启动后, 引脚状态也会保留, 因此在使用任何引脚之前, 总是必须初始化其状态

有三种可用状态: 上拉, 下拉和两者都不显示(以删除当前的上拉或下拉状态), 这里我们需要第三个
</pre>

<p>
引脚状态之间的切换不是一个非常简单的过程, 因为它需要物理上触发电路上的一个开关. 该过程涉及 <span class="underline">GPPUD</span> 和 <span class="underline">GPPUDCLK</span> 寄存器。
在 BCM2837 ARM Peripherals 手册的第101页中进行了描述如果通过 GPIO上/下时钟寄存器 控制 相应GPIO引脚 上下拉的设置. 这些寄存器必须与GPPUD结合使用 寄存器以影响GPIO上拉/下拉更改
</p>


<pre class="example" id="org00907d9">
需要以下事件顺序：

1. 写入GPPUD以设置所需的控制信号(即上拉或下拉, 或都不设置以消除当前的上拉/下拉)
2. 等待150个周期：这为控制信号提供了所需的建立时间
3. 写入 GPPUDCLK0/1 以将控制信号输入您要修改的GPIO引脚：注意只有接收时钟的引脚会被修改, 所有其他将保持以前的状态.
4. 等待150个循环： 这为控制信号提供了所需的保持时间
5. 写入GPPUD以删除控制信号
6. 写入 GPPUDCLK0/1 以删除时钟
</pre>

<p>
此过程描述了如何从引脚上移除上拉和下拉状态。在下面的代码中, 对引脚14和15进行操作：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(GPPUD, 0);
delay(150);
<span style="color: #daa520; font-weight: bold;">put32</span>(GPPUDCLK0, (1&lt;&lt;14)|(1&lt;&lt;15));
delay(150);
<span style="color: #daa520; font-weight: bold;">put32</span>(GPPUDCLK0, 0);
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e27924" class="outline-4">
<h4 id="org8e27924">初始化Mini UART</h4>
<div class="outline-text-4" id="text-org8e27924">
<p>
现在 Mini UART已连接到GPIO引脚, 并且已配置了这些引脚. uart_init函数的其余部分专用于Mini UART初始化
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_ENABLES,1);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160; mini uart (&#21516;&#26102;&#20801;&#35768;&#20889;&#20837;&#23427;&#30340;&#23492;&#23384;&#22120;) </span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,0);               <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#29992;&#33258;&#21160;&#27969;&#25511;, &#25509;&#25910;&#22120;&#20197;&#21450;&#21457;&#23556;&#22120; (&#36825;&#26159;&#26242;&#26102;&#30340;) </span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_IER_REG,0);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#29992;&#25509;&#21463;&#21644;&#21457;&#36865;&#20013;&#26029;</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_LCR_REG,3);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#29992; 8bit &#27169;&#24335;</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_MCR_REG,0);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25226; RTS line &#35774;&#32622;&#20026;&#27704;&#36828;&#39640;&#30005;&#24179;</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_BAUD_REG,270);             <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#27604;&#29305;&#29575;&#20026; 115200</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_IIR_REG,6);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Clear FIFO</span>

<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,3);               <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26368;&#21518;, &#21551;&#29992;&#21457;&#23556;&#22120;&#21644;&#25509;&#25910;&#22120;</span>
</pre>
</div>

<p>
逐行检查此代码段:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_ENABLES,1);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160; mini uart (&#21516;&#26102;&#20801;&#35768;&#20889;&#20837;&#23427;&#30340;&#23492;&#23384;&#22120;)</span>
</pre>
</div>

<p>
这行启动了 Mini UART. 必须在一开始就这样做, 因为这样才可以访问所有其他 Mini UART 寄存器
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,0);               <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#29992;&#33258;&#21160;&#27969;&#25511;, &#25509;&#25910;&#22120;&#20197;&#21450;&#21457;&#23556;&#22120; (&#36825;&#26159;&#26242;&#26102;&#30340;)</span>
</pre>
</div>

<p>
在这里, 在配置完成之前禁用接收器和发送器
</p>

<pre class="example" id="org663c620">
接下来将永久禁用自动流控制, 因为它需要使用其他GPIO引脚, 而TTL转串口电缆不支持
</pre>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_IER_REG,0);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31105;&#29992;&#25509;&#21463;&#21644;&#21457;&#36865;&#20013;&#26029;</span>
</pre>
</div>

<p>
可以配置Mini UART, 以在每次有新数据可用时产生处理器中断
</p>

<pre class="example" id="org476ebb5">
将在以后中开始处理中断, 所以现在禁用此功能
</pre>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_LCR_REG,3);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#29992; 8bit &#27169;&#24335;</span>
</pre>
</div>

<p>
MINI UART可以支持7位或8位操作. 这是因为ASCII字符对于标准集是7位, 扩展集是8位。这里使用8位模式
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_MCR_REG,0);                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25226; RTS line &#35774;&#32622;&#20026;&#27704;&#36828;&#39640;&#30005;&#24179;</span>
</pre>
</div>

<p>
RTS line 用于流量控制, 不需要它. 始终将其设置为高.
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_BAUD_REG,270);             <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set baud rate to 115200</span>
</pre>
</div>

<p>
波特率是在通信信道中传输信息的速率： <span class="underline">115200</span> 表示该串行端口每秒最多可传输115200位。Raspberry Pi 的 MINI UART设备的波特率应与终端仿真器中的波特率相同。Mini UART根据以下公式计算波特率:
</p>
<pre class="example" id="org0d77285">
baudrate = system_clock_freq / (8 * ( baudrate_reg + 1 ))
</pre>

<p>
system_clock_freq是 250 MHz, 这样就可以轻松计算出 baudrate_reg 应为 <span class="underline">270</span> 
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,3);               <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26368;&#21518;, &#21551;&#29992;&#21457;&#23556;&#22120;&#21644;&#25509;&#25910;&#22120;</span>
</pre>
</div>

<p>
执行完此行后, Mini UART准备就绪！
</p>
</div>
</div>
</div>

<div id="outline-container-orgfa63a8a" class="outline-3">
<h3 id="orgfa63a8a">使用Mini UART</h3>
<div class="outline-text-3" id="text-orgfa63a8a">
<p>
Mini UART准备好后, 可以尝试使用它来发送和接收一些数据. 为此, 实现了以下两个函数：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uart_send</span> ( <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">c</span> )
{
    <span style="color: #00bfff; font-weight: bold;">while</span>(1) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(get32(AUX_MU_LSR_REG)&amp;0x20) 
            <span style="color: #00bfff; font-weight: bold;">break</span>;
    }
    put32(AUX_MU_IO_REG,c);
}

<span style="color: #98f5ff;">char</span> <span style="color: #daa520; font-weight: bold;">uart_recv</span> ( <span style="color: #98f5ff;">void</span> )
{
    <span style="color: #00bfff; font-weight: bold;">while</span>(1) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(get32(AUX_MU_LSR_REG)&amp;0x01) 
            <span style="color: #00bfff; font-weight: bold;">break</span>;
    }
    <span style="color: #00bfff; font-weight: bold;">return</span>(get32(AUX_MU_IO_REG)&amp;0xFF);
}
</pre>
</div>

<p>
这两个函数：
</p>
<ol class="org-ol">
<li>都以无限循环开始, 其目的是验证设备是否已准备好发送或接收数据. 使用 <span class="underline">AUX_MU_LSR_REG</span> 寄存器来执行此操作
<ul class="org-ul">
<li>第 <span class="underline">零</span> 位, 如果设置为 <span class="underline">1</span> , 表示数据已 <b>准备就绪</b> ; 这意味着我们可以从 MINI UART中 <b>读取</b></li>
<li>第 <span class="underline">五</span> 位, 如果设置为 <span class="underline">1</span> , 表示发射器是 <b>空闲</b> 的, 这意味着我们可以 <b>写入</b> MINI UART</li>
</ul></li>
<li>使用 <span class="underline">AUX_MU_IO_REG</span> 来 <b>存储</b> 已发送字符的值或 <b>读取</b> 已接收字符的值</li>
</ol>

<p>
还有一个非常简单的功能, 能够发送字符串而不是字符：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uart_send_string</span>(<span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">str</span>)
{
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; str[i] != <span style="color: #deb887;">'\0'</span>; i ++) {
        uart_send((<span style="color: #98f5ff;">char</span>)str[i]);
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgab03da8" class="outline-2">
<h2 id="orgab03da8">Raspberry Pi 配置</h2>
<div class="outline-text-2" id="text-orgab03da8">
<p>
Raspberry Pi的启动顺序如下(简化):
</p>
<ol class="org-ol">
<li>设备上电</li>
<li>GPU启动并从启动分区读取 <span class="underline">config.txt</span> 文件. 该文件包含一些配置参数, GPU使用这些参数进一步调整启动顺序</li>
<li><span class="underline">kernel8.img</span> 被加载到内存中并执行</li>
</ol>

<p>
为了能够运行我们的简单操作系统, config.txt文件应为以下文件:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #4eee94;">kernel_old</span>=1
<span style="color: #4eee94;">disable_commandline_tags</span>=1
</pre>
</div>

<ul class="org-ul">
<li>kernel_old=1: 内核将被加载到内存地址0</li>
<li>disable_commandline_tags: gpu不会传递任何参数给加载的内核</li>
</ul>
</div>
</div>

<div id="outline-container-org6f55ed9" class="outline-2">
<h2 id="org6f55ed9">内核测试</h2>
<div class="outline-text-2" id="text-org6f55ed9">
<pre class="example" id="orgb06d8be">
现在已经遍历了所有源代码, 是时候来看一下它的工作了
</pre>
<p>
要构建和测试内核, 需要执行以下操作：
</p>
<ol class="org-ol">
<li>执行 <span class="underline">./build.sh</span> 或者 <span class="underline">./build.bat</span> 从 src/lesson01 去构建内核</li>
<li><p>
将生成的 <span class="underline">kernel8.img</span> 文件 <b>复制</b> 到 Raspberry Pi 闪存卡的 <span class="underline">boot 分区</span> 和 <b>删除</b> <span class="underline">kernel7.img</span>
</p>
<pre class="example" id="orgb86d974">
请保留启动分区中的所有其他文件
</pre></li>
<li>如上一节所述修改 <span class="underline">config.txt</span> 文件</li>
<li>连接 <span class="underline">USB至TTL</span> 串行电缆</li>
<li>给 Raspberry Pi 供电</li>
<li>打开终端模拟器. 应该可以在那里看到 Hello, world！ 消息</li>
</ol>

<pre class="example" id="org99c5ff5">
请注意, 上述步骤顺序假定 SD卡上已安装Raspbian

</pre>

<p>
当然也可以使用空的SD卡运行RPi OS
</p>
<ol class="org-ol">
<li>准备 SD卡:
<ul class="org-ul">
<li>使用 MBR分区表</li>
<li><p>
将 boot 分区格式化为 FAT32
</p>
<pre class="example" id="orgc594d1d">
该卡的格式应与安装Raspbian所需的格式完全相同

可以查看 HOW TO FORMAT AN SD CARD AS FAT 部分在 official documenation 官方文档 来获取更多信息
</pre></li>
</ul></li>
<li>将以下文件复制到卡中：
<ul class="org-ul">
<li><span class="underline">bootcode.bin</span> : 这是 <span class="underline">GPU引导程序</span> , 它包含用于 <b>启动</b> GPU和 <b>加载</b> GPU固件的GPU代码</li>
<li><span class="underline">start.elf</span> 这是 <span class="underline">GPU固件</span> . 它 <b>读取</b> <span class="underline">config.txt</span> , 并使GPU从 <span class="underline">kernel8.img</span> 加载并运行ARM特定的用户代码</li>
</ul></li>
<li>复制 <span class="underline">kernel8.img</span> 和 <span class="underline">config.txt</span> 文件</li>
<li>连接 <span class="underline">USB至TTL</span> 串行电缆</li>
<li>给 Raspberry Pi 供电</li>
<li>使用终端仿真器连接到RPi OS</li>
</ol>

<pre class="example" id="org6e8ffdb">
不幸的是, 所有Raspberry Pi固件文件都是闭源的没有文档

有关Raspberry Pi启动顺序的更多信息, 可以参考一些非官方的资料, 比如
(https://raspberrypi.stackexchange.com/questions/10442/what-is-the-boot-sequence) StackExchange 问​​题
(https://github.com/DieterReuter/workshop-raspberrypi-64bit-os/blob/master/part1-bootloader.md) 这个 Github 仓库
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="linux.html">Next: Linux 项目结构</a></td>
<td class="org-left"><a href="initialization.html">Home: 内核初始化</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
