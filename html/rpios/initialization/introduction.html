<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Introducing RPi OS, or bare-metal "Hello, World!"</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="./initialization.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Introducing RPi OS, or bare-metal "Hello, World!"</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5d5f8e9">Project structure</a></li>
<li><a href="#orgcdb8261">Makefile</a></li>
<li><a href="#org7cc1d32">The linker script</a></li>
<li><a href="#orgce842b2">Booting the kernel</a>
<ul>
<li><a href="#orgcdea281">assembler instructions</a></li>
</ul>
</li>
<li><a href="#org3f9fd33">The kernel_main function</a>
<ul>
<li><a href="#orgd26d045">Raspberry Pi devices</a>
<ul>
<li><a href="#orgbd761a1">GPIO</a></li>
</ul>
</li>
<li><a href="#orgda891db">Mini UART initialization</a>
<ul>
<li><a href="#orgaa73207">GPIO alternative function selection</a></li>
<li><a href="#orge6cc327">GPIO pull-up/down</a></li>
<li><a href="#org72f81eb">Initializing the Mini UART</a></li>
</ul>
</li>
<li><a href="#org9ff1731">Sending data using the Mini UART</a></li>
</ul>
</li>
<li><a href="#org407de89">Raspberry Pi config</a></li>
<li><a href="#org6cee46d">Testing the kernel</a></li>
</ul>
</div>
</div>
<p>
We are going to start our journey in OS development by writing a small, bare-metal "Hello, World" application. 
</p>
<div id="outline-container-org5d5f8e9" class="outline-2">
<h2 id="org5d5f8e9">Project structure</h2>
<div class="outline-text-2" id="text-org5d5f8e9">
<p>
Let's briefly describe the main components of this folder:
</p>
<ol class="org-ol">
<li><span class="underline">Makefile</span> : We will use the make utility to build the kernel. make's behavior is configured by a Makefile, which contains instructions on how to compile and link the source code.</li>
<li><span class="underline">build.sh</span> or <span class="underline">build.bat</span> : You'll need these files if you want to build the kernel using Docker. You won't need to have the make utility or the compiler toolchain installed on your laptop.</li>
<li><span class="underline">src</span> : This folder contains all of the source code.</li>
<li><span class="underline">include</span> : All of the header files are placed here.</li>
</ol>
</div>
</div>
<div id="outline-container-orgcdb8261" class="outline-2">
<h2 id="orgcdb8261">Makefile</h2>
<div class="outline-text-2" id="text-orgcdb8261">
<p>
Now let's take a closer look at the project Makefile. The primary purpose of the make utility is to automatically determine what pieces of a program need to be recompiled, and to issue commands to recompile them. If you are not familiar with make and Makefiles, I recommend that you read this article. The Makefile used in the first lesson can be found here. The whole Makefile is listed below:
</p>

<div class="org-src-container">
<pre class="src src-sh">ARMGNU ?= aarch64-linux-gnu

COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
ASMOPS = -Iinclude 

BUILD_DIR = build
SRC_DIR = src

all : kernel8.img

clean :
rm -rf $(BUILD_DIR) *.img 

$(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
mkdir -p $(@D)
$(ARMGNU)-gcc $(COPS) -MMD -c $&lt; -o $<span style="color: #4eee94;">@</span>

$(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
$(ARMGNU)-gcc $(ASMOPS) -MMD -c $&lt; -o $<span style="color: #4eee94;">@</span>

C_FILES = $(wildcard $(SRC_DIR)/*.c)
ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)

DEP_FILES = $(OBJ_FILES:%.o=%.d)
-include $(DEP_FILES)

kernel8.img: $(SRC_DIR)/linker.ld $(OBJ_FILES)
$(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o $(BUILD_DIR)/kernel8.elf  $(OBJ_FILES)
$(ARMGNU)-objcopy $(BUILD_DIR)/kernel8.elf -O binary kernel8.img
</pre>
</div>

<p>
Now, let's inspect this file in detail:
</p>

<div class="org-src-container">
<pre class="src src-sh">ARMGNU ?= aarch64-linux-gnu
</pre>
</div>

<p>
The Makefile starts with a variable definition. <span class="underline">ARMGNU</span> is a cross-compiler prefix. We need to use a cross-compiler because we are compiling the source code for the arm64 architecture on an x86 machine. So instead of gcc, we will use <span class="underline">aarch64-linux-gnu-gcc</span> 
</p>

<div class="org-src-container">
<pre class="src src-sh">COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only
ASMOPS = -Iinclude 
</pre>
</div>


<p>
<span class="underline">COPS</span> and <span class="underline">ASMOPS</span> are options that we pass to the compiler when compiling C and assembler code, respectively. These options require a short explanation:
</p>
<ul class="org-ul">
<li><span class="underline">-Wall</span> : Show all warnings</li>
<li><p>
<span class="underline">-nostdlib</span> : Don't use the C standard library
</p>
<pre class="example" id="org34d1098">
Most of the calls in the C standard library eventually interact with the operating system

We are writing a bare-metal program, and we don't have any underlying operating system

so the C standard library is not going to work for us anyway
</pre></li>
<li><p>
<span class="underline">-nostartfiles</span> Don't use standard startup files
</p>
<pre class="example" id="orgd1decf8">
Startup files are responsible for setting an initial stack pointer, initializing static data, and jumping to the main entry point

We are going to do all of this by ourselves
</pre></li>
<li><p>
<span class="underline">-ffreestanding</span> A freestanding environment is an environment in which the standard library may not exist, and program startup may not necessarily be at main
</p>
<pre class="example" id="org0bcf051">
The option -ffreestanding directs the compiler to not assume that standard functions have their usual definition
</pre></li>
<li><span class="underline">-Iinclude</span> : Search for header files in the include folder</li>
<li><p>
<span class="underline">-mgeneral-regs-only</span> : Use only general-purpose registers. ARM processors also have NEON registers. We don't want the compiler to use them because they add additional complexity 
</p>
<pre class="example" id="org8dfb561">
for example, we will need to store the registers during a context switch
</pre>

<div class="org-src-container">
<pre class="src src-sh">BUILD_DIR = build
SRC_DIR = src
</pre>
</div>

<p>
<span class="underline">SRC_DIR</span> and <span class="underline">BUILD_DIR</span> are directories that contain source code and compiled object files, respectively 
</p>

<div class="org-src-container">
<pre class="src src-sh">all : kernel8.img

clean :
rm -rf $(BUILD_DIR) *.img 
</pre>
</div>

<p>
Next, we define make targets. The first two targets are pretty simple: 
</p>
<ul class="org-ul">
<li>the all target is the default one, and it is executed whenever you type make without any arguments (make always uses the first target as the default). This target just redirects all work to a different target, kernel8.img</li>
<li>The clean target is responsible for deleting all compilation artifacts and the compiled kernel image</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
mkdir -p $(@D)
$(ARMGNU)-gcc $(COPS) -MMD -c $&lt; -o $<span style="color: #4eee94;">@</span>

$(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
$(ARMGNU)-gcc $(ASMOPS) -MMD -c $&lt; -o $<span style="color: #4eee94;">@</span>
</pre>
</div>

<p>
The next two targets are responsible for compiling C and assembler files. If, for example, in the src directory we have <span class="underline">foo.c</span> and <span class="underline">foo.S</span> files, they will be compiled into <span class="underline">build/foo_c.o</span> and <span class="underline">build/foo_s.o</span> , respectively. <b>$&lt;</b> and <b>$@</b> are substituted at runtime with the <b>input and output filenames</b> (foo.c and foo_c.o). Before compiling C files, we also create a build directory in case it doesn't exist yet 
</p>

<div class="org-src-container">
<pre class="src src-sh">C_FILES = $(wildcard $(SRC_DIR)/*.c)
ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)
</pre>
</div>

<p>
Here we are building an array of all object files (OBJ_FILES) created from the concatenation of both C and assembler source files (see Substitution References).
</p>

<div class="org-src-container">
<pre class="src src-sh">DEP_FILES = $(OBJ_FILES:%.o=%.d)
-include $(DEP_FILES)
</pre>
</div>

<p>
The next two lines are a little bit tricky. If you take a look at how we defined our compilation targets for both C and assembler source files, you will notice that we used the <span class="underline">-MMD</span> parameter. This parameter instructs the gcc compiler to create a dependency file for each generated object file. A dependency file defines all of the dependencies for a particular source file. These dependencies usually contain a list of all included headers. We need to include all of the generated dependency files so that make knows what exactly to recompile in case a header changes 
</p>

<div class="org-src-container">
<pre class="src src-sh">$(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o kernel8.elf  $(OBJ_FILES)
</pre>
</div>

<p>
We use the <span class="underline">OBJ_FILES</span> array to build the <span class="underline">kernel8.elf</span> file. We use the linker script <span class="underline">src/linker.ld</span> to define the <b>basic layout of the resulting executable image</b> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$(ARMGNU)-objcopy kernel8.elf -O binary kernel8.img
</pre>
</div>

<p>
kernel8.elf is in the <b>ELF</b> format
</p>

<pre class="example" id="org7e3ef99">
The problem is that ELF files are designed to be executed by an operating system
</pre>

<p>
To write a bare-metal program, we need to extract all executable and data sections from the ELF file and put them into the kernel8.img image. The trailing <span class="underline">8</span> denotes ARMv8 which is a 64-bit architecture. This filename tells the firmware to <b>boot</b> the processor into <span class="underline">64-bit</span> mode. You can also boot the CPU in the 64-bit mode by using <span class="underline">arm_control=0x200</span> flag in the config.txt file
</p>

<pre class="example" id="org67ae10e">
The RPi OS previously used this method, and you can still find it in some of the exercise answers

However, arm_control flag is undocumented and it is preferable to use kernel8.img naming convention instead
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org7cc1d32" class="outline-2">
<h2 id="org7cc1d32">The linker script</h2>
<div class="outline-text-2" id="text-org7cc1d32">
<p>
The primary purpose of the linker script is to describe how the sections in the input object files ( <span class="underline">c.o</span> and <span class="underline">s.o</span> ) should be mapped into the output file ( <span class="underline">.elf</span> )
</p>

<pre class="example" id="org4fdcc9d">
More information about linker scripts can be found: https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts
</pre>

<p>
Now let's take a look at the RPi OS linker script:
</p>

<div class="org-src-container">
<pre class="src src-sh">SECTIONS
{
    .text.boot : { *(.text.boot) }
    .text :  { *(.text) }
    .rodata : { *(.rodata) }
    .data : { *(.data) }
    . = ALIGN(0x8);
    bss_begin = .;
    .bss : { *(.bss*) } 
    bss_end = .;
}
</pre>
</div>

<ol class="org-ol">
<li><p>
After startup, the Raspberry Pi loads <span class="underline">kernel8.img</span> into memory and starts execution from the beginning of the file. That's why the <span class="underline">.text.boot section</span> must be first
</p>
<pre class="example" id="org6e8d424">
we are going to put the OS startup code inside this section
</pre></li>
<li>The <span class="underline">.text</span> , <span class="underline">.rodata</span> , and <span class="underline">.data</span> sections contain <b>kernel-compiled</b> <span class="underline">instructions</span> , <span class="underline">read-only data</span> , and <span class="underline">normal data</span></li>
<li>The <span class="underline">.bss</span> section contains data that should be initialized to 0:
<ul class="org-ul">
<li><p>
By putting such data in a separate section, the compiler can save some space in the ELF binary
</p>
<pre class="example" id="orgc5f2ff4">
only the section size is stored in the ELF header, but the section itself is omitted
</pre></li>
<li><p>
After loading the image into memory, we must initialize the .bss section to 0
</p>
<pre class="example" id="orgbfd8d5b">
that's why we need to record the start and end of the section

hence the bss_begin and bss_end symbols
</pre></li>
<li><p>
align the section so that it starts at an address that is a <span class="underline">multiple</span> of 8
</p>
<pre class="example" id="orgdf4ff1e">
If the section is not aligned, it would be more difficult to use the str instruction to store 0 at the beginning of the bss section

because the str instruction can be used only with 8-byte-aligned addresses
</pre></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgce842b2" class="outline-2">
<h2 id="orgce842b2">Booting the kernel</h2>
<div class="outline-text-2" id="text-orgce842b2">
<p>
Now it is time to take a look at the <span class="underline">boot.S</span> file. This file contains the kernel startup code:
</p>

<div class="org-src-container">
<pre class="src src-asm">        #include <span style="color: #deb887;">"mm.h"</span>

        <span style="color: #00bfff; font-weight: bold;">.section</span> <span style="color: #deb887;">".text.boot"</span>

        <span style="color: #00bfff; font-weight: bold;">.globl</span> _start
<span style="color: #daa520; font-weight: bold;">_start</span>:
        <span style="color: #00bfff; font-weight: bold;">mrs</span>    x0, mpidr_el1        
        <span style="color: #00bfff; font-weight: bold;">and</span>    x0, x0,#0xFF        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Check processor id</span>
        <span style="color: #00bfff; font-weight: bold;">cbz</span>    x0, master        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Hang for all non-primary CPU</span>
        <span style="color: #00bfff; font-weight: bold;">b</span>    proc_hang

<span style="color: #daa520; font-weight: bold;">proc_hang</span>: 
        <span style="color: #00bfff; font-weight: bold;">b</span> proc_hang

<span style="color: #daa520; font-weight: bold;">master</span>:
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x0, bss_begin
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x1, bss_end
        <span style="color: #00bfff; font-weight: bold;">sub</span>    x1, x1, x0
        <span style="color: #00bfff; font-weight: bold;">bl</span>     memzero

        <span style="color: #00bfff; font-weight: bold;">mov</span>    sp, #LOW_MEMORY
        <span style="color: #00bfff; font-weight: bold;">bl</span>    kernel_main
</pre>
</div>

<p>
Let's review this file in detail:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00bfff; font-weight: bold;">.section</span> <span style="color: #deb887;">".text.boot"</span>
</pre>
</div>


<p>
First, we specify that everything defined in boot.S should go in the <span class="underline">.text.boot</span> section. Previously, we saw that this section is placed at the beginning of the kernel image by the linker script. So when the kernel is started, execution begins at the <span class="underline">start</span> function: 
</p>

<div class="org-src-container">
<pre class="src src-asm">        <span style="color: #00bfff; font-weight: bold;">.globl</span> _start
<span style="color: #daa520; font-weight: bold;">_start</span>:
        <span style="color: #00bfff; font-weight: bold;">mrs</span>    x0, mpidr_el1        
        <span style="color: #00bfff; font-weight: bold;">and</span>    x0, x0,#0xFF        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Check processor id</span>
        <span style="color: #00bfff; font-weight: bold;">cbz</span>    x0, master        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Hang for all non-primary CPU</span>
        <span style="color: #00bfff; font-weight: bold;">b</span>    proc_hang
</pre>
</div>

<p>
The first thing this function does is check the processor ID. The Raspberry Pi 3 has four core processors, and after the device is powered on, each core begins to execute the same code
</p>

<pre class="example" id="org3ce542f">
However, we don't want to work with four cores

we want to work only with the first one and put all of the other cores in an endless loop
</pre>

<p>
This is exactly what the start function is responsible for. It gets the processor ID from the <span class="underline">mpidr_el1</span> system register. If the current process ID is 0, then execution is transferred to the master function:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">master</span>:
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x0, bss_begin
        <span style="color: #00bfff; font-weight: bold;">adr</span>    x1, bss_end
        <span style="color: #00bfff; font-weight: bold;">sub</span>    x1, x1, x0
        <span style="color: #00bfff; font-weight: bold;">bl</span>     memzero
</pre>
</div>


<p>
Here, we clean the <span class="underline">.bss</span> section by calling <span class="underline">memzero</span> 
</p>

<pre class="example" id="orgd2ee76d">
We will define this function memzero later

In ARMv8 architecture, by convention, the first seven arguments are passed to the called function via registers x0 ~ x6

The memzero function accepts only two arguments: the start address (bss_begin) and the size of the section needed to be cleaned (bss_end - bss_begin) 
</pre>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #daa520; font-weight: bold;">mov</span>    <span style="color: #00bfff; font-weight: bold;">sp</span>, #LOW_MEMORY
<span style="color: #daa520; font-weight: bold;">bl</span>    <span style="color: #00bfff; font-weight: bold;">kernel</span>_main
</pre>
</div>

<p>
After cleaning the .bss section, we <b>initialize</b> the <span class="underline">stack pointer</span> and pass <b>execution</b> to the <span class="underline">kernel_main</span> function. The Raspberry Pi loads the kernel at address <span class="underline">0</span> 
</p>

<pre class="example" id="org35beaea">
that's why the initial stack pointer can be set to any location high enough so that stack will not override the kernel image when it grows sufficiently large
</pre>

<p>
<span class="underline">LOW_MEMORY</span> is defined in <span class="underline">mm.h</span> and is equal to <span class="underline">4MB</span> 
</p>

<pre class="example" id="orgd75a0e4">
Our kernel's stack won't grow very large and the image itself is tiny

so 4MB is more than enough for us
</pre>
</div>
<div id="outline-container-orgcdea281" class="outline-3">
<h3 id="orgcdea281">assembler instructions</h3>
<div class="outline-text-3" id="text-orgcdea281">
<p>
For those of you who are not familiar with ARM assembler syntax, let me quickly summarize the instructions that we have used:
</p>
<ul class="org-ul">
<li>mrs: Load value from a system register to one of the general purpose registers x0 ~ x30</li>
<li><p>
and: Perform the logical AND operation
</p>
<pre class="example" id="orgbc971af">
We use this command to strip the last byte from the value we obtain from the mpidr_el1 register
</pre></li>
<li>cbz: Compare the result of the previously executed operation to <span class="underline">0</span> and <b>jump</b> (or branch in ARM terminology) to the provided label if the comparison yields <span class="underline">true</span></li>
<li>b: Perform an unconditional branch to some label</li>
<li><p>
adr: Load a label's relative address into the target register
</p>
<pre class="example" id="orgbcf4e2d">
In this case, we want pointers to the start and end of the .bss region
</pre></li>
<li>sub: Subtract values from two registers</li>
<li><p>
bl: perform an unconditional branch and store the <b>return address</b> in <span class="underline">x30</span> (the link register)
</p>
<pre class="example" id="orgaad6b4f">
Branch With a link:

When the subroutine is finished, use the ret instruction to jump back to the return address
</pre></li>
<li>mov: Move a value between registers or from a constant to a register</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3f9fd33" class="outline-2">
<h2 id="org3f9fd33">The kernel_main function</h2>
<div class="outline-text-2" id="text-org3f9fd33">
<p>
We have seen that the boot code eventually passes control to the <span class="underline">kernel_main</span> function. Let's take a look at it:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"mini_uart.h"</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">kernel_main</span>(<span style="color: #98f5ff;">void</span>)
{
    uart_init();
    uart_send_string(<span style="color: #deb887;">"Hello, world!\r\n"</span>);

    <span style="color: #00bfff; font-weight: bold;">while</span> (1) {
        uart_send(uart_recv());
    }
}
</pre>
</div>

<p>
This function is one of the simplest in the kernel. It works with the <span class="underline">Mini UART</span> device to print to screen and read user input. The kernel just prints Hello, world! and then enters an infinite loop that reads characters from the user and sends them back to the screen
</p>
</div>
<div id="outline-container-orgd26d045" class="outline-3">
<h3 id="orgd26d045">Raspberry Pi devices</h3>
<div class="outline-text-3" id="text-orgd26d045">
<p>
Now we are going to dig into something specific to the Raspberry Pi
</p>

<pre class="example" id="org0598103">
Before we begin, I recommend that you download the BCM2837 ARM Peripherals manual
</pre>

<p>
<span class="underline">BCM2837</span> is a board that is used by the Raspberry Pi 3 Models B, and B+
</p>

<pre class="example" id="org05b191b">
Sometime in our discussion, I will also mention BCM2835 and BCM2836 - those are names of the board used in older versions of the Raspberry Pi
</pre>

<p>
Before we proceed to the implementation details, I want to share some basic concepts on how to work with <b>memory-mapped</b> devices. BCM2837 is a simple <span class="underline">SOC</span> (System on a chip) board. In such a board, access to all devices is performed via memory-mapped registers. The Raspberry Pi 3 reserves the memory above address <span class="underline">0x3F000000</span> for <b>devices</b> . To activate or configure a particular device, you need to write some data in one of the device's registers. A device register is just a <span class="underline">32-bit</span> region of memory. The meaning of each bit in each device register is described in the BCM2837 ARM Peripherals manual
</p>

<pre class="example" id="orgb869e87">
Take a look at section 1.2.3 ARM physical addresses in the manual and the surrounding documentation for more context on why we use 0x3F000000 as a base address

even though 0x7E000000 is used throughout the manual
</pre>

<p>
From the kernel_main function, you can guess that we are going to work with a Mini UART device. UART stands for <span class="underline">Universal asynchronous receiver-transmitter</span> (通用异步接收器). This device is capable of converting values stored in one of its memory mapped registers to a sequence of high and low voltages. This sequence is passed to your computer via the <span class="underline">TTL-to-serial</span> cable and is interpreted by your terminal emulator 
</p>

<pre class="example" id="org1f773c5">
We are going to use the Mini UART to facilitate communication with our Raspberry Pi

If you want to see the specification of the Mini UART registers, please go to page 8 of the BCM2837 ARM Peripherals manual
</pre>

<p>
A Raspberry Pi has two UARTs:  <span class="underline">Mini UART</span> and <span class="underline">PL011 UART</span>
</p>

<pre class="example" id="org8d53988">
There is, however, an optional exercise that shows how to work with PL011 UART

You can refer to the official documentation if you want to find out more about Raspberry Pi UARTs and learn the difference between them
</pre>
</div>
<div id="outline-container-orgbd761a1" class="outline-4">
<h4 id="orgbd761a1">GPIO</h4>
<div class="outline-text-4" id="text-orgbd761a1">
<p>
Another device that you need to familiarize yourself with is the <b>GPIO</b> <span class="underline">General-purpose input/output</span> . GPIOs are responsible for controlling GPIO pins. You should be able to easily recognize them in the image below:
</p>


<div id="org8aa5872" class="figure">
<p><img src="../pic/gpio-pins.jpg" alt="gpio-pins.jpg" width="70%" />
</p>
</div>

<p>
The GPIO can be used to configure the behavior of different GPIO pins. For example, to be able to use the Mini UART, we need to activate <span class="underline">pins 14</span> and <span class="underline">15</span> and set them up to use this device. The image below illustrates how numbers are assigned to the GPIO pins:
</p>


<div id="org1549f17" class="figure">
<p><img src="../pic/gpio-numbers.png" alt="gpio-numbers.png" width="70%" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgda891db" class="outline-3">
<h3 id="orgda891db">Mini UART initialization</h3>
<div class="outline-text-3" id="text-orgda891db">
<p>
Now let's take a look at how mini UART is initialized. This code is defined in <span class="underline">mini_uart.c</span> : 
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uart_init</span> ( <span style="color: #98f5ff;">void</span> )
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">selector</span>;

    selector = get32(GPFSEL1);
    selector &amp;= ~(7&lt;&lt;12);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">clean gpio14</span>
    selector |= 2&lt;&lt;12;                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">set alt5 for gpio14</span>
    selector &amp;= ~(7&lt;&lt;15);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">clean gpio15</span>
    selector |= 2&lt;&lt;15;                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">set alt5 for gpio 15</span>
    put32(GPFSEL1,selector);

    put32(GPPUD,0);
    delay(150);
    put32(GPPUDCLK0,(1&lt;&lt;14)|(1&lt;&lt;15));
    delay(150);
    put32(GPPUDCLK0,0);

    put32(AUX_ENABLES,1);                   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Enable mini uart (this also enables access to its registers)</span>
    put32(AUX_MU_CNTL_REG,0);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Disable auto flow control and disable receiver and transmitter (for now)</span>
    put32(AUX_MU_IER_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Disable receive and transmit interrupts</span>
    put32(AUX_MU_LCR_REG,3);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Enable 8 bit mode</span>
    put32(AUX_MU_MCR_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set RTS line to be always high</span>
    put32(AUX_MU_BAUD_REG,270);             <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set baud rate to 115200</span>

    put32(AUX_MU_CNTL_REG,3);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Finally, enable transmitter and receiver</span>
}
</pre>
</div>

<p>
Here, we use the two functions <span class="underline">put32</span> and <span class="underline">get32</span> . Those functions are very simple; they allow us to read and write some data to and from a 32-bit register
</p>

<pre class="example" id="org7b4f089">
You can take a look at how they are implemented in utils.S

uart_init is one of the most complex and important functions in this lesson, and we will continue to examine it in the next three sections
</pre>
</div>
<div id="outline-container-orgaa73207" class="outline-4">
<h4 id="orgaa73207">GPIO alternative function selection</h4>
<div class="outline-text-4" id="text-orgaa73207">
<p>
First, we need to <b>activate</b> the <span class="underline">GPIO pins</span> . Most of the pins can be used with different devices, so before using a particular pin, we need to select the pin's alternative function. An alternative function is just a number from 0 to 5 that can be set for each pin and configures which device is connected to the pin. You can see the list of all available GPIO alternative functions in the image below:
</p>


<div id="org19ceaf8" class="figure">
<p><img src="../pic/alt.png" alt="alt.png" width="70%" />
</p>
</div>

<p>
Here you can see that pins <span class="underline">14</span> and <span class="underline">15</span> have the <span class="underline">TXD1</span> and <span class="underline">RXD1</span> alternative functions available. This means that if we select alternative function number 5 for pins 14 and 15, they will be used as a Mini UART Transmit Data pin and Mini UART Receive Data pin, respectively. The <span class="underline">GPFSEL1</span> register is used to control alternative functions for pins 10-19. The meaning of all the bits in those registers is shown in the following table: 
</p>


<div id="org8a6eb01" class="figure">
<p><img src="../pic/gpfsel1.png" alt="gpfsel1.png" width="70%" />
</p>
</div>


<p>
So now you know everything you need to understand the following lines of code that are used to configure GPIO pins 14 and 15 to work with the Mini UART device:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">selector</span>;

selector = get32(GPFSEL1);
selector &amp;= ~(7&lt;&lt;12);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">clean gpio14</span>
selector |= 2&lt;&lt;12;                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">set alt5 for gpio14</span>
selector &amp;= ~(7&lt;&lt;15);                   <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">clean gpio15</span>
selector |= 2&lt;&lt;15;                      <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">set alt5 for gpio 15</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(GPFSEL1,selector);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6cc327" class="outline-4">
<h4 id="orge6cc327">GPIO pull-up/down</h4>
<div class="outline-text-4" id="text-orge6cc327">
<pre class="example" id="orgbbdc1dd">
When you work with Raspberry Pi GPIO pins, you will often encounter terms such as pull-up/pull-down

For those who are too lazy to read the whole article, I will briefly explain the pull-up/pull-down concept
</pre>
<p>
If you use a particular pin as input and don't connect anything to this pin, you will not be able to identify whether the value of the pin is 1 or 0. In fact, the device will report random values. The pull-up/pull-down mechanism allows you to overcome this issue. If you set the pin to the pull-up state and nothing is connected to it, it will report 1 all the time (for the pull-down state, the value will always be 0). In our case, we need neither the <span class="underline">pull-up</span> nor the <span class="underline">pull-down</span> state, because both the 14 and 15 pins are going to be connected all the time. The pin state is preserved even after a reboot, so before using any pin, we always have to initialize its state. There are three available states: pull-up, pull-down, and <b>neither</b> (to remove the current pull-up or pull-down state), and we need the third one.
</p>

<p>
Switching between pin states is not a very simple procedure because it requires physically toggling a switch on the electric circuit. This process involves the GPPUD and GPPUDCLK registers and is described on page 101 of the BCM2837 ARM Peripherals manual. I copied the description here:
</p>

<pre class="example" id="orgdd6fe5d">
The GPIO Pull-up/down Clock Registers control the actuation of internal pull-downs on
the respective GPIO pins. These registers must be used in conjunction with the GPPUD
register to effect GPIO Pull-up/down changes. The following sequence of events is
required:
1. Write to GPPUD to set the required control signal (i.e. Pull-up or Pull-Down or neither
to remove the current Pull-up/down)
2. Wait 150 cycles – this provides the required set-up time for the control signal
3. Write to GPPUDCLK0/1 to clock the control signal into the GPIO pads you wish to
modify – NOTE only the pads which receive a clock will be modified, all others will
retain their previous state.
4. Wait 150 cycles – this provides the required hold time for the control signal
5. Write to GPPUD to remove the control signal
6. Write to GPPUDCLK0/1 to remove the clock
</pre>

<p>
This procedure describes how we can remove both the pull-up and pull-down states from a pin, which is what we are doing for pins 14 and 15 in the following code:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(GPPUD,0);
delay(150);
<span style="color: #daa520; font-weight: bold;">put32</span>(GPPUDCLK0,(1&lt;&lt;14)|(1&lt;&lt;15));
delay(150);
<span style="color: #daa520; font-weight: bold;">put32</span>(GPPUDCLK0,0);
</pre>
</div>
</div>
</div>

<div id="outline-container-org72f81eb" class="outline-4">
<h4 id="org72f81eb">Initializing the Mini UART</h4>
<div class="outline-text-4" id="text-org72f81eb">
<p>
Now our Mini UART is connected to the GPIO pins, and the pins are configured. The rest of the uart_init function is dedicated to Mini UART initialization.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_ENABLES,1);                   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Enable mini uart (this also enables access to its registers)</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,0);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Disable auto flow control and disable receiver and transmitter (for now)</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_IER_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Disable receive and transmit interrupts</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_LCR_REG,3);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Enable 8 bit mode</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_MCR_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set RTS line to be always high</span>
<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_BAUD_REG,270);             <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set baud rate to 115200</span>

<span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,3);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Finally, enable transmitter and receiver</span>
</pre>
</div>

<p>
Let's examine this code snippet line by line.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_ENABLES,1);                   <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Enable mini uart (this also enables access to its registers)</span>
</pre>
</div>

<p>
This line enables the Mini UART. We must do this in the beginning, because this also enables access to all the other Mini UART registers.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,0);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Disable auto flow control and disable receiver and transmitter (for now)</span>
</pre>
</div>

<p>
Here we disable the receiver and transmitter before the configuration is finished. We also permanently disable auto-flow control because it requires us to use additional GPIO pins, and the TTL-to-serial cable doesn't support it
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_IER_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Disable receive and transmit interrupts</span>
</pre>
</div>

<p>
It is possible to configure the Mini UART to generate a processor interrupt each time new data is available
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_LCR_REG,3);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Enable 8 bit mode</span>
</pre>
</div>

<pre class="example" id="org4d1089e">
We are going to start working with interrupts in lesson 3, so for now, we will just disable this feature
</pre>

<p>
Mini UART can support either 7- or 8-bit operations. This is because an ASCII character is 7 bits for the standard set and 8 bits for the extended. We are going to use 8-bit mode.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_MCR_REG,0);                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set RTS line to be always high</span>
</pre>
</div>

<p>
The RTS line is used in the flow control and we don't need it. Set it to be high all the time.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_BAUD_REG,270);             <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Set baud rate to 115200</span>
</pre>
</div>

<p>
The baud rate is the rate at which information is transferred in a communication channel. “115200 baud” means that the serial port is capable of transferring a maximum of <span class="underline">115200</span> bits per second. The baud rate of your Raspberry Pi mini UART device should be the same as <b>the baud rate in your terminal emulator</b> . The Mini UART calculates baud rate according to the following equation:
</p>

<pre class="example" id="orgd6e4fc5">
baudrate = system_clock_freq / (8 * ( baudrate_reg + 1 ))

The system_clock_freq is 250 MHz, so we can easily calculate the value of baudrate_reg as 270
</pre>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #daa520; font-weight: bold;">put32</span>(AUX_MU_CNTL_REG,3);               <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Finally, enable transmitter and receiver</span>
</pre>
</div>

<p>
After this line is executed, the Mini UART is ready for work!
</p>
</div>
</div>
</div>

<div id="outline-container-org9ff1731" class="outline-3">
<h3 id="org9ff1731">Sending data using the Mini UART</h3>
<div class="outline-text-3" id="text-org9ff1731">
<p>
After the Mini UART is ready, we can try to use it to send and receive some data. To do this, we can use the following two functions:
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uart_send</span> ( <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">c</span> )
{
    <span style="color: #00bfff; font-weight: bold;">while</span>(1) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(get32(AUX_MU_LSR_REG)&amp;0x20) 
            <span style="color: #00bfff; font-weight: bold;">break</span>;
    }
    put32(AUX_MU_IO_REG,c);
}

<span style="color: #98f5ff;">char</span> <span style="color: #daa520; font-weight: bold;">uart_recv</span> ( <span style="color: #98f5ff;">void</span> )
{
    <span style="color: #00bfff; font-weight: bold;">while</span>(1) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(get32(AUX_MU_LSR_REG)&amp;0x01) 
            <span style="color: #00bfff; font-weight: bold;">break</span>;
    }
    <span style="color: #00bfff; font-weight: bold;">return</span>(get32(AUX_MU_IO_REG)&amp;0xFF);
}
</pre>
</div>

<p>
Both of the functions:
</p>
<ol class="org-ol">
<li>start with an <span class="underline">infinite loop</span>, the purpose of which is to verify whether the device is <b>ready</b> to transmit or receive data, We are using the <span class="underline">AUX_MU_LSR_REG</span> register to do this:
<ul class="org-ul">
<li>Bit zero, if set to 1, indicates that the data is ready, this means that we can read from the UART</li>
<li>Bit five, if set to 1, tells us that the transmitter is empty, meaning that we can write to the UART</li>
</ul></li>
<li><p>
we use <span class="underline">AUX_MU_IO_REG</span> to either store the value of the transmitted character or read the value of the received character 
</p>

<p>
We also have a very simple function that is capable of sending strings instead of characters:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uart_send_string</span>(<span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">str</span>)
{
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; str[i] != <span style="color: #deb887;">'\0'</span>; i ++) {
        uart_send((<span style="color: #98f5ff;">char</span>)str[i]);
    }
}
</pre>
</div>

<p>
This function just iterates over all characters in a string and sends them one by one 
</p></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org407de89" class="outline-2">
<h2 id="org407de89">Raspberry Pi config</h2>
<div class="outline-text-2" id="text-org407de89">
<p>
The Raspberry Pi startup sequence is the following:
</p>
<ol class="org-ol">
<li>The device is powered on</li>
<li>The GPU starts up and reads the <span class="underline">config.txt</span> file from the boot partition. This file contains some configuration parameters that the GPU uses to further adjust the startup sequence</li>
<li><span class="underline">kernel8.img</span> is loaded into memory and executed</li>
</ol>

<p>
To be able to run our simple OS, the config.txt file should be the following:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #4eee94;">kernel_old</span>=1
<span style="color: #4eee94;">disable_commandline_tags</span>=1
</pre>
</div>

<ul class="org-ul">
<li>kernel_old=1: specifies that the kernel image should be loaded at address 0</li>
<li>disable_commandline_tags: instructs the GPU to not pass any command line arguments to the booted image</li>
</ul>
</div>
</div>

<div id="outline-container-org6cee46d" class="outline-2">
<h2 id="org6cee46d">Testing the kernel</h2>
<div class="outline-text-2" id="text-org6cee46d">
<p>
Now that we have gone through all of the source code, it is time to see it work. To build and test the kernel you need to do the following:
</p>
<ol class="org-ol">
<li>Execute <span class="underline">./build.sh</span> or ./build.bat from src/lesson01 in order to build the kernel</li>
<li><p>
Copy the generated kernel8.img file to the boot partition of your Raspberry Pi flash card and delete kernel7.img as well as any other kernel*.img files that may be present on your SD card
</p>
<pre class="example" id="org2ca76d7">
Make sure you left all other files in the boot partition untouched
</pre></li>
<li>Modify the <span class="underline">config.txt</span> file as described in the previous section</li>
<li>Connect the <span class="underline">USB-to-TTL serial cable</span> as described in the Prerequisites</li>
<li>Power on your Raspberry Pi</li>
<li>Open your terminal emulator. You should be able to see the <span class="underline">Hello, world!</span> message there</li>
</ol>

<p>
Note that the sequence of steps described above asumes that you have Raspbian installed on your SD card. It is also posible to run the RPi OS using an empty SD card:
</p>
<ol class="org-ol">
<li>Prepare your SD card:
<ul class="org-ul">
<li>Use an MBR partition table</li>
<li><p>
Format the boot partition as FAT32
</p>
<pre class="example" id="org8a6caf6">
The card should be formatted exactly in the same way as it is required to install Raspbian

Check HOW TO FORMAT AN SD CARD AS FAT section in the official documentation for more information
</pre></li>
</ul></li>
<li>Copy the following files to the card:
<ul class="org-ul">
<li><span class="underline">bootcode.bin</span> This is the GPU bootloader, it contains the <span class="underline">GPU code</span> to <b>start</b> the GPU and <b>load</b> the GPU firmware</li>
<li><span class="underline">start.elf</span> This is the <span class="underline">GPU firmware</span> . It reads config.txt and <b>enables</b> the GPU to load and run ARM specific user code from kernel8.img</li>
</ul></li>
<li>Copy kernel8.img and config.txt files</li>
<li>Connect the USB-to-TTL serial cable</li>
<li>Power on your Raspberry Pi</li>
<li>Use your terminal emulator to connect to the RPi OS</li>
</ol>

<pre class="example" id="orgd4882a1">
Unfortunately, all Raspberry Pi firmware files are closed-sourced and undocumented

For more information about the Raspberry Pi startup sequence, you can refer to some unofficial sources, like this StackExchange question or this Github repository
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="linux.html">Next: Linux project structure</a></td>
<td class="org-left"><a href="initialization.html">Home: Kernel Initialization</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
