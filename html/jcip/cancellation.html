<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>取消和关闭</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="executor.html"> UP </a>
 |
 <a accesskey="H" href="jcip.html"> HOME </a>
</div><div id="content">
<h1 class="title">取消和关闭</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6763852">任务取消</a>
<ul>
<li><a href="#org9dc69e0">设置自定义flag结束线程</a></li>
<li><a href="#orgce43b24">中断</a>
<ul>
<li><a href="#org4af5771">可中断的阻塞方法</a></li>
<li><a href="#orge5d3b22">不可中断的阻塞方法</a></li>
</ul>
</li>
<li><a href="#org030b546">处理InterruptedException</a>
<ul>
<li><a href="#org8ecdfdf">直接向上层抛出</a></li>
<li><a href="#orgede353d">设置当前线程的中断标记为true</a></li>
<li><a href="#org396fc45">仍然继续循环执行某阻塞方法</a></li>
<li><a href="#org04407a8">忽略</a></li>
</ul>
</li>
<li><a href="#orgf1d4488">限时运行</a></li>
<li><a href="#orgc8ff25a">取消Future</a>
<ul>
<li><a href="#org9b2b1df">取消Future的方法</a></li>
<li><a href="#org92a99cb">客户化取消Future</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org82539bb">取消线程</a>
<ul>
<li><a href="#orga594476">基于生产消费者模型的LoggerWriter</a></li>
<li><a href="#orgcf8ebd2">中断线程的问题</a>
<ul>
<li><a href="#orgec4a5a6">shutdownNow的局限性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org651b7d4">异常退出</a>
<ul>
<li><a href="#org8f4dffa">未捕获异常处理器</a></li>
</ul>
</li>
<li><a href="#orgc453efe">关闭JVM</a>
<ul>
<li><a href="#orgcff2946">正常关闭　</a>
<ul>
<li><a href="#org41425cc">关闭钩子</a></li>
<li><a href="#orge2bb2f5">守护线程</a></li>
</ul>
</li>
<li><a href="#org54b9886">强行关闭</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6763852" class="outline-2">
<h2 id="org6763852">任务取消</h2>
<div class="outline-text-2" id="text-org6763852">
<pre class="example">
启动任务之后, 大多数时候会等待运行完成，但是有时希望可以提前终止任务的运行:

1. 用户申请取消时，比如用户点击了取消按钮.
2. 时间限制的任务，有些任务具有时间限制, 如果在一定的时间内仍然没有得到想要的结果, 可能希望终止该任务的运行.
3. 发生特定的事件时，比如多个任务同时在不同的位置搜索某一文件, 当其中一个搜索到了想要的文件, 应该终止其他仍在运行的任务
4. 发生错误时，比如发生了磁盘已满的错误, 需要向磁盘写入数据的任务应该提前终止
5. 应用或者服务被关闭时
</pre>
</div>

<div id="outline-container-org9dc69e0" class="outline-3">
<h3 id="org9dc69e0">设置自定义flag结束线程</h3>
<div class="outline-text-3" id="text-org9dc69e0">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">PrimeGenerator</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Runnable</span> {
    <span style="color: #ffd700;">@GuardedBy</span>(<span style="color: #deb887;">"this"</span>)
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">primes</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ArrayList</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt;();

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#33258;&#23450;&#20041;&#30340;flag, &#20026;&#20445;&#35777;&#32447;&#31243;&#21487;&#35265;&#24615;, &#23558;&#20854;&#22768;&#26126;&#20026;volatile </span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">cancelled</span>;

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #98f5ff;">BigInteger</span> <span style="color: #4eee94;">p</span> = <span style="color: #ffd700;">BigInteger</span>.ONE;
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27599;&#27425;&#24490;&#29615;&#20043;&#21069;&#26816;&#26597;cancelled&#26631;&#35760;&#30340;&#20540;, &#22914;&#26524;cancelled&#20026;true, &#24490;&#29615;&#32456;&#27490;, &#32447;&#31243;&#20063;&#23601;&#36816;&#34892;&#32467;&#26463;&#20102; </span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (!cancelled) {
            p = p.nextProbablePrime();
            <span style="color: #00bfff; font-weight: bold;">synchronized</span> (<span style="color: #00bfff; font-weight: bold;">this</span>) {
                primes.add(p);
            }
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cancel</span>() {
        cancelled = <span style="color: #ffd700;">true</span>;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">synchronized</span> <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #daa520; font-weight: bold;">get</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ArrayList</span>&lt;&gt;(primes);
    }
}

</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
    <span style="color: #98f5ff;">PrimeGenerator</span> <span style="color: #4eee94;">generator</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">PrimeGenerator</span>();
    <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(generator);
    t.start();

    <span style="color: #00bfff; font-weight: bold;">try</span> {
        Thread.sleep(1000);
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">e</span>) {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#38500;&#38750;&#26126;&#30830;&#30693;&#36947;&#20027;&#32447;&#31243;&#24212;&#35813;&#32456;&#27490;&#65292;&#19981;&#28982;&#36890;&#24120;&#24773;&#20917;&#19979;&#24212;&#35813;&#37325;&#26032;&#25243;&#20986;InterruptedException&#25110;&#32773;&#24674;&#22797;&#34987;&#20013;&#26029;&#30340;&#32447;&#31243;</span>
    }
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36890;&#36807;&#35843;&#29992;cancel&#26041;&#27861;, &#23558;&#33258;&#23450;&#20041;&#30340;cancelled&#26631;&#35760;&#35774;&#32622;&#20026;true, &#20174;&#32780;&#20351;&#24471;&#32447;&#31243;t&#36816;&#34892;&#32456;&#27490;  </span>
    generator.cancel();
    System.out.println(generator.get().size());
}
</pre>
</div>

<pre class="example">
   假如循环中执行了阻塞操作, 那么即使cancelled标记被设置为true, run方法却没有机会去检查cancelled标记的值, 线程将迟迟无法结束！　
</pre>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">BrokenPrimeProducer</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">queue</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">cancelled</span> = <span style="color: #ffd700;">false</span>;
    <span style="color: #daa520; font-weight: bold;">BrokenPrimeProducer</span>(<span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">queue</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.queue = queue;
    }
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #98f5ff;">BigInteger</span> <span style="color: #4eee94;">p</span> = <span style="color: #ffd700;">BigInteger</span>.ONE;
            <span style="color: #00bfff; font-weight: bold;">while</span> (!cancelled)
                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24403;&#38431;&#21015;&#24050;&#28385;&#26102;, put&#26041;&#27861;&#23558;&#20250;&#38459;&#22622;. &#19968;&#26086;put&#26041;&#27861;&#38459;&#22622;</span>
                <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#19988;&#27809;&#26377;&#20854;&#20182;&#32447;&#31243;&#20174;&#38431;&#21015;&#20013;&#21462;&#25968;&#25454;&#26102;, &#38459;&#22622;&#23558;&#19968;&#30452;&#25345;&#32493;&#19979;&#21435;  </span>
                queue.put(p = p.nextProbablePrime());
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">consumed</span>) { }
    }
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cancel</span>() { cancelled = <span style="color: #ffd700;">true</span>; }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#38431;&#21015;&#30340;&#26368;&#22823;&#23481;&#37327;&#20026;10  </span>
    <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">primes</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt;(10);  
    <span style="color: #98f5ff;">BrokenPrimeProducer</span> <span style="color: #4eee94;">producer</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">BrokenPrimeProducer</span>(primes);  
    producer.start();  

    <span style="color: #00bfff; font-weight: bold;">try</span> {  
        Thread.sleep(1000);  
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">e</span>) {
    }  
    producer.cancel();  
}  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce43b24" class="outline-3">
<h3 id="orgce43b24">中断</h3>
<div class="outline-text-3" id="text-orgce43b24">
<pre class="example">
java没有直接规定如何安全的提前终止线程的运行, 而是提供了不具约束力的协商式机制:

线程A可以请求线程B中断, 但是是否响应, 何时响应, 如何响应中断请求, 由线程B自己决定
</pre>

<p>
每个 <span class="underline">线程</span> 对象都有一个 <span class="underline">boolean</span> 型的 <b>中断标记</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">其他线程</span> 请求 <span class="underline">目标线程</span> <b>中断</b> 时, 会将 <span class="underline">目标线程</span> 的 <span class="underline">中断标记</span> <b>设置为true</b></li>
<li>由 <span class="underline">目标线程</span> <b>自己决定</b> 如何处理</li>
</ul>

<pre class="example">
     所以中断线程时, 需要明确知道目标线程的中断机制

     如果不知道目标线程会怎样处理中断请求, 不要贸然请求其中断
</pre>

<p>
Thread类中与中断标记相关的方法有:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Thread</span> {   
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35831;&#27714;&#32447;&#31243;&#20013;&#26029;, &#35813;&#26041;&#27861;&#20250;&#23558;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#35774;&#32622;&#20026;true. &#22914;&#20309;&#22788;&#29702;&#20013;&#26029;&#30001;&#30446;&#26631;&#32447;&#31243;&#20915;&#23450;  </span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">interrupt</span>() { ... }   
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238;&#20013;&#26029;&#26631;&#35760;&#30340;&#20540;  </span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">isInterrupted</span>() { ... }  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#38745;&#24577;&#26041;&#27861;&#29992;&#20110;&#37325;&#32622;&#24403;&#21069;&#36827;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;(&#23558;&#20854;&#35774;&#32622;&#20026;false), &#24182;&#36820;&#22238;&#37325;&#32622;&#20043;&#21069;&#30340;&#20540;  </span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">interrupted</span>() { ... }   
    ...   
}  
</pre>
</div>
</div>

<div id="outline-container-org4af5771" class="outline-4">
<h4 id="org4af5771">可中断的阻塞方法</h4>
<div class="outline-text-4" id="text-org4af5771">
<p>
java API中的 <span class="underline">大多数 <b>阻塞</b> 方法</span> 都是 <b>可中断的</b> ：如 <span class="underline">Thread.sleep</span> ,  <span class="underline">Object.wait</span> ,  <span class="underline">BlockingQueue.put</span> 等 
</p>
<ul class="org-ul">
<li>可中断的阻塞方法有一个共同的特点:  <b>声明</b> 抛出 <span class="underline">InterruptedException</span> 异常</li>
<li>在 <span class="underline">阻塞期间</span> 会 <span class="underline">周期性</span> 检查当前线程的 <span class="underline">中断标记</span> ， 如果发现当前线程的 <span class="underline">中断标记</span> 为 <b>true</b> ：
<ol class="org-ol">
<li><b>重置中断标记</b></li>
<li>提前 <b>从阻塞状态返回</b></li>
<li>抛出 <span class="underline">InterruptedException</span> 异常</li>
</ol></li>
</ul>

<p>
使用中断终止PrimeProducer    
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">PrimeProducer</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">queue</span>;

    <span style="color: #daa520; font-weight: bold;">PrimeProducer</span>(<span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">queue</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.queue = queue;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #98f5ff;">BigInteger</span> <span style="color: #4eee94;">p</span> = <span style="color: #ffd700;">BigInteger</span>.ONE;
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27599;&#27425;&#24490;&#29615;&#21069;&#26816;&#26597;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;, &#22914;&#26524;&#20013;&#26029;&#26631;&#35760;&#20026;&#35774;&#23450;&#20026;true, &#21017;&#24490;&#29615;&#32467;&#26463;  </span>
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23601;&#31639;&#24403;&#21069;&#32447;&#31243;&#38459;&#22622;&#22312;put&#26041;&#27861;&#19978;, &#22312;&#38459;&#22622;&#26399;&#38388;&#20063;&#20250;&#21608;&#26399;&#24615;&#26816;&#26597;&#20013;&#26029;&#26631;&#35760;, </span>
            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#19968;&#26086;&#21457;&#29616;&#20013;&#26029;&#26631;&#35760;&#20026;true, &#23601;&#20250;&#20174;&#38459;&#22622;&#29366;&#24577;&#20013;&#36820;&#22238;, &#24182;&#25243;&#20986;InterruptedException&#24322;&#24120;  </span>
            <span style="color: #00bfff; font-weight: bold;">while</span> (!Thread.currentThread().isInterrupted()) {
                queue.put(p = p.nextProbablePrime());
            }
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">consumed</span>) {
            System.out.println(<span style="color: #deb887;">"InterruptedException happened"</span>);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cancel</span>() {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">interrupt&#26041;&#27861;&#20250;&#23558;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#35774;&#32622;&#20026;true  </span>
        interrupt();
    }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#38431;&#21015;&#30340;&#26368;&#22823;&#23481;&#37327;&#20026;10  </span>
    <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">BigInteger</span>&gt; <span style="color: #4eee94;">primes</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;&gt;(10);
    <span style="color: #98f5ff;">PrimeProducer</span> <span style="color: #4eee94;">producer</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">PrimeProducer</span>(primes);
    producer.start();

    <span style="color: #00bfff; font-weight: bold;">try</span> {
        Thread.sleep(1000);
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">e</span>) {
    }
    <span style="color: #5f9ea0; font-style: italic;">//</span>
    producer.cancel();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge5d3b22" class="outline-4">
<h4 id="orge5d3b22">不可中断的阻塞方法</h4>
<div class="outline-text-4" id="text-orge5d3b22">
<p>
有些方法阻塞的时候不会检查中断标记　
</p>
<ol class="org-ol">
<li><b>同步socket I/O</b> :　基于 <span class="underline">InputStream</span> 的读写方法不会响应中断， <b>关闭socket</b> 可以使阻塞方法退出</li>
<li><b>同步nio</b> :  <b>关闭</b> <span class="underline">InterruptibleChannel</span> 可以扔出 <span class="underline">AsynchronousCloseException</span></li>
<li><b>异步Selector</b> ：*关闭* <span class="underline">selector</span></li>
<li><b>内置锁</b> ： <b>等待获得内置锁</b> 不会响应中断，使用新的 <span class="underline">Lock</span> 对象替代内置锁</li>
</ol>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ReaderThread</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">socket</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">InputStream</span> <span style="color: #4eee94;">in</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">BUFSZ</span> = 8192;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">ReaderThread</span>(<span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">socket</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">IOException</span> {
        <span style="color: #00bfff; font-weight: bold;">this</span>.socket = socket;
        <span style="color: #00bfff; font-weight: bold;">this</span>.in = socket.getInputStream();
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">interrupt</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#21457;&#29983;&#20013;&#26029;&#26102;, &#32447;&#31243;&#38459;&#22622;&#22312;read&#26041;&#27861;&#19978;, socket&#30340;&#20851;&#38381;&#20250;&#23548;&#33268;read&#26041;&#27861;&#25243;&#20986;SocketException&#65292;&#28982;&#21518;run&#26041;&#27861;&#36816;&#34892;&#23436;&#27605; </span>
            socket.close();
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">IOException</span> <span style="color: #4eee94;">ignored</span>) {
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#38459;&#22622;&#22312;&#19968;&#20010;&#21487;&#21709;&#24212;&#38459;&#22622;&#30340;&#26041;&#27861;&#65292;&#32487;&#32493;&#20256;&#36882;&#19968;&#20010;&#20013;&#26029;</span>
            <span style="color: #00bfff; font-weight: bold;">super</span>.interrupt();
        }
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">buf</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">byte</span>[BUFSZ];
            <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
                <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">count</span> = in.read(buf);
                <span style="color: #00bfff; font-weight: bold;">if</span> (count &lt; 0) {
                    <span style="color: #00bfff; font-weight: bold;">break</span>;
                } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (count &gt; 0) {
                    processBuffer(buf, count);
                }
            }
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">IOException</span> <span style="color: #4eee94;">e</span>) {
            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Allow thread to exit */</span> 
        }
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">processBuffer</span>(<span style="color: #98f5ff;">byte</span>[] <span style="color: #4eee94;">buf</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">count</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">do something ...</span>
    }
}
</pre>
</div>

<p>
<b>覆写</b> Thread的 <span class="underline">interrupt</span> 方法：
</p>
<ul class="org-ul">
<li>如果阻塞在不可响应中断的read方法，则 <span class="underline">关闭socket</span> 退出read方法</li>
<li>反之则 <span class="underline">继续传递一个中断</span></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org030b546" class="outline-3">
<h3 id="org030b546">处理InterruptedException</h3>
<div class="outline-text-3" id="text-org030b546">
</div>
<div id="outline-container-org8ecdfdf" class="outline-4">
<h4 id="org8ecdfdf">直接向上层抛出</h4>
<div class="outline-text-4" id="text-org8ecdfdf">
<p>
也可以 <span class="underline">做一些清理工作</span> 之后 <b>重抛该异常</b> 
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#30452;&#25509;&#21521;&#19978;&#23618;&#25243;&#20986;InterruptedException, dosomething&#26041;&#27861;&#20063;&#26159;&#19968;&#20010;&#21487;&#20013;&#26029;&#30340;&#38459;&#22622;&#26041;&#27861;  </span>
<span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">dosomething</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {  
    Thread.sleep(1000);  
}  
</pre>
</div>

<pre class="example">
	这样的处理使得你的方法也成为一个可中断的阻塞方法 
</pre>
</div>
</div>

<div id="outline-container-orgede353d" class="outline-4">
<h4 id="orgede353d">设置当前线程的中断标记为true</h4>
<div class="outline-text-4" id="text-orgede353d">
<p>
表明 <b>当前线程发生了中断</b> , 以便 <span class="underline">调用栈上层</span> 进行处理
</p>

<pre class="example">
      一般用于当前进程无法直接向上抛出InterruptedException异常
</pre>

<ol class="org-ol">
<li>主线程 <b>启动</b>  <span class="underline">InterruptedExceptionHandler线程</span> 1s后, 设置 <span class="underline">InterruptedExceptionHandler线程</span> 的 <span class="underline">中断标记</span> 为 <b>true</b></li>
<li><span class="underline">InterruptedExceptionHandler线程</span> 应该 <b>阻塞</b> 在 <span class="underline">wait</span> 方法上
<ul class="org-ul">
<li>由于wait方法是 <b>可中断的阻塞方法</b> , 所以其检查到 <span class="underline">中断标记</span> 为 <span class="underline">true</span> 时</li>
<li><span class="underline">重置</span> 当前线程的 <span class="underline">中断标记</span> 后</li>
<li>抛出InterruptedException</li>
</ul></li>
<li><span class="underline">dosomething</span> 方法catch住 <span class="underline">InterruptedException</span> 异常后,  <b>再次</b> 将 <span class="underline">当前线程的中断标记</span> 设置为 <span class="underline">true</span></li>
<li><p>
<span class="underline">run</span> 方法检查到 <span class="underline">中断标记</span> 为 <span class="underline">true</span> , 循环不再继续 
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">InterruptedExceptionHandler</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Runnable</span> {  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">Object</span> <span style="color: #4eee94;">lock</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Object</span>();  

    <span style="color: #ffd700;">@Override</span>  
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #00bfff; font-weight: bold;">while</span> (!Thread.currentThread().isInterrupted()) {  
            dosomething();  
        }  
    }  

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">dosomething</span>() {  
        <span style="color: #00bfff; font-weight: bold;">try</span> {  
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Object.wait&#26159;&#19968;&#20010;&#21487;&#20013;&#26029;&#30340;&#38459;&#22622;&#26041;&#27861;</span>
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#22312;&#20854;&#38459;&#22622;&#26399;&#38388;&#26816;&#26597;&#21040;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#20026;true, &#20250;&#37325;&#32622;&#20013;&#26029;&#26631;&#35760;&#21518;&#20174;&#38459;&#22622;&#29366;&#24577;&#36820;&#22238;, &#24182;&#25243;&#20986;InterruptedException&#24322;&#24120;  </span>
            <span style="color: #00bfff; font-weight: bold;">synchronized</span> (lock) {  
                lock.wait();  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20250;&#37325;&#32622;&#20013;&#26029;&#26631;&#35760;&#21518;&#20174;&#38459;&#22622;&#29366;&#24577;&#36820;&#22238;, &#24182;&#25243;&#20986;InterruptedException&#24322;&#24120; </span>
            }  
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">e</span>) {  
            System.out.println(<span style="color: #deb887;">"InterruptedException happened"</span>);  
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">catch&#20303;InterruptedException&#21518;&#35774;&#32622;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#20026;true, &#20197;&#20379;&#35843;&#29992;&#26632;&#19978;&#23618;&#36827;&#34892;&#30456;&#24212;&#30340;&#22788;&#29702;  </span>
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#27492;&#20363;&#20013;, dosomething&#26041;&#27861;&#30340;&#35843;&#29992;&#26632;&#19978;&#23618;&#26159;run&#26041;&#27861;.  </span>
            Thread.currentThread().interrupt();  
        }  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {  
        <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InterruptedExceptionHandler</span>());  
        t.start();  
        Thread.sleep(1000);
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#32447;&#31243;1s&#21518;&#35774;&#32622;&#20854;&#20013;&#26029;&#26631;&#35760;&#20026;true</span>
        t.interrupt();  
    }  
}  
</pre>
</div></li>
</ol>

<pre class="example">
      假如dosomething方法catch住InterruptedException异常后没有设置中断标记

      其调用栈上层的run方法就无法得知线程曾经发生过中断, 循环也就无法终止
</pre>
</div>
</div>

<div id="outline-container-org396fc45" class="outline-4">
<h4 id="org396fc45">仍然继续循环执行某阻塞方法</h4>
<div class="outline-text-4" id="text-org396fc45">
<p>
将 <span class="underline">中断状态</span> <b>保存</b> 下来, 当 <span class="underline">循环完成</span> 后再根据 <span class="underline">保存下来的中断状态</span> 执行相应的操作
</p>

<ol class="org-ol">
<li>等待doSomething的 <span class="underline">循环执行完毕</span></li>
<li><b>恢复</b> <span class="underline">中断状态</span> 为 <span class="underline">true</span></li>
<li><p>
<span class="underline">run</span> 中 <b>处理中断</b> 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">InterruptedExceptionContinueHandler</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Runnable</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt; <span style="color: #4eee94;">queue</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">InterruptedExceptionContinueHandler</span>(<span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt; <span style="color: #4eee94;">queue</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.queue = queue;
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #00bfff; font-weight: bold;">while</span> (!Thread.currentThread().isInterrupted()) {
            dosomething();
        }
        System.out.println(queue.size());
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">dosomething</span>() {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">cancelled&#21464;&#37327;&#29992;&#20110;&#34920;&#26126;&#32447;&#31243;&#26159;&#21542;&#21457;&#29983;&#36807;&#20013;&#26029;</span>
        <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">cancelled</span> = <span style="color: #ffd700;">false</span>;
        <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; 10000; i++) {
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                queue.put(i);
            } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">e</span>) {
                <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23601;&#31639;&#21457;&#29983;&#20102;InterruptedException, &#24490;&#29615;&#20063;&#24076;&#26395;&#32487;&#32493;&#36816;&#34892;&#19979;&#21435;, &#27492;&#26102;&#23558;cancelled&#35774;&#32622;&#20026;true, &#20197;&#34920;&#26126;&#36941;&#21382;&#36807;&#31243;&#20013;&#21457;&#29983;&#20102;&#20013;&#26029;</span>
                System.out.println(<span style="color: #deb887;">"InterruptedException happened when i = "</span> + i);
                cancelled = <span style="color: #ffd700;">true</span>;
            }
        }
        <span style="color: #00bfff; font-weight: bold;">if</span> (cancelled) {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#24403;&#21069;&#32447;&#31243;&#26366;&#32463;&#21457;&#29983;&#36807;&#20013;&#26029;, &#23601;&#23558;&#20854;&#20013;&#26029;&#26631;&#35760;&#35774;&#32622;&#20026;true, &#20197;&#36890;&#30693;dosomething&#26041;&#27861;&#30340;&#19978;&#23618;&#35843;&#29992;&#26632;</span>
            Thread.currentThread().interrupt();
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
        <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">InterruptedExceptionContinueHandler</span>(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;<span style="color: #98f5ff;">Integer</span>&gt;()));
        t.start();

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;&#32447;&#31243;2ms&#21518;&#35774;&#32622;&#20854;&#20013;&#26029;&#26631;&#35760;&#20026;true</span>
        Thread.sleep(2);
        t.interrupt();
    }
}
</pre>
</div>

<pre class="example">
	 “直接设置当前进程的中断标志为true“还是”保存中断状态“直到循环结束？

	 取决于业务场景是否需要”立刻结束循环“，还是”循环结束“再处理！
</pre></li>
</ol>
</div>
</div>

<div id="outline-container-org04407a8" class="outline-4">
<h4 id="org04407a8">忽略</h4>
<div class="outline-text-4" id="text-org04407a8">
<p>
同时满足下面两个条件：
</p>
<ol class="org-ol">
<li>被 <b>捕获</b> 在 <b>调用栈的最上层</b> ： <span class="underline">run</span> 方法或者 <span class="underline">main</span> 方法中</li>
<li><p>
<span class="underline">后续代码</span> <b>不检查</b> <span class="underline">中断状态</span> 
</p>

<pre class="example">
       其他任何情况下都应该对InterruptedException作处理
</pre></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgf1d4488" class="outline-3">
<h3 id="orgf1d4488">限时运行</h3>
<div class="outline-text-3" id="text-orgf1d4488">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ScheduledExecutorService</span> <span style="color: #4eee94;">cancelExec</span> = ...;
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">timedRun</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>,
                <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">timeout</span>, <span style="color: #98f5ff;">TimeUnit</span> <span style="color: #4eee94;">unit</span>) {
    <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">taskThread</span> = Thread.currentThread();
    cancelExec.schedule(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
            <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() { taskThread.interrupt(); }
        }, timeout, unit);
    r.run();
}
</pre>
</div>

<pre class="example">
timeRun方法可以在任何一个线程中调用，然而 timeRun 方法无法知道运行线程处理中断的策略，不应该贸然向对应的线程发出中断请求

1. 在 r.run 运行完成后，调用线程捕获中断异常是危险的
2. 如果调用线程忽略了中断异常，那只有r.run运行完毕timeRun才能结束，这会超出所要求的运行时间
</pre>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ScheduledExecutorService</span> <span style="color: #4eee94;">cancelExec</span> = Executors.newSingleThreadScheduledExecutor();

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">timedRun</span>(<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>,
                <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">timeout</span>, <span style="color: #98f5ff;">TimeUnit</span> <span style="color: #4eee94;">unit</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {

    <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ReThrowableTask</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Runnable</span> {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#24403;&#21069;&#32447;&#31243;&#21644;taskThread&#32447;&#31243;&#20849;&#20139;&#24322;&#24120;</span>
        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">t</span>;

        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                r.run();
            } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">t</span>) {
                <span style="color: #00bfff; font-weight: bold;">this</span>.t = t;
            }
        }

        <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rethrow</span>() {
            <span style="color: #00bfff; font-weight: bold;">if</span> (t != <span style="color: #ffd700;">null</span>)
                <span style="color: #00bfff; font-weight: bold;">throw</span> launderThrowable(t);
        }
    }

    <span style="color: #98f5ff;">ReThrowableTask</span> <span style="color: #4eee94;">task</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ReThrowableTask</span>();
    <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">taskThread</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(task);
    taskThread.start();
    cancelExec.schedule(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
            <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                taskThread.interrupt();
            }
        }, timeout, unit);
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20572;&#27490;&#24403;&#21069;&#36827;&#31243;&#65292;&#35753;taskThread&#36816;&#34892;&#38480;&#26102;&#26102;&#38388;</span>
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#36229;&#36807;&#38480;&#26102;&#65292;&#21017;&#35753;cancelExec&#32447;&#31243;&#27744;&#30340;&#32447;&#31243;&#23545;taskThread&#21457;&#36215;&#20013;&#26029;&#35831;&#27714;</span>
    taskThread.join(unit.toMillis(timeout));
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;taskThread&#32447;&#31243;&#20869;&#25429;&#33719;&#24322;&#24120;&#65292;&#37325;&#26032;&#25243;&#20986;</span>
    task.rethrow();
}
</pre>
</div>
<ol class="org-ol">
<li>创建 <span class="underline">taskThread</span> 线程，把 <span class="underline">运行任务</span> 包装到 taskThread</li>
<li>通过 <b>join</b> 方法让 <span class="underline">taskThread</span> 跑 <span class="underline">限时</span> 时间</li>
<li>超过限时时间，向 <span class="underline">taskThread</span>  <b>发送中断</b> 请求</li>
<li>在 <span class="underline">taskThread中发现异常</span> ，则 <b>重新抛出</b> 供主线程处理</li>
</ol>
</div>
</div>

<div id="outline-container-orgc8ff25a" class="outline-3">
<h3 id="orgc8ff25a">取消Future</h3>
<div class="outline-text-3" id="text-orgc8ff25a">
<pre class="example">
     将task提交给线程池运行, 由于不知道task会由线程池中的哪一个线程运行, 也不知道线程池中的线程会怎样处理中断,

     所以无法直接调用 Thread 对象的 interrupt 方法提前终止线程的运行
</pre>

<p>
<span class="underline">ExecutorService</span> 类的 <span class="underline">submit</span> 等方法会返回表示 <b>task未决结果</b> 的 <span class="underline">Future</span> 对象, 调用Future对象的 <b>cancel</b> 方法, 可以 <b>取消task的运行</b> 
</p>
</div>

<div id="outline-container-org9b2b1df" class="outline-4">
<h4 id="org9b2b1df">取消Future的方法</h4>
<div class="outline-text-4" id="text-org9b2b1df">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#23581;&#35797;&#21462;&#28040;task&#30340;&#25191;&#34892;</span>
<span style="color: #ffebcd;"> * &#22914;&#26524;task&#24050;&#32463;&#23436;&#25104;, &#25110;&#24050;&#21462;&#28040;, &#25110;&#30001;&#20110;&#26576;&#20123;&#21407;&#22240;&#26080;&#27861;&#21462;&#28040;, &#21017;&#23581;&#35797;&#22833;&#36133;, &#36820;&#22238;false </span>
<span style="color: #ffebcd;"> * &#22914;&#26524;task&#23578;&#26410;&#21551;&#21160;, &#21017;&#25104;&#21151;&#35843;&#29992;&#20854;Future&#23545;&#35937;&#30340;cancel&#26041;&#27861;&#23558;&#23548;&#33268;&#20854;&#27704;&#19981;&#21551;&#21160; </span>
<span style="color: #ffebcd;"> * mayInterruptIfRunning&#22914;&#26524;&#20026;true, &#19988;&#27492;&#26102;task&#27491;&#22312;&#26576;&#20010;&#32447;&#31243;&#20013;&#36816;&#34892;, &#37027;&#20040;&#35813;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#23558;&#34987;&#35774;&#32622;&#20026;true </span>
<span style="color: #ffebcd;"> * &#24403;mayInterruptIfRunning&#20026;false&#26102;, &#22914;&#26524;task&#27809;&#26377;&#21551;&#21160;&#21017;&#19981;&#20877;&#21551;&#21160;, &#22914;&#26524;task&#24050;&#32463;&#21551;&#21160;, &#21017;&#23581;&#35797;&#22833;&#36133; </span>
<span style="color: #ffebcd;"> * &#22914;&#26524;task&#27809;&#26377;&#22788;&#29702;&#20013;&#26029;, mayInterruptIfRunning&#24212;&#35813;&#20026;false</span>
<span style="color: #ffebcd;"> * cancel&#26041;&#27861;&#36820;&#22238;&#21518;, isDone&#26041;&#27861;&#23558;&#22987;&#32456;&#36820;&#22238;true, &#22914;&#26524;cancel&#36820;&#22238;true, &#23545;isCancelled&#26041;&#27861;&#30340;&#21518;&#32493;&#35843;&#29992;&#23558;&#22987;&#32456;&#36820;&#22238;true</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">cancel</span>(<span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">mayInterruptIfRunning</span>)
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#22914;&#26524;task&#27491;&#24120;&#23436;&#25104;&#21069;&#34987;&#21462;&#28040;, &#35813;&#26041;&#27861;&#36820;&#22238;true.</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">boolean</span> isCancelled();

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;"> * &#22914;&#26524;task&#24050;&#32463;&#23436;&#25104;, &#35813;&#26041;&#27861;&#36820;&#22238;true. &#23436;&#25104;&#30340;&#24773;&#20917;&#21253;&#25324;&#27491;&#24120;&#23436;&#25104;, task&#34987;&#21462;&#28040;, &#24322;&#24120;&#32456;&#27490;&#31561;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">isDone</span>();
</pre>
</div>

<pre class="example">
      如果不知道线程会怎样处理中断, 就不应该调用该线程的interrupt方法，

      那么调用Future的cancel方法, 并将mayInterruptIfRunning参数设置为true是否合适?
</pre>

<p>
线程池中用于 <span class="underline">执行task的线程</span> 会将 <span class="underline">中断的处理</span> <b>委托给task</b> , 所以这样做是合适的
</p>
<pre class="example">
      当然还有个前提是task中正确处理了中断
</pre>

<p>
通过取消Future实现timeRun
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">timedRun</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">timeout</span>, <span style="color: #98f5ff;">TimeUnit</span> <span style="color: #4eee94;">unit</span>) 
    <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
    <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">taskExec</span> = Executors.newCachedThreadPool();
    <span style="color: #98f5ff;">Future</span>&lt;?&gt; <span style="color: #4eee94;">task</span> = taskExec.submit(r);
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#32447;&#31243;&#27744;&#20013;&#30340;&#32447;&#31243;&#25191;&#34892;&#20219;&#21153;&#36807;&#31243;&#20013;&#35813;&#32447;&#31243;&#21457;&#29983;&#20102;&#20013;&#26029;, &#37027;&#20040;&#35843;&#29992;task&#30340;get&#26041;&#27861;&#23558;&#20250;&#25243;&#20986;InterruptedException&#24322;</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23545;&#20110;InterruptedException, &#25353;&#29031;&#20043;&#21069;&#24635;&#32467;&#30340;&#26041;&#27861;&#22788;&#29702;&#21363;&#21487;. &#27492;&#20363;&#23558;&#20854;&#25243;&#32473;&#19978;&#23618;</span>
        task.get(timeout, unit);
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">TimeoutException</span> <span style="color: #4eee94;">e</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#21457;&#29983;TimeoutException&#24322;&#24120;, &#34920;&#26126;&#25191;&#34892;&#26102;&#38388;&#36229;&#26102;, &#27492;&#26102;&#21462;&#28040;&#35813;&#20219;&#21153;&#21363;&#21487;</span>
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">ExecutionException</span> <span style="color: #4eee94;">e</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#29983;&#20854;&#20182;&#24322;&#24120;&#26102;, &#19981;&#20165;&#35201;&#21462;&#28040;&#20219;&#21153;&#30340;&#25191;&#34892;, &#20063;&#24212;&#35813;&#37325;&#25243;&#35813;&#24322;&#24120;</span>
        <span style="color: #00bfff; font-weight: bold;">throw</span> launderThrowable(e.getCause());
    } <span style="color: #00bfff; font-weight: bold;">finally</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Harmless if task already completed</span>
        task.cancel(<span style="color: #ffd700;">true</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">interrupt if running</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org92a99cb" class="outline-4">
<h4 id="org92a99cb">客户化取消Future</h4>
<div class="outline-text-4" id="text-org92a99cb">
<pre class="example">
      有时候需要覆写Future.cancel方法，比如：

      对于不可响应中断的阻塞方法需要在其中加入诸如关闭socket的操作等
</pre>
<p>
定义 <span class="underline">CacellableTask</span> 接口
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">interface</span> <span style="color: #98f5ff;">CancellableTask</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Callable</span>&lt;<span style="color: #98f5ff;">T</span>&gt; {
    <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cancel</span>();
    <span style="color: #98f5ff;">RunnableFuture</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #daa520; font-weight: bold;">newTask</span>();
}
</pre>
</div>

<p>
实现 <span class="underline">SocketUsingTask&lt;T&gt;</span> 对象 ：覆盖其中的 <b>cancel</b> 方法来关闭 <span class="underline">socket</span> 连接
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">SocketUsingTask</span>&lt;<span style="color: #98f5ff;">T</span>&gt;
    <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">CancellableTask</span>&lt;<span style="color: #98f5ff;">T</span>&gt; {
    <span style="color: #ffd700;">@GuardedBy</span>(<span style="color: #deb887;">"this"</span>)
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">socket</span>;

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #00bfff; font-weight: bold;">synchronized</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">setSocket</span>(<span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">s</span>) {
        socket = s;
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">synchronized</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cancel</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (socket != <span style="color: #ffd700;">null</span>) {
                socket.close();
            }
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">IOException</span> <span style="color: #4eee94;">ignored</span>) {
        }
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">RunnableFuture</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #daa520; font-weight: bold;">newTask</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">FutureTask</span>&lt;<span style="color: #98f5ff;">T</span>&gt;(<span style="color: #00bfff; font-weight: bold;">this</span>) {
            <span style="color: #ffd700;">@Override</span>
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23450;&#20041;FutureTask&#30340;&#21311;&#21517;&#20869;&#37096;&#31867;, &#24182;&#35206;&#30422;cancel&#26041;&#27861;, &#21521;&#20854;&#20013;&#21152;&#20837;&#20851;&#38381;socket&#30340;&#25805;&#20316;  </span>
            <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">cancel</span>(<span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">mayInterruptIfRunning</span>) {
                <span style="color: #00bfff; font-weight: bold;">try</span> {
                    SocketUsingTask.<span style="color: #00bfff; font-weight: bold;">this</span>.cancel();
                } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">super</span>.cancel(mayInterruptIfRunning);
                }
            }
        };
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">T</span> <span style="color: #daa520; font-weight: bold;">call</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
        ...
    }
}
</pre>
</div>

<p>
<b>继承</b> <span class="underline">ThreadPoolExecutor</span> 类并覆盖 <span class="underline">newTaskFor</span> 方法, 返回 <span class="underline">自定义的CancelTask对象</span>  
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffd700;">@ThreadSafe</span>
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">CancellingExecutor</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span> {

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">CancellingExecutor</span>() {
        <span style="color: #00bfff; font-weight: bold;">super</span>(10, 10,
              0L, <span style="color: #ffd700;">TimeUnit</span>.MILLISECONDS,
              <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;());
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">protected</span> &lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">RunnableFuture</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #daa520; font-weight: bold;">newTaskFor</span>(<span style="color: #98f5ff;">Callable</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">callable</span>) {
        <span style="color: #00bfff; font-weight: bold;">if</span> (callable <span style="color: #00bfff; font-weight: bold;">instanceof</span> CancellableTask) {
            <span style="color: #00bfff; font-weight: bold;">return</span> ((<span style="color: #98f5ff;">CancellableTask</span>&lt;<span style="color: #98f5ff;">T</span>&gt;) callable).newTask();
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
            <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">super</span>.newTaskFor(callable);
        }
    }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">CancellingExecutorTest</span> {
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">IOException</span> {
        <span style="color: #98f5ff;">CancellingExecutor</span> <span style="color: #4eee94;">executor</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">CancellingExecutor</span>();
        <span style="color: #98f5ff;">SocketUsingTask</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">task</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SocketUsingTask</span>&lt;&gt;();
        task.setSocket(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Socket</span>(<span style="color: #deb887;">"www.baidu.com"</span>, 80));
        <span style="color: #98f5ff;">Future</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">future</span> = executor.submit(task);
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            future.get(1000L, <span style="color: #ffd700;">TimeUnit</span>.MILLISECONDS);
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (TimeoutException | InterruptedException ex) {
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">ExecutionException</span> <span style="color: #4eee94;">ex</span>) {
            <span style="color: #00bfff; font-weight: bold;">throw</span> launderThrowable(ex.getCause());
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            future.cancel(<span style="color: #ffd700;">true</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">interrupt if running</span>
            executor.shutdown();
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org82539bb" class="outline-2">
<h2 id="org82539bb">取消线程</h2>
<div class="outline-text-2" id="text-org82539bb">
<p>
如果一个线程在 <span class="underline">创建结束</span> 之后 <span class="underline">依然运行</span> ，那就必须为这个线程提供诸如 <b>取消</b> ， <b>关闭</b> 等生命周期方法
</p>

<pre class="example">
    比如: ExecutorService提供了shutDown和shutDownNow方法关闭Service

    而Service负责停止其拥有的线程
</pre>
</div>

<div id="outline-container-orga594476" class="outline-3">
<h3 id="orga594476">基于生产消费者模型的LoggerWriter</h3>
<div class="outline-text-3" id="text-orga594476">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LogWriter</span> {  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">queue</span>;  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">LoggerThread</span> <span style="color: #4eee94;">logger</span>;  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">LogWriter</span>(<span style="color: #98f5ff;">Writer</span> <span style="color: #4eee94;">writer</span>) {  
        <span style="color: #00bfff; font-weight: bold;">this</span>.queue = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;<span style="color: #98f5ff;">String</span>&gt;(CAPACITY);  
        <span style="color: #00bfff; font-weight: bold;">this</span>.logger = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LoggerThread</span>(writer);  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">start</span>() {  
        logger.start();  
    }  

    <span style="color: #ffebcd;">/** </span>
<span style="color: #ffebcd;">     * &#38656;&#35201;&#25171;&#21360;&#25968;&#25454;&#30340;&#32447;&#31243;&#35843;&#29992;&#35813;&#26041;&#27861;, &#23558;&#24453;&#25171;&#21360;&#25968;&#25454;&#21152;&#20837;&#38459;&#22622;&#38431;&#21015; </span>
<span style="color: #ffebcd;">     */</span>  
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">log</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">msg</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {  
        queue.put(msg);  
    }  

    <span style="color: #ffebcd;">/** </span>
<span style="color: #ffebcd;">     * &#36127;&#36131;&#20174;&#38459;&#22622;&#38431;&#21015;&#20013;&#21462;&#20986;&#25968;&#25454;&#36755;&#20986;&#30340;&#32447;&#31243; </span>
<span style="color: #ffebcd;">     */</span>  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LoggerThread</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {  
        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">PrintWriter</span> <span style="color: #4eee94;">writer</span>;  
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">...  </span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {  
            <span style="color: #00bfff; font-weight: bold;">try</span> {  
                <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>)  
                    writer.println(queue.take());  
            } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">ignored</span>) {  
            } <span style="color: #00bfff; font-weight: bold;">finally</span> {  
                writer.close();  
            }  
        }  
    }  
}  
</pre>
</div>

<pre class="example">
LogWriter 内部封装有 LoggerThread 线程, 所以是一个基于线程构建的Service

需要在LogWriter中提供停止LoggerThread线程的方法
</pre>
<p>
在LogWriter中添加shutDown方法
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #ffebcd;">/** </span>
<span style="color: #ffebcd;"> * &#35813;&#26041;&#27861;&#29992;&#20110;&#20572;&#27490;LoggerThread&#32447;&#31243; </span>
<span style="color: #ffebcd;"> */</span>  
<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">shutDown</span>() {  
    logger.interrupt();  
}  
</pre>
</div>
<ol class="org-ol">
<li>当 <span class="underline">LogWriter.shutDown</span> 方法被调用时</li>
<li><span class="underline">LoggerThread线程的中断标记</span> 被设置为 <span class="underline">true</span></li>
<li><span class="underline">LoggerThread线程</span> 执行 <span class="underline">queue.take()</span> 方法时会抛出 <span class="underline">InterruptedException</span> 异常</li>
<li>使得 <span class="underline">LoggerThread线程</span> <b>结束</b></li>
</ol>
</div>
</div>

<div id="outline-container-orgcf8ebd2" class="outline-3">
<h3 id="orgcf8ebd2">中断线程的问题</h3>
<div class="outline-text-3" id="text-orgcf8ebd2">
<ol class="org-ol">
<li><b>丢弃</b> 了队列中 <span class="underline">尚未来得及输出</span> 的数据</li>
<li>假如 <span class="underline">线程A</span> 对 <span class="underline">LogWriter.log方法的调用</span> 因为 <span class="underline">队列已满</span> 而 <b>阻塞</b> , 此时 <span class="underline">停止LoggerThread线程</span> 将导致 <b>线程A永远阻塞在queue.put方法上</b> 　</li>
</ol>

<pre class="example">
     当停止LogService以后，设置状态不在接受新的任务，并处理完所有已经存在的数据
</pre>
<p>
这种处理方式会导致 <span class="underline">竞争条件</span> ，所以必须 <b>手动同步</b> 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LogService</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">BlockingQueue</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">queue</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">LoggerThread</span> <span style="color: #4eee94;">loggerThread</span>;
    <span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">     * &#34920;&#31034;&#26159;&#21542;&#20851;&#38381;Service</span>
<span style="color: #ffebcd;">     */</span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">isShutdown</span>;
    <span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">     * &#38431;&#21015;&#20013;&#24453;&#22788;&#29702;&#25968;&#25454;&#30340;&#25968;&#37327;</span>
<span style="color: #ffebcd;">     */</span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">reservations</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">LogService</span>(<span style="color: #98f5ff;">PrintWriter</span> <span style="color: #4eee94;">writer</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.queue = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;&gt;(100);
        <span style="color: #00bfff; font-weight: bold;">this</span>.loggerThread = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LoggerThread</span>(writer);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">start</span>() {
        loggerThread.start();
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">shutDown</span>() {
        <span style="color: #00bfff; font-weight: bold;">synchronized</span> (<span style="color: #00bfff; font-weight: bold;">this</span>) {
            isShutdown = <span style="color: #ffd700;">true</span>;
        }
        loggerThread.interrupt();
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">log</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">msg</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
        <span style="color: #00bfff; font-weight: bold;">synchronized</span> (<span style="color: #00bfff; font-weight: bold;">this</span>) {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">service&#24050;&#20851;&#38381;&#21518;&#35843;&#29992;log&#26041;&#27861;&#30452;&#25509;&#25243;&#20986;&#24322;&#24120;  </span>
            <span style="color: #00bfff; font-weight: bold;">if</span> (isShutdown) {
                <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">IllegalStateException</span>(<span style="color: #deb887;">"Service has been shut down"</span>);
            }
            ++reservations;
        }
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">BlockingQueue&#26412;&#36523;&#23601;&#26159;&#32447;&#31243;&#23433;&#20840;&#30340;, put&#26041;&#27861;&#30340;&#35843;&#29992;&#19981;&#22312;&#21516;&#27493;&#20195;&#30721;&#22359;&#20013;  </span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25105;&#20204;&#21482;&#38656;&#35201;&#20445;&#35777;isShutdown&#21644;reservations&#26159;&#32447;&#31243;&#23433;&#20840;&#30340;&#21363;&#21487;  </span>
        queue.put(msg);
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LoggerThread</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {
        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">PrintWriter</span> <span style="color: #4eee94;">writer</span>;
        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #daa520; font-weight: bold;">LoggerThread</span>(<span style="color: #98f5ff;">PrintWriter</span> <span style="color: #4eee94;">writer</span>) {
            <span style="color: #00bfff; font-weight: bold;">this</span>.writer = writer;
        }

        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
            <span style="color: #00bfff; font-weight: bold;">try</span> {
                <span style="color: #00bfff; font-weight: bold;">while</span> (<span style="color: #ffd700;">true</span>) {
                    <span style="color: #00bfff; font-weight: bold;">try</span> {
                        <span style="color: #00bfff; font-weight: bold;">synchronized</span> (<span style="color: #00bfff; font-weight: bold;">this</span>) {
                            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#24403;service&#24050;&#20851;&#38381;&#19988;&#22788;&#29702;&#23436;&#38431;&#21015;&#20013;&#30340;&#25152;&#26377;&#25968;&#25454;&#26102;&#25165;&#36339;&#20986;while&#24490;&#29615;  </span>
                            <span style="color: #00bfff; font-weight: bold;">if</span> (isShutdown &amp;&amp; reservations == 0) {
                                <span style="color: #00bfff; font-weight: bold;">break</span>;
                            }
                        }
                        <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">msg</span> = queue.take();
                        <span style="color: #00bfff; font-weight: bold;">synchronized</span> (<span style="color: #00bfff; font-weight: bold;">this</span>) {
                            --reservations;
                        }
                        writer.println(msg);
                    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">e</span>) {
                        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#29983;InterruptedException&#24322;&#24120;&#26102;&#19981;&#24212;&#35813;&#31435;&#21051;&#36339;&#20986;while&#24490;&#29615;  </span>
                        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#32780;&#24212;&#35813;&#32487;&#32493;&#36755;&#20986;log, &#30452;&#21040;&#22788;&#29702;&#23436;&#38431;&#21015;&#20013;&#30340;&#25152;&#26377;&#25968;&#25454;  </span>
                    }
                }
            } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                writer.close();
            }
        }
    }
}
</pre>
</div>

<p>
可以 <b>使用 <span class="underline">ExecutorService</span> 简化</b>  ：
</p>
<ul class="org-ul">
<li>关闭ExecutorService后再调用其 <span class="underline">awaitTermination</span> 将导致 <b>当前线程阻塞</b> , 直到 <span class="underline">所有已提交的任务执行完毕</span> , 或者发生 <span class="underline">超时</span></li>
<li><p>
<span class="underline">线程池关闭</span> 后再 <span class="underline">调用其execute方法</span> 将抛出 <span class="underline">RejectedExecutionException</span> 异常  
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LogService</span> {

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">exec</span> = Executors.newSingleThreadExecutor();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">PrintWriter</span> <span style="color: #4eee94;">writer</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">LogService</span>(<span style="color: #98f5ff;">PrintWriter</span> <span style="color: #4eee94;">writer</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.writer = writer;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">shutdown</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
        <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">TIMEOUT</span> = 10L; 
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20851;&#38381;ExecutorService&#21518;&#20877;&#35843;&#29992;&#20854;awaitTermination&#23558;&#23548;&#33268;&#24403;&#21069;&#32447;&#31243;&#38459;&#22622;, &#30452;&#21040;&#25152;&#26377;&#24050;&#25552;&#20132;&#30340;&#20219;&#21153;&#25191;&#34892;&#23436;&#27605;, &#25110;&#32773;&#21457;&#29983;&#36229;&#26102;  </span>
            exec.shutdown();
            exec.awaitTermination(TIMEOUT, <span style="color: #ffd700;">TimeUnit</span>.SECONDS);
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            writer.close();
        }
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">log</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">msg</span>) {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#32447;&#31243;&#27744;&#20851;&#38381;&#21518;&#20877;&#35843;&#29992;&#20854;execute&#26041;&#27861;&#23558;&#25243;&#20986;RejectedExecutionException&#24322;&#24120;  </span>
            exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">WriteTask</span>(msg));
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RejectedExecutionException</span> <span style="color: #4eee94;">ignored</span>) {
        }
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">WriteTask</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Runnable</span> {
        <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">msg</span>;
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">WriteTask</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">msg</span>) {
            <span style="color: #00bfff; font-weight: bold;">this</span>.msg = msg;
        }

        <span style="color: #ffd700;">@Override</span>
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
            writer.println(msg);
        }
    }
}
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-orgec4a5a6" class="outline-4">
<h4 id="orgec4a5a6">shutdownNow的局限性</h4>
<div class="outline-text-4" id="text-orgec4a5a6">
<pre class="example">
      无法知道那些正在运行任务的最终结束状态
</pre>

<p>
必须 <b>手动记录</b> 那些 <span class="underline">被中断的任务</span>
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">abstract</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">TrackingExecutor</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">AbstractExecutorService</span> {

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">exec</span> = Executors.newCachedThreadPool();
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#24050;&#32463;&#21551;&#21160;&#36824;&#27809;&#26377;&#32467;&#26463;&#34987;cancel&#30340;&#32447;&#31243;&#23384;&#25918;&#22312;&#36825;&#37324;</span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Set</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt; <span style="color: #4eee94;">tasksCancelledAtShutdown</span>
    = Collections.synchronizedSet(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">HashSet</span>&lt;&gt;());

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt; <span style="color: #daa520; font-weight: bold;">getCancelledTasks</span>() {
        <span style="color: #00bfff; font-weight: bold;">if</span> (!exec.isTerminated()) {
            <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">IllegalStateException</span>(<span style="color: #deb887;">"illegal task status"</span>);
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ArrayList</span>&lt;&gt;(tasksCancelledAtShutdown);
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">execute</span>(<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">runnable</span>) {
        exec.execute(() -&gt; {
                <span style="color: #00bfff; font-weight: bold;">try</span> {
                    runnable.run();
                } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                    <span style="color: #00bfff; font-weight: bold;">if</span> (isShutdown()
                        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#25191;&#34892;&#30340;&#20219;&#21153;&#24517;&#39035;&#20445;&#35777;&#27491;&#30830;&#22320;&#25226;&#20013;&#26029;&#29366;&#24577;&#20256;&#36882;&#22238;&#26469;</span>
                        &amp;&amp; Thread.currentThread().isInterrupted()) {
                        tasksCancelledAtShutdown.add(runnable);
                    }
                }
            });
    }
}
</pre>
</div>

<pre class="example">
      极小的概率可能发生在关闭线程池的那一刻某个任务实际上已经执行完最后一条指令，但还没来得及记录任务运行结束

      这种情况下就会造成将来重复执行任务
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org651b7d4" class="outline-2">
<h2 id="org651b7d4">异常退出</h2>
<div class="outline-text-2" id="text-org651b7d4">
<p>
<b>线程异常退出</b> 的主要原因是 <span class="underline">RunTimeException</span>
</p>

<pre class="example">
    这种情况下往往不会通知主线程
</pre>

<p>
在某些情况下需要 <b>捕获</b> 这些RunTimeException
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
    <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">thrown</span> = <span style="color: #ffd700;">null</span>;
    <span style="color: #00bfff; font-weight: bold;">try</span> {
        <span style="color: #00bfff; font-weight: bold;">while</span> (!isInterrupted())
            runTask(getTaskFromWorkQueue());
    } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">e</span>) {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20445;&#23384;&#25152;&#26377;&#24322;&#24120;</span>
        thrown = e;
    } <span style="color: #00bfff; font-weight: bold;">finally</span> {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36890;&#30693;&#20027;&#32447;&#31243;&#20445;&#23384;&#30340;&#24322;&#24120;</span>
        threadExited(<span style="color: #00bfff; font-weight: bold;">this</span>, thrown);
    }
}
</pre>
</div>
</div>

<div id="outline-container-org8f4dffa" class="outline-3">
<h3 id="org8f4dffa">未捕获异常处理器</h3>
<div class="outline-text-3" id="text-org8f4dffa">
<p>
长时间运行的应用，对于未捕获的异常至少要在 <b>日志记录</b> 下来　
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">UEHLogger</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #ffd700;">Thread</span>.<span style="color: #98f5ff;">UncaughtExceptionHandler</span> {
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uncaughtException</span>(<span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span>, <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">e</span>) {
        <span style="color: #98f5ff;">Logger</span> <span style="color: #4eee94;">logger</span> = Logger.getAnonymousLogger();
        logger.log(<span style="color: #ffd700;">Level</span>.SEVERE,
               <span style="color: #deb887;">"Thread terminated with exception: "</span> + t.getName(),
               e);
    }
}
</pre>
</div>

<pre class="example">
     通过线程池构造器的ThreadFactory参数可以使用自定义UncaughtExceptionHandler　
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc453efe" class="outline-2">
<h2 id="orgc453efe">关闭JVM</h2>
<div class="outline-text-2" id="text-orgc453efe">
</div>
<div id="outline-container-orgcff2946" class="outline-3">
<h3 id="orgcff2946">正常关闭　</h3>
<div class="outline-text-3" id="text-orgcff2946">
<ul class="org-ul">
<li>运行完 <span class="underline">主线程最后一条命令</span></li>
<li>调用 <span class="underline">System.exit</span></li>
<li>发送 <b>SIGINT</b> 信号(CTRL+C)</li>
</ul>

<pre class="example">
jvm不会主动关闭或者中断任何其他线程
</pre>

<p>
正常关闭的时候：
</p>
<ol class="org-ol">
<li>开始运行 <b>注册</b> 在 <span class="underline">Runtime.addShutdownHook</span> 的 <b>钩子线程</b></li>
<li>所有的钩子线程运行完毕，如果 <span class="underline">runFinalizersOnExit</span> <b>被设置</b> 的话，jvm开始运行 <b>finializer</b></li>
<li>停止jvm</li>
</ol>
</div>

<div id="outline-container-org41425cc" class="outline-4">
<h4 id="org41425cc">关闭钩子</h4>
<div class="outline-text-4" id="text-org41425cc">
<ul class="org-ul">
<li>钩子线程必须是 <b>同步</b></li>
<li>钩子线程 <b>不能死锁</b> ，不然jvm无法关闭</li>
<li>所有的钩子线程会 <b>同时运行</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">start</span>() {
    Runtime.getRuntime().addShutdownHook(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>() {
            <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                <span style="color: #00bfff; font-weight: bold;">try</span> { LogService.<span style="color: #00bfff; font-weight: bold;">this</span>.stop(); }
                <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">InterruptedException</span> <span style="color: #4eee94;">ignored</span>) {}
            }
        });
}
</pre>
</div>

<pre class="example">
      尽量使用一个钩子关闭所有的服务！
</pre>
</div>
</div>

<div id="outline-container-orge2bb2f5" class="outline-4">
<h4 id="orge2bb2f5">守护线程</h4>
<div class="outline-text-4" id="text-orge2bb2f5">
<p>
<span class="underline">守护线程</span> 在被关闭的时候不会运行 <span class="underline">finializer</span> ， <span class="underline">回收函数栈</span> 
</p>

<pre class="example">
    当jvm停止的那一刻，守护线程只是被抛弃

    慎用守护线程！
</pre>
</div>
</div>
</div>
<div id="outline-container-org54b9886" class="outline-3">
<h3 id="org54b9886">强行关闭</h3>
<div class="outline-text-3" id="text-org54b9886">
<ul class="org-ul">
<li>调用 <span class="underline">RunTime.halt</span></li>
<li><p>
发送 <b>SIGKILL</b> 信号(kill -9) 
</p>

<p>
<a href="thread_pool.html">Next:线程池</a>
</p>

<p>
<a href="executor.html">Previous:任务执行</a>
</p>

<p>
<a href="jcip.html">Up:目录</a>
</p></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
