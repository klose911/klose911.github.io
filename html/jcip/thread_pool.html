<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>线程池</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="cancellation.html"> UP </a>
 |
 <a accesskey="H" href="jcip.html"> HOME </a>
</div><div id="content">
<h1 class="title">线程池</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org08c5c8a">任务和执行策略的隐形耦合</a>
<ul>
<li><a href="#org27a2888">线程死锁</a></li>
<li><a href="#org985e341">长时间运行任务</a></li>
</ul>
</li>
<li><a href="#org8841dc9">线程池大小</a></li>
<li><a href="#orgad2f694">线程池配置</a>
<ul>
<li><a href="#org4594a05">线程的创建和销毁</a></li>
<li><a href="#org6797865">任务队列</a></li>
<li><a href="#org58c6981">饱和策略</a>
<ul>
<li><a href="#orgfe0d106">CallerRunsPolicy</a></li>
<li><a href="#org70c194c">BoundExecutor</a></li>
</ul>
</li>
<li><a href="#org3f8e2bb">ThreadFactory</a></li>
</ul>
</li>
<li><a href="#org612ea7c">扩展线程池</a></li>
<li><a href="#orgdaa187c">并行执行递归算法</a></li>
</ul>
</div>
</div>
<div id="outline-container-org08c5c8a" class="outline-2">
<h2 id="org08c5c8a">任务和执行策略的隐形耦合</h2>
<div class="outline-text-2" id="text-org08c5c8a">
<p>
某些 <span class="underline">任务的特质</span> 会 <b>要求或者排除</b> 某些特定的 <span class="underline">执行策略</span> 
</p>
<ul class="org-ul">
<li>有 <span class="underline">相互依赖</span> 的任务在 <span class="underline">同一个线程池</span> 会要求 <span class="underline">线程池无限大</span></li>
<li>依赖于 <span class="underline">线程封闭</span> 的任务 <span class="underline">只能用</span>  <span class="underline">单线程执行</span> 的线程池</li>
<li><span class="underline">快速响应</span> 的任务 <span class="underline">不适合</span>  <span class="underline">单线程执行</span> 的线程池</li>
<li>使用 <span class="underline">ThreadLocal</span> 的任务 <b>不适合</b> <span class="underline">线程池</span></li>
</ul>
</div>

<div id="outline-container-org27a2888" class="outline-3">
<h3 id="org27a2888">线程死锁</h3>
<div class="outline-text-3" id="text-org27a2888">
<p>
<b>相互依赖</b> 的任务在 <span class="underline">一个线程池</span> 中执行，就可能出现 <span class="underline">饥饿死锁</span> 
</p>

<pre class="example">
     比如在一个单线程执行的线程池中
     线程B需要等待线程A执行完毕才能进入线程池执行
     而线程A又要等待线程B执行完毕才能完毕。这样就造成了死锁

     当线程池容量更大一点的情况下，依然可能所有存在于线程池中的线程都在等待“未能进入线程池”的线程执行完毕
</pre>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ThreadDeadlock</span> {
    <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">exec</span> = Executors.newSingleThreadExecutor();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">RenderPageTask</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Callable</span>&lt;<span style="color: #98f5ff;">String</span>&gt; {
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">String</span> <span style="color: #daa520; font-weight: bold;">call</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #98f5ff;">Future</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">header</span>, <span style="color: #4eee94;">footer</span>;
            header = exec.submit(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LoadFileTask</span>(<span style="color: #deb887;">"header.html"</span>)); 
            footer = exec.submit(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LoadFileTask</span>(<span style="color: #deb887;">"footer.html"</span>));
            <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">page</span> = renderBody();
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Will deadlock -- task waiting for result of subtask</span>
            <span style="color: #00bfff; font-weight: bold;">return</span> header.get() + page + footer.get();
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org985e341" class="outline-3">
<h3 id="org985e341">长时间运行任务</h3>
<div class="outline-text-3" id="text-org985e341">
<p>
线程池包含 <span class="underline">许多运行长时间</span> 的任务会导致 <b>所有任务 <span class="underline">哪怕本来响应很快</span> 的响应变慢</b>  
</p>

<pre class="example">
     使用timeout机制，标记那些超时的任务为失败，在未来串行执行
</pre>
</div>
</div>
</div>

<div id="outline-container-org8841dc9" class="outline-2">
<h2 id="org8841dc9">线程池大小</h2>
<div class="outline-text-2" id="text-org8841dc9">
<ul class="org-ul">
<li>对于 <b>计算密集型</b> task, 合适的size大约为 <span class="underline">CPU数量 + 1</span></li>
<li>对于 <b>I/O占较大比例</b> 的task, 合适的size大约为:  <span class="underline">size = CPU数量 * CPU利用率 * (1 + I/O时间比例)</span></li>
</ul>

<pre class="example">
    实际size还受到内存,  文件句柄,  socket, 数据库连接数 等稀缺资源的约束

    将总的稀缺资源除以每一个task使用的资源数,  能得到线程数的上限
</pre>
</div>
</div>

<div id="outline-container-orgad2f694" class="outline-2">
<h2 id="orgad2f694">线程池配置</h2>
<div class="outline-text-2" id="text-orgad2f694">
</div>
<div id="outline-container-org4594a05" class="outline-3">
<h3 id="org4594a05">线程的创建和销毁</h3>
<div class="outline-text-3" id="text-org4594a05">
<p>
<span class="underline">ThreadPoolExecutor</span> 构造函数中与线程的 <span class="underline">创建</span> 和 <span class="underline">销毁</span> 有关的参数： 
</p>
<ul class="org-ul">
<li><span class="underline">corePoolSize</span> ：线程池中持有的 <b>核心线程数</b> 
<ul class="org-ul">
<li><span class="underline">除非task队列已满</span> , ThreadPoolExecutor <b>不会创建</b> <span class="underline">超过核心线程数</span> 的线程
<ul class="org-ul">
<li><span class="underline">corePoolSize为0</span> ：一种特殊情况, 此时就算task队列没有饱和, 向线程池第一次提交task时仍然会创建新的线程</li>
</ul></li>
<li><span class="underline">核心线程</span> 一旦 <span class="underline">创建</span> 就 <b>不会销毁</b> ，除非： 
<ul class="org-ul">
<li>设置了 <span class="underline">allowCoreThreadTimeOut(true)</span></li>
<li><b>关闭</b> 线程池</li>
</ul></li>
</ul></li>
<li><span class="underline">maximumPoolSize</span> ：线程池中持有的 <b>最大线程数</b></li>
<li><p>
<span class="underline">keepAliveTime</span> ：对于 <span class="underline">超过核心线程数</span> 的线程, 如果在 <span class="underline">指定的超时时间内</span> <b>没有使用</b> 到, 就会被 <b>销毁</b> 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #daa520; font-weight: bold;">newCachedThreadPool</span>() {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26680;&#24515;&#32447;&#31243;&#25968;&#20026;0, &#26368;&#22823;&#32447;&#31243;&#25968;&#20026;Integer.MAX_VALUE, &#36229;&#26102;&#26102;&#38388;&#20026;60s  </span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(0, <span style="color: #ffd700;">Integer</span>.MAX_VALUE, 60L, <span style="color: #ffd700;">TimeUnit</span>.SECONDS, <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SynchronousQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;());  
}  

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #daa520; font-weight: bold;">newFixedThreadPool</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nThreads</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26680;&#24515;&#32447;&#31243;&#25968;&#21644;&#26368;&#22823;&#32447;&#31243;&#25968;&#37117;&#20026;&#35843;&#29992;&#26041;&#25351;&#23450;&#30340;&#20540;nThreads, &#36229;&#26102;&#26102;&#38388;&#20026;0  </span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(nThreads, nThreads, 0L, <span style="color: #ffd700;">TimeUnit</span>.MILLISECONDS,  
                      <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;());  
}  

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">ScheduledExecutorService</span> <span style="color: #daa520; font-weight: bold;">newScheduledThreadPool</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">corePoolSize</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26680;&#24515;&#32447;&#31243;&#25968;&#30001;&#35843;&#29992;&#26041;&#25351;&#23450;, &#26368;&#22823;&#32447;&#31243;&#25968;&#20026;Integer.MAX_VALUE, &#36229;&#26102;&#26102;&#38388;&#20026;0  </span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(corePoolSize, <span style="color: #ffd700;">Integer</span>.MAX_VALUE, 0, <span style="color: #ffd700;">TimeUnit</span>.NANOSECONDS, <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">DelayedWorkQueue</span>());  
}   
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org6797865" class="outline-3">
<h3 id="org6797865">任务队列</h3>
<div class="outline-text-3" id="text-org6797865">
<p>
线程池内部持有一个 <b>任务队列</b> , 当 <span class="underline">任务的提交速度</span> <b>超过</b> <span class="underline">任务的执行速度</span> 时, 任务将被 <b>缓存</b> 在 <span class="underline">任务队列</span> 中等待有线程可用时再执行。ThreadPoolExecutor在创建时可以为其指定任务队列。一般有三种选择: 
</p>
<ol class="org-ol">
<li><span class="underline">有界</span> 队列</li>
<li><span class="underline">无界</span> 队列：newFixedThreadPool, newScheduledThreadPool</li>
<li><span class="underline">同步</span> 队列：newCashedThreadPool</li>
</ol>

<p>
<span class="underline">线程数不多</span> 的线程池：
</p>
<ul class="org-ul">
<li>指定一个 <b>容量大的队列</b> (或者无界队列)：
<ul class="org-ul">
<li>有助于 <span class="underline">减少线程间切换</span> , CPU等方面的消耗</li>
<li>可能会造成吞吐量下降</li>
</ul></li>
<li>如果使用的是 <span class="underline">有界队列</span> , 队列 <b>可能会被填满</b> ：将根据 <span class="underline">指定的饱和策略</span> 进行处理</li>
</ul>

<pre class="example">
     同步队列其实不能算是一种队列，因为同步队列没有缓存的作用

     使用同步队列时, task被提交时, 直接由线程池中的线程接手
     如果此时线程池中没有可用的线程, 线程池将创建新的线程接手
     如果线程池无法创建新的线程(比如线程数已到达maximumPoolSize), 则根据指定的饱和策略进行处理 
</pre>

<p>
<span class="underline">线程数很大</span> 的线程池, 可以使用 <b>同步队列</b> 
</p>
</div>
</div>

<div id="outline-container-org58c6981" class="outline-3">
<h3 id="org58c6981">饱和策略</h3>
<div class="outline-text-3" id="text-org58c6981">
<ul class="org-ul">
<li><span class="underline">有界队列</span> ： <b>队列满后继续提交</b> task时, 饱和策略会被触发.</li>
<li><span class="underline">同步队列</span> :  线程池 <b>无法创建新的线程</b> 接手task时, 饱和策略会被触发.</li>
<li><span class="underline">线程池被关闭</span> 后,：向其提交task时, 饱和策略也会被触发.</li>
</ul>

<p>
<span class="underline">ThreadPoolExecutor.setRejectedExecutionHandler</span> 方法用于 <b>设定饱和策略</b> 
</p>

<p>
预定义 <span class="underline">RejectedExecutionHandler</span> 的实现类
</p>
<ol class="org-ol">
<li><p>
<span class="underline">AbortPolicy</span> :  <b>默认的</b> 饱和策略, 抛出 <span class="underline">RejectedExecutionException</span> 异常 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">RejectedExecutionException</span>();  
}   
</pre>
</div></li>
<li><p>
<span class="underline">CallerRunsPolicy</span> : 在 <span class="underline">提交task的线程中执行</span> task, 而不是由线程池中的线程执行
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #00bfff; font-weight: bold;">if</span> (!e.isShutdown()) {  
        r.run();  
    }  
}  
</pre>
</div></li>
<li><p>
<span class="underline">DiscardPolicy</span> : 将最新提交的任务 <b>丢弃</b> 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20002;&#24323;, &#19981;&#20570;&#20219;&#20309;&#22788;&#29702;  </span>
}   
</pre>
</div></li>

<li><p>
<span class="underline">DiscardOldestPolicy</span> : 将 <b>队列头部的任务丢弃</b> ，然后尝试重新提交新的任务
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #00bfff; font-weight: bold;">if</span> (!e.isShutdown()) {  
        e.getQueue().poll();  
        e.execute(r);  
    }  
}   
</pre>
</div></li>
</ol>
</div>

<div id="outline-container-orgfe0d106" class="outline-4">
<h4 id="orgfe0d106">CallerRunsPolicy</h4>
<div class="outline-text-4" id="text-orgfe0d106">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LifecycleWebServer</span> {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">MAX_THREAD_COUNT&#21644;MAX_QUEUE_COUNT&#30340;&#20540;&#26681;&#25454;&#31995;&#32479;&#30340;&#23454;&#38469;&#24773;&#20917;&#30830;&#23450;  </span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">MAX_THREAD_COUNT</span> = 100;  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">MAX_QUEUE_COUNT</span> = 1000;  

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#26377;&#30028;&#38431;&#21015;&#20316;&#20026;task&#38431;&#21015;, &#24403;&#26377;&#30028;&#38431;&#21015;&#28385;&#26102;, &#23558;&#35302;&#21457;&#39281;&#21644;&#31574;&#30053;  </span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">exec</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(0, MAX_THREAD_COUNT, 60L, <span style="color: #ffd700;">TimeUnit</span>.SECONDS,  
                                       <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ArrayBlockingQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;(MAX_QUEUE_COUNT));  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">start</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">IOException</span> {  
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#39281;&#21644;&#31574;&#30053;&#20026;CallerRunsPolicy  </span>
        exec.setRejectedExecutionHandler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #ffd700;">ThreadPoolExecutor</span>.<span style="color: #98f5ff;">CallerRunsPolicy</span>());  
        <span style="color: #98f5ff;">ServerSocket</span> <span style="color: #4eee94;">socket</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ServerSocket</span>(80);  
        <span style="color: #00bfff; font-weight: bold;">while</span> (!exec.isShutdown()) {  
            <span style="color: #00bfff; font-weight: bold;">try</span> {  
                <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">conn</span> = socket.accept();  
                exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {  
                        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {  
                            handleRequest(conn);  
                        }  
                    });  
            } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RejectedExecutionException</span> <span style="color: #4eee94;">e</span>) {  
                <span style="color: #00bfff; font-weight: bold;">if</span> (!exec.isShutdown())  
                    log(<span style="color: #deb887;">"task submission rejected"</span>, e);  
            }  
        }  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">stop</span>() {  
        exec.shutdown();  
    }  

    <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">handleRequest</span>(<span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">connection</span>) {  
        <span style="color: #98f5ff;">Request</span> <span style="color: #4eee94;">req</span> = readRequest(connection);  
        <span style="color: #00bfff; font-weight: bold;">if</span> (isShutdownRequest(req))  
            stop();  
        <span style="color: #00bfff; font-weight: bold;">else</span>  
            dispatchRequest(req);  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {  
        <span style="color: #98f5ff;">LifecycleWebServer</span> <span style="color: #4eee94;">server</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LifecycleWebServer</span>();  
        <span style="color: #00bfff; font-weight: bold;">try</span> {  
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;main&#32447;&#31243;&#20013;&#21551;&#21160;server  </span>
            server.start();  
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">IOException</span> <span style="color: #4eee94;">e</span>) {  
            e.printStackTrace();  
        }  
    }  
}   
</pre>
</div>
<ul class="org-ul">
<li>如果线程池饱和时主线程仍然向线程池提交任务, 那么任务将在主线程中执行</li>
<li>主线程执行任务是需要一定时间的，这样就给了线程池喘息的机会
<ul class="org-ul">
<li>主线程在执行任务的时间内 <b>无法接受socket连接</b> , 因此socket连接请求将 <span class="underline">缓存在tcp层</span></li>
<li>如果 <span class="underline">server过载持续的时间较长</span> , 使得 <b>tcp层的缓存不够</b> , 那么 <span class="underline">tcp缓存</span> 将根据其策略 <b>丢弃部分请求</b></li>
</ul></li>
</ul>

<pre class="example">
      整个系统的过载压力逐步向外扩散: 线程池 - 线程池中的队列 - main线程 - tcp层 - client

      不会因为过多的请求而导致系统资源耗尽, 也不会一发生过载时就拒绝服务, 只有发生长时间系统过载时才会出现客户端无法连接的情况！！！
</pre>
</div>
</div>
<div id="outline-container-org70c194c" class="outline-4">
<h4 id="org70c194c">BoundExecutor</h4>
<div class="outline-text-4" id="text-org70c194c">
<p>
<b>没有预定的饱和策略</b> 来限定线程池中执行任务线程的数量，可以结合 <span class="underline">Semaphore</span> 来实现
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">BoundedExecutor</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Semaphore</span> <span style="color: #4eee94;">semaphore</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">BoundedExecutor</span>(<span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">bound</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.exec = exec;
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#23450;&#20449;&#21495;&#37327;permit&#30340;&#19978;&#38480;</span>
        <span style="color: #00bfff; font-weight: bold;">this</span>.semaphore = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Semaphore</span>(bound);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">submitTask</span>(<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">command</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25552;&#20132;task&#21069;&#20808;&#30003;&#35831;permit, &#22914;&#26524;&#26080;&#27861;&#30003;&#35831;&#21040;permit, &#35843;&#29992;submitTask&#30340;&#32447;&#31243;&#23558;&#34987;&#38459;&#22622;, &#30452;&#21040;&#26377;permit&#21487;&#29992;</span>
        semaphore.acquire();
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                        <span style="color: #00bfff; font-weight: bold;">try</span> {
                            command.run();
                        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25552;&#20132;&#25104;&#21151;&#20102;, &#36816;&#34892;task&#21518;&#37322;&#25918;permit</span>
                            semaphore.release();
                        }
                    }
                });
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RejectedExecutionException</span> <span style="color: #4eee94;">e</span>) {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#25552;&#20132;&#25104;&#21151;, &#20063;&#38656;&#35201;&#37322;&#25918;permit</span>
            semaphore.release();
        }
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3f8e2bb" class="outline-3">
<h3 id="org3f8e2bb">ThreadFactory</h3>
<div class="outline-text-3" id="text-org3f8e2bb">
<p>
创建ThreadPoolExecutor时还可以为其 <b>指定</b> <span class="underline">ThreadFactory</span> ：当线程池需要 <b>创建新的线程</b> 时会调用 <span class="underline">ThreadFactory</span> 的 <b>newThread</b> 方法
</p>
<ul class="org-ul">
<li><b>默认的</b> ThreadFactory创建的线程是 <span class="underline">nonDaemon</span> ：
<ul class="org-ul">
<li>线程优先级： <span class="underline">普通</span> 的线程</li>
<li>指定了 <span class="underline">可识别的线程名称</span></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">Thread</span> <span style="color: #daa520; font-weight: bold;">newThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>) {  
    <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), 0);  
    <span style="color: #00bfff; font-weight: bold;">if</span> (t.isDaemon())  
        t.setDaemon(<span style="color: #ffd700;">false</span>);  
    <span style="color: #00bfff; font-weight: bold;">if</span> (t.getPriority() != <span style="color: #ffd700;">Thread</span>.NORM_PRIORITY)  
        t.setPriority(<span style="color: #ffd700;">Thread</span>.NORM_PRIORITY);  
    <span style="color: #00bfff; font-weight: bold;">return</span> t;  
}  
</pre>
</div>

<p>
客户化的MyAppThread
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyAppThread</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">DEFAULT_NAME</span> = <span style="color: #deb887;">"MyAppThread"</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicInteger</span> <span style="color: #4eee94;">created</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicInteger</span>();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicInteger</span> <span style="color: #4eee94;">alive</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicInteger</span>();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Logger</span> <span style="color: #4eee94;">log</span> = Logger.getAnonymousLogger();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">debugLifecycle</span> = <span style="color: #ffd700;">false</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">MyAppThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>(r, DEFAULT_NAME);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">MyAppThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">runnable</span>, <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">name</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20026;&#33258;&#23450;&#20041;&#30340;Thread&#31867;&#25351;&#23450;&#32447;&#31243;&#21517;&#31216;</span>
        <span style="color: #00bfff; font-weight: bold;">super</span>(runnable, name + <span style="color: #deb887;">"-"</span> + created.incrementAndGet());
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;UncaughtExceptionHandler. UncaughtExceptionHandler&#30340;uncaughtException&#26041;&#27861;&#23558;&#22312;&#32447;&#31243;&#36816;&#34892;&#20013;&#25243;&#20986;&#26410;&#25429;&#33719;&#24322;&#24120;&#26102;&#30001;&#31995;&#32479;&#35843;&#29992;</span>
        setUncaughtExceptionHandler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #ffd700;">Thread</span>.<span style="color: #98f5ff;">UncaughtExceptionHandler</span>() {
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uncaughtException</span>(<span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span>, <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">e</span>) {
                    log.log(<span style="color: #ffd700;">Level</span>.SEVERE, <span style="color: #deb887;">"UNCAUGHT in thread "</span> + t.getName(), e);
                }
            });
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getThreadsCreated</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> created.get();
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getThreadsAlive</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> alive.get();
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">getDebug</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> debugLifecycle;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">setDebug</span>(<span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">b</span>) {
        debugLifecycle = b;
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Copy debug flag to ensure consistent value throughout.</span>
        <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">debug</span> = debugLifecycle;
        <span style="color: #00bfff; font-weight: bold;">if</span> (debug)
            log.log(<span style="color: #ffd700;">Level</span>.FINE, <span style="color: #deb887;">"Created "</span> + getName());
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            alive.incrementAndGet();
            <span style="color: #00bfff; font-weight: bold;">super</span>.run();
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            alive.decrementAndGet();
            <span style="color: #00bfff; font-weight: bold;">if</span> (debug)
                log.log(<span style="color: #ffd700;">Level</span>.FINE, <span style="color: #deb887;">"Exiting "</span> + getName());
        }
    }
}
</pre>
</div>

<p>
客户化ThreadFactory返回MyAppThread
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyThreadFactory</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">ThreadFactory</span> {  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">poolName</span>;  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">MyThreadFactory</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">poolName</span>) {  
        <span style="color: #00bfff; font-weight: bold;">this</span>.poolName = poolName;  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">Thread</span> <span style="color: #daa520; font-weight: bold;">newThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">runnable</span>) {  
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">MyAppThread</span>(runnable, poolName);  
    }  
}  
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org612ea7c" class="outline-2">
<h2 id="org612ea7c">扩展线程池</h2>
<div class="outline-text-2" id="text-org612ea7c">
<p>
<span class="underline">ThreadPoolExecutor</span> 类提供了多个 <span class="underline">钩子</span> 方法，以 <b>供其子类实现</b> 
</p>
<ol class="org-ol">
<li><span class="underline">beforeExecute</span> :  <b>任务执行前</b></li>
<li><span class="underline">afterExecute</span> :  <b>任务执行后</b></li>
<li><span class="underline">terminated</span> :  <b>线程池被关闭后</b> (释放线程池申请的资源)</li>
</ol>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">runTask</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">task</span>) {  
    <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ReentrantLock</span> <span style="color: #4eee94;">runLock</span> = <span style="color: #00bfff; font-weight: bold;">this</span>.runLock;  
    runLock.lock();  
    <span style="color: #00bfff; font-weight: bold;">try</span> {  
        <span style="color: #00bfff; font-weight: bold;">if</span> (runState &lt; <span style="color: #98f5ff;">STOP</span> &amp;&amp; Thread.interrupted() &amp;&amp; runState &gt;= STOP)  
            thread.interrupt();  
        <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">ran</span> = <span style="color: #ffd700;">false</span>;  
        beforeExecute(thread, task);  
        <span style="color: #00bfff; font-weight: bold;">try</span> {  
            task.run();  
            ran = <span style="color: #ffd700;">true</span>;  
            afterExecute(task, <span style="color: #ffd700;">null</span>);  
            ++completedTasks;  
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RuntimeException</span> <span style="color: #4eee94;">ex</span>) {  
            <span style="color: #00bfff; font-weight: bold;">if</span> (!ran)  
                afterExecute(task, ex);  
            <span style="color: #00bfff; font-weight: bold;">throw</span> ex;  
        }  
    } <span style="color: #00bfff; font-weight: bold;">finally</span> {  
        runLock.unlock();  
    }  
}   
</pre>
</div>

<p>
扩展线程池，在日志中 <span class="underline">记录每个任务执行时间</span> 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">TimingThreadPool</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ThreadLocal</span>&lt;<span style="color: #98f5ff;">Long</span>&gt; <span style="color: #4eee94;">startTime</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadLocal</span>&lt;<span style="color: #98f5ff;">Long</span>&gt;();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Logger</span> <span style="color: #4eee94;">log</span> = Logger.getLogger(<span style="color: #deb887;">"TimingThreadPool"</span>);
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicLong</span> <span style="color: #4eee94;">numTasks</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicLong</span>();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicLong</span> <span style="color: #4eee94;">totalTime</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicLong</span>();

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">beforeExecute</span>(<span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span>, <span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>) {
        <span style="color: #00bfff; font-weight: bold;">super</span>.beforeExecute(t, r);
        log.fine(String.format(<span style="color: #deb887;">"Thread %s: start %s"</span>, t, r));
        startTime.set(System.nanoTime());
    }

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">afterExecute</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">t</span>) {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">endTime</span> = System.nanoTime();
            <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">taskTime</span> = endTime - startTime.get();
            numTasks.incrementAndGet();
            totalTime.addAndGet(taskTime);
            log.fine(String.format(<span style="color: #deb887;">"Thread %s: end %s, time=%dns"</span>,
                           t, r, taskTime));
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            <span style="color: #00bfff; font-weight: bold;">super</span>.afterExecute(r, t);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">terminated</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            log.info(String.format(<span style="color: #deb887;">"Terminated: avg time=%dns"</span>,
                           totalTime.get() / numTasks.get()));
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            <span style="color: #00bfff; font-weight: bold;">super</span>.terminated();
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdaa187c" class="outline-2">
<h2 id="orgdaa187c">并行执行递归算法</h2>
<div class="outline-text-2" id="text-orgdaa187c">
<p>
如果 <span class="underline">循环体所进行的操作</span> 是 <b>相互独立</b> 的, 这样的循环可以并发的运行 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">processSequentially</span>(<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Element</span>&gt; <span style="color: #4eee94;">elements</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">Element</span> <span style="color: #4eee94;">e</span> : elements)
        process(e);
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#30456;&#20114;&#29420;&#31435;&#30340;&#24490;&#29615;&#25805;&#20316;&#36716;&#21464;&#20026;&#24182;&#21457;&#25805;&#20316;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">processInParallel</span>(<span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Element</span>&gt; <span style="color: #4eee94;">elements</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Element</span> <span style="color: #4eee94;">e</span> : elements)
        exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() { process(e); }
            });
    exec.shutdown();   
    exec.awaitTermination(<span style="color: #ffd700;">Long</span>.MAX_VALUE, <span style="color: #ffd700;">TimeUnit</span>.SECONDS); 
}
</pre>
</div>

<p>
<span class="underline">有循环的递归操作</span> 也可以并发进行计算
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sequentialRecursive</span>(<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt;&gt; <span style="color: #4eee94;">nodes</span>,
                   <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">results</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">n</span> : nodes) {
        results.add(n.compute());
        sequentialRecursive(n.getChildren(), results);
    }
}

<span style="color: #00bfff; font-weight: bold;">public</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">parallelRecursive</span>(<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>,
                 <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt;&gt; <span style="color: #4eee94;">nodes</span>,
                 <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">results</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">n</span> : nodes) {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#24182;&#21457;&#36827;&#34892;&#35745;&#31639;</span>
        exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                    results.add(n.compute());
                }
            });
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36941;&#21382;&#20381;&#26087;&#26159;&#36882;&#24402;</span>
        parallelRecursive(exec, n.getChildren(), results);
    }
}

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#33719;&#21462;&#26368;&#32456;&#32467;&#26524;</span>
<span style="color: #00bfff; font-weight: bold;">public</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #daa520; font-weight: bold;">getParallelResults</span>(<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt;&gt; <span style="color: #4eee94;">nodes</span>)
    <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
    <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">exec</span> = Executors.newCachedThreadPool();
    <span style="color: #98f5ff;">Queue</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">resultQueue</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ConcurrentLinkedQueue</span>&lt;<span style="color: #98f5ff;">T</span>&gt;();
    parallelRecursive(exec, nodes, resultQueue);
    exec.shutdown();
    exec.awaitTermination(<span style="color: #ffd700;">Long</span>.MAX_VALUE, <span style="color: #ffd700;">TimeUnit</span>.SECONDS);
    <span style="color: #00bfff; font-weight: bold;">return</span> resultQueue;
}
</pre>
</div>

<pre class="example">
Java7 之后可以使用 ForkJoinPool

Java 8 之后可以使用 parallel stream 
</pre>

<p>
<a href="explicit_lock.html">Next:显式锁</a>
</p>

<p>
<a href="cancellation.html">Previous:任务取消</a>
</p>

<p>
<a href="jcip.html">Up:目录</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
