<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZFS文件系统</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">ZFS文件系统</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org48d2afb">ZFS 简介</a>
<ul>
<li><a href="#org5b3f08d">存储池</a></li>
<li><a href="#org5eda869">即写即拷</a></li>
<li><a href="#orga19f730">数据保护</a></li>
<li><a href="#org2a06569">校验和</a></li>
<li><a href="#org993b959">快照和克隆</a></li>
<li><a href="#org11875ee">可变块大小</a></li>
<li><a href="#orgfb4e43f">其他</a></li>
</ul>
</li>
<li><a href="#org4a9ce9a">入门</a>
<ul>
<li><a href="#orga89c8f5">单个磁盘存储池</a></li>
<li><a href="#orgacd5666">RAID-Z</a></li>
<li><a href="#org69eb55e">数据校验</a></li>
</ul>
</li>
<li><a href="#org588118f">管理</a>
<ul>
<li><a href="#org78ebad2">zpool</a>
<ul>
<li><a href="#org086e0ca">创建和销毁存储池</a></li>
</ul>
</li>
<li><a href="#org3065e9e">zpool</a></li>
</ul>
</li>
<li><a href="#org369a515">实例</a>
<ul>
<li><a href="#orga4aaea1">概述</a>
<ul>
<li><a href="#orgc1f569c">OS 和 GRUB 概述</a></li>
<li><a href="#org86d180f">设置过程</a></li>
</ul>
</li>
<li><a href="#org5bd6e55">准备工作</a></li>
<li><a href="#org1bb8d63">FreeBSD 安装程序</a>
<ul>
<li><a href="#org3ba6ae0">创建分区和 ZFS 池</a></li>
<li><a href="#org2d36041">创建 ZFS 数据集</a></li>
</ul>
</li>
<li><a href="#org1e77b4e">安装配置 FreeBSD</a>
<ul>
<li><a href="#orgf5fa35c">创建 fstab</a></li>
<li><a href="#org896ca6d">安装 FreeBSD 原生引导程序</a></li>
</ul>
</li>
<li><a href="#orgd6ef98a">FreeBSD 主要操作系统</a>
<ul>
<li><a href="#org0c15a9b">安装 GRUB</a></li>
</ul>
</li>
<li><a href="#org8ba063b">Gentoo 安装程序</a>
<ul>
<li><a href="#orga233cce">挂载文件系统</a></li>
<li><a href="#orgfab0a23">创建 fstab</a></li>
<li><a href="#org2076fc9">构建内核、ZFS 模块以及 initramfs</a></li>
<li><a href="#org9bd9abb">最后是 Gentoo 的安装</a></li>
</ul>
</li>
<li><a href="#org6e8f105">启动进入 Gentoo</a></li>
<li><a href="#org988d679">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org48d2afb" class="outline-2">
<h2 id="org48d2afb">ZFS 简介</h2>
<div class="outline-text-2" id="text-org48d2afb">
<p>
将 ZFS 称为文件系统有点名不副实，因为它在传统意义上不仅仅是个文件系统。ZFS 将 <span class="underline">逻辑卷管理器</span> 的概念与功能丰富的和 <span class="underline">可大规模扩展</span> 的文件系统结合起来。首先探索一些 ZFS 所基于的原则：
</p>
<ul class="org-ul">
<li>ZFS 使用 <b>池存储</b> 模型，而不是传统的基于卷的模型： ZFS 视存储为可根据需要动态分配（和缩减）的共享池。这优于传统模型，在传统模型中，文件系统位于卷上，使用独立卷管理器来管理这些资产</li>
<li>ZFS 内嵌入的是重要功能集
<ul class="org-ul">
<li>快照</li>
<li>即写即拷，克隆</li>
<li>连续完整性检查</li>
<li>通过 RAID-Z 的数据保护</li>
</ul></li>
<li>可以在 ZFS 卷的顶端使用其他的文件系统（如 ext4）：这意味着可以获得那些 ZFS 的功能，如独立文件系统中的快照（该文件系统可能并不直接支持它们）</li>
</ul>

<p>
ZFS 不只是组成有用文件系统的功能集合。相反，它是 <b>构建出色文件系统</b> 的集成和 <b>补充功能</b> 的集合
</p>
</div>
<div id="outline-container-org5b3f08d" class="outline-3">
<h3 id="org5b3f08d">存储池</h3>
<div class="outline-text-3" id="text-org5b3f08d">
<p>
ZFS 合并了 <b>卷管理</b> 功能来提取 <span class="underline">底层物理存储设备</span> 到文件系统：
</p>
<ul class="org-ul">
<li>ZFS 对存储池（zpools）进行操作，而不是直接查看物理块设备，存储池构建自 <span class="underline">虚拟驱动器</span> ，可由驱动器或驱动器的一部分物理地进行表示</li>
<li>可以动态构造这些池，甚至这些池正在活跃地使用时也可以</li>
</ul>
</div>
</div>
<div id="outline-container-org5eda869" class="outline-3">
<h3 id="org5eda869">即写即拷</h3>
<div class="outline-text-3" id="text-org5eda869">
<p>
ZFS 使用 <b>即写即拷</b> 模型来管理存储中的数据。虽然这意味着数据永远不会写入到位（从来没有被覆盖），而是写入新块并更新元数据来引用数据。即写即拷有利的原因有多个，不仅仅是因为它可以启用的快照和克隆等一些功能：
</p>
<ul class="org-ul">
<li>由于从来不覆盖数据，这可以更简单地确保存储 <b>永远不会处于不一致</b> 的状态：因为在新的写入操作完成以后较早的数据仍保留</li>
<li>这允许 ZFS 基于 <span class="underline">事务</span> ，且更容易实现类似原子操作等的功能</li>
<li>文件系统的所有写入都成为 <b>顺序写入</b> （因为始终进行重新映射）：避免存储中的热点并利用顺序写入的性能（比随机写入更快）</li>
</ul>
</div>
</div>
<div id="outline-container-orga19f730" class="outline-3">
<h3 id="orga19f730">数据保护</h3>
<div class="outline-text-3" id="text-orga19f730">
<p>
可以使用 ZFS 的众多保护方案之一来保护由虚拟设备组成的存储池：
</p>
<ul class="org-ul">
<li><span class="underline">跨两个或多个设备</span> (RAID 1)来对池进行镜像</li>
<li>通过 <span class="underline">奇偶校验</span> 来保护该池（类似于 RAID 5）</li>
<li><span class="underline">跨动态带区宽度</span> 来镜像池</li>
</ul>

<p>
基于池中设备数量，ZFS 支持各种不同的的奇偶校验方案：
</p>
<ul class="org-ul">
<li>通过 RAID-Z (RAID-Z 1) 来保护三个设备</li>
<li>对于四个设备，可以使用 RAID-Z 2（双重奇偶校验，类似于 RAID6）</li>
<li>对于更大的保护来说，可以将 RAID-Z 3 用于更大数量的磁盘进行三重奇偶校验</li>
<li>为提高速度（不存在错误检测以外的数据保护），可以跨设备进行条带化（RAID 0）</li>
<li>可以创建条带化镜像（来镜像条带化设备），类似于 RAID 10</li>
</ul>

<pre class="example" id="org7a847bc">
ZFS 的一个有趣属性随 RAID-Z、即写即拷事务和动态条带宽度的组合而来

在传统的 RAID 5 体系结构中，所有磁盘都必须在条带内具有其自己的数据，或者条带不一致
因为没有方法自动更新所有磁盘，所以这可能产生众所周知的 RAID 5 写入漏洞问题（其中在 RAID 集的驱动器中条带是不一致的）
假设 ZFS 处理事务且从不需要写入到位，则写入漏洞问题就消除了

此方法的另外一个便捷性体现在磁盘出现故障且需要重建时
传统的 RAID 5 系统使用来自该集中其他磁盘的数据来重建新驱动器的数据
RAID-Z 遍历可用的元数据以便只读取有关几何学的数据并避免读取磁盘上未使用的空间
随着磁盘变得更大以及重建次数的增加，此行为变得更加重要
</pre>
</div>
</div>
<div id="outline-container-org2a06569" class="outline-3">
<h3 id="org2a06569">校验和</h3>
<div class="outline-text-3" id="text-org2a06569">
<p>
虽然数据保护提供了在故障时重新生成数据的能力，但是这并不涉及处于第一位的数据的有效性。ZFS 通过为写入的每个块的元数据生成 <span class="underline">32 位校验和</span> （或 256 位散列）解决了此问题：
</p>
<ul class="org-ul">
<li>在读取块时，将 <b>验证此校验和</b> 以避免静默数据损坏问题</li>
<li>在有数据保护（镜像或 AID-Z）的卷中，可自动读取或 <b>重新生成备用数据</b></li>
</ul>

<p>
在 ZFS 上校验和与元数据存储在一起，因此如果提供数据保护（RAID-Z） ，可以检测并更正错位写入
</p>
</div>
</div>
<div id="outline-container-org993b959" class="outline-3">
<h3 id="org993b959">快照和克隆</h3>
<div class="outline-text-3" id="text-org993b959">
<p>
由于 ZFS 的即写即拷性质，类似快照和克隆的功能变得易于提供。因为 ZFS 从不覆盖数据而是写入到新的位置，所以可以保护较早的数据（但是在不重要的情况下被标记为删除以逆转磁盘空间）：
</p>
<ul class="org-ul">
<li>快照：旧块的保存以便及时维护给定实例中的文件系统状态。这种方法也是空间有效的，因为无需复制（除非重新写入文件系统中的所有数据）
<ul class="org-ul">
<li>克隆：一种快照形式，在其中获取可写入的快照。在这种情况下，由每一个克隆共享初始的未写入块，且被写入的块仅可用于特定文件系统克隆</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org11875ee" class="outline-3">
<h3 id="org11875ee">可变块大小</h3>
<div class="outline-text-3" id="text-org11875ee">
<p>
传统的文件系统由匹配后端存储（512 字节）的静态大小的块组成。ZFS 为各种不同的使用实现了 <span class="underline">可变块大小</span> （通常大小达到 128KB，但是您可以变更此值）：
</p>
<ul class="org-ul">
<li>可变块大小的一个重要使用是 <span class="underline">压缩</span> （因为压缩时的结果块大小理想情况下将小于初始大小）
<ul class="org-ul">
<li>除了提供更好的存储网络利用外，此功能也使存储系统中的 <b>浪费最小化</b> （因为传输更好的数据到存储需要更少的时间）</li>
</ul></li>
<li>支持可变块大小还意味着您可以针对所期望的特定工作量优化块大小，以便改进性能</li>
</ul>
</div>
</div>
<div id="outline-container-orgfb4e43f" class="outline-3">
<h3 id="orgfb4e43f">其他</h3>
<div class="outline-text-3" id="text-orgfb4e43f">
<p>
ZFS 并入了许多其他功能，如 <b>重复数据删除</b> （最小化数据重复）、 <b>可配置的复制</b> 、 <b>加密</b> 、 <b>缓存管理的自适应更换缓存</b> 以及 <b>在线磁盘清理</b> （标识并修复在不使用保护时可以修复的潜在错误）。它通过巨大的可扩展性来实现该功能，支持 16 千兆兆个字节的可寻址存储（2<sup>64</sup> 字节）
</p>
</div>
</div>
</div>
<div id="outline-container-org4a9ce9a" class="outline-2">
<h2 id="org4a9ce9a">入门</h2>
<div class="outline-text-2" id="text-org4a9ce9a">
</div>
<div id="outline-container-orga89c8f5" class="outline-3">
<h3 id="orga89c8f5">单个磁盘存储池</h3>
<div class="outline-text-3" id="text-orga89c8f5">
<p>
在单个磁盘上创建一个简单， 非冗余的 ZFS， 使用 zpool 命令：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create example /dev/da0
</pre>
</div>

<p>
可以通过 df 的输出查看新的存储池：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ df

Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example
</pre>
</div>

<p>
这份输出清楚的表明了 example 存储池不仅创建成功而且被挂载了。 能像访问普通的文件系统那样访问它， 就像以下例子中演示的那样，用户能够在上面创建文件并浏览：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cd /example
$ ls

$ touch testfile
$ ls -al
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile
</pre>
</div>

<p>
遗憾的是这个存储池并没有利用到 ZFS 的任何特性。 在这个存储池上创建一个文件系统，并启用压缩：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs create example/compressed
$ zfs set <span style="color: #eedd82;">compression</span>=gzip example/compressed
</pre>
</div>

<p>
现在 example/compressed 是一个启用了压缩的 ZFS 文件系统了。 可以尝试复制一些大的文件到 /example/compressed
</p>

<p>
使用这个命令可以禁用压缩：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs set <span style="color: #eedd82;">compression</span>=off example/compressed
</pre>
</div>

<p>
使用如下的命令卸载这个文件系统，并用 df 工具确认：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs umount example/compressed
$ df

Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example
</pre>
</div>

<p>
重新挂在这个文件系统使之能被访问， 并用 df 确认：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs mount example/compressed
$ df

Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
</pre>
</div>

<p>
存储池与文件系统也可通过 mount 的输出查看：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mount

/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
example on /example (zfs, local)
example/data on /example/data (zfs, local)
example/compressed on /example/compressed (zfs, local)
</pre>
</div>

<p>
正如前面所提到的，ZFS 文件系统， 在创建之后就能像普通的文件系统那样使用。然而， 还有很多其他的特性是可用的。在下面的例子中， 将创建一个新的文件系统，data。 并要在上面存储些重要的文件， 所以文件系统需要被设置成把每一个数据块都保存两份拷贝：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs create example/data
$ zfs set <span style="color: #eedd82;">copies</span>=2 example/data
</pre>
</div>

<p>
现在可以再次使用 df 查看数据和空间的使用状况：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ df

Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data
</pre>
</div>

<p>
注意：存储池上的 <b>每一个文件系统都有着相同数量的可用空间</b>  
</p>
<pre class="example" id="org24609bb">
这就是在这些例子中使用 df 的原因， 是为了文件系统都是从相同的存储池取得它们所需的空间

ZFS 去掉了诸如卷和分区此类的概念， 并允许多个文件系统占用同一个存储池
</pre>

<p>
不再需要文件系统与存储池的时候能像这样销毁它们：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs destroy example/compressed
$ zfs destroy example/data
$ zpool destroy example
</pre>
</div>
</div>
</div>
<div id="outline-container-orgacd5666" class="outline-3">
<h3 id="orgacd5666">RAID-Z</h3>
<div class="outline-text-3" id="text-orgacd5666">
<p>
磁盘无法避免的会坏掉和停止运转。 当这块磁盘坏掉的时候，上面的数据都将丢失。 一个避免因磁盘损坏而丢失数据的方法是使用 RAID。ZFS 在它的存储池设计中支持这样的特性。假设存在 3 个 SCSI 设备， da0， da1 和 da2 。 使用如下的命令创建一个 RAID-Z 存储池：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create storage raidz da0 da1 da2
</pre>
</div>
</div>
</div>
<div id="outline-container-org69eb55e" class="outline-3">
<h3 id="org69eb55e">数据校验</h3>
<div class="outline-text-3" id="text-org69eb55e">
<p>
ZFS 使用 <b>校验和</b> (checksum) 来检查存储数据的完整性。 这时在文件系统创建时 <b>自动启用</b> 的，可使用以下的命令禁用：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zfs set <span style="color: #eedd82;">checksum</span>=off storage/home
</pre>
</div>

<p>
这不是个明智的选择，因为校验和 不仅非常有用而且只需占用少量的存储空间。 并且启用它们也不会明显的消耗过多资源。 启用后就可以让 ZFS 使用校验和校验来检查数据的完整。 这个过程通常称为 <span class="underline">scrubbing</span> 。 可以使用以下的命令检查 storage 存储池里数据的完整性：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool scrub storage
</pre>
</div>

<p>
这个过程需花费相当长的时间，取决于存储的数据量。 而且 I/O 非常密集， 所以在任何时间只能执行一个这样的操作。 在 scrub 完成之后，状态就会被更新， 可使用如下的命令查看：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool status storage

pool: storage
state: ONLINE
scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008
config:

NAME        STATE     READ WRITE CKSUM
storage     ONLINE       0     0     0
raidz1    ONLINE       0     0     0
da0     ONLINE       0     0     0
da1     ONLINE       0     0     0
da2     ONLINE       0     0     0

errors: No known data errors
</pre>
</div>

<p>
这个例子中完成时间非常的清楚。 这个特性可以帮助你在很长的一段时间内确保数据的完整
</p>
</div>
</div>
</div>
<div id="outline-container-org588118f" class="outline-2">
<h2 id="org588118f">管理</h2>
<div class="outline-text-2" id="text-org588118f">
<p>
ZFS 管理由两个工具组成：
</p>
<ul class="org-ul">
<li>zpool: 控制存储池和增加、删除、替换和管理磁盘</li>
<li>zfs: 增加、删除和管理文件系统和卷</li>
</ul>
</div>
<div id="outline-container-org78ebad2" class="outline-3">
<h3 id="org78ebad2">zpool</h3>
<div class="outline-text-3" id="text-org78ebad2">
</div>
<div id="outline-container-org086e0ca" class="outline-4">
<h4 id="org086e0ca">创建和销毁存储池</h4>
<div class="outline-text-4" id="text-org086e0ca">
<p>
创建一个ZFS寸尺池包含许多预先的设定，因为存储池的结构在创建之后是没法改变的。 最重要的决定是什么类型的虚拟磁盘(vdev)来构成物理磁盘。一旦存储池构建完毕后，绝大多数类型的虚拟磁盘不允许添加额外的物理磁盘，例外是镜像(mirrors)和条带（stripe: 可以从镜像升级）。尽管额外的虚拟磁盘可以被添加到存储池，但是存储池的布局在创建存储池之后仍然不会被改变。因此，在销毁和重建存储池之前必须备份 
</p>

<p>
创建一个简单的镜像池：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zpool create mypool mirror /dev/ada1 /dev/ada2
$ zpool status

pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors
</pre>
</div>

<p>
多个虚拟磁盘可以被同时创建，之间用 <span class="underline">虚拟磁盘类型</span> 来分割：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors
</pre>
</div>

<p>
存储池可以使用分区来构建，而不是使用整块硬盘，使用分区来创建 RAID-Z2 存储池：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3
$ zpool status

  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors

</pre>
</div>

<p>
存储池可以被销毁来回收空间
</p>
</div>
</div>
</div>
<div id="outline-container-org3065e9e" class="outline-3">
<h3 id="org3065e9e">zpool</h3>
</div>
</div>
<div id="outline-container-org369a515" class="outline-2">
<h2 id="org369a515">实例</h2>
<div class="outline-text-2" id="text-org369a515">
<p>
利用 ZFS 文件系统的通用功能 (即利用面向使用了基于 <span class="underline">fstab</span> 方法的 OS 数据集的挂载点功能) 结合 <span class="underline">GRUB</span> ，实现一个双引导 OS
</p>
</div>
<div id="outline-container-orga4aaea1" class="outline-3">
<h3 id="orga4aaea1">概述</h3>
<div class="outline-text-3" id="text-orga4aaea1">
<p>
ZFS 系统同 FreeBSD 和 Linux 上“典型的”ZFS设置有些微不同。某些数据集 (比如 <b>home</b> 目录) 是由两个操作系统共享的, 但是位于各自挂载点中的 OS 数据集则要依赖于所使用的OS，而因此 ZFS 特定的挂载点功能是不能有效使用的
</p>

<pre class="example" id="orgab298f8">
假定存储卷的名字是 data

</pre>

<p>
整个方案看起来如下:
</p>
<ul class="org-ul">
<li>data/home 被挂载到 /home, 与其所有的子数据集一起使用 ZFS 挂载点系统</li>
<li>data/freebsd 及其子数据集包含了 FreeBSD 系统，而其所有的挂载点都被设置成 legacy</li>
<li>data/gentoo 及其子数据集包含了 Gentoo 系统，其所有的挂载点也都被设置成 legacy</li>
</ul>
</div>
<div id="outline-container-orgc1f569c" class="outline-4">
<h4 id="orgc1f569c">OS 和 GRUB 概述</h4>
<div class="outline-text-4" id="text-orgc1f569c">
<p>
两个 OS 都必须利用 <b>/etc/fstab</b> 方法来挂载他们大多数的文件系统, 因此不能使用 ZFS 挂载点功能。这样每个 OS 就都需要一个不同的 fstab
</p>
<pre class="example" id="org7450da5">
data/home 数据集 (以及其它类似的数据集) 都会使用 ZFS 挂载点方法来进行挂载，而不是 fstab
</pre>

<p>
两个OS都要通过一个特殊的顶层目录 (Gentoo 上是 /freebsd, FreeBSD 上是 /gentoo) 来 <b>访问另外一个系统的数据</b> 
</p>

<p>
<span class="underline">GRUB</span> 引导加载程序可以被用来提供一个 <b>引导选择设施</b> ，而无需进行大的修改和配置 (不过要知道输入到 grub.cfg 文件中去的类型的神奇方式!)
</p>
</div>
</div>
<div id="outline-container-org86d180f" class="outline-4">
<h4 id="org86d180f">设置过程</h4>
<div class="outline-text-4" id="text-org86d180f">
<p>
设置过程包括如下几个步骤：
</p>
<ol class="org-ol">
<li>使用 FreeBSD 安装器创建 GPT 和 ZFS 池</li>
<li>使用 FreeBSD 启动加载程序安装并配置 FreeBSD</li>
<li>启动并进入 FreeBSD 创建 Gentoo Linux 数据集，安装 GRUB</li>
<li>启动并进入 Gentoo Linux 安装器，安装 Gentoo</li>
<li>启动并进入 Gentoo, 完成配置任务</li>
</ol>

<pre class="example" id="org18459f1">
当然也可以将步骤倒着进行，先安装 Gentoo，然后再使用它的工具

只是上列顺序能使 FreeBSD 上 GPT 的创建和 GRUB 的安装顺利许多
</pre>
</div>
</div>
</div>
<div id="outline-container-org5bd6e55" class="outline-3">
<h3 id="org5bd6e55">准备工作</h3>
<div class="outline-text-3" id="text-org5bd6e55">
<p>
执行这个安装过程，需要为两个OS安装 memstick 镜像，还需要有途径能进行互联网访问
</p>
</div>
</div>
<div id="outline-container-org1bb8d63" class="outline-3">
<h3 id="org1bb8d63">FreeBSD 安装程序</h3>
<div class="outline-text-3" id="text-org1bb8d63">
<p>
引导进入 FreeBSD 安装程序，通过引导程序菜单选择 <b>手动分区</b> 模式。这样做会进入一个 shell 操作环境，创建分区并将所有的东西挂载到 /mnt 
</p>
</div>
<div id="outline-container-org3ba6ae0" class="outline-4">
<h4 id="org3ba6ae0">创建分区和 ZFS 池</h4>
<div class="outline-text-4" id="text-org3ba6ae0">
<p>
使用 <span class="underline">gpart</span> 工具来 <b>创建分区</b> ：
</p>

<div class="org-src-container">
<pre class="src src-sh">gpart create -s gpt ada0
gpart create -s gpt ada1
gpart add -t efi -l efi-system -s 200M ada0
gpart add -t freebsd-zfs -l zfs-data ada0
gpart add -t linux-swap -l swap -s 96G ada0
gpart add -t freebsd-zfs -l zfs-data-log -s 16G ada0
gpart add -t freebsd-zfs -l zfs-data-cache ada0
</pre>
</div>

<p>
用新的分区来 <b>创建一个 ZFS 池</b> ，并使用 <span class="underline">DOS 文件系统</span> 来对 <span class="underline">EFI 系统分区</span> 进行 <b>格式化</b> 
</p>

<div class="org-src-container">
<pre class="src src-sh">newfs_msdos /dev/ada0p1

zpool create -m legacy -o <span style="color: #eedd82;">atime</span>=off -o <span style="color: #eedd82;">checksum</span>=sha256 data /dev/ada0p2 log /dev/ada0p2 cache /dev/ada0p3
</pre>
</div>

<pre class="example" id="orga1462d2">
注意：已经将 atime （它可以大大降低磁盘的写入量）关掉了，并且将校验算法设置成了 sha256
</pre>

<p>
ada1 磁盘是一块装进去的 SSD（固态硬盘）：
</p>
<ul class="org-ul">
<li>如果没有 SSD，那么做日志或者缓存方面的设置就没啥意义</li>
<li>16GB 的意向日志是有点多余，但是它可以减轻设备的压力</li>
<li>将 <span class="underline">根数据集</span> 的挂载点设置成了 <b>legacy</b></li>
</ul>
</div>
</div>
<div id="outline-container-org2d36041" class="outline-4">
<h4 id="org2d36041">创建 ZFS 数据集</h4>
<div class="outline-text-4" id="text-org2d36041">
<p>
有了一个 ZFS 存储池后，接下来要做的就是 <b>创建数据集</b> 。先创建 <span class="underline">FreeBSD 根目录</span> (root)并对其进行挂载 
</p>
<div class="org-src-container">
<pre class="src src-sh">zfs create -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd

mount -t zfs data/freebsd /mnt/
</pre>
</div>

<pre class="example" id="org5d6ab30">
注意：它会从父目录继承 “legacy”挂载点
</pre>

<p>
创建一些挂载点目录:
</p>
<div class="org-src-container">
<pre class="src src-sh">mkdir /mnt/home
mkdir /mnt/gentoo/
mkdir /mnt/tmp
mkdir /mnt/usr
mkdir /mnt/var
</pre>
</div>

<p>
下面是一个相当精细的 ZFS 方案， 它对不同的目录设置不同的可执行性、权限和压缩比等属性。这样可以达到很显著的压缩比，有效的增加了磁盘的可用空间：
</p>

<div class="org-src-container">
<pre class="src src-sh">zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/tmp
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=on -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/include
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/lib
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/lib32
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/libdata
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=on -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/local
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/local/etc
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/local/include
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/local/lib
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/local/lib32
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip <span style="color: #eedd82;">data</span>=freebsd/usr/local/libdata
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/local/share
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/usr/local/share/info
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/usr/local/share/man
zfs create -o <span style="color: #eedd82;">exec</span>=on <span style="color: #eedd82;">setuid</span>=on -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/obj
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=on -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/ports
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/usr/ports
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/share
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/usr/share/info
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/usr/share/man
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/usr/src
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/var
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/var/db
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/freebsd/var/db/pkg
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/var/log
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/var/empty
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=gzip data/freebsd/var/mail
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/freebsd/var/tmp
</pre>
</div>

<pre class="example" id="orge0ccb56">
因为 FreeBSD 对于某些文件的所在位置有着非常严格要求，所以这个方案效果很好
</pre>

<p>
对于 Gentoo，由于 Linux 更倾向于宽松的文件定位，可以采取一个更简单的方案： 
</p>
<div class="org-src-container">
<pre class="src src-sh">zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=off data/gentoo/tmp
zfs create -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=on -o <span style="color: #eedd82;">compression</span>=lz4 data/gentoo/usr
zfs create -o <span style="color: #eedd82;">exec</span>=off -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/gentoo/var
</pre>
</div>

<p>
最后的任务是手动挂载所有的文件系统，命令模版如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">mount -t zfs data/freebsd/&lt;path&gt; /mnt/&lt;path&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1e77b4e" class="outline-3">
<h3 id="org1e77b4e">安装配置 FreeBSD</h3>
<div class="outline-text-3" id="text-org1e77b4e">
<p>
现在输入“exit”能返回到 FreeBSD 安装程序，并且所有东西都挂载在 <i>mnt</i> 目录。剩余部分的安装工作很简单，但是需要到 shell 界面来完成最后两个配置任务。
</p>

<p>
在 shell 界面执行下面的命令, 然后进入新安装的 FreeBSD 系统：
</p>

<div class="org-src-container">
<pre class="src src-sh">chroot /mnt
</pre>
</div>
</div>
<div id="outline-container-orgf5fa35c" class="outline-4">
<h4 id="orgf5fa35c">创建 fstab</h4>
<div class="outline-text-4" id="text-orgf5fa35c">
<p>
由于挂载到每一个系统的 ZFS 数据集合是在不同的路径下， 因此需要为它们创建一个 /etc/fstab 文件.  下面这个 fstab 会将数据集合挂载到正确的位置:
</p>

<pre class="example" id="org2dfec6a">
data/freebsd/tmp /tmp zfs rw 0 0
data/freebsd/usr /usr zfs rw 0 0
data/freebsd/usr/include /usr/include zfs rw 0 0
...
data/gentoo/ /gentoo zfs rw 0 0
data/gentoo/tmp /gentoo/tmp zfs rw 0 0
...
proc /proc procfs rw 0 0
</pre>
</div>
</div>
<div id="outline-container-org896ca6d" class="outline-4">
<h4 id="org896ca6d">安装 FreeBSD 原生引导程序</h4>
<div class="outline-text-4" id="text-org896ca6d">
<p>
安装 FreeBSD 引导加载程序来执行首次进入系统的操作。执行如下几个步骤进行安装：
</p>

<div class="org-src-container">
<pre class="src src-sh">mount -t msdosfs /dev/ada0p1 /mnt
mkdir /mnt/efi
mkdir /mnt/efi/BOOT
cp /boot/boot1.efi /mnt/efi/BOOT/BOOTX64.EFI
</pre>
</div>

<p>
然后设置 zpool 上的 <b>bootfs 参数</b> , 以便 FreeBSD 引导加载程序可以选到正确的数据集：
</p>

<div class="org-src-container">
<pre class="src src-sh">zpool set -o <span style="color: #eedd82;">bootfs</span>=data/freebsd data
</pre>
</div>

<p>
可能还需要为某些硬件设置 EFI 系统分区上的 <b>bootme 标识</b> ：
</p>

<div class="org-src-container">
<pre class="src src-sh">gpart set -a bootme -i 1 ada0
</pre>
</div>

<p>
现在你的系统可以直接进入 OS 了
</p>
</div>
</div>
</div>
<div id="outline-container-orgd6ef98a" class="outline-3">
<h3 id="orgd6ef98a">FreeBSD 主要操作系统</h3>
<div class="outline-text-3" id="text-orgd6ef98a">
<p>
现在可以直接引导进入 FreeBSD 了
</p>
</div>
<div id="outline-container-org0c15a9b" class="outline-4">
<h4 id="org0c15a9b">安装 GRUB</h4>
<div class="outline-text-4" id="text-org0c15a9b">
<p>
grub-efi port 会安装一个兼容 EFI 系统的 GRUB 版本。这个port要比在 Gentoo 上进行同等的操作简单得多。安装方法如下：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b0c4de;">cd</span> /usr/ports/sysutils/grub2-efi
make install clean
</pre>
</div>


<p>
需要使用 <span class="underline">grub-mkconfig</span> 命令 <b>创建一个 grub.cfg 文件</b> ，过程中可能需要对该命令进行编辑。也可以直接使用下面这个文件 (确保文件在/boot/grub/grub.cfg):
</p>

<pre class="example" id="org147d1f2">
insmod part_gpt
insmod zfs

menuentry 'FreeBSD' --class freebsd --class bsd --class os {
  search.fs_label data ZFS_PART
  echo "Loading FreeBSD Kernel..."
  kfreebsd ($ZFS_PART)/freebsd/@/boot/kernel/kernel
  kfreebsd_loadenv ($ZFS_PART)/freebsd/@/boot/device.hints
  kfreebsd_module_elf ($ZFS_PART)/freebsd/@/boot/kernel/opensolaris.ko
  kfreebsd_module_elf ($ZFS_PART)/freebsd/@/boot/kernel/acl_nfs4.ko
  kfreebsd_module_elf ($ZFS_PART)/freebsd/@/boot/kernel/zfs.ko
  set kFreeBSD.vfs.root.mountfrom=zfs:data/freebsd
  set kFreeBSD.vfs.root.mountfrom.options=rw}

menuentry 'Gentoo Linux' {
  search.fs_label data ZFS_PART
  linux ($ZFS_PART)/gentoo@/boot/kernel dozfs=force root=ZFS=data/gentoo
  initrd ($ZFS_PART)/gentoo@/boot/initramfs
}
</pre>

<p>
注意：此时已为 Gentoo 创建了一项配置。最后， <b>需要挂载 EFI 系统分区</b> 然后 <b>安装 GRUB</b> :
</p>

<div class="org-src-container">
<pre class="src src-sh">mount -t msdosfs /dev/ada0p1 /mnt
grub-install --efi-directory=/mnt --disk-module=efi
</pre>
</div>

<p>
这样做会将 GRUB 引导程序安装到 EFI 系统分区的 /efi/grub/grub.efi，仍然需要将它拷贝到相应位置。在此之前，建议先对 FreeBSD 本地的引导加载程序进行备份：
</p>

<div class="org-src-container">
<pre class="src src-sh">cp /mnt/efi/BOOT/BOOTX64.EFI /mnt/efi/BOOT/BOOTX64.BAK
</pre>
</div>

<p>
这样能省去在操作有误时的回退操作。现在拷贝 GRUB 引导加载程序：
</p>

<div class="org-src-container">
<pre class="src src-sh">cp /mnt/efi/grub/grub.efi /mnt/efi/BOOT/BOOTX64.EFI
</pre>
</div>

<p>
之后需要对 GRUB 引导加载程序进行测试，以确保它能有效的对系统进行重新启动，并引导进入 FreeBSD
</p>
</div>
</div>
</div>
<div id="outline-container-org8ba063b" class="outline-3">
<h3 id="org8ba063b">Gentoo 安装程序</h3>
<div class="outline-text-3" id="text-org8ba063b">
<p>
下一个任务是安装 Gentoo 基础系统。 Gentoo 的安装可以通过命令行手动完成
</p>
<pre class="example" id="org8095a37">
注意，因为使用了 ZFS 作为根文件系统，因此需要使用 genkernel 来安装内核
</pre>
</div>
<div id="outline-container-orga233cce" class="outline-4">
<h4 id="orga233cce">挂载文件系统</h4>
<div class="outline-text-4" id="text-orga233cce">
<p>
要使用 FreeBSD, 就会需要对文件系统进行挂载：
</p>

<div class="org-src-container">
<pre class="src src-sh">zpool import -f data
mount -t zfs data/gentoo /mnt/gentoo
mkdir /mnt/gentoo/tmp
mkdir /mnt/gentoo/usr
mkdir /mnt/gentoo/var
mount -t zfs data/gentoo/tmp /mnt/gentoo/tmp
mount -t zfs data/gentoo/usr /mnt/gentoo/usr
mount -t zfs data/gentoo/var /mnt/gentoo/var
</pre>
</div>

<p>
现在可以按照 Gentoo 的安装步骤来进行
</p>
</div>
</div>
<div id="outline-container-orgfab0a23" class="outline-4">
<h4 id="orgfab0a23">创建 fstab</h4>
<div class="outline-text-4" id="text-orgfab0a23">
<p>
使用 FreeBSD 系统时, 需要创建一个 /etc/fstab 文件，它与 FreeBSD 的版本类似, 不过 gentoo 文件系统被挂载到了根目录的相对位置下，而 FreeBSD 文件系统则被挂载到了 /freebsd 目录的相对位置下:
</p>

<pre class="example" id="orgf6a2758">
data/freebsd/tmp /freebsd/tmp zfs rw 0 0
data/freebsd/usr /freebsd/usr zfs rw 0 0
data/freebsd/usr/include /freebsd/usr/include zfs rw 0 0
...
data/gentoo/tmp /tmp zfs rw 0 0
data/gentoo/usr /usr zfs rw 0 0
...
</pre>
</div>
</div>
<div id="outline-container-org2076fc9" class="outline-4">
<h4 id="org2076fc9">构建内核、ZFS 模块以及 initramfs</h4>
<div class="outline-text-4" id="text-org2076fc9">
<p>
需要设置一个支持 ZFS 的内核。你可以在这里查看<a href="https://github.com/pendor/gentoo-zfs-install/blob/master/install/GentooInstall.mdown">指南</a>（跳转到 “配置内核（Configuring the Kernel）” 一节查阅）
</p>

<p>
已经将 GRUB 的安装放在 /boot/kernel 和 /boot/initramfs 之后。 Gentoo 会默认将其内核安装到 /boot/kernel-&lt;版本信息&gt;, initramfs 也是如此。然后，需要使用 /boot/kernel 和 /boot/initramfs 这两个名称来创建符号链接，或者自行将文件拷贝到正确的位置
</p>
</div>
</div>

<div id="outline-container-org9bd9abb" class="outline-4">
<h4 id="org9bd9abb">最后是 Gentoo 的安装</h4>
<div class="outline-text-4" id="text-org9bd9abb">
<p>
在重启之前，请务必阅读该小节。下列检查列出了一些必要操作，如有遗漏则需重新进入安装程序进行操作：
</p>
<ul class="org-ul">
<li>设置一个根密码，这样才可以真正登录进去</li>
<li>安装可以使用无线网络的软件</li>
<li>不要漏掉 /etc/fstab 中的存储卷（如果遗漏了 /var, 系统间的互操作会很繁琐）</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org6e8f105" class="outline-3">
<h3 id="org6e8f105">启动进入 Gentoo</h3>
<div class="outline-text-3" id="text-org6e8f105">
<p>
直接从 GRUB 启动进入 Gentoo，并成功在单 ZFS 文件系统里实现了双引导。但在创建用户主目录之前，需要为 /home 创建一个 ZFS 数据集。在 Gentoo 系统中，进行如下操作：
</p>

<div class="org-src-container">
<pre class="src src-sh">rm /home || rmdir /home
rm /freebsd/home || rmdir /freebsd/home
mkdir /home
mkdir /freebsd/home
zfs create -o <span style="color: #eedd82;">mountpoint</span>=/home -o <span style="color: #eedd82;">exec</span>=on -o <span style="color: #eedd82;">setuid</span>=off -o <span style="color: #eedd82;">compression</span>=lz4 data/home
</pre>
</div>
</div>
</div>

<div id="outline-container-org988d679" class="outline-3">
<h3 id="org988d679">总结</h3>
<div class="outline-text-3" id="text-org988d679">
<p>
这样的设置相当强大且灵活，是内核高手及驱动开发者的福音。下面列出了是进行该设置的好处：
</p>
<ul class="org-ul">
<li>可以从 FreeBSD 系统访问一个完整的 Linux 系统，包括内核的源代码</li>
<li>便于实验性质的系统间切换操作</li>
<li>在某个系统坏掉时可以有效地恢复机制</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
