<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>E1000网卡</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">E1000网卡</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1d64655">网卡架构概述</a>
<ul>
<li><a href="#orge382fda">介绍</a></li>
<li><a href="#org6fb27ab">微架构</a>
<ul>
<li><a href="#org5bc4cdc">PCI/PCI-X 核心接口</a></li>
<li><a href="#org6ae59cf">DMA引擎和数据FIFO</a></li>
<li><a href="#org7166c5c">10/100/1000 Mb/s 接收和发送MAC模块</a></li>
<li><a href="#org1b3b644">MII/GMII/TBI/Internal SerDes接口模块</a></li>
<li><a href="#org2564ee1">PHY接口</a></li>
<li><a href="#org66a1ace">EEPROM接口</a></li>
<li><a href="#orga7a37a0">闪存存储器接口</a></li>
</ul>
</li>
<li><a href="#org0dd12de">DMA地址</a></li>
<li><a href="#org4ebfcec">以太网寻址</a></li>
<li><a href="#org82c6d27">中断</a></li>
<li><a href="#org1636fbc">硬件加速能力</a>
<ul>
<li><a href="#org470b792">校验和卸载</a></li>
<li><a href="#org6f9c7fb">TCP分段</a></li>
</ul>
</li>
<li><a href="#orge06dcaf">缓冲区和描述符结构</a></li>
</ul>
</li>
<li><a href="#orgb6257d2">发送和接收</a>
<ul>
<li><a href="#org5e949c2">数据包接收</a>
<ul>
<li><a href="#orga2e0363">包地址过滤</a></li>
<li><a href="#orgb305571">接收数据存储</a></li>
<li><a href="#org34f403f">接收描述符格式</a>
<ul>
<li><a href="#org73e7878">接收描述符状态字段</a></li>
<li><a href="#org941eb75">接收描述符错误字段</a></li>
<li><a href="#org06c9468">Receive Descriptor Special Field</a></li>
</ul>
</li>
<li><a href="#org7efd49a">接收描述符获取</a></li>
</ul>
</li>
<li><a href="#orgf28fcb1">网络包发送</a>
<ul>
<li><a href="#org859a584">传输数据的存储</a></li>
<li><a href="#orgeba1942">传输描述符</a></li>
<li><a href="#org5705dcd">传统描述符格式</a>
<ul>
<li><a href="#org2760f34">CMD字段</a></li>
<li><a href="#org2674e07">传输状态字段</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org74cff7e">网卡初始化</a></li>
</ul>
</div>
</div>
<div id="outline-container-org1d64655" class="outline-2">
<h2 id="org1d64655">网卡架构概述</h2>
<div class="outline-text-2" id="text-org1d64655">
</div>
<div id="outline-container-orge382fda" class="outline-3">
<h3 id="orge382fda">介绍</h3>
<div class="outline-text-3" id="text-orge382fda">
<pre class="example" id="org8bc03d0">
这一章将介绍PCI/PCI-X系列网卡（以下简称网卡）。接下来将介绍网卡功能、寄存器描述和初始化顺序、以及网卡的主要接口
</pre>

<p>
设计准则如下：
</p>
<ol class="org-ol">
<li>提供一个以太网接口，支持 <span class="underline">10/100/1000 Mb/s</span> 物理层接口，同时也支持 <span class="underline">1000 Base-X</span></li>
<li>基于以下准则，提供高性能解决方案：
<ul class="org-ul">
<li><p>
提供对所有内存的直接访问，不使用映射寄存器
</p>
<pre class="example" id="orgf668af9">
映射寄存器：假设有一个网络接口卡（NIC），需要从内存中读取数据包以进行处理

如果使用映射寄存器，首先需要将数据包的内存地址写入映射寄存器，然后处理器会根据映射寄存器中的值来读取实际的数据

这个过程可能会减慢数据传输速度，因为每次访问都需要经过映射寄存器。

如果是直接访问内存，NIC可以直接读取或写入内存。无需通过映射寄存器

数据传输更加高效，因为减少了硬件层面的操作，从而降低了延迟并提高了整体性能

这对于高速网络通信尤其重要，因为网络通信需要快速处理大量数据
</pre></li>
<li><p>
尽量减少管理网卡所需的PCI 访问次数
</p>
<pre class="example" id="org50feba6">
举例来说，假设需要发送一封电子邮件

在这个过程中，CPU需要多次通过PCI接口与网卡通信：处理数据包的组装、发送以及状态的监控

如果网卡设计得不够高效，会导致大量的PCI访问，从而增加系统的处理时间和延迟
</pre></li>
<li>尽量减少管理网卡所需的中断</li>
<li>在网卡中直接完成简单任务（如TCP校验和计算），减轻CPU负担</li>
<li>最大化PCI的效率和性能</li>
<li>使用混合信号处理来确保物理层特性超过UTP铜介质的规格要求</li>
</ul></li>
<li>为基本操作提供简单的软件接口</li>
<li>提供高度可配置的设计，可在不同环境中有效使用</li>
</ol>

<p>
PCI/PCI-X系列的网卡架构是82542和82543设计的衍生品。继承了前代产品的 <b>MAC</b> <span class="underline">媒体访问控制</span> 功能和集成的 <b>铜质PHY</b> <span class="underline">物理层</span> ，并为MAC1增加了基于_SMBus_ 的 <b>可管理性</b> 和 集成的 <b>ASF</b>  <span class="underline">自适应速度和双工</span> 控制器功能。此外，82546GB/EB在一个集成的双端口解决方案中采用了这种架构，该解决方案由两个独立的MAC/PHY实例组成
</p>


<div id="orgfd6f4e7" class="figure">
<p><img src="pic/image-20240319131216988.png" alt="image-20240319131216988.png" width="70%" /> 
</p>
</div>
</div>
</div>
<div id="outline-container-org6fb27ab" class="outline-3">
<h3 id="org6fb27ab">微架构</h3>
<div class="outline-text-3" id="text-org6fb27ab">
<p>
与前代相比，PCI/PCI-X系列网卡的MAC增加了改进的 <b>数据包过滤</b> 功能，以支持基于SMBus的 <b>可管理性</b> ，以及传输基于SMBus的可管理性数据包的能力。此外，控制器的MAC集成了一个符合ASF标准的 <b>TCO</b> <span class="underline">透明冷却覆盖</span> 控制器，用于降低成本的基本ASF可管理性
</p>

<pre class="example" id="orgc729810">
注：82544GC/EI和82541ER不支持基于SMBus的可管理性
</pre>
<p>
对于82546GB/EB，这些新功能被打包在一个集成的双端口组合中。该架构包括 <b>两个</b> <span class="underline">MAC和PHY</span> 的实例以及一个*单一* 的 <span class="underline">PCI/PCI-X</span> 接口。因此，每个逻辑局域网设备都表现为一个 <b>独立</b> 的 <span class="underline">PCI/PCI-X</span> 总线设备
</p>

<pre class="example" id="org2db2b8b">
接下来几节将描述硬件构成。图2-4展示内部微架构
</pre>


<div id="org9e1b513" class="figure">
<p><img src="pic/image-20240319131713720.png" alt="image-20240319131713720.png" width="90%" /> 
</p>
</div>
</div>
<div id="outline-container-org5bc4cdc" class="outline-4">
<h4 id="org5bc4cdc">PCI/PCI-X 核心接口</h4>
<div class="outline-text-4" id="text-org5bc4cdc">
<p>
PCI/PCI-X核心提供了与 <span class="underline">33/66 MHz</span> 、32/64位PCI总线或33/66/133 MHz、32/64位PCI-X总线完全无缝连接的接口。网卡提供了32或64位的寻址和数据，以及完整的控制接口，以便在32或64位的PCI或PCI-X总线上运行。在为网卡提供专用总线的系统中，这提供了足够的带宽来支持持续的1000 Mb/s全双工传输速率。在共享总线的系统中（特别是32位宽的接口），可能无法维持1000 Mb/s的速度，但可以维持数百兆每秒的传输速率 
</p>
<ul class="org-ul">
<li>当网卡作为 <span class="underline">PCI目标设备</span> 时，它 <b>遵循</b> <span class="underline">PCI配置规范</span> ，允许在PCI系统 <span class="underline">初始化</span> 时，所有对其的访问 <b>自动映射</b> 到 <span class="underline">空闲的内存和I/O空间</span> 中</li>
<li>在处理 <span class="underline">发送</span> 和 <span class="underline">接收</span> 的数据帧时，网卡在PCI总线上充当 <span class="underline">主设备</span> 。作为主设备，PCI总线上的事务突发长度由多个因素决定
<ul class="org-ul">
<li>PCI延迟计时器的到期</li>
<li>正在进行的总线传输类型</li>
<li>数据传输的大小</li>
<li>数据传输是由接收逻辑还是发送逻辑发起的</li>
</ul></li>
</ul>

<p>
PCI/PCI-X总线与DMA引擎相连
</p>
</div>
</div>
<div id="outline-container-org6ae59cf" class="outline-4">
<h4 id="org6ae59cf">DMA引擎和数据FIFO</h4>
<div class="outline-text-4" id="text-org6ae59cf">
<p>
<span class="underline">DMA引擎</span> 负责处理 <span class="underline">主机内存</span> 与 <span class="underline">片上内存</span> 之间的 <b>接收</b> 和 <b>发送</b> <span class="underline">数据</span> 以及 <span class="underline">描述符</span> 的 <b>传输</b> 
</p>
<ul class="org-ul">
<li>接收路径：DMA引擎将存储在 <span class="underline">接收数据FIFO缓冲区</span> 中的数据 <b>传输</b> 到 <span class="underline">主机内存中的接收缓冲区</span> ，具体位置由 <span class="underline">描述符中的地址指定</span> 。同时，它还会 <b>获取</b> 并 <b>回写</b> <span class="underline">更新后的接收描述符</span> 到 <span class="underline">主机内存</span></li>
<li>发送路径：DMA引擎将存储在 <span class="underline">主机内存缓冲区中的数据</span> 传输到 <span class="underline">发送数据FIFO缓冲区</span> 。它也会 <b>获取</b> 并 <b>回写</b> <span class="underline">更新后的发送描述符</span></li>
</ul>

<p>
网卡有一个 <b>片上缓冲区</b> ，大小为 <span class="underline">64KB</span> 。接收和发送缓冲区的大小可根据系统需求进行分配
</p>
<pre class="example" id="org425f716">
这个缓冲区为网卡接收或传输数据帧提供了一个临时的缓冲存储区域
</pre>

<p>
DMA引擎和缓冲区经过优化，以最大化PCI总线的效率并减少处理器的使用，具体方法包括：
</p>
<ul class="org-ul">
<li>在传输前 <b>缓冲</b> <span class="underline">整个待发送的数据包</span> ，减轻瞬时接收带宽需求和消除发送欠流</li>
<li>在 <span class="underline">发送缓冲区</span> 中 <b>排队</b> <span class="underline">发送帧</span> ，允许 <b>连续</b> 传输，最小化帧间间隔</li>
<li>允许网卡 <b>承受</b> <span class="underline">长时间的PCI总线延迟</span> ，而不会丢失接收数据或损坏发送数据</li>
<li>允许 <b>调整</b> <span class="underline">发送缓冲区大小</span> 。对系统性能的调整基于可用的PCI带宽、线速和延迟考虑</li>
<li>在网卡上完成接收和发送的IP及TCP/UDP校验和计算</li>
<li><b>直接</b> 从发送缓冲区重传失败的传输（碰撞检测、数据欠流），无需重新从主机内存访问这些数据。</li>
</ul>
</div>
</div>
<div id="outline-container-org7166c5c" class="outline-4">
<h4 id="org7166c5c">10/100/1000 Mb/s 接收和发送MAC模块</h4>
<div class="outline-text-4" id="text-org7166c5c">
<p>
控制器的 <span class="underline">CSMA/CD单元</span> 在*DMA* 和 <b>TBI/内部SerDes/MII/GMII接口</b> 模块之间处理所有IEEE 802.3 <b>接收</b> 和 <b>发送</b> <span class="underline">MAC功能</span> 
</p>
<pre class="example" id="org43bf75e">
CSMA/CD单元支持10 Mb/s的IEEE 802.3、100 Mb/s的IEEE 802.3u以及1000 Mb/s的IEEE 802.3z和IEEE 802.3ab
</pre>

<p>
以太网控制器支持 <b>半双工</b> 10/100 Mb/s <span class="underline">MII</span> 或 <span class="underline">1000 Mb/s</span> GMII模式，并在全双工操作中全面支持上述规范的所有方面。在半双工模式下，以太网控制器支持按照IEEE 802.3z规范规定的操作。在接收路径中，以太网控制器支持扩展的载波包和在包突发操作期间生成的包。在发送路径中，82554GC/EI还支持载波扩展的包，并且可以配置为以包突发模式发送。
</p>

<p>
以太网控制器提供各种过滤功能，以提供更好的性能和降低处理器利用率，具体如下：
</p>
<ul class="org-ul">
<li>提供多达16个地址用于精确匹配单播/多播地址过滤</li>
<li>提供基于4096位向量的多播地址过滤。同时支持混杂单播和混杂多播过滤</li>
<li>以太网控制器剥离IEEE802.1q VLAN标签，并根据其VLAN ID过滤数据包。支持多达4096个VLAN标签</li>
<li>在发送路径中，以太网控制器支持逐包插入VLAN标签信息</li>
</ul>

<p>
以太网控制器实现了IEEE 802.3x定义的流量控制功能，以及IEEE 802.3z定义的不对称流量控制的具体操作。以太网控制器还提供外部引脚，用于通过外部逻辑控制流量控制功能
</p>
</div>
</div>
<div id="outline-container-org1b3b644" class="outline-4">
<h4 id="org1b3b644">MII/GMII/TBI/Internal SerDes接口模块</h4>
<div class="outline-text-4" id="text-org1b3b644">
<p>
网卡提供以下串行接口：
</p>
<ul class="org-ul">
<li>AGMII/MII接口用于内部PHY</li>
<li>内部SerDes接口（82546GB/EB和82545GM/EM）/ TenBit接口（TBI）用于82544GC/EI：
<ul class="org-ul">
<li>网卡实现了802.3z PCS功能、自动协商功能和10位数据路径接口（TBI），用于接收和发送操作</li>
<li>它用于1000BASE-SX、-LX和-CX配置，仅以1000 Mb/s全双工工作</li>
<li>芯片上的PCS电路仅在链路接口配置为TBI模式时使用，并且在内部PHY模式下被绕过</li>
</ul></li>
</ul>

<pre class="example" id="org3c65236">
注意： 请参考扩展设备控制寄存器（位23:22）进行模式选择（请参阅第13.4.6节）
</pre>
</div>
</div>
<div id="outline-container-org2564ee1" class="outline-4">
<h4 id="org2564ee1">PHY接口</h4>
<div class="outline-text-4" id="text-org2564ee1">
<p>
链路可以通过多种方法进行配置。软件可以通过将MAC设置为TBI模式（82546GB/EB和82545GM/EM的内部SerDes），或将PHY设置为内部PHY模式来强制链路设置为自动协商
</p>

<p>
内部PHY模式下的链路速度可以通过多种方法确定：
</p>
<ul class="org-ul">
<li>基于PHY生成的接收时钟信号进行自动速度检测</li>
<li>检测PHY链路速度指示</li>
<li>软件强制配置链路速度</li>
</ul>
</div>
</div>
<div id="outline-container-org66a1ace" class="outline-4">
<h4 id="org66a1ace">EEPROM接口</h4>
<div class="outline-text-4" id="text-org66a1ace">
<p>
PCI/PCI-X系列网卡提供了一个与串行EEPROM设备（如93C46或兼容设备）直接连接的四线接口，用于存储产品配置信息。在复位后，网卡会自动访问EEPROM中的几个字，以在主机软件可以访问之前向网卡提供预启动配置数据。存储的其余信息由各种软件模块访问，用于报告产品配置、序列号和其他参数
</p>
</div>
</div>
<div id="outline-container-orga7a37a0" class="outline-4">
<h4 id="orga7a37a0">闪存存储器接口</h4>
<div class="outline-text-4" id="text-orga7a37a0">
<p>
网卡提供了一个外部并行接口，用于连接闪存设备。对闪存的访问由网卡控制，并可像对FLASH内存映射区域进行普通PCI读取或写入那样被软件访问。网卡支持最大容量为512 KB的闪存设备
</p>

<p>
82540EP/EM提供了一个外部接口，用于连接串行闪存或引导EEPROM设备
</p>
</div>
</div>
</div>
<div id="outline-container-org0dd12de" class="outline-3">
<h3 id="org0dd12de">DMA地址</h3>
<div class="outline-text-3" id="text-org0dd12de">
<p>
在适当的系统中，网卡管理的地址都是 <span class="underline">64位的</span> ，以支持拥有大于32位物理寻址的系统。提供64位地址消除了对特殊段寄存器的需求。
</p>
<pre class="example" id="org09d008f">
注：PCI 2.2或2.3规范要求，任何高32位全为0b的64位地址都应该表现为32位地址周期。以太网控制器符合PCI 2.2或2.3规范
</pre>

<p>
PCI是 <span class="underline">little endian</span> 的；然而，并非所有使用PCI的系统中的处理器都将内存视为 little endian。网络数据本质上是 <b>字节流</b> 。因此， <span class="underline">处理器</span> 和以太网控制器就内存数据的表示达成一致非常重要。默认情况下是little endia模式
</p>

<p>
以下示例说明了 little endia 中的数据字节顺序。接收数据包的字节按 <b>从左到右</b> 的顺序到达
</p>
<div class="org-src-container">
<pre class="src src-sh">01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e
</pre>
</div>

<p>
数据包缓冲区地址没有对齐限制。主要字的字节地址如左侧所示。PCI总线的字节号和位号如顶部所示
</p>

<div id="orgff071fe" class="figure">
<p><img src="pic/image-20240319132832019.png" alt="image-20240319132832019.png" width="70%" /> 
</p>
</div>

<pre class="example" id="org42f83d1">
描述符访问不会字节交换
</pre>
</div>
</div>
<div id="outline-container-org4ebfcec" class="outline-3">
<h3 id="org4ebfcec">以太网寻址</h3>
<div class="outline-text-3" id="text-org4ebfcec">
<p>
网卡中的几个寄存器存储了 <span class="underline">以太网地址</span> 。地址由 <span class="underline">两个32位</span> 寄存器组成：一个称为“高”（high），另一个称为“低”（low）
</p>
<pre class="example" id="orgdda2496">
例如，接收地址寄存器由接收地址高（RAH）和接收地址低（RAL）组成
</pre>

<p>
存储在寄存器中的地址的 <span class="underline">最低有效字节</span> 的 <span class="underline">最低有效位</span> （例如RAL的位0）是 <b>多播位</b> ，LS <span class="underline">最低有效字节</span> 是第一个出现在线上的字节。这种表示适用于所有地址寄存器，包括流量控制寄存器
</p>


<div id="org0500e0b" class="figure">
<p><img src="pic/image-20240319132858589.png" alt="image-20240319132858589.png" width="70%" /> 
</p>
</div>

<p>
图2-5展示了线上的位/字节地址顺序与唯一接收地址寄存器中的值之间的比较
</p>
</div>
</div>
<div id="outline-container-org82c6d27" class="outline-3">
<h3 id="org82c6d27">中断</h3>
<div class="outline-text-3" id="text-org82c6d27">
<p>
以太网控制器提供了一整套中断，允许进行高效的软件管理。中断结构的设计旨在实现以下目标：
</p>
<ul class="org-ul">
<li>通过使用 <span class="underline">设置</span> 和 <span class="underline">读后清除</span> 操作而不是“读-修改-写”操作，使访问 <b>线程安全</b></li>
<li><b>最小化</b> 完成工作所需的 <span class="underline">中断数量</span></li>
<li><b>最小化</b> 与每个中断相关的 <span class="underline">处理开销</span></li>
</ul>

<p>
英特尔通过由 <span class="underline">四个中断寄存器</span> 组成的中断逻辑实现了第一个目标。关于这些寄存器的更多细节在第13.4.17节到13.4.21节中有详细说明
</p>
<ul class="org-ul">
<li>中断原因 <b>Read寄存器</b> 和 <b>Set寄存器</b>
<ul class="org-ul">
<li>Read寄存器记录中断的原因。在 <span class="underline">读取</span> 时会被 <b>自动清除</b></li>
<li><p>
对于在Set寄存器中写入为 <span class="underline">1b</span> 的每个位，会 <b>设置</b> <span class="underline">原因位</span> ，如果硬件设置原因位和软件清除中断之间存在竞争，该位将保持设置
</p>
<pre class="example" id="org8eb25ea">
在写入Set寄存器时不存在竞争条件，Set操作允许软件发布中断。Read操作自动清除，以避免昂贵的写操作

大多数系统都有写缓冲，这最小化了开销，但通常需要一个读操作来保证写操作已经从发布的缓冲区中刷新

如果没有自动清除，清除中断的成本可能高达两次读取和一次写入
</pre></li>
</ul></li>
<li>中断屏蔽 <b>设置</b> （读）和 <b>清除</b> 寄存器
<ul class="org-ul">
<li>只有在中断原因位为1b，且相应的中断屏蔽位也为1b时，中断才会出现在PCI上</li>
<li><p>
软件可以通过清除屏蔽寄存器中的位来阻止中断线的断言
</p>
<pre class="example" id="orgac08911">
无论屏蔽位的状态如何，原因位都会存储中断事件

清除和设置操作通过避免在屏蔽寄存器上执行“读-修改-写”操作，使这个寄存器更加“线程安全”
</pre></li>
<li>对于在设置寄存器中写入的每个位，屏蔽位被设置为1b，并在清除寄存器中写入的每个位被清除。读取设置寄存器将返回当前值</li>
</ul></li>
</ul>

<p>
英特尔通过三个行动实现了第二个目标（最小化中断）：
</p>
<ul class="org-ul">
<li>减少所有中断的频率（见第13.4.17节）。不适用于82544GC/EI</li>
<li>在信号中断之前接受多个接收数据包（见第3.2.3节）</li>
<li>消除（或至少减少）发送时对中断的需求（见第3.2.7节）</li>
</ul>

<p>
第三个目标是通过有一个中断寄存器合并所有中断信息来实现的。这消除了多次访问的需求
</p>
</div>
</div>
<div id="outline-container-org1636fbc" class="outline-3">
<h3 id="org1636fbc">硬件加速能力</h3>
<div class="outline-text-3" id="text-org1636fbc">
<p>
网卡提供了在传输时卸载IP、TCP和UDP校验和的功能。这些功能可以显著 <b>减少</b> <span class="underline">处理器的利用率</span> ，通过将这些功能的负担从驱动程序转移到硬件来实现
</p>

<pre class="example" id="org37abccc">
校验和卸载功能在以下章节中简要概述。关于所有硬件加速功能的更多详细信息，请参阅第3.2.9节
</pre>
</div>
<div id="outline-container-org470b792" class="outline-4">
<h4 id="org470b792">校验和卸载</h4>
<div class="outline-text-4" id="text-org470b792">
<p>
网卡提供了从软件设备驱动程序中 <b>卸载</b> <span class="underline">IP</span> <span class="underline">TCP</span> 和 <span class="underline">UDP</span> 校验和要求的能力。对于常见的帧类型，硬件会自动计算、插入和检查通常由软件处理的适当的校验和值
</p>
<ul class="org-ul">
<li><p>
对于传输，在网卡可能会为每个以太网数据包计算并插入两个校验和
</p>
<pre class="example" id="org6dd3dcd">
通常情况下，这些将是IP校验和，以及TCP或UDP校验和
</pre>
<ul class="org-ul">
<li><p>
软件设备驱动程序指定了哪些部分的数据包包含在校验和计算中，并通过描述符指定了计算出的值的插入位置
</p>
<pre class="example" id="org97c267a">
详情请参阅第3.3.5节
</pre></li>
</ul></li>
<li>对于接收，在硬件识别数据包类型并自动执行校验和计算和错误检查
<ul class="org-ul">
<li><p>
校验和和错误信息通过接收描述符提供给软件
</p>
<pre class="example" id="orgc3604fa">
详情请参阅第3.2.9节
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6f9c7fb" class="outline-4">
<h4 id="org6f9c7fb">TCP分段</h4>
<div class="outline-text-4" id="text-org6f9c7fb">
<p>
网卡实现了一个 <span class="underline">TCP分段</span> 功能，用于传输，允许软件设备驱动程序将数据包分段和封装卸载到硬件。软件设备驱动程序可以将整个由网络操作系统 <span class="underline">NOS</span> 发送的IP、TCP或UDP消息发送给网卡进行传输。网卡将数据包分段成合法的以太网帧并将它们传输到电缆上。通过处理分段任务，硬件 <b>减轻</b> 了软件处理某些帧处理责任的负担。这减少了CPU在传输过程中的开销，从而降低了整体CPU利用率
</p>
<pre class="example" id="org7188223">
详情请参见第3.5节
</pre>
</div>
</div>
</div>
<div id="outline-container-orge06dcaf" class="outline-3">
<h3 id="orge06dcaf">缓冲区和描述符结构</h3>
<div class="outline-text-3" id="text-orge06dcaf">
<p>
软件 <b>分配</b> <span class="underline">传输</span> 和 <span class="underline">接收</span> <b>缓冲区*，并形成 *包含</b> <span class="underline">指向</span> 这些缓冲区以及其状态的 <b>描述符</b>
</p>

<pre class="example" id="orgd76b29d">
在缓冲区和描述符的硬件与驱动程序软件之间存在一个概念上的所有权边界

软件将 接收缓冲区的所有权交给硬件，这些接收缓冲区存储着软件一旦收到有效数据包后所拥有的数据
</pre>

<p>
对于传输，软件 <b>维护</b> 一个缓冲区队列。驱动程序软件拥有一个缓冲区，直到 <span class="underline">准备好进行传输</span> 。然后，软件将缓冲区 <b>提交</b> 给硬件；硬件随后拥有该缓冲区，直到 <span class="underline">数据被加载</span> 或 <span class="underline">传输到传输FIFO</span> 中
</p>

<p>
描述符存储有关缓冲区的以下信息：
</p>
<ul class="org-ul">
<li>物理地址</li>
<li>长度</li>
<li>关于引用缓冲区的状态和命令信息</li>
</ul>

<p>
描述符包含一个指示数据包的最后一个缓冲区的 <span class="underline">结束字段</span> 。描述符还包含指示 <span class="underline">数据包类型</span> 的特定于数据包的信息，以及在 <span class="underline">传输数据包的上下文</span> 中执行的特定操作
</p>
<pre class="example" id="org913083f">
例如用于VLAN或校验和卸载的操作
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb6257d2" class="outline-2">
<h2 id="orgb6257d2">发送和接收</h2>
<div class="outline-text-2" id="text-orgb6257d2">
</div>
<div id="outline-container-org5e949c2" class="outline-3">
<h3 id="org5e949c2">数据包接收</h3>
<div class="outline-text-3" id="text-org5e949c2">
<p>
包接收包括以下步骤：
</p>
<ol class="org-ol">
<li>识别线路上包的存在</li>
<li>执行地址过滤</li>
<li>将包存储在接收缓冲区中</li>
<li>将数据传输到主机内存中的接收缓冲区</li>
<li>更新接收描述符的状态</li>
</ol>
</div>
<div id="outline-container-orga2e0363" class="outline-4">
<h4 id="orga2e0363">包地址过滤</h4>
<div class="outline-text-4" id="text-orga2e0363">
<p>
硬件根据以下过滤模式将传入的包存储在主机内存中。如果接收队列中没有足够的空间，硬件将丢弃它们，并在相应的统计寄存器中指示丢失的包
</p>
<ol class="org-ol">
<li>ExactUnicast/Multicast：数据包的目的地址必须与 <b>存储</b> 在 <span class="underline">控制器中的16个地址之一</span> 完全匹配。这些地址可以是 <span class="underline">单播</span> 或 <span class="underline">多播</span> 地址</li>
<li>PromiscuousUnicast：接收 <b>所有</b> <span class="underline">单播数据包</span> ，不论其目的地址是什么</li>
<li>Multicast：传入数据包的目的地址的 <span class="underline">高位</span> 用于 <b>索引</b> 一个 <span class="underline">位向量</span> ，该位向量指示是否接受该数据包；
<ul class="org-ul">
<li>如果位向量中的位是1，则接受数据包，否则拒绝</li>
<li>控制器提供了一个4096位的位向量，软件可以选择使用位向量中的哪几位进行索引，选项包括[47:36]、[46:35]、[45:34]或[43:32]</li>
</ul></li>
<li>PromiscuousMulticast：接收 <b>所有</b> <span class="underline">多播数据包</span></li>
<li>VLAN：接收所有VLAN中为此站准备的数据包，并且这些数据包在VLAN过滤表中有相应的位设置</li>
</ol>

<p>
通常，只有良好的数据包会被接收。这些数据包被定义为 <b>没有</b> <span class="underline">CRC错误</span> 、 <span class="underline">符号错误</span> 、 <span class="underline">序列错误</span> 、 <span class="underline">长度错误</span> 、 <span class="underline">对齐错误</span> ，或者在其中检测到 <span class="underline">载波扩展</span> 或 <span class="underline">接收错误</span>
</p>
<pre class="example" id="org027ed35">
然而，如果设备控制寄存器 RCTL.SBP 中设置了存储坏包位，则通过过滤功能的坏包也会被存储在主机内存中

接收描述符 RDESC.ERRORS 中的错误位指示了包错误

通过设置混杂模式使能位 RCTL.UPE/MPE 和存储坏包位 RCTL.SBP ，无论数据包是否损坏，都可以接收所有数据包 
</pre>
</div>
</div>
<div id="outline-container-orgb305571" class="outline-4">
<h4 id="orgb305571">接收数据存储</h4>
<div class="outline-text-4" id="text-orgb305571">
<p>
由 <span class="underline">接收描述符</span> 指向的 <span class="underline">内存缓冲区</span> 存储包数据。支持七种接收缓冲区大小
</p>

<pre class="example" id="orgf3cf01a">
• 256 B     • 4096 B
• 512 B     • 8192 B
• 1024 B    • 16384 B
• 2048 B
</pre>

<p>
缓冲区大小通过 <b>接收控制寄存器</b> <span class="underline">RCTL.BSIZE</span> &amp; <span class="underline">RCTL.BSEX</span> 中的位来设置
</p>

<pre class="example" id="org10fee49">
网卡对包缓冲区地址没有对齐限制。但建议地址对齐
</pre>
</div>
</div>
<div id="outline-container-org34f403f" class="outline-4">
<h4 id="org34f403f">接收描述符格式</h4>
<div class="outline-text-4" id="text-org34f403f">
<p>
接收描述符是一种数据结构，包含接收 <span class="underline">数据缓冲区地址</span> 和用于 <span class="underline">硬件存储包信息</span> 的字段。表3-1说明了接收描述符的格式
</p>

<div id="orgb2e8eb7" class="figure">
<p><img src="pic/image-20240319144554618.png" alt="image-20240319144554618.png" width="70%" /> 
</p>
</div>

<p>
注意：
</p>
<ul class="org-ul">
<li><b>校验和</b> 指的是数据包的 <b>未调整</b> 的 <span class="underline">16位补数</span>
<ul class="org-ul">
<li>在将数据包发送到上层软件层之前，可能需要软件辅助来删除部分信息</li>
<li>数据包校验和始终在第一个描述符中报告（即使在多描述符数据包的情况下也是如此）</li>
</ul></li>
<li>对于网卡接收到的数据包，硬件将数据包数据存储到指定的缓冲区，并写入 <span class="underline">长度</span> 、 <span class="underline">数据包校验和</span> 、 <span class="underline">状态</span> 、 <span class="underline">错误</span> 和 <span class="underline">状态</span> 字段
<ul class="org-ul">
<li>长度包括写入接收缓冲区的数据，包括CRC字节（如果有）</li>
<li>对于跨越多个接收缓冲区的数据包，软件必须读取多个描述符以确定完整的长度</li>
</ul></li>
<li>对于标准的802.3数据包（非VLAN），数据包校验和默认情况下是计算整个数据包，从 <b>第一个字节到最后一个字节</b> ，包括 <span class="underline">以太网</span> 和 <span class="underline">IP头</span> 
<ul class="org-ul">
<li>软件可以通过接收控制寄存器来修改数据包校验和计算的起始偏移量</li>
<li>要使用数据包校验和验证TCP校验和，软件必须调整数据包校验和的值，以撤销不属于TCP校验和的字节</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org73e7878" class="outline-5">
<h5 id="org73e7878">接收描述符状态字段</h5>
<div class="outline-text-5" id="text-org73e7878">
<p>
<b>状态信息</b> 指示描述符是否已使用以及引用的缓冲区是否是数据包的最后一个。表3-2说明了状态字段的布局
</p>

<div id="org4c7c0fa" class="figure">
<p><img src="pic/image-20240319144702733.png" alt="image-20240319144702733.png" width="70%" /> 
</p>
</div>


<p>
对于多描述符数据包，数据包状态在数据包的 <span class="underline">最后一个描述符</span> 中提供 EOP 。如果描述符的EOP未设置，则只有地址、长度和DD位有效
</p>

<ul class="org-ul">
<li><b>IPCS</b> <span class="underline">bit 6</span> IP校验和计算： 当未设置忽略校验和指示位（IXSM = 0b）时，IPCS位指示硬件是否对接收到的数据包计算IP校验和
<ul class="org-ul">
<li>0b = 不执行IP校验和</li>
<li><p>
1b = 执行IP校验和
</p>
<pre class="example" id="org14da509">
校验和的Pass/Fail信息在描述符接收错误（RDESC.ERRORS）的错误位（IPE）中指示

IPv6数据包不设置IPCS位。读取为0b
</pre></li>
</ul></li>
<li><b>TCPCS</b> <span class="underline">bit 5</span> TCP校验和计算：当未设置忽略校验和指示位（IXSM = 0b）时，TCPCS位指示硬件是否对接收到的数据包计算TCP/UDP校验和
<ul class="org-ul">
<li>0b = 不执行TCP/UDP校验和</li>
<li><p>
1b = 执行TCP/UDP校验和
</p>
<pre class="example" id="orgfebbb8e">
关于校验和的通过/失败信息在描述符接收错误（RDESC.ERRORS）的错误位（TCPE）中指示。

如果识别出TCP/UDP数据包，则IPv6数据包可能设置此位。读取为0b
</pre></li>
</ul></li>
<li><b>RSV</b> <span class="underline">bit 4</span>  保留位，值位0b</li>
<li><b>IXSM</b> <span class="underline">bit 2</span> 忽略校验和指示：
<ul class="org-ul">
<li>IXSM = 1b时，忽略校验和指示结果（IPCS、TCPCS位）</li>
<li>IXSM = 0b时，IPCS和TCPCS位指示硬件是否对接收到的数据包执行了IP或TCP/UDP校验和</li>
</ul></li>
<li><b>EOP</b> <span class="underline">bit 1</span> 指示这是否是传入数据包的最后一个描述符</li>
<li><p>
<b>DD</b> <span class="underline">bit 0</span> 指示硬件是否完成了对描述符的处理
</p>
<pre class="example" id="orga679d57">
当与EOP一起设置时，表示接收到的数据包已完全存储在主存储器中
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org941eb75" class="outline-5">
<h5 id="org941eb75">接收描述符错误字段</h5>
<div class="outline-text-5" id="text-org941eb75">
<p>
大多数错误信息仅在 <b>设置</b> 了 <span class="underline">存储错误数据包位</span> RCTL.SBP 并接收到 <span class="underline">错误数据包</span> 时才出现。仅当描述符状态字段中的EOP和DD位设置时，错误位才有效。错误状态信息在表3-3中 
</p>


<div id="orgbbb9321" class="figure">
<p><img src="pic/image-20240319152813055.png" alt="image-20240319152813055.png" width="70%" /> 
</p>
</div>

<ul class="org-ul">
<li><b>RXE</b> <span class="underline">bit 7</span> 略</li>
<li><b>IPE</b> <span class="underline">bit 6</span> IP校验和错误。当设置时，表示在接收到的数据包中检测到IP校验和错误。仅在通过RDESC.STATUS字段中的IPCS位指示接收数据包进行IP校验和时有效
<ul class="org-ul">
<li>如果接收IP校验和卸载被禁用（RXCSUM.IPOFL），则IPE位被设置为0b</li>
<li><p>
读取为0b
</p>
<pre class="example" id="orgd0d7385">
它对数据包过滤机制没有影响
</pre></li>
</ul></li>
<li><b>TCPE</b> <span class="underline">bit 5</span> TCP/UDP校验和错误 当设置时，表示在接收到的数据包中检测到TCP/UDP校验和错误
<ul class="org-ul">
<li>仅在通过RDESC.STATUS字段中的TCPCS位指示接收数据包进行TCP/UDP校验和时有效</li>
<li>如果接收TCP/UDP校验和卸载被禁用（RXCSUM.TUOFL），则TCPE位被设置为0b</li>
<li>它对数据包过滤机制没有影响。读取为0b</li>
</ul></li>
<li><b>CXE RSV</b> <span class="underline">bit 4</span> 略</li>
<li><b>SEQ</b> <span class="underline">bit 2</span> 序列错误
<ul class="org-ul">
<li>当设置时，表示接收到的数据包具有错误的分隔符序列。在其他802.3实现中，这将被分类为帧错误</li>
<li>有效的分隔符序列包括：空闲态 -&gt; 帧起始（SOF） -&gt; 数据 -&gt; 填充（可选）-&gt; 帧结束（EOF） -&gt; 填充（可选） -&gt; 空闲态</li>
</ul></li>
<li><b>SE</b> <span class="underline">bit 1</span> 略</li>
<li><b>CE</b> <span class="underline">bit0</span> CRC错误或对齐错误
<ul class="org-ul">
<li><p>
CRC错误和对齐错误都通过CE位指示
</p>
<pre class="example" id="org5656e34">
软件可以通过监视相应的统计寄存器来区分这些错误
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org06c9468" class="outline-5">
<h5 id="org06c9468">Receive Descriptor Special Field</h5>
<div class="outline-text-5" id="text-org06c9468">
<p>
略
</p>
</div>
</div>
</div>
<div id="outline-container-org7efd49a" class="outline-4">
<h4 id="org7efd49a">接收描述符获取</h4>
<div class="outline-text-4" id="text-org7efd49a">
<p>
接收描述符获取策略旨在支持跨PCI总线的大数据突发。这是通过使用 <span class="underline">64个</span> <b>片上接收描述符</b> 和优化的 <b>获取算法</b> 实现的。获取算法试图通过每次突发获取一个或多个缓存行的描述符，以最大限度地利用PCI带宽
</p>
<ul class="org-ul">
<li>当片上缓冲区 <b>为空</b> 时，只要有任何描述符可用（软件写入尾指针），就会进行获取
<ul class="org-ul">
<li>当片上缓冲区 <b>几乎为空</b> （RXDCTL.PTHRESH）时，在 <span class="underline">主机内存</span> 中有 <b>足够多的有效描述符</b> （RXDCTL.HTHRESH）可用，并且 <b>没有</b> <span class="underline">更高优先级的其他PCI活动</span> （描述符获取和写回或数据包传输）挂起时，将执行预取</li>
</ul></li>
<li>当主机内存中的 <span class="underline">描述符数量</span> <b>大于</b> <span class="underline">可用的片上描述符存储</span> 时，芯片 <b>可能</b> 会选择执行 <span class="underline">不是缓存行大小倍数的获取</span>
<ul class="org-ul">
<li><p>
如果这样做可以使下一个描述符获取在缓存行边界上对齐，硬件将执行此非对齐获取
</p>
<pre class="example" id="org712d565">
该机制提供了在获取落后于软件的情况下的最高效率
</pre></li>
</ul></li>
</ul>
<pre class="example" id="org3d09dc5">
注：以太网控制器从不获取超出描述符尾部指针的描述符
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf28fcb1" class="outline-3">
<h3 id="orgf28fcb1">网络包发送</h3>
<div class="outline-text-3" id="text-orgf28fcb1">
<p>
常规数据包（非TCP分段数据包）的传输过程包括以下步骤：
</p>
<ol class="org-ol">
<li>协议栈从应用程序接收要传输的数据块</li>
<li>协议栈根据 <span class="underline">MTU大小</span> 和 <span class="underline">所需的数据包头部</span> 计算出需要传输的 <span class="underline">数据块数量</span></li>
<li>对于数据块中的每个数据包：
<ul class="org-ul">
<li>协议栈准备以太网、IP和TCP/UDP头部</li>
<li>协议栈调用设备驱动程序，命令其发送单个数据包</li>
<li>驱动程序获取帧并与硬件通信</li>
<li>硬件通过DMA从内存读取数据包</li>
<li>当硬件完成帧的DMA传输后（通过 <b>中断</b> 指示），驱动程序将数据包的所有权返回给网络操作系统（NOS）</li>
</ul></li>
</ol>

<p>
输出的数据包由 <b>指针-长度</b> 对组成，构成一个 <span class="underline">描述符链</span> （基于描述符的传输）。软件通过组装 指针-长度对列表，将这些信息存储在 <span class="underline">传输描述符</span> 中，然后更新芯片上的 <b>传输尾指针</b> 到描述符。 <span class="underline">传输描述符</span> 和 <span class="underline">缓冲区</span> 存储在 <span class="underline">主机内存</span> 中。硬件只有在完全从内存获取到所有数据并将其存入 <span class="underline">芯片上的传输FIFO</span> 后，才会传输数据包
</p>
<pre class="example" id="orgba28e20">
这样可以允许TCP或UDP校验和计算
</pre>
</div>
<div id="outline-container-org859a584" class="outline-4">
<h4 id="org859a584">传输数据的存储</h4>
<div class="outline-text-4" id="text-org859a584">
<p>
数据存储在 <span class="underline">描述符</span> 指向的 <span class="underline">缓冲区</span> 中
</p>
<ul class="org-ul">
<li>数据的对齐是在任意字节边界上进行的</li>
<li>每个描述符的最大大小受限于允许的最大数据包大小 <span class="underline">16288字节</span></li>
<li>一个数据包通常由两个（或更多）描述符组成
<ul class="org-ul">
<li>一个（或更多）用于头部</li>
<li><p>
一个用于实际数据
</p>
<pre class="example" id="orga416e41">
一些软件实现将头部和数据包数据复制到一个缓冲区中，并为每个传输的数据包仅使用一个描述符
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgeba1942" class="outline-4">
<h4 id="orgeba1942">传输描述符</h4>
<div class="outline-text-4" id="text-orgeba1942">
<p>
以太网控制器提供三种类型的传输描述符格式。原始描述符被称为 <span class="underline">传统</span> 描述符格式
</p>
<pre class="example" id="orgbdf6357">
另外两种描述符类型统称为扩展描述符，本次LAB只使用传统描述符格式，所以只翻译这部分
</pre>
</div>
</div>
<div id="outline-container-org5705dcd" class="outline-4">
<h4 id="org5705dcd">传统描述符格式</h4>
<div class="outline-text-4" id="text-org5705dcd">
<p>
要选择传统模式操作，位29 <span class="underline">TDESC.DEXT</span> 应设置为 <span class="underline">0b</span> 。在这种情况下，描述符格式如表3-8所示
</p>

<div id="orga021a5f" class="figure">
<p><img src="pic/image-20240321155938339.png" alt="image-20240321155938339.png" width="70%" /> 
</p>
</div>

<p>
地址和长度必须由软件提供
</p>
<pre class="example" id="orgbffcd52">
CMD中的位是可选的，校验和偏移（CSO）和校验和开始（CSS）字段也是如此
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 表3-8. 传输描述符（TDESC）布局 - 传统模式</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">字段</td>
<td class="org-left">含义</td>
</tr>

<tr>
<td class="org-left">Buffer Address</td>
<td class="org-left">传输描述符在 <span class="underline">主机内存中的地址</span> 。地址为null的描述符不会传输数据。如果在CMD中设置了RS位（TDESC.CMD），那么在硬件处理完这个描述符时，状态字（TDESC.STATUS）中的DD字段会被写入</td>
</tr>

<tr>
<td class="org-left">Length</td>
<td class="org-left">长度是 <b>每段的长度</b> ，不是总长度，单个描述符的最大长度是 16288 字节。尽管允许缓冲区长度仅为1字节，但在填充和写入CRC之前，数据包总长度应不少于48字节。Length最大值为16288字节缓冲区的长度最大可为允许的最大传输数据包长度。长度为零的描述符不会传输数据</td>
</tr>

<tr>
<td class="org-left">CSO</td>
<td class="org-left">校验和偏移字段：存储了如果启用了该模式在TDESC.CMD中设置了插入校验和位(IC)，TCP校验和相对于数据包起始位置的偏移量。除非在TDESC.CMD中设置了EOP，否则硬件会忽略CSO。CSO以字节为单位提供，并且必须在描述符提供给以太网控制器的数据范围内。（CSO &lt; 长度 - 1）。为了未来的兼容性，应该用0b来写入</td>
</tr>

<tr>
<td class="org-left">CMD</td>
<td class="org-left">3.3.3.1节介绍</td>
</tr>

<tr>
<td class="org-left">STA</td>
<td class="org-left">3.3.3.2节介绍</td>
</tr>

<tr>
<td class="org-left">RSV</td>
<td class="org-left">保留字段，全部写成0b</td>
</tr>

<tr>
<td class="org-left">CSS</td>
<td class="org-left">校验和开始字段（TDESC.CSS）：指示了从哪里开始计算校验和，排除不应包含在TCP校验和中的字节。单位为字节。对于软件填充的短数据包，CSS必须在未填充数据长度的范围内。0b的值对应于&gt;数据包中的第一个字节。 CSS 必须在数据包的第一个描述符中设置</td>
</tr>

<tr>
<td class="org-left">Special</td>
<td class="org-left">本次LAB不用</td>
</tr>
</tbody>
</table>

<p>
注：
</p>
<ul class="org-ul">
<li>尽管CSO和CSS以字节为单位，但校验和计算通常在16位字上进行。硬件不会强制执行偶字节对齐</li>
<li><p>
尽管可以像上面描述的那样使用传统描述符格式编程以太网控制器来计算和插入TCP校验和，但建议软件使用更新的TCP/IP上下文传输描述符格式
</p>
<pre class="example" id="orgb70df22">
这种新的描述符格式允许硬件为传出的数据包计算IP和TCP校验和
</pre></li>
</ul>
</div>
<div id="outline-container-org2760f34" class="outline-5">
<h5 id="org2760f34">CMD字段</h5>
<div class="outline-text-5" id="text-org2760f34">

<div id="org81974ad" class="figure">
<p><img src="pic/image-20240321162519317.png" alt="image-20240321162519317.png" width="70%" /> 
</p>
</div>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> CMD Layout</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">字段</td>
<td class="org-left">含义</td>
</tr>

<tr>
<td class="org-left">IDE (bit 7)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">VLE (bit 6)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">DEXT (bit 5)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">RSV (bit 4)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">RS (bit 3)</td>
<td class="org-left">Report Status 此位被设置时，网卡在传输完当前描述符的数据后，会报告状态信息。设置STA中的DD位</td>
</tr>

<tr>
<td class="org-left">IC (bit 2)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">IFCS (bit 1)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">EOP (bit 0)</td>
<td class="org-left">数据包结束。当设置时，表示组成数据包的最后一个描述符。一个或多个描述符可以用来形成一个数据包</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org2674e07" class="outline-5">
<h5 id="org2674e07">传输状态字段</h5>
<div class="outline-text-5" id="text-org2674e07">

<div id="orgec95a8a" class="figure">
<p><img src="pic/image-20240321162639560.png" alt="image-20240321162639560.png" width="70%" /> 
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">字段</td>
<td class="org-left">含义</td>
</tr>

<tr>
<td class="org-left">RSV (bit 3)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">LC (bit 2)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">EC (bit 1)</td>
<td class="org-left">用不上</td>
</tr>

<tr>
<td class="org-left">DD (bit 0)</td>
<td class="org-left">设置了CMD中的RS位后，当描述符被网卡发送完成时，会设置此位，以告知传输已完成</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org74cff7e" class="outline-2">
<h2 id="org74cff7e">网卡初始化</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
