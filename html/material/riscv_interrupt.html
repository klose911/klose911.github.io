<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RISCV 中断</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">RISCV 中断</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgfa01905">中断有关的寄存器</a>
<ul>
<li><a href="#orgd942420">M-mode</a>
<ul>
<li><a href="#org101b591">mcause</a></li>
<li><a href="#orgb707c4d">mstatus</a></li>
<li><a href="#org42e0677">mtvec</a></li>
<li><a href="#org0c11215">medeleg 与 mideleg</a></li>
<li><a href="#org9c2cbc8">mip 与 mie</a></li>
<li><a href="#org497947c">mpec</a></li>
<li><a href="#org08f064f">mtval</a></li>
</ul>
</li>
<li><a href="#org373f607">S-mode</a>
<ul>
<li><a href="#orgd1485a6">sstatus</a></li>
<li><a href="#org6caa02f">其它 s 特权级寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org413628d">特权级转换</a>
<ul>
<li><a href="#orgf215fd3">U 与 S 间的切换</a>
<ul>
<li><a href="#org7ff7612">U 切换到 S</a></li>
<li><a href="#org3c753f1">S 切换到 U</a></li>
</ul>
</li>
<li><a href="#org949e81b">S 与 M 间的切换</a>
<ul>
<li><a href="#orgb4e16c8">S 切换到 M</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org39a9b30">系统调用的实现</a></li>
<li><a href="#org8213206">地址空间布局</a>
<ul>
<li><a href="#orgd1d35c9">跳板页</a></li>
<li><a href="#org00e4749">Page Fault</a></li>
</ul>
</li>
<li><a href="#orgf43e042">如何设置 stvec 的</a>
<ul>
<li><a href="#org18353c7">第一次的 stvec 是如何设置的</a></li>
</ul>
</li>
<li><a href="#orgac17f69">与中断有关的硬件单元</a>
<ul>
<li><a href="#org4f50753">PLIC</a>
<ul>
<li><a href="#orgc16c997">寄存器与内存映射</a></li>
<li><a href="#org071b894">工作流程与时序要点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org83ac224">时钟中断</a>
<ul>
<li><a href="#org9e40eba">时钟中断相关的寄存器</a></li>
<li><a href="#orgb12c26f">时钟中断的基本处理过程</a></li>
<li><a href="#org8645236">xv6 实现</a>
<ul>
<li><a href="#org0e7596c">timer_init</a></li>
<li><a href="#org3977192">时钟中断处理函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf99cd2e">软件中断</a></li>
</ul>
</div>
</div>
<p>
<b>trap</b>  <span class="underline">陷阱</span> 可以分为 <b>异常</b> 与 <b>中断</b> 。在 RISC v 下，中断有三种来源：
</p>
<ul class="org-ul">
<li>software interrupt</li>
<li>timer interrupt（顾名思义，时钟中断）</li>
<li>external interrupt</li>
</ul>

<p>
你可能见过 NMI，但是这是一种中断类型而非中断来源：
</p>
<ul class="org-ul">
<li>Non-maskable interrupt，不可屏蔽中断，与之相对的就是可屏蔽中断</li>
<li>NMI 都是硬件中断，只有在发生严重错误时才会触发这种类型的中断</li>
</ul>

<pre class="example" id="org4dacfce">
你可能接触过 Linux 中的软中断，即 softirq

但是请注意 software interrupt 与 softirq 是完完全全不一样的

</pre>

<p>
接下来将全面介绍 RISC v 下的中断发送与处理、软件中断、用户态中断和特权级转换，并结合 xv6 内核、rcore、Linux 内核等实现进行介绍
</p>
<div id="outline-container-orgfa01905" class="outline-2">
<h2 id="orgfa01905">中断有关的寄存器</h2>
<div class="outline-text-2" id="text-orgfa01905">
<ul class="org-ul">
<li>M-mode 寄存器：</li>
</ul>
<p>
<b>mstatus</b> ， <b>mtvec</b> ， <b>medeleg</b> ， <b>mideleg</b> ， <b>mip</b> ， <b>mie</b> ， <b>mepc</b> ， <b>mcause</b> ， <b>mtval</b> 
</p>
<ul class="org-ul">
<li>S-mode 寄存器:</li>
</ul>
<p>
<b>sstatus</b> ， <b>stvec</b> ， <b>sip</b> ， <b>sie</b> ， <b>sepc</b> ， <b>scause</b> ， <b>stval</b> ， <b>satp</b>
</p>

<p>
在后文中，可能会有 <span class="underline">xstatus</span> , <span class="underline">xtvec</span> 等的写法，其中 x 表示特权级 m 或者 s 或者 u（u 仅仅在实现了用户态中断的 CPU 上存在）
</p>
</div>
<div id="outline-container-orgd942420" class="outline-3">
<h3 id="orgd942420">M-mode</h3>
<div class="outline-text-3" id="text-orgd942420">
</div>
<div id="outline-container-org101b591" class="outline-4">
<h4 id="org101b591">mcause</h4>
<div class="outline-text-4" id="text-org101b591">

<div id="orge1e97a1" class="figure">
<p><img src="pic/1653979-20230712210012313-359133103.png" alt="1653979-20230712210012313-359133103.png" width="100%" />
</p>
</div>

<p>
RISC-V 定义 mcause 的高位和低位分别表示不同的信息：
</p>
<ul class="org-ul">
<li>最高位 (Interrupt bit)
<ul class="org-ul">
<li>0：表示 异常 (Exception)</li>
<li>1：表示 中断 (Interrupt)</li>
</ul></li>
<li>其余位 (Exception Code / Interrupt Code)
<ul class="org-ul">
<li>当最高位是 0：剩余位表示 异常原因</li>
<li>当最高位是 1：剩余位表示 中断类型</li>
</ul></li>
</ul>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 常见异常代码（当 Interrupt=0）</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">Code</td>
<td class="org-left">异常 (Exception) 类型</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-left">指令地址不对齐 (Instruction address misaligned)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">指令访问错误 (Instruction access fault)</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">非法指令 (Illegal instruction)</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">断点 (Breakpoint)</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">加载地址不对齐 (Load address misaligned)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">加载访问错误 (Load access fault)</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">存储/AMO 地址不对齐 (Store/AMO address misaligned)</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">存储/AMO 访问错误 (Store/AMO access fault)</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">环境调用 U 模式 (Environment call from U-mode)</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">环境调用 S 模式 (Environment call from S-mode)</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">环境调用 M 模式 (Environment call from M-mode)</td>
</tr>

<tr>
<td class="org-right">12</td>
<td class="org-left">指令页错误 (Instruction page fault)</td>
</tr>

<tr>
<td class="org-right">13</td>
<td class="org-left">加载页错误 (Load page fault)</td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-left">存储/AMO 页错误 (Store/AMO page fault)</td>
</tr>
</tbody>
</table>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 常见中断代码（当 Interrupt=1）</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">Code</td>
<td class="org-left">中断 (Interrupt) 类型</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-left">用户软件中断 (User software interrupt)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">管理员软件中断 (Supervisor software interrupt)</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">机器软件中断 (Machine software interrupt)</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">用户定时器中断 (User timer interrupt)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">管理员定时器中断 (Supervisor timer interrupt)</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">机器定时器中断 (Machine timer interrupt)</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">用户外部中断 (User external interrupt)</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">管理员外部中断 (Supervisor external interrupt)</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">机器外部中断 (Machine external interrupt)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgb707c4d" class="outline-4">
<h4 id="orgb707c4d">mstatus</h4>
<div class="outline-text-4" id="text-orgb707c4d">

<div id="org6ec08dc" class="figure">
<p><img src="pic/1653979-20230712210012932-1184025042.png" alt="1653979-20230712210012932-1184025042.png" width="100%" /> 
</p>
</div>

<p>
<span class="underline">MIE</span> 与 <span class="underline">SIE</span> 是 <b>全局中断使能位</b> ，当 xIE 为 1 时，允许在 x 特权级发生中断，否则不允许中断。
</p>
<ul class="org-ul">
<li>当 hart 处于 x 特权级时
<ul class="org-ul">
<li>当 xIE 为 0 时，x 特权级的中断被全部禁用， xIE 为1 时被全部启用</li>
<li>当 xIE 为 0 时
<ul class="org-ul">
<li>对于任意的 w&lt;x，w 特权级的中断都是处于全局禁用状态</li>
<li>对于任意的 y&gt;x，y 特权级的中断默认处于全局启用状态，无论 xIE 是否为 1</li>
</ul></li>
</ul></li>
<li>为支持嵌套陷阱，每个可以响应中断的特权模式 x 都有一个 <b>两级中断使能位</b> 和 <b>特权模式堆栈</b>
<ul class="org-ul">
<li>xPIE 保存陷阱之前活动的中断使能位的值</li>
<li>xPP 保存之前的特权模式
<ul class="org-ul">
<li>xPP 字段只能保存 x 及以下特权模式，因此 <span class="underline">MPP</span> 为 <b>两位</b> 宽， <span class="underline">SPP</span> 为 <b>一位</b> 宽</li>
</ul></li>
<li>当从特权模式 y 进入特权模式 x 时
<ul class="org-ul">
<li>xPIE 设置为 xIE 的值，xIE 设置为 0</li>
<li>xPP 设置为 y：对于 MPP，可以设置的值有 0b00（用户模式），0b01（S-mode），0b10(reserved)，0b11(M-mode)</li>
</ul></li>
</ul></li>
<li>在 M 模式或 S 模式中，使用 <b>mret</b> 或 <b>sret</b> 指令返回陷阱。执行 xret 指令时
<ul class="org-ul">
<li>将 xIE 设置为 xPIE；将 xPIE 设置为 1</li>
<li>假设 xPP 值为 y，则将特权模式更改为 y</li>
<li>将 xPP 设置为 U（如果不支持用户模式，则为 M）
<ul class="org-ul">
<li>如果 xPP≠M，则 xRET 还会设置 MPRV=0</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org42e0677" class="outline-4">
<h4 id="org42e0677">mtvec</h4>
<div class="outline-text-4" id="text-org42e0677">

<div id="orgdd63fec" class="figure">
<p><img src="pic/1653979-20230712210013404-19738400.png" alt="1653979-20230712210013404-19738400.png" width="100%" />
</p>
</div>

<p>
<b>mtvec</b> 记录的是 <span class="underline">异常处理函数的起始地址</span> ：
</p>
<ul class="org-ul">
<li>BASE 字段中的值必须始终对齐于 4 字节边界</li>
<li>MODE 设置可能会对 BASE 字段中的值施加额外的对齐约束
<ul class="org-ul">
<li>如果 MODE 为 0，那么所有的异常处理都有同一个入口地址</li>
<li><p>
否则的话异常处理的入口地址是 BASE+4*CAUSE
</p>
<pre class="example" id="org7a8f337">
cause 记录在 xcause 中
</pre></li>
</ul></li>
</ul>


<div id="orge9a2ed9" class="figure">
<p><img src="pic/1653979-20230712210013684-694188924.png" alt="1653979-20230712210013684-694188924.png" width="100%" />
</p>
</div>
</div>
</div>
<div id="outline-container-org0c11215" class="outline-4">
<h4 id="org0c11215">medeleg 与 mideleg</h4>
<div class="outline-text-4" id="text-org0c11215">
<pre class="example" id="org0107a73">
默认情况下，各个特权级的陷阱都是被捕捉到了 M-mode

可以通过代码实现将 trap 转发到其它特权级进行处理
</pre>
<p>
为了提高转发的性能在 CPU 级别做了改进并提供了 <b>medeleg</b> 和 <b>mideleg</b> 两个寄存器：
</p>
<ul class="org-ul">
<li>medeleg <span class="underline">machine exception delegation</span> 用于指示转发哪些异常到 S-mode</li>
<li>mideleg <span class="underline">machine interrupt delegation</span> 用于指示转发哪些中断到 S-mode</li>
</ul>

<p>
当将陷阱委托给 S 模式时
</p>
<ul class="org-ul">
<li>scause 寄存器会写入 <b>陷阱原因</b></li>
<li>sepc 寄存器会写入 <b>引发陷阱的指令的虚拟地址</b></li>
<li>stval 寄存器会写入 <b>特定于异常的数据</b></li>
<li>mstatus 的 <span class="underline">SPP</span> 字段会写入 <b>发生陷阱时的活动特权级</b></li>
<li>mstatus 的 <span class="underline">SPIE</span> 字段会写入 <b>发生陷阱时的 SIE 字段的值</b></li>
<li>mstatus 的 <span class="underline">SIE</span> 字段会被 <b>清除</b></li>
<li>mcause、mepc 和 mtval 寄存器以及 mstatus 的 MPP 和 MPIE 字段不会被写入</li>
</ul>

<p>
被委托的中断会导致该中断在委托者所在的特权级 <b>屏蔽</b>
</p>
<pre class="example" id="org559e583">
比如说 M-mode 将一些中断委托给了 S-mode，那么 M-mode 就无法捕捉到这些中断了
</pre>
</div>
</div>
<div id="outline-container-org9c2cbc8" class="outline-4">
<h4 id="org9c2cbc8">mip 与 mie</h4>
<div class="outline-text-4" id="text-org9c2cbc8">
<p>
<b>mip</b> 与 <b>mie</b> 是分别用于保存 <span class="underline">pending interrupt</span> 和 <span class="underline">pending interrupt enable bits</span>
</p>

<pre class="example" id="org86ddcbb">
每个中断都有中断号 i（定义在 mcause 表中）

每个中断号如果被 pending 了，那么对应的第 i 位就会被置为 1

因为 RISC v spec 定义了 16 个标准的中断，因此低 16bit 是用于标准用途，其它位则自定义
</pre>
<p>
如下图所示是低 16bit 的 mip 与 mie 寄存器
</p>

<div id="org37f8f3e" class="figure">
<p><img src="pic/1653979-20230712210014053-1431446270.png" alt="1653979-20230712210014053-1431446270.png" width="100%" /> 
</p>
</div>

<pre class="example" id="orgad547f2">
只需要知道 mcause 中的中断源即可

例如 SSIP 就是 supervisor software interrupt pending

SSIE 就是 supervisor software interrupt enable
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> mie 寄存器（Machine Interrupt Enable Register）</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">位位置</td>
<td class="org-left">名称</td>
<td class="org-left">含义</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-left">USIE</td>
<td class="org-left">用户软件中断使能</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">SSIE</td>
<td class="org-left">管理员（S 模式）软件中断使能</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">MSIE</td>
<td class="org-left">机器（M 模式）软件中断使能</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">UTIE</td>
<td class="org-left">用户定时器中断使能</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">STIE</td>
<td class="org-left">S 模式定时器中断使能</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">MTIE</td>
<td class="org-left">M 模式定时器中断使能</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">UEIE</td>
<td class="org-left">用户外部中断使能</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">SEIE</td>
<td class="org-left">S 模式外部中断使能</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">MEIE</td>
<td class="org-left">M 模式外部中断使能</td>
</tr>
</tbody>
</table>

<pre class="example" id="org7cafb15">
如果要允许 “机器定时器中断” ，就需要把 mie.MTIE 位置 1
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> mip 寄存器（Machine Interrupt Pending Register）</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">位位置</td>
<td class="org-left">名称</td>
<td class="org-left">含义</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-left">USIP</td>
<td class="org-left">用户软件中断挂起</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">SSIP</td>
<td class="org-left">S 模式软件中断挂起</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">MSIP</td>
<td class="org-left">M 模式软件中断挂起</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">UTIP</td>
<td class="org-left">用户定时器中断挂起</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">STIP</td>
<td class="org-left">S 模式定时器中断挂起</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">MTIP</td>
<td class="org-left">M 模式定时器中断挂起</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">UEIP</td>
<td class="org-left">用户外部中断挂起</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">SEIP</td>
<td class="org-left">S 模式外部中断挂起</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">MEIP</td>
<td class="org-left">M 模式外部中断挂起</td>
</tr>
</tbody>
</table>

<pre class="example" id="org878ab3f">
当定时器溢出时，硬件会把 mip.MTIP 置 1，表示有一个 M 模式定时器中断等待处理
</pre>

<p>
mie 和 mip 的关系
</p>
<ul class="org-ul">
<li>mie: 允许哪些中断</li>
<li>mip: 哪些中断正在等待</li>
</ul>

<p>
CPU 是否真正响应中断取决于：
</p>

<pre class="example" id="org6aa228d">
if (mstatus.MIE == 1) and (mip &amp; mie 有重叠的位) → 触发中断
</pre>
<p>
也就是说：
</p>
<ol class="org-ol">
<li>必须 全局中断使能位 mstatus.MIE=1</li>
<li>必须 mie 里对应的中断源被允许</li>
<li>必须 mip 里对应的中断源正在挂起</li>
</ol>

<pre class="example" id="orgd6a124c">
举个例子：机器定时器中断

1. 硬件定时器达到设定值 → mip.MTIP = 1
2. 软件提前打开了 mie.MTIE = 1
3. 且全局 mstatus.MIE = 1

→ 4. CPU 立即跳转到 mtvec 指定的中断入口
  5. 处理中断时，硬件会自动清 mstatus.MIE=0，防止嵌套
  6. 返回时执行 mret，恢复原始 MIE 状态
</pre>
</div>
</div>
<div id="outline-container-org497947c" class="outline-4">
<h4 id="org497947c">mpec</h4>
<div class="outline-text-4" id="text-org497947c">
<p>
当 trap 陷入到 M-mode 时，mepc 会被 CPU 自动写入 <b>引发 trap 的指令的虚拟地址</b> 或者是 <b>被中断的指令的虚拟地址</b> 
</p>
</div>
</div>
<div id="outline-container-org08f064f" class="outline-4">
<h4 id="org08f064f">mtval</h4>
<div class="outline-text-4" id="text-org08f064f">
<p>
当 trap 陷入到 M-mode 时，mtval 会被 <b>置零</b> 或者被写入与 <b>异常相关的信息</b> 来辅助处理 trap
</p>
<ul class="org-ul">
<li>当触发 <span class="underline">硬件断点</span> 、 <span class="underline">地址未对齐</span> 、 <span class="underline">access fault</span> 、 <span class="underline">page fault</span> 时，mtval 记录的是 <b>引发这些问题的虚拟地址</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org373f607" class="outline-3">
<h3 id="org373f607">S-mode</h3>
<div class="outline-text-3" id="text-org373f607">
</div>
<div id="outline-container-orgd1485a6" class="outline-4">
<h4 id="orgd1485a6">sstatus</h4>
<div class="outline-text-4" id="text-orgd1485a6">

<div id="org1f7aa9a" class="figure">
<p><img src="pic/1653979-20230712210014505-699545048.png" alt="1653979-20230712210014505-699545048.png" width="100%" /> 
</p>
</div>

<p>
与中断相关的字段是 <span class="underline">SIE</span> 、 <span class="underline">SPIE</span> 、 <span class="underline">SPP</span> ：
</p>
<ul class="org-ul">
<li>SPP 位：指示处理器 <span class="underline">进入 supervisor 模式之前</span> 的 <b>特权级别</b>
<ul class="org-ul">
<li>当发生陷阱时，如果该陷阱来自用户模式，则 SPP 设置为 0；否则设置为 1</li>
<li>当执行 SRET 指令从陷阱处理程序返回时
<ul class="org-ul">
<li>如果 SPP 位为 0，则特权级别设置为用户模式</li>
<li>如果 SPP 位为 1，则特权级别设置为 supervisor 模式，然后将 SPP 设置为 0</li>
</ul></li>
</ul></li>
<li>SIE 位：在 supervisor 模式下 <span class="underline">启用</span> 或 <span class="underline">禁用</span> 所有中断
<ul class="org-ul">
<li>当 SIE 为零时，在 supervisor 模式下不会进行中断处理</li>
<li>当处理器在用户模式下运行时，忽略 SIE 的值，并启用 supervisor 级别的中断</li>
<li>可以使用 sie 寄存器 来禁用单个中断源</li>
</ul></li>
<li>SPIE 位：指示 <span class="underline">陷入 supervisor 模式</span> 之前是否 <b>启用</b> 了 supervisor 级别的中断
<ul class="org-ul">
<li><p>
当执行跳转到 supervisor 模式的陷阱时，将 SPIE 设置为 SIE，并将 SIE 设置为 0
</p>
<div class="org-src-container">
<pre class="src src-c">SPIE = SIE;
SIE = 0;
</pre>
</div></li>
<li><p>
当执行 SRET 指令时，将 SIE 设置为 SPIE，然后将 SPIE 设置为 1
</p>
<div class="org-src-container">
<pre class="src src-c">SIE = SPIE;
SPIE = 1;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6caa02f" class="outline-4">
<h4 id="org6caa02f">其它 s 特权级寄存器</h4>
<div class="outline-text-4" id="text-org6caa02f">
<pre class="example" id="orgeaa4e93">
stvec, sip, sie,sepc, scause, stval 与 m-mode 的相应寄存器区别不大

可自行参阅 RISC v 的 spec
</pre>

<p>
satp 比较特殊，在 M-mode 没有对应的寄存器，因为 M-mode 没有分页，satp 记录的是 <b>根页表物理地址的页帧号</b> 
</p>

<pre class="example" id="org761cd68">
在从 U 切换到 S 时，需要切换页表，也即是切换 satp 的根页表物理地址的页帧号
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org413628d" class="outline-2">
<h2 id="org413628d">特权级转换</h2>
<div class="outline-text-2" id="text-org413628d">
</div>
<div id="outline-container-orgf215fd3" class="outline-3">
<h3 id="orgf215fd3">U 与 S 间的切换</h3>
<div class="outline-text-3" id="text-orgf215fd3">
<p>
在这里只介绍了 U 和 S 之间的切换
</p>

<pre class="example" id="org07f5623">
其实 S 和 M 之间的切换过程也是一样的，只不过使用到的寄存器不一样了而已

比如说保存 pc 的寄存，S 保存 U 的 pc 值使用的是 sepc，M 保存 S 的 pc 使用的是 mepc

此外，U 切换到 S 时一般需要切换页表，而从 S 切换到 M 时不需要切换页表

因为 M 没有实现分页，也没有 matp 寄存器（页表根地址存储在 satp 寄存器中，所以这里胡诌了个 matp）
</pre>
</div>
<div id="outline-container-org7ff7612" class="outline-4">
<h4 id="org7ff7612">U 切换到 S</h4>
<div class="outline-text-4" id="text-org7ff7612">
<p>
当执行一个 trap 时，除了 timer interrupt，所有的过程都是相同的，硬件会自动完成下述过程：
</p>
<ul class="org-ul">
<li>如果该 trap 是一个 <span class="underline">设备中断</span> 并且 <span class="underline">sstatus</span> 的 <span class="underline">SIE bit</span> 为 0，那么不再执行下述过程</li>
<li>开始执行下面过程：
<ol class="org-ol">
<li><p>
通过 置零 SIE 禁用中断
</p>
<div class="org-src-container">
<pre class="src src-c">SIE = 0
</pre>
</div></li>
<li><p>
将 pc 拷贝到 sepc
</p>
<div class="org-src-container">
<pre class="src src-nil">sepc = pc 
</pre>
</div></li>
<li><p>
保存当前的特权级到 sstatus 的 SPP 字段
</p>
<div class="org-src-container">
<pre class="src src-c">sstaus.SPP = U
</pre>
</div></li>
<li><p>
将 scause 设置成 trap 的原因
</p>
<div class="org-src-container">
<pre class="src src-c">scause = trap.reason 
</pre>
</div></li>
<li>设置当前特权级为 supervisor</li>
<li><p>
拷贝 stvec（中断服务程序的首地址）到 pc
</p>
<div class="org-src-container">
<pre class="src src-c">pc = stvec 
</pre>
</div></li>
<li>开始执行中断服务程序</li>
</ol></li>
</ul>

<p>
CPU 不会自动切换到内核的页表，也不会切换到内核栈，也不会保存除了 pc 之外的寄存器的值，内核需要自行完成
</p>
<pre class="example" id="orgfd9a02a">
对于Linux而言，内核空间与用户态空间是使用的同一套页表，不需要切换页表

内核空间一般位于进程的高虚拟地址空间
</pre>

<p>
如果启用了分页，当陷入到 S 模式时，CPU 没有切换页表（换出进程的页表，换入内核页表），内核需要自行切换页表。其实切换页表的过程也很简单，只需要将内核的页表地址写入 satp 寄存器即可
</p>

<p>
在执行中断服务例程时还需要首先判断 sstatus 的 SPP 字段是不是 0
</p>
<ul class="org-ul">
<li>如果是 0 表示之前是 U 模式，否则表示 S 模式</li>
<li><p>
如果 SPP 是 1 那就出现了严重错误
</p>

<pre class="example" id="orgb74be62">
因为既然是从 U 切换到 S 的过程，怎么可以 SPP 是 S 模式呢？

当然，如果是内核执行时发生了中断 SPP 是 1 那自然是对的

内核执行时发生中断时如果检查 SPP 是 0 那也是严重的错误
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org3c753f1" class="outline-4">
<h4 id="org3c753f1">S 切换到 U</h4>
<div class="outline-text-4" id="text-org3c753f1">
<p>
在从 S 切换到 U 时，要 <b>手动</b>
</p>
<ol class="org-ol">
<li>清除 sstatus 的 SPP 字段，将其置为零</li>
<li>将 sstatus 的 SPIE 字段置为 1，启用用户中断</li>
<li><p>
设置 sepc 为用户进程的 PC 值
</p>
<pre class="example" id="orgedcfbf1">
可能疑惑在 U 转换到 S 时不是已经将用户进程的保存在了 sepc 了吗?

因为在 S-mode 也会发生中断呀，那么 sepc 就会被用来保存发生中断位置时的 PC 了
</pre></li>
<li>如果启用了页表，就需要还原用户进程的页表，即将用户进程的页表地址写入 satp</li>
<li>之后恢复上下文</li>
<li>最后 sret 指令，硬件会自动完成以下操作：
<ul class="org-ul">
<li>从 sepc 寄存器中取出要恢复的下一条指令地址，将其复制到程序计数器 pc 中，以恢复现场</li>
<li>从 sstatus 寄存器中取出用户模式的相关状态，包括中断使能位、虚拟存储模式等，以恢复用户模式的状态</li>
<li>将当前特权模式设置为用户模式，即取消特权模式，回到用户模式</li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org949e81b" class="outline-3">
<h3 id="org949e81b">S 与 M 间的切换</h3>
<div class="outline-text-3" id="text-org949e81b">
</div>
<div id="outline-container-orgb4e16c8" class="outline-4">
<h4 id="orgb4e16c8">S 切换到 M</h4>
<div class="outline-text-4" id="text-orgb4e16c8">
<pre class="example" id="org4d82d3b">
切换到 M 与从 U 切换到 M 类似，都是从低特权级到高特权级的切换
</pre>
<p>
在 S 运行的代码，也可以通过 <b>ecall</b> 指令陷入到 M 中：
</p>
<ol class="org-ol">
<li><p>
S-mode 的代码执行一个指令触发了异常或陷阱
</p>
<pre class="example" id="org207f02f">
例如调用（ECALL）指令
</pre></li>
<li>处理器将当前的 S-mode 上下文的状态保存下来，包括 <b>程序计数器</b> <span class="underline">PC</span> 、 <b>S-mode 特权级别</b> 和其他相关寄存器，保存在 <span class="underline">当前特权级别堆栈中的 S-MODE 陷阱帧</span> （trap frame，其实就是一个页面）中</li>
<li>处理器通过将 mstatus 寄存器中的 MPP 字段设置为 0b11（表示先前的模式是 S 模式）, 将特权级别设置为 M-mode</li>
<li>处理器将程序计数器设置为在 M-mode 中的陷阱处理程序例程的地址</li>
<li>处理器还在 mstatus 寄存器中设置 M-mode 中断使能位 (MIE) 为 0，以在陷阱处理程序中禁用中断</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org39a9b30" class="outline-2">
<h2 id="org39a9b30">系统调用的实现</h2>
<div class="outline-text-2" id="text-org39a9b30">
<p>
系统调用是利用异常机制实现的。在 mcause 中看到有 Environment call from U-mode 和 Environment call from S-mode 两个异常类型
</p>

<pre class="example" id="org370255f">
那么如何触发这两个异常呢？

分别在 U-mode 和 S-mode 执行 ecall 指令就能触发这两个异常了
</pre>

<p>
执行 ecall 后，CPU 进行如下操作：
</p>
<ol class="org-ol">
<li>记录异常原因
<ul class="org-ul">
<li>把异常类型写入 mcause/scause 寄存器（在用户态发起时通常是 scause = 8，表示 "Environment call from U-mode"）</li>
</ul></li>
<li>保存异常现场
<ul class="org-ul">
<li>把触发 ecall 的 PC 保存到 sepc</li>
<li>修改 sstatus，进入 S-mode</li>
</ul></li>
<li>跳转到异常处理入口
<ul class="org-ul">
<li>stvec 寄存器保存了陷入入口地址，CPU跳转到该地址执行内核 trap handler</li>
</ul></li>
</ol>

<p>
内核 trap handler（位于 S-mode）做的事情是：
</p>
<ol class="org-ol">
<li>检查 scause，确认是 ecall from U-mode</li>
<li>读取用户寄存器里的系统调用号和参数（从 trap frame 里取出 a7, a0–a5）</li>
<li>根据系统调用号，跳转到相应的内核服务例程</li>
<li>把返回值写回 a0</li>
<li>调用 sret 指令恢复到 sepc，返回用户态继续执行</li>
</ol>
</div>
</div>
<div id="outline-container-org8213206" class="outline-2">
<h2 id="org8213206">地址空间布局</h2>
<div class="outline-text-2" id="text-org8213206">
<p>
启用分页模式下，内核代码的访存地址也会被视为一个虚拟地址并需要经过 <span class="underline">MMU</span> 的地址转换，因此也需要为内核对应构造一个地址空间，除了仍然需要允许内核的各数据段能够被正常访问之后，还需要包含所有应用的内核栈以及一个 <b>跳板</b> <span class="underline">Trampoline</span>
</p>

<pre class="example" id="orgb1cd196">
值得注意的是，下面是是 rCore 的内核地址空间分布，不同的 OS 设计不同
</pre>

<p>
高 256GB 内核地址空间：
</p>


<div id="orgc9a441a" class="figure">
<p><img src="pic/1653979-20230712210014907-59405883.png" alt="1653979-20230712210014907-59405883.png" width="100%" />
</p>
</div>

<p>
低 256GB 内核地址空间
</p>


<div id="orgdf53b8a" class="figure">
<p><img src="pic/1653979-20230712210015309-973629164.png" alt="1653979-20230712210015309-973629164.png" width="100%" />
</p>
</div>

<p>
应用程序高 256GB 地址空间
</p>

<div id="orgb53d3e8" class="figure">
<p><img src="pic/1653979-20230712210015683-979795453.png" alt="1653979-20230712210015683-979795453.png" width="100%" />
</p>
</div>

<p>
应用程序低 256GB 地址空间
</p>

<div id="org51b54a9" class="figure">
<p><img src="pic/1653979-20230712210016165-419532978.png" alt="1653979-20230712210016165-419532978.png" width="100%" /> 
</p>
</div>
</div>
<div id="outline-container-orgd1d35c9" class="outline-3">
<h3 id="orgd1d35c9">跳板页</h3>
<div class="outline-text-3" id="text-orgd1d35c9">
<p>
使能了分页机制之后，必须在 trap 过程中同时完成地址空间的切换。具体来说：
</p>
<ul class="org-ul">
<li>当 <span class="underline">_alltraps 保存 Trap 上下文的时候，必须通过修改 _satp</span> 从应用地址空间切换到内核地址空间，因为 trap handler 只有在内核地址空间中才能访问</li>
<li>同理，在 __restore 恢复 Trap 上下文的时候，也必须从内核地址空间切换回应用地址空间，因为应用的代码和数据只能在它自己的地址空间中才能访问，应用是看不到内核地址空间的</li>
</ul>


<pre class="example" id="orgacd0801">
为何将应用的 Trap 上下文放到应用地址空间的次高页面而不是内核地址空间中的内核栈中呢？
</pre>

<p>
原因在于，在保存 Trap 上下文到内核栈中之前，必须完成两项工作：
</p>
<ol class="org-ol">
<li>先切换到内核地址空间，这就需要将 <span class="underline">内核地址空间的页表地址</span> 写入 satp 寄存器</li>
<li>还需要保存 <span class="underline">应用的内核栈栈顶的位置</span> ，这样才能以它为基址保存 Trap 上下文</li>
</ol>

<p>
这两步需要用寄存器作为临时周转，然而无法在不破坏任何一个通用寄存器的情况下做到这一点
</p>

<pre class="example" id="org130d251">
因为事实上需要用到内核的两条信息：内核地址空间的页表地址，以及应用的内核栈栈顶的位置

RISC-V 却只提供一个 sscratch 寄存器可用来进行周转

所以，不得不将 Trap 上下文保存在应用地址空间的一个虚拟页面中，而不是切换到内核地址空间去保存
</pre>
</div>
</div>
<div id="outline-container-org00e4749" class="outline-3">
<h3 id="org00e4749">Page Fault</h3>
<div class="outline-text-3" id="text-org00e4749">
<p>
当 CPU 无法将虚拟地址转换为物理地址时，CPU 会生成页面错误异常。RISC-V 有三种不同类型的页面错误：
</p>
<ol class="org-ol">
<li>加载页面错误(当加载指令无法转换其虚拟地址时)</li>
<li>存储页面错误(当存储指令无法转换其虚拟地址时)</li>
<li>指令页面错误(当指令的地址不转换时)</li>
</ol>

<pre class="example" id="orgbccdb82">
Cow(copy on write) Fork 中的基本方案是：

让父子进程在最开始时共享所有物理页面，但将它们映射为只读

因此，当子进程或父进程执行存储指令时，RISC-V CPU 会引发页面错误异常

作为对此异常的响应，内核会复制包含错误地址的页面

它将一个副本映射到子进程的地址空间中，并将另一个副本映射到父进程的地址空间中

在更新页表之后，内核在导致错误的指令处恢复出错进程

因为内核已经更新了相关的 PTE 以允许写入，所以出错指令现在将正常执行
</pre>

<p>
scause 寄存器中的值指示页面错误的类型，而 stval 寄存器中包含无法转换的地址
</p>
</div>
</div>
</div>
<div id="outline-container-orgf43e042" class="outline-2">
<h2 id="orgf43e042">如何设置 stvec 的</h2>
<div class="outline-text-2" id="text-orgf43e042">
<pre class="example" id="org004e23b">
stvec 寄存器保存的是中断服务程序的首地址

在 U 模式下，stvec 必须指向的是 uservec，在 S 模式下，stvec 必须指向的是 kernelvec

这样做的原因是需要在 uservec 切换页表，那么 xv6 是如何设置 stvec 的呢？
</pre>

<p>
uservec 例程中除了执行保存上下文、切换页表等操作之外，还会在 usertrap 中将 stvec 指向 kernelvec
</p>

<pre class="example" id="orge19de71">

</pre>

<p>
当需要返回 usertrap 时，usertrap 会调用 usertrapret，usertrapret 会重新设置 stvec 的值使其指向 uservec，之后跳转到 userret，恢复上下文和切换页表。
</p>
</div>
<div id="outline-container-org18353c7" class="outline-3">
<h3 id="org18353c7">第一次的 stvec 是如何设置的</h3>
<div class="outline-text-3" id="text-org18353c7">
<p>
在 main 中：
</p>
<ol class="org-ol">
<li>cpu0 调用了 userinit() 创建了第一个用户进程，并在 scheduler 中会切换到该进程
<ul class="org-ul">
<li>该进程的上下文中的 ra(返回地址)被设置成了 forkret()</li>
</ul></li>
<li>当 scheduler 执行 swtch 函数时，会将进程上下文中的 ra 写入到 ra 寄存器中</li>
<li>这样当要从 swtch() 中返回时，就会返回到了 forkret()
<ul class="org-ul">
<li>在 forkret() 中会直接调用 usertrapret 以实现 stvec 的设置和页表的切换</li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgac17f69" class="outline-2">
<h2 id="orgac17f69">与中断有关的硬件单元</h2>
<div class="outline-text-2" id="text-orgac17f69">
<p>
在 RISC v 中，与中断有关的硬件单元主要有 <span class="underline">ACLINT</span> 、 <span class="underline">CLINT</span> 、 <span class="underline">PLIC</span> 、 <span class="underline">CLIC</span> 
</p>
<ul class="org-ul">
<li>CLINT 的全称是 Core Local Interrupt</li>
<li>ACLINT 的全称是 Advanced Core Local Interrupt,</li>
<li>CLIC 的全称是 Core-Local Interrupt Controller</li>
<li>PLIC 的全称 Platform-Level Interrupt Controller</li>
</ul>

<pre class="example" id="orgee91406">
尽管 CLIC 与 PLIC 名称相似，但是 CLIC 其实是为取代 CLINT 而设计的，而ACLINT 是为了取代 SiFive CLINT 而设计的

本质上讲，ACLINT 相比于 CLINT 的优势就在于进行了模块化设计，将定时器和 IPI 功能分开了，同时能够支持 NUMA 系统

但是 ACLINT 和 CLINT 都还是 RISC-V basic local Interrupts 的范畴
</pre>
<p>
PLIC 和 CLIC 的区别在于，前者负责的是整体的外部中断，CLIC 负责的是每个 HART 的本地中断
</p>
</div>
<div id="outline-container-org4f50753" class="outline-3">
<h3 id="org4f50753">PLIC</h3>
<div class="outline-text-3" id="text-org4f50753">
<p>
它把 <span class="underline">全局外设中断</span> 按优先级分发到各个 hart 的特权上下文（M/S 模式）的控制器，提供 <span class="underline">优先级</span> 、 <span class="underline">屏蔽</span> 、 <span class="underline">仲裁</span> 和 <span class="underline">索取/完成</span> （claim/complete）流程
</p>

<p>
PLC 的组成：
</p>
<ul class="org-ul">
<li>中断源（source）：来自 外设 或 MSI 的全局中断，编号从 1 开始
<ul class="org-ul">
<li>ID=0 表示“无中断”
同优先级下用 更小的 ID 抢占
单个源在 PLIC 内 同时最多挂起 1 个请求</li>
</ul></li>
<li><p>
目标/上下文（target/context）：通常是“某个 hart 的某个特权级”
</p>
<pre class="example" id="org200a66b">
是否给 S 模式提供目标由实现与委派决定
</pre></li>
<li>网关（gateway）：把外设的电平/边沿信号或 MSI 转成 PLIC 能理解的请求，并控制同一中断源的流量</li>
</ul>
</div>
<div id="outline-container-orgc16c997" class="outline-4">
<h4 id="orgc16c997">寄存器与内存映射</h4>
<div class="outline-text-4" id="text-orgc16c997">
<p>
PLIC 规定了统一的 操作参数块，但 <span class="underline">基地址</span> 由平台决定：
</p>
<ul class="org-ul">
<li>Priority：每个中断源一个 32-bit 优先级寄存器；0=永不触发；最大优先级级数由实现给出</li>
<li>Pending（IP）：挂起位数组，表示哪些源在等服务</li>
<li>Enable（IE）：对每个 上下文 的允许位数组；一个源可被多个上下文使能</li>
<li>Threshold：每个上下文一个阈值寄存器；仅当“最高优先级挂起源的优先级 &gt; 阈值”才会给该上下文发通知</li>
<li>Claim/Complete：同一个地址既可读（claim）也可写（complete），按上下文 4 KB 对齐+4 偏移布置。</li>
</ul>

<p>
规范给出从 priority → pending → enable → threshold/claim 的 标准偏移布局
</p>
</div>
</div>
<div id="outline-container-org071b894" class="outline-4">
<h4 id="org071b894">工作流程与时序要点</h4>
<div class="outline-text-4" id="text-org071b894">
<ol class="org-ol">
<li>通知：当某上下文存在“已使能且优先级高于阈值”的挂起源时，PLIC 在该上下文的 xEIP（meip/seip） 上置位，通知 hart
<ul class="org-ul">
<li>PLIC 天然做“多播”：所有被使能且满足条件的上下文都会收到通知，谁先 claim 到就算谁</li>
</ul></li>
<li>索取（claim）：读取 claim 寄存器得到“该上下文可见的最高优先级挂起源 ID”（无则返回 0），并原子地清除此源的挂起位。之后更低优先级的挂起源才会“浮现”
<ul class="org-ul">
<li>claim 不受阈值影响，允许用于“轮询”</li>
</ul></li>
<li>完成（complete）：中断服务完毕后，把 刚得到的 ID 写回同一寄存器，PLIC 会把“完成消息”转交对应 网关，随后该源才允许进入下一次请求
<ul class="org-ul">
<li>写一个未使能/无效的 ID 会被静默忽略</li>
</ul></li>
</ol>

<p>
电平 vs. 边沿（在网关侧）
</p>
<ul class="org-ul">
<li>电平触发：
<ul class="org-ul">
<li>第一次置位会形成一次请求</li>
<li>在收到 完成 之前即使电平一直保持也不会再转发第二个请求</li>
<li>若完成时电平仍为高，立即转发新的请求（等价“再挂起一次”）</li>
</ul></li>
<li>边沿触发/MSI：
<ul class="org-ul">
<li>第一次边沿形成请求</li>
<li>在“请求→完成”间，网关可选择忽略掉后续边沿或做计数</li>
<li>只有完成后才把下一次请求送入 PLIC</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org83ac224" class="outline-2">
<h2 id="org83ac224">时钟中断</h2>
<div class="outline-text-2" id="text-org83ac224">
<p>
<b>定时器中断</b> 是由一个独立的计时器电路发出的信号，表示预定的时间间隔已经结束。计时器子系统将中断当前正在执行的代码
</p>
<ul class="org-ul">
<li>定时器中断可以由操作系统处理，用于实现时间片多线程</li>
<li><p>
但是对于 MTIME 和 MTIMECMP 的读写只能由 M-mode 的代码实现
</p>
<pre class="example" id="org1c90f29">
因此内核需要调用 SBI 的服务
</pre></li>
</ul>
</div>
<div id="outline-container-org9e40eba" class="outline-3">
<h3 id="org9e40eba">时钟中断相关的寄存器</h3>
<div class="outline-text-3" id="text-org9e40eba">
<p>
mtime 需要以固定的频率递增，并在发生溢出时回绕
</p>
<ul class="org-ul">
<li>当 mtime 大于或等于 mtimecmp 时，由核内中断控制器 (CLINT, Core-Local Interrupt Controller) 产生 timer 中断
<ul class="org-ul">
<li>中断的使能由 mie 寄存器中的 MTIE 和 STIE 位控制，mip 中的 MPIE 和 SPIE 则指示了 timer 中断是否处于 pending</li>
<li>读取 mtimecmp 结果为低 32 位， mtimecmp 的高 32 位需要 mtimecmph 得到</li>
</ul></li>
</ul>

<p>
由于 mtimecmp 只能在 M 模式下访问，对于 S/HS 模式下的内核和 VU/VS 模式下的虚拟机需要通过 SBI 才能访问，会造成较大的中断延迟和性能开销
</p>
<pre class="example" id="org5edf7c2">
为了解决这一问题，RISC-V 新增了 Sstc 拓展支持
</pre>
<p>
Sstc 扩展为 HS 模式和 VS 模式分别新增了 <span class="underline">stimecmp</span> 和 <span class="underline">vstimecmp</span> 寄存器，当 time&gt;=stimecmp 或者 time+htimedelta&gt;=vstimecmp 会产生 timer 中断，不再需要通过 SBI 陷入到其它模式
</p>
</div>
</div>
<div id="outline-container-orgb12c26f" class="outline-3">
<h3 id="orgb12c26f">时钟中断的基本处理过程</h3>
<div class="outline-text-3" id="text-orgb12c26f">
<p>
下图所示是时钟中断的基本过程(xv6 的处理过程)：
</p>

<div id="org90f33ce" class="figure">
<p><img src="pic/1653979-20230712210016664-572388837.png" alt="1653979-20230712210016664-572388837.png" width="100%" />
</p>
</div>

<pre class="example" id="org02c928a">
回顾一下有关 timer 的寄存器
</pre>

<p>
首先要明确的是，timer 的寄存器在 timer 设备里，不在 CPU 中，是通过 <span class="underline">MMIO</span> 的方式 <b>映射</b> 到内存中的：
</p>
<ul class="org-ul">
<li>mtime 寄存器是一个同步计数器。它从处理器上电开始运行，并以 tick 单位提供当前的实时时间</li>
<li>mtimecmp 寄存器用于存储定时器中断应该发生的时间间隔，mtimecmp 的值与 mtime 寄存器进行比较
<ul class="org-ul">
<li>当 mtime 值变得大于 mtimecmp 时，就会产生一个定时器中断</li>
<li>mtime 和 mtimecmp 寄存器都是 64 位内存映射寄存器，因此可以直接按照内存读写的方式修改这两个寄存器的值</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8645236" class="outline-3">
<h3 id="org8645236">xv6 实现</h3>
<div class="outline-text-3" id="text-org8645236">
<p>
xv6 对于时钟中断的处理方式是这样的：
</p>
<ul class="org-ul">
<li>在 M-mode 设置好时钟中断的处理函数</li>
<li>当发生时钟中断：
<ol class="org-ol">
<li>由 M-mode 的代码读写 mtime 和 mtimecmp</li>
<li>激活 sip：SSIP 以软件中断的形式通知内核</li>
<li>内核在收到软件中断之后会递增 ticks 变量，并调用 wakeup 函数唤醒沉睡的进程。内核本身也会收到时钟中断：
<ul class="org-ul">
<li>此时内核会判断当前运行的是不是进程号为 0 的进程，如果不是就会调用 yield() 函数使当前进程放弃 CPU 并调度下一个进程</li>
<li>如果使进程号为 0 的进程，那就不做处理</li>
</ul></li>
</ol></li>
</ul>
</div>
<div id="outline-container-org0e7596c" class="outline-4">
<h4 id="org0e7596c">timer_init</h4>
<div class="outline-text-4" id="text-org0e7596c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">core local interruptor (CLINT), which contains the timer.
</span><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">CLINT</span> 0x2000000L
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">CLINT_MTIMECMP</span>(<span style="color: #eedd82;">hartid</span>) (CLINT + 0x4000 + 8*(hartid))
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">CLINT_MTIME</span> (CLINT + 0xBFF8) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">cycles since boot.
</span>
<span style="color: #98fb98;">void</span>
<span style="color: #87cefa;">timerinit</span>()
{
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">each CPU has a separate source of timer interrupts.
</span>                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span> = r_mhartid();

                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">ask the CLINT for a timer interrupt.
</span>                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">interval</span> = 1000000; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">cycles; about 1/10th second in qemu.
</span>
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25105;&#24050;&#32463;&#25552;&#36807;&#65292;mtimecmp &#26159;&#26144;&#23556;&#21040;&#20102;&#29289;&#29702;&#22320;&#22336;&#20013;&#30340;&#65292;&#22240;&#27492;&#21487;&#20197;&#30452;&#25509;&#25353;&#29031;&#20869;&#23384;&#35835;&#20889;&#30340;&#26041;&#24335;
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20462;&#25913;&#23492;&#23384;&#22120;&#30340;&#20540;
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">MTIME &#23492;&#23384;&#22120;&#26144;&#23556;&#21040;&#20102; 0x2000_BFF8
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#19968;&#22359;CPU&#26377;&#19968;&#20010;MTIME&#65292;&#25152;&#26377;&#30340;hart&#37117;&#20849;&#29992;&#36825;&#19968;&#20010; MTIME
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">MTIMECMP &#30340;&#20869;&#23384;&#22522;&#22320;&#22336;&#26159; 0x2000000L
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27599;&#20010;&#23492;&#23384;&#22120;&#21344; 8&#20010;&#23383;&#33410;&#65292;&#27599;&#20010;hart&#37117;&#26377;&#19968;&#20010;MTIMECMP&#23492;&#23384;&#22120;
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22240;&#27492;&#21602;&#65292;&#31532;id&#20010;&#65288;&#20174;0&#24320;&#22987;&#35745;&#25968;&#65289;&#30340;hart&#23545;&#24212;&#30340; MTIMECMP &#30340;&#23492;&#23384;&#22120;&#30340;&#29289;&#29702;&#22320;&#22336;&#23601;&#26159;
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">0x2000000L + 8 * id
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22240;&#27492;&#21602;&#23601;&#23481;&#26131;&#29702;&#35299;&#19979;&#38754;&#30340;&#25805;&#20316;&#20102;&#65292;&#23454;&#38469;&#19978;&#23601;&#26159;&#26681;&#25454; MTIME &#21021;&#22987;&#21270; MTIMECMP
</span>                *(<span style="color: #98fb98;">uint64</span>*)CLINT_MTIMECMP(id) = *(<span style="color: #98fb98;">uint64</span>*)CLINT_MTIME + interval;

                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">prepare information in scratch[] for timervec.
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">scratch[0..2] : space for timervec to save registers.
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">scratch[3] : address of CLINT MTIMECMP register.
</span>                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">scratch[4] : desired interval (in cycles) between timer interrupts.
</span>                <span style="color: #98fb98;">uint64</span> *<span style="color: #eedd82;">scratch</span> = &amp;timer_scratch[id][0];
                scratch[3] = CLINT_MTIMECMP(id);<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#35760;&#24405;&#24403;&#21069;hart&#23545;&#24212;&#30340; MTIMECMP &#23492;&#23384;&#22120;&#26144;&#23556;&#21040;&#30340;&#29289;&#29702;&#22320;&#22336;
</span>                scratch[4] = interval;
                w_mscratch((<span style="color: #98fb98;">uint64</span>)scratch);<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23558;&#25968;&#32452;&#25351;&#38024;&#20889;&#20837;mscratch
</span>
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">set the machine-mode trap handler.
</span>                w_mtvec((<span style="color: #98fb98;">uint64</span>)timervec);

                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">enable machine-mode interrupts.
</span>                w_mstatus(r_mstatus() | MSTATUS_MIE);

                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">enable machine-mode timer interrupts.
</span>                w_mie(r_mie() | MIE_MTIE);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3977192" class="outline-4">
<h4 id="org3977192">时钟中断处理函数</h4>
<div class="outline-text-4" id="text-org3977192">
<p>
将 mscratch 与 a0 寄存器交换了值，此时 a0 保存的值就是个数组指针(这一点在前面的 timer_init 中已经分析了)
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87cefa;">timervec</span>:
        # start.c has set up the memory that mscratch points to:
        # scratch[0,8,16] : register save area.
        # scratch[24] : address of CLINT's MTIMECMP register.
        # scratch[32] : desired interval between interrupts.

        <span style="color: #00ffff;">csrrw</span> a0, mscratch, a0

        # &#20445;&#23384;&#23492;&#23384;&#22120;&#30340;&#19978;&#19979;&#25991;
        <span style="color: #00ffff;">sd</span> a1, 0(a0)
        <span style="color: #00ffff;">sd</span> a2, 8(a0)
        <span style="color: #00ffff;">sd</span> a3, 16(a0)

        # schedule the next timer interrupt
        # by adding interval to mtimecmp.
        # &#23454;&#38469;&#19978;&#25191;&#34892;&#30340;&#23601;&#26159; MTIMECMP = MTIME + INTERVAL
        <span style="color: #00ffff;">ld</span> a1, 24(a0) # CLINT_MTIMECMP(hart)
        <span style="color: #00ffff;">ld</span> a2, 32(a0) # interval
        <span style="color: #00ffff;">ld</span> a3, 0(a1)
        <span style="color: #00ffff;">add</span> a3, a3, a2
        <span style="color: #00ffff;">sd</span> a3, 0(a1)

        # arrange for a supervisor software interrupt
        # after this handler returns.
        # &#36890;&#36807;supervisor software &#20013;&#26029;&#30340;&#26041;&#24335;&#36890;&#30693; S-mode &#30340;&#20869;&#26680;&#22788;&#29702;&#26102;&#38047;&#20013;&#26029;
        # &#23454;&#38469;&#19978;&#21602;&#65292;&#26102;&#38047;&#20013;&#26029;&#24050;&#32463;&#22312;M-mode&#34987;&#22788;&#29702;&#25481;&#20102;
        # &#20043;&#25152;&#20197;&#36824;&#35201;&#36890;&#30693;S-mode&#30340;&#20869;&#26680;&#26159;&#22240;&#20026;&#20869;&#26680;&#30340;&#36827;&#31243;&#35843;&#24230;&#22120;&#20381;&#36182;&#20110;&#23545;&#26102;&#38388;&#30340;&#25484;&#25569;
        # S-mode&#21482;&#26159;&#26681;&#25454;&#26102;&#38047;&#21464;&#21270;&#21435;&#20570;&#36827;&#31243;&#35843;&#24230;&#22120;&#30456;&#20851;&#30340;&#22788;&#29702;
        <span style="color: #00ffff;">li</span> a1, 2
        <span style="color: #00ffff;">csrw</span> sip, a1

        # &#24674;&#22797;&#19978;&#19979;&#25991;
        <span style="color: #00ffff;">ld</span> a3, 16(a0)
        <span style="color: #00ffff;">ld</span> a2, 8(a0)
        <span style="color: #00ffff;">ld</span> a1, 0(a0)
        <span style="color: #00ffff;">csrrw</span> a0, mscratch, a0

        <span style="color: #00ffff;">mret</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf99cd2e" class="outline-2">
<h2 id="orgf99cd2e">软件中断</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
