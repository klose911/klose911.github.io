<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Map-Reduce</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="proxy.html"> UP </a>
 |
 <a accesskey="H" href="go-patterns.html"> HOME </a>
</div><div id="content">
<h1 class="title">Map-Reduce</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc48ca5a">基本示例</a>
<ul>
<li><a href="#org2d8a67a">Map</a></li>
<li><a href="#org2eb13f9">Reduce &amp; Filter</a></li>
</ul>
</li>
<li><a href="#org9f73deb">业务示例</a>
<ul>
<li><a href="#org0b2749e">员工信息</a></li>
<li><a href="#org9690fb4">相关的Reduce/Fitler函数</a></li>
<li><a href="#org384928a">各种自定义的统计示例</a></li>
</ul>
</li>
<li><a href="#org7b7ecd4">泛型Map-Reduce</a>
<ul>
<li><a href="#org31034f8">简单版 Generic Map</a></li>
<li><a href="#org620d121">健壮版的Generic Map</a></li>
<li><a href="#orgea31047">健壮版的 Generic Reduce</a></li>
<li><a href="#orgd35499c">健壮版的 Generic Filter</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
在本篇文章中，学习一下函数式编程的中非常重要的Map、Reduce、Filter的三种操作，这三种操作可以非常方便灵活地进行一些数据处理

程序中大多数情况下都是在到倒腾数据，尤其对于一些需要统计的业务场景，Map/Reduce/Filter是非常通用的玩法
</pre>

<div id="outline-container-orgc48ca5a" class="outline-2">
<h2 id="orgc48ca5a">基本示例</h2>
<div class="outline-text-2" id="text-orgc48ca5a">
</div>
<div id="outline-container-org2d8a67a" class="outline-3">
<h3 id="org2d8a67a">Map</h3>
<div class="outline-text-3" id="text-org2d8a67a">
<p>
下面的程序代码中，写了两个Map函数，这两个函数需要两个参数：
</p>
<ul class="org-ul">
<li>一个是字符串数组 <span class="underline">[]string</span> ，说明需要处理的数据一个字符串</li>
<li>另一个是一个函数 <span class="underline">func(s string) string</span> 或 <span class="underline">func(s string) int</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">MapStrToStr</span>(<span style="color: #4eee94;">arr</span> []<span style="color: #98f5ff;">string</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">string</span>) []<span style="color: #98f5ff;">string</span> {
        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">newArray</span> = []<span style="color: #98f5ff;">string</span>{}
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">_</span>, <span style="color: #4eee94;">it</span> := <span style="color: #00bfff; font-weight: bold;">range</span> arr {
                newArray = <span style="color: #f08080;">append</span>(newArray, <span style="color: #daa520; font-weight: bold;">fn</span>(it))
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> newArray
}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">MapStrToInt</span>(<span style="color: #4eee94;">arr</span> []<span style="color: #98f5ff;">string</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">int</span>) []<span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">newArray</span> = []<span style="color: #98f5ff;">int</span>{}
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">_</span>, <span style="color: #4eee94;">it</span> := <span style="color: #00bfff; font-weight: bold;">range</span> arr {
                newArray = <span style="color: #f08080;">append</span>(newArray, <span style="color: #daa520; font-weight: bold;">fn</span>(it))
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> newArray
}
</pre>
</div>

<pre class="example">
整个Map函数运行逻辑都很相似：
1. 函数体都是在遍历第一个参数的数组
2. 调用第二个参数的函数
3. 把其值组合成另一个数组返回
</pre>
<p>
于是可以这样使用这两个函数：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">list</span> = []<span style="color: #98f5ff;">string</span>{<span style="color: #deb887;">"Hao"</span>, <span style="color: #deb887;">"Chen"</span>, <span style="color: #deb887;">"MegaEase"</span>}
<span style="color: #4eee94;">x</span> := <span style="color: #daa520; font-weight: bold;">MapStrToStr</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">string</span> {
    <span style="color: #00bfff; font-weight: bold;">return</span> strings.<span style="color: #daa520; font-weight: bold;">ToUpper</span>(s)
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"%v\n"</span>, x) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">["HAO", "CHEN", "MEGAEASE"]</span>

<span style="color: #4eee94;">y</span> := <span style="color: #daa520; font-weight: bold;">MapStrToInt</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">int</span> {
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #f08080;">len</span>(s)
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"%v\n"</span>, y) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">[3, 4, 8]</span>
</pre>
</div>


<pre class="example">
可以看到，给第一个 MapStrToStr() 传了函数做的是 转大写，于是出来的数组就成了全大写的

给MapStrToInt() 传的是算其长度，所以出来的数组是每个字符串的长度。
</pre>
</div>
</div>

<div id="outline-container-org2eb13f9" class="outline-3">
<h3 id="org2eb13f9">Reduce &amp; Filter</h3>
<div class="outline-text-3" id="text-org2eb13f9">
<p>
再来看一下Reduce和Filter的函数是什么样的：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">Reduce</span>(<span style="color: #4eee94;">arr</span> []<span style="color: #98f5ff;">string</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #4eee94;">sum</span> := 0
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">_</span>, <span style="color: #4eee94;">it</span> := <span style="color: #00bfff; font-weight: bold;">range</span> arr {
                sum += <span style="color: #daa520; font-weight: bold;">fn</span>(it)
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> sum
}

<span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">list</span> = []<span style="color: #98f5ff;">string</span>{<span style="color: #deb887;">"Hao"</span>, <span style="color: #deb887;">"Chen"</span>, <span style="color: #deb887;">"MegaEase"</span>}

<span style="color: #4eee94;">x</span> := <span style="color: #daa520; font-weight: bold;">Reduce</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #f08080;">len</span>(s)
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"%v\n"</span>, x) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">15</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">Filter</span>(<span style="color: #4eee94;">arr</span> []<span style="color: #98f5ff;">int</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">n</span> <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">bool</span>) []<span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">newArray</span> = []<span style="color: #98f5ff;">int</span>{}
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">_</span>, <span style="color: #4eee94;">it</span> := <span style="color: #00bfff; font-weight: bold;">range</span> arr {
                <span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #daa520; font-weight: bold;">fn</span>(it) {
                        newArray = <span style="color: #f08080;">append</span>(newArray, it)
                }
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> newArray
}

<span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">intset</span> = []<span style="color: #98f5ff;">int</span>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
<span style="color: #4eee94;">out</span> := <span style="color: #daa520; font-weight: bold;">Filter</span>(intset, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">n</span> <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">bool</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> n%2 == 1
})
fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"%v\n"</span>, out)

out = <span style="color: #daa520; font-weight: bold;">Filter</span>(intset, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">n</span> <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">bool</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> n &gt; 5
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"%v\n"</span>, out)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9f73deb" class="outline-2">
<h2 id="org9f73deb">业务示例</h2>
<div class="outline-text-2" id="text-org9f73deb">
<pre class="example">
通过上面的一些示例，可能有一些明白，Map/Reduce/Filter只是一种控制逻辑，真正的业务逻辑是在传给他们的数据和那个函数来定义的

这是一个很经典的“业务逻辑”和“控制逻辑”分离解耦的编程模式
</pre>

<p>
下面来看一个有业务意义的代码，来让大家强化理解一下什么叫“控制逻辑”与”业务逻辑“分离 
</p>
</div>

<div id="outline-container-org0b2749e" class="outline-3">
<h3 id="org0b2749e">员工信息</h3>
<div class="outline-text-3" id="text-org0b2749e">
<p>
首先，有一个员工对象，以及一些数据：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">type</span> <span style="color: #98f5ff;">Employee</span> <span style="color: #00bfff; font-weight: bold;">struct</span> {
        Name     <span style="color: #98f5ff;">string</span>
        Age      <span style="color: #98f5ff;">int</span>
        Vacation <span style="color: #98f5ff;">int</span>
        Salary   <span style="color: #98f5ff;">int</span>
}
<span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">list</span> = []<span style="color: #98f5ff;">Employee</span>{
        {<span style="color: #deb887;">"Hao"</span>, 44, 0, 8000},
        {<span style="color: #deb887;">"Bob"</span>, 34, 10, 5000},
        {<span style="color: #deb887;">"Alice"</span>, 23, 5, 9000},
        {<span style="color: #deb887;">"Jack"</span>, 26, 0, 4000},
        {<span style="color: #deb887;">"Tom"</span>, 48, 9, 7500},
        {<span style="color: #deb887;">"Marry"</span>, 29, 0, 6000},
        {<span style="color: #deb887;">"Mike"</span>, 32, 8, 4000},
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9690fb4" class="outline-3">
<h3 id="org9690fb4">相关的Reduce/Fitler函数</h3>
<div class="outline-text-3" id="text-org9690fb4">
<p>
然后有如下的几个函数：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">EmployeeCountIf</span>(<span style="color: #4eee94;">list</span> []<span style="color: #98f5ff;">Employee</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">bool</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #4eee94;">count</span> := 0
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">_</span> := <span style="color: #00bfff; font-weight: bold;">range</span> list {
                <span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #daa520; font-weight: bold;">fn</span>(&amp;list[i]) {
                        count += 1
                }
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> count
}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">EmployeeFilterIn</span>(<span style="color: #4eee94;">list</span> []<span style="color: #98f5ff;">Employee</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">bool</span>) []<span style="color: #98f5ff;">Employee</span> {
        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">newList</span> []<span style="color: #98f5ff;">Employee</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">_</span> := <span style="color: #00bfff; font-weight: bold;">range</span> list {
                <span style="color: #00bfff; font-weight: bold;">if</span> <span style="color: #daa520; font-weight: bold;">fn</span>(&amp;list[i]) {
                        newList = <span style="color: #f08080;">append</span>(newList, list[i])
                }
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> newList
}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">EmployeeSumIf</span>(<span style="color: #4eee94;">list</span> []<span style="color: #98f5ff;">Employee</span>, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">sum</span> = 0
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">_</span> := <span style="color: #00bfff; font-weight: bold;">range</span> list {
                sum += <span style="color: #daa520; font-weight: bold;">fn</span>(&amp;list[i])
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> sum
}
</pre>
</div>

<p>
简单说明一下：
</p>
<ul class="org-ul">
<li><span class="underline">EmployeeConutIf</span> 和 <span class="underline">EmployeeSumIf</span> 分别用于统满足某个条件的个数或总数。它们都是Filter + Reduce的语义</li>
<li><span class="underline">EmployeeFilterIn</span> 就是按某种条件过虑。就是Fitler的语义</li>
</ul>
</div>
</div>

<div id="outline-container-org384928a" class="outline-3">
<h3 id="org384928a">各种自定义的统计示例</h3>
<div class="outline-text-3" id="text-org384928a">
<p>
现在就可以有如下的代码：
</p>
<ul class="org-ul">
<li>统计有多少员工大于40岁</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">old</span> := <span style="color: #daa520; font-weight: bold;">EmployeeCountIf</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">bool</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> e.Age &gt; 40
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"old people: %d\n"</span>, old) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">old people: 2</span>
</pre>
</div>
<ul class="org-ul">
<li>统计有多少员工薪水大于6000</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">high_pay</span> := <span style="color: #daa520; font-weight: bold;">EmployeeCountIf</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">bool</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> e.Salary &gt;= 6000
})
fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"High Salary people: %d\n"</span>, high_pay) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">High Salary people: 4</span>
</pre>
</div>
<ul class="org-ul">
<li>列出有没有休假的员工</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">no_vacation</span> := <span style="color: #daa520; font-weight: bold;">EmployeeFilterIn</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">bool</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> e.Vacation == 0
})
fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"People no vacation: %v\n"</span>, no_vacation) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">People no vacation: [{Hao 44 0 8000} {Jack 26 0 4000} {Marry 29 0 6000}]</span>
</pre>
</div>
<ul class="org-ul">
<li>统计所有员工的薪资总和</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">total_pay</span> := <span style="color: #daa520; font-weight: bold;">EmployeeSumIf</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> e.Salary
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"Total Salary: %d\n"</span>, total_pay) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Total Salary: 43500</span>
</pre>
</div>
<ul class="org-ul">
<li>统计30岁以下员工的薪资总和</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">younger_pay</span> := <span style="color: #daa520; font-weight: bold;">EmployeeSumIf</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> *<span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">int</span> {
    <span style="color: #00bfff; font-weight: bold;">if</span> e.Age &lt; 30 {
        <span style="color: #00bfff; font-weight: bold;">return</span> e.Salary
    } 
    <span style="color: #00bfff; font-weight: bold;">return</span> 0
})

fmt.<span style="color: #daa520; font-weight: bold;">Printf</span>(<span style="color: #deb887;">"Younger Salary: %d\n"</span>, younger_pay) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Younger Salary: 19000</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7b7ecd4" class="outline-2">
<h2 id="org7b7ecd4">泛型Map-Reduce</h2>
<div class="outline-text-2" id="text-org7b7ecd4">
<p>
上面的Map-Reduce都因为要处理数据的类型不同而需要写出不同版本的Map-Reduce，虽然他们的代码看上去是很类似的。所以，这里就要带出来泛型编程了
</p>

<pre class="example">
Go开发团队技术负责人Russ Cox在golang-dev上的mail确认了Go泛型(type parameter)将在Go 1.18版本落地，即2022.2月份
</pre>
</div>

<div id="outline-container-org31034f8" class="outline-3">
<h3 id="org31034f8">简单版 Generic Map</h3>
<div class="outline-text-3" id="text-org31034f8">
<p>
目前的Go语言的泛型只能用 <span class="underline">interface{} + reflect</span> 来完成：
</p>
<ul class="org-ul">
<li>interface{}： 可以理解为C中的 <span class="underline">void*</span> ，Java中的 <span class="underline">Object</span></li>
<li>reflect：Go的 <span class="underline">反射机制包</span> ，用于在运行时检查类型</li>
</ul>

<p>
先来看一下一个非常简单 <b>不作任何类型检查</b> 的 <span class="underline">泛型的</span> Map函数： 
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">Map</span>(<span style="color: #4eee94;">data</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}, <span style="color: #4eee94;">fn</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}) []<span style="color: #00bfff; font-weight: bold;">interface</span>{} {
        <span style="color: #4eee94;">vfn</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(fn)
        <span style="color: #4eee94;">vdata</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(data)
        <span style="color: #4eee94;">result</span> := <span style="color: #f08080;">make</span>([]<span style="color: #00bfff; font-weight: bold;">interface</span>{}, vdata.<span style="color: #daa520; font-weight: bold;">Len</span>())

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span> := 0; i &lt; vdata.<span style="color: #daa520; font-weight: bold;">Len</span>(); i++ {
                result[i] = vfn.<span style="color: #daa520; font-weight: bold;">Call</span>([]<span style="color: #98f5ff;">reflect.Value</span>{vdata.<span style="color: #daa520; font-weight: bold;">Index</span>(i)})[0].<span style="color: #daa520; font-weight: bold;">Interface</span>()
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> result
}
</pre>
</div>

<p>
上面的代码中，
</p>
<ul class="org-ul">
<li>通过 <span class="underline">reflect.ValueOf()</span> 来获得 <span class="underline">interface{}</span> 的值：
<ul class="org-ul">
<li>一个是数据 <span class="underline">vdata</span></li>
<li>另一个是函数 <span class="underline">vfn</span></li>
</ul></li>
<li>通过 <span class="underline">vfn.Call()</span> 方法来 <b>调用函数</b></li>
<li>通过 <span class="underline">[]refelct.Value{vdata.Index(i)}</span> 来 <b>获得数据</b></li>
</ul>

<pre class="example">
Go语言中的反射的语法还是有点令人费解的，但是简单看一下手册还是能够读懂的
</pre>

<p>
现在对于不同类型的数据可以使用相同逻辑的Map()代码：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">square</span> := <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">x</span> <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> x * x
}
<span style="color: #4eee94;">nums</span> := []<span style="color: #98f5ff;">int</span>{1, 2, 3, 4}

<span style="color: #4eee94;">squared_arr</span> := <span style="color: #daa520; font-weight: bold;">Map</span>(nums,square)
fmt.<span style="color: #daa520; font-weight: bold;">Println</span>(squared_arr) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">[1 4 9 16]</span>

<span style="color: #4eee94;">upcase</span> := <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">s</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">string</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> strings.<span style="color: #daa520; font-weight: bold;">ToUpper</span>(s)
}

<span style="color: #4eee94;">strs</span> := []<span style="color: #98f5ff;">string</span>{<span style="color: #deb887;">"Hao"</span>, <span style="color: #deb887;">"Chen"</span>, <span style="color: #deb887;">"MegaEase"</span>}
<span style="color: #4eee94;">upstrs</span> := <span style="color: #daa520; font-weight: bold;">Map</span>(strs, upcase);
fmt.<span style="color: #daa520; font-weight: bold;">Println</span>(upstrs) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">[HAO CHEN MEGAEASE]</span>
</pre>
</div>

<p>
但是因为反射是运行时的事，所以，如果类型什么出问题的话，就会有运行时的错误。比如：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">x</span> := <span style="color: #daa520; font-weight: bold;">Map</span>(5, 5)
fmt.<span style="color: #daa520; font-weight: bold;">Println</span>(x)
</pre>
</div>
<p>
上面的代码可以编译通过，但是在运行时就出问题：
</p>

<div class="org-src-container">
<pre class="src src-sh">panic: reflect: call of reflect.Value.Len on int Value

goroutine 1 [running]:
<span style="color: #daa520; font-weight: bold;">reflect.Value.Len</span>(0x4a6240, 0x4dcda0, 0x82, 0x4708fc)
        /usr/local/go/src/reflect/value.go:1163 +0x185
<span style="color: #daa520; font-weight: bold;">main.Map</span>(0x4a6240, 0x4dcda0, 0x4a6240, 0x4dcda8, 0x1, 0x14, 0x0)
        /home/klose/Documents/programming/html/klose911.github.io/src/go/go-patterns/src/map_reduce/simple_generic_map.go:12 +0x16b
<span style="color: #daa520; font-weight: bold;">main.main</span>()
        /home/klose/Documents/programming/html/klose911.github.io/src/go/go-patterns/src/map_reduce/simple_generic_map.go:36 +0x25c
<span style="color: #00bfff; font-weight: bold;">exit</span> status 2
</pre>
</div>
</div>
</div>

<div id="outline-container-org620d121" class="outline-3">
<h3 id="org620d121">健壮版的Generic Map</h3>
<div class="outline-text-3" id="text-org620d121">
<pre class="example">
因此如果要写一个健壮的程序，对于这种用interface{} 的“过度泛型”，就需要自己来做类型检查
</pre>
<p>
下面是一个有类型检查的Map代码：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">Transform</span>(<span style="color: #4eee94;">slice</span>, <span style="color: #4eee94;">function</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}) <span style="color: #00bfff; font-weight: bold;">interface</span>{} {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #daa520; font-weight: bold;">transform</span>(slice, function, <span style="color: #ffd700;">false</span>)
}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">TransformInPlace</span>(<span style="color: #4eee94;">slice</span>, <span style="color: #4eee94;">function</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}) <span style="color: #00bfff; font-weight: bold;">interface</span>{} {
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #daa520; font-weight: bold;">transform</span>(slice, function, <span style="color: #ffd700;">true</span>)
}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">transform</span>(<span style="color: #4eee94;">slice</span>, <span style="color: #4eee94;">function</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}, <span style="color: #4eee94;">inPlace</span> <span style="color: #98f5ff;">bool</span>) <span style="color: #00bfff; font-weight: bold;">interface</span>{} {

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">check the `slice` type is Slice</span>
        <span style="color: #4eee94;">sliceInType</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(slice)
        <span style="color: #00bfff; font-weight: bold;">if</span> sliceInType.<span style="color: #daa520; font-weight: bold;">Kind</span>() != reflect.Slice {
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"transform: not slice"</span>)
        }

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">check the function signature</span>
        <span style="color: #4eee94;">fn</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(function)
        <span style="color: #4eee94;">elemType</span> := sliceInType.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">Elem</span>()
        <span style="color: #00bfff; font-weight: bold;">if</span> !<span style="color: #daa520; font-weight: bold;">verifyFuncSignature</span>(fn, elemType, <span style="color: #ffd700;">nil</span>) {
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"trasform: function must be of type func("</span> + sliceInType.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">Elem</span>().<span style="color: #daa520; font-weight: bold;">String</span>() + <span style="color: #deb887;">") outputElemType"</span>)
        }

        <span style="color: #4eee94;">sliceOutType</span> := sliceInType
        <span style="color: #00bfff; font-weight: bold;">if</span> !inPlace {
                sliceOutType = reflect.<span style="color: #daa520; font-weight: bold;">MakeSlice</span>(reflect.<span style="color: #daa520; font-weight: bold;">SliceOf</span>(fn.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">Out</span>(0)), sliceInType.<span style="color: #daa520; font-weight: bold;">Len</span>(), sliceInType.<span style="color: #daa520; font-weight: bold;">Len</span>())
        }

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span> := 0; i &lt; sliceInType.<span style="color: #daa520; font-weight: bold;">Len</span>(); i++ {
                sliceOutType.<span style="color: #daa520; font-weight: bold;">Index</span>(i).<span style="color: #daa520; font-weight: bold;">Set</span>(fn.<span style="color: #daa520; font-weight: bold;">Call</span>([]<span style="color: #98f5ff;">reflect.Value</span>{sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(i)})[0])
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> sliceOutType.<span style="color: #daa520; font-weight: bold;">Interface</span>()

}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">verifyFuncSignature</span>(<span style="color: #4eee94;">fn</span> <span style="color: #98f5ff;">reflect.Value</span>, <span style="color: #4eee94;">types</span> ...<span style="color: #98f5ff;">reflect.Type</span>) <span style="color: #98f5ff;">bool</span> {

        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">Check it is a funciton</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> fn.<span style="color: #daa520; font-weight: bold;">Kind</span>() != reflect.Func {
                <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #ffd700;">false</span>
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">NumIn() - returns a function type's input parameter count.</span>
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">NumOut() - returns a function type's output parameter count.</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (fn.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">NumIn</span>() != <span style="color: #f08080;">len</span>(types)-1) || (fn.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">NumOut</span>() != 1) {
                <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #ffd700;">false</span>
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">In() - returns the type of a function type's i'th input parameter.</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span> := 0; i &lt; <span style="color: #f08080;">len</span>(types)-1; i++ {
                <span style="color: #00bfff; font-weight: bold;">if</span> fn.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">In</span>(i) != types[i] {
                        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #ffd700;">false</span>
                }
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Out() - returns the type of a function type's i'th output parameter.</span>
        <span style="color: #4eee94;">outType</span> := types[<span style="color: #f08080;">len</span>(types)-1]
        <span style="color: #00bfff; font-weight: bold;">if</span> outType != <span style="color: #ffd700;">nil</span> &amp;&amp; fn.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">Out</span>(0) != outType {
                <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #ffd700;">false</span>
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #ffd700;">true</span>
}
</pre>
</div>

<pre class="example">
上面的代码一下子就复杂起来了，可见，复杂的代码都是在处理异常的地方
</pre>
<p>
下面列几个代码中的要点：
</p>
<ul class="org-ul">
<li>代码中没有使用Map函数，因为和数据结构和关键有含义冲突的问题，所以使用 <span class="underline">Transform</span> ，这个来源于 C++ STL库中的命名</li>
<li>有两个版本的函数
<ul class="org-ul">
<li>一个是返回一个全新的数组: Transform()</li>
<li>一个是“就地完成”: TransformInPlace()</li>
</ul></li>
<li>在 <span class="underline">主函数</span> 中，用 <span class="underline">Kind()</span> 方法 <b>检查</b> 了 <span class="underline">数据类型</span> 是不是 <span class="underline">Slice</span> ， <span class="underline">函数类型</span> 是不是 <span class="underline">Func</span></li>
<li><b>检查</b> 函数的 <span class="underline">参数</span> 和 <span class="underline">返回类型</span> 是通过 <span class="underline">verifyFuncSignature()</span>  来完成的，其中：
<ul class="org-ul">
<li>NumIn(): 用来检查函数的“入参”</li>
<li>NumOut() 用来检查函数的“返回值”</li>
</ul></li>
<li>如果需要新生成一个Slice，会使用 <span class="underline">reflect.MakeSlice()</span> 来完成</li>
</ul>

<p>
有了上面的这段代码，就很可以很开心的使用了：
</p>
<ul class="org-ul">
<li>可以用于字符串数组</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">list</span> := []<span style="color: #98f5ff;">string</span>{<span style="color: #deb887;">"1"</span>, <span style="color: #deb887;">"2"</span>, <span style="color: #deb887;">"3"</span>, <span style="color: #deb887;">"4"</span>, <span style="color: #deb887;">"5"</span>, <span style="color: #deb887;">"6"</span>}
<span style="color: #4eee94;">result</span> := <span style="color: #daa520; font-weight: bold;">Transform</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">a</span> <span style="color: #98f5ff;">string</span>) <span style="color: #98f5ff;">string</span>{
        <span style="color: #00bfff; font-weight: bold;">return</span> a +a +a
}) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">{"111","222","333","444","555","666"}</span>
</pre>
</div>

<ul class="org-ul">
<li>可以用于整形数组</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #4eee94;">list</span> := []<span style="color: #98f5ff;">int</span>{1, 2, 3, 4, 5, 6, 7, 8, 9}
<span style="color: #daa520; font-weight: bold;">TransformInPlace</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span> (<span style="color: #4eee94;">a</span> <span style="color: #98f5ff;">int</span>) <span style="color: #98f5ff;">int</span> {
        <span style="color: #00bfff; font-weight: bold;">return</span> a*3
}) <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">{3, 6, 9, 12, 15, 18, 21, 24, 27}</span>
</pre>
</div>

<ul class="org-ul">
<li>可以用于结构体</li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">list</span> = []<span style="color: #98f5ff;">Employee</span>{
        {<span style="color: #deb887;">"Hao"</span>, 44, 0, 8000},
        {<span style="color: #deb887;">"Bob"</span>, 34, 10, 5000},
        {<span style="color: #deb887;">"Alice"</span>, 23, 5, 9000},
        {<span style="color: #deb887;">"Jack"</span>, 26, 0, 4000},
        {<span style="color: #deb887;">"Tom"</span>, 48, 9, 7500},
}

<span style="color: #4eee94;">result</span> := <span style="color: #daa520; font-weight: bold;">TransformInPlace</span>(list, <span style="color: #00bfff; font-weight: bold;">func</span>(<span style="color: #4eee94;">e</span> <span style="color: #98f5ff;">Employee</span>) <span style="color: #98f5ff;">Employee</span> {
        e.Salary += 1000
        e.Age += 1
        <span style="color: #00bfff; font-weight: bold;">return</span> e
}) <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">// [{Hao 45 0 9000} {Bob 35 10 6000} {Alice 24 5 10000} {Jack 27 0 5000} {Tom 49 9 8500}]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea31047" class="outline-3">
<h3 id="orgea31047">健壮版的 Generic Reduce</h3>
<div class="outline-text-3" id="text-orgea31047">
<p>
泛型版的 Reduce 代码如下：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">Reduce</span>(<span style="color: #4eee94;">slice</span>, <span style="color: #4eee94;">pairFunc</span>, <span style="color: #4eee94;">zero</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}) <span style="color: #00bfff; font-weight: bold;">interface</span>{} {
        <span style="color: #4eee94;">sliceInType</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(slice)
        <span style="color: #00bfff; font-weight: bold;">if</span> sliceInType.<span style="color: #daa520; font-weight: bold;">Kind</span>() != reflect.Slice {
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"reduce: wrong type, not slice"</span>)
        }

        <span style="color: #4eee94;">len</span> := sliceInType.<span style="color: #daa520; font-weight: bold;">Len</span>()
        <span style="color: #00bfff; font-weight: bold;">if</span> len == 0 {
                <span style="color: #00bfff; font-weight: bold;">return</span> zero
        } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> len == 1 {
                <span style="color: #00bfff; font-weight: bold;">return</span> sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(0)
        }

        <span style="color: #4eee94;">elemType</span> := sliceInType.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">Elem</span>()
        <span style="color: #4eee94;">fn</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(pairFunc)
        <span style="color: #00bfff; font-weight: bold;">if</span> !<span style="color: #daa520; font-weight: bold;">verifyFuncSignature</span>(fn, elemType, elemType, elemType) {
                <span style="color: #4eee94;">t</span> := elemType.<span style="color: #daa520; font-weight: bold;">String</span>()
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"reduce: function must be of type func("</span> + t + <span style="color: #deb887;">", "</span> + t + <span style="color: #deb887;">") "</span> + t)
        }

        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">ins</span> [2]<span style="color: #98f5ff;">reflect.Value</span>
        ins[0] = sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(0)
        ins[1] = sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(1)
        <span style="color: #4eee94;">out</span> := fn.<span style="color: #daa520; font-weight: bold;">Call</span>(ins[:])[0]

        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span> := 2; i &lt; len; i++ {
                ins[0] = out
                ins[1] = sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(i)
                out = fn.<span style="color: #daa520; font-weight: bold;">Call</span>(ins[:])[0]
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> out.<span style="color: #daa520; font-weight: bold;">Interface</span>()
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd35499c" class="outline-3">
<h3 id="orgd35499c">健壮版的 Generic Filter</h3>
<div class="outline-text-3" id="text-orgd35499c">
<p>
泛型版的 Filter 代码如下：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">Filter</span>(<span style="color: #4eee94;">slice</span>, <span style="color: #4eee94;">function</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}) <span style="color: #00bfff; font-weight: bold;">interface</span>{} {
        <span style="color: #4eee94;">result</span>, <span style="color: #4eee94;">_</span> := <span style="color: #daa520; font-weight: bold;">filter</span>(slice, function, <span style="color: #ffd700;">false</span>)
        <span style="color: #00bfff; font-weight: bold;">return</span> result
}

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">FilterInPlace</span>(<span style="color: #4eee94;">slicePtr</span>, <span style="color: #4eee94;">function</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}) {
        <span style="color: #4eee94;">in</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(slicePtr)
        <span style="color: #00bfff; font-weight: bold;">if</span> in.<span style="color: #daa520; font-weight: bold;">Kind</span>() != reflect.Ptr {
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"FilterInPlace: wrong type, "</span> +
                        <span style="color: #deb887;">"not a pointer to slice"</span>)
        }
        <span style="color: #4eee94;">_</span>, <span style="color: #4eee94;">n</span> := <span style="color: #daa520; font-weight: bold;">filter</span>(in.<span style="color: #daa520; font-weight: bold;">Elem</span>().<span style="color: #daa520; font-weight: bold;">Interface</span>(), function, <span style="color: #ffd700;">true</span>)
        in.<span style="color: #daa520; font-weight: bold;">Elem</span>().<span style="color: #daa520; font-weight: bold;">SetLen</span>(n)
}

<span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">boolType</span> = reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(<span style="color: #ffd700;">true</span>).<span style="color: #daa520; font-weight: bold;">Type</span>()

<span style="color: #00bfff; font-weight: bold;">func</span> <span style="color: #daa520; font-weight: bold;">filter</span>(<span style="color: #4eee94;">slice</span>, <span style="color: #4eee94;">function</span> <span style="color: #00bfff; font-weight: bold;">interface</span>{}, <span style="color: #4eee94;">inPlace</span> <span style="color: #98f5ff;">bool</span>) (<span style="color: #00bfff; font-weight: bold;">interface</span>{}, <span style="color: #98f5ff;">int</span>) {

        <span style="color: #4eee94;">sliceInType</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(slice)
        <span style="color: #00bfff; font-weight: bold;">if</span> sliceInType.<span style="color: #daa520; font-weight: bold;">Kind</span>() != reflect.Slice {
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"filter: wrong type, not a slice"</span>)
        }

        <span style="color: #4eee94;">fn</span> := reflect.<span style="color: #daa520; font-weight: bold;">ValueOf</span>(function)
        <span style="color: #4eee94;">elemType</span> := sliceInType.<span style="color: #daa520; font-weight: bold;">Type</span>().<span style="color: #daa520; font-weight: bold;">Elem</span>()
        <span style="color: #00bfff; font-weight: bold;">if</span> !<span style="color: #daa520; font-weight: bold;">verifyFuncSignature</span>(fn, elemType, boolType) {
                <span style="color: #f08080;">panic</span>(<span style="color: #deb887;">"filter: function must be of type func("</span> + elemType.<span style="color: #daa520; font-weight: bold;">String</span>() + <span style="color: #deb887;">") bool"</span>)
        }

        <span style="color: #00bfff; font-weight: bold;">var</span> <span style="color: #4eee94;">which</span> []<span style="color: #98f5ff;">int</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span> := 0; i &lt; sliceInType.<span style="color: #daa520; font-weight: bold;">Len</span>(); i++ {
                <span style="color: #00bfff; font-weight: bold;">if</span> fn.<span style="color: #daa520; font-weight: bold;">Call</span>([]<span style="color: #98f5ff;">reflect.Value</span>{sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(i)})[0].<span style="color: #daa520; font-weight: bold;">Bool</span>() {
                        which = <span style="color: #f08080;">append</span>(which, i)
                }
        }

        <span style="color: #4eee94;">out</span> := sliceInType

        <span style="color: #00bfff; font-weight: bold;">if</span> !inPlace {
                out = reflect.<span style="color: #daa520; font-weight: bold;">MakeSlice</span>(sliceInType.<span style="color: #daa520; font-weight: bold;">Type</span>(), <span style="color: #f08080;">len</span>(which), <span style="color: #f08080;">len</span>(which))
        }
        <span style="color: #00bfff; font-weight: bold;">for</span> <span style="color: #4eee94;">i</span> := <span style="color: #00bfff; font-weight: bold;">range</span> which {
                out.<span style="color: #daa520; font-weight: bold;">Index</span>(i).<span style="color: #daa520; font-weight: bold;">Set</span>(sliceInType.<span style="color: #daa520; font-weight: bold;">Index</span>(which[i]))
        }

        <span style="color: #00bfff; font-weight: bold;">return</span> out.<span style="color: #daa520; font-weight: bold;">Interface</span>(), <span style="color: #f08080;">len</span>(which)
}
</pre>
</div>

<pre class="example">
1. 使用反射来做这些东西，会有一个问题，那就是代码的性能会很差。所以，上面的代码不能用于需要高性能的地方

2. 上面的代码大量的参考了 Rob Pike的版本，他的代码在 https://github.com/robpike/filter

3. 其实，在全世界范围内，有大量的程序员都在问Go语言官方什么时候在标准库中支持 Map/Reduce，Rob Pike说，这种东西难写吗？还要官方来帮你们写么？这种代码我多少年前就写过了，但是，我从来一次都没有用过，我还是喜欢用“For循环”，我觉得你最好也跟我一起用 “For循环” 
</pre>

<p>
<a href="code_generation.html">Next：代码生成器</a>
</p>

<p>
<a href="proxy.html">Previous：委托模式</a> 
</p>

<p>
<a href="go-patterns.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
