<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Map-Reduce</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="proxy.html"> UP </a>
 |
 <a accesskey="H" href="go-patterns.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Map-Reduce</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5acd7d9">基本示例</a>
<ul>
<li><a href="#orgd4b3f7c">Map</a></li>
<li><a href="#org3bb484c">Reduce &amp; Filter</a></li>
</ul>
</li>
<li><a href="#orgbd979bf">业务示例</a>
<ul>
<li><a href="#org6499c63">员工信息</a></li>
<li><a href="#org04e6f31">相关的Reduce/Fitler函数</a></li>
<li><a href="#org60aab94">各种自定义的统计示例</a></li>
</ul>
</li>
<li><a href="#org6a66f3b">泛型Map-Reduce</a>
<ul>
<li><a href="#org7545338">简单版 Generic Map</a></li>
<li><a href="#org1904ebb">健壮版的Generic Map</a></li>
<li><a href="#orge999abc">健壮版的 Generic Reduce</a></li>
<li><a href="#orgcf4f5a7">健壮版的 Generic Filter</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example" id="org4ade03e">
在本篇文章中，学习一下函数式编程的中非常重要的Map、Reduce、Filter的三种操作，这三种操作可以非常方便灵活地进行一些数据处理

程序中大多数情况下都是在到倒腾数据，尤其对于一些需要统计的业务场景，Map/Reduce/Filter是非常通用的玩法
</pre>
<div id="outline-container-org5acd7d9" class="outline-2">
<h2 id="org5acd7d9">基本示例</h2>
<div class="outline-text-2" id="text-org5acd7d9">
</div>
<div id="outline-container-orgd4b3f7c" class="outline-3">
<h3 id="orgd4b3f7c">Map</h3>
<div class="outline-text-3" id="text-orgd4b3f7c">
<p>
下面的程序代码中，写了两个Map函数，这两个函数需要两个参数：
</p>
<ul class="org-ul">
<li>一个是字符串数组 <span class="underline">[]string</span> ，说明需要处理的数据一个字符串</li>
<li>另一个是一个函数 <span class="underline">func(s string) string</span> 或 <span class="underline">func(s string) int</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">MapStrToStr</span>(<span style="color: #eedd82;">arr</span> []<span style="color: #98fb98;">string</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">string</span>) []<span style="color: #98fb98;">string</span> {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">newArray</span> = []<span style="color: #98fb98;">string</span>{}
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">_</span>, <span style="color: #eedd82;">it</span> := <span style="color: #00ffff;">range</span> arr {
                  newArray = <span style="color: #b0c4de;">append</span>(newArray, <span style="color: #87cefa;">fn</span>(it))
          }
          <span style="color: #00ffff;">return</span> newArray
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">MapStrToInt</span>(<span style="color: #eedd82;">arr</span> []<span style="color: #98fb98;">string</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">int</span>) []<span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">newArray</span> = []<span style="color: #98fb98;">int</span>{}
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">_</span>, <span style="color: #eedd82;">it</span> := <span style="color: #00ffff;">range</span> arr {
                  newArray = <span style="color: #b0c4de;">append</span>(newArray, <span style="color: #87cefa;">fn</span>(it))
          }
          <span style="color: #00ffff;">return</span> newArray
}
</pre>
</div>

<pre class="example" id="org7d06fa8">
整个Map函数运行逻辑都很相似：
1. 函数体都是在遍历第一个参数的数组
2. 调用第二个参数的函数
3. 把其值组合成另一个数组返回
</pre>
<p>
于是可以这样使用这两个函数：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">var</span> <span style="color: #eedd82;">list</span> = []<span style="color: #98fb98;">string</span>{<span style="color: #ffa07a;">"Hao"</span>, <span style="color: #ffa07a;">"Chen"</span>, <span style="color: #ffa07a;">"MegaEase"</span>}
<span style="color: #eedd82;">x</span> := <span style="color: #87cefa;">MapStrToStr</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">string</span> {
    <span style="color: #00ffff;">return</span> strings.<span style="color: #87cefa;">ToUpper</span>(s)
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"%v\n"</span>, x) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">["HAO", "CHEN", "MEGAEASE"]</span>

<span style="color: #eedd82;">y</span> := <span style="color: #87cefa;">MapStrToInt</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">int</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">len</span>(s)
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"%v\n"</span>, y) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">[3, 4, 8]</span>
</pre>
</div>


<pre class="example" id="orgce254dc">
可以看到，给第一个 MapStrToStr() 传了函数做的是 转大写，于是出来的数组就成了全大写的

给MapStrToInt() 传的是算其长度，所以出来的数组是每个字符串的长度。
</pre>
</div>
</div>
<div id="outline-container-org3bb484c" class="outline-3">
<h3 id="org3bb484c">Reduce &amp; Filter</h3>
<div class="outline-text-3" id="text-org3bb484c">
<p>
再来看一下Reduce和Filter的函数是什么样的：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Reduce</span>(<span style="color: #eedd82;">arr</span> []<span style="color: #98fb98;">string</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #eedd82;">sum</span> := 0
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">_</span>, <span style="color: #eedd82;">it</span> := <span style="color: #00ffff;">range</span> arr {
                  sum += <span style="color: #87cefa;">fn</span>(it)
          }
          <span style="color: #00ffff;">return</span> sum
}

<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">list</span> = []<span style="color: #98fb98;">string</span>{<span style="color: #ffa07a;">"Hao"</span>, <span style="color: #ffa07a;">"Chen"</span>, <span style="color: #ffa07a;">"MegaEase"</span>}

<span style="color: #eedd82;">x</span> := <span style="color: #87cefa;">Reduce</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">len</span>(s)
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"%v\n"</span>, x) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">15</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Filter</span>(<span style="color: #eedd82;">arr</span> []<span style="color: #98fb98;">int</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">n</span> <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">bool</span>) []<span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">newArray</span> = []<span style="color: #98fb98;">int</span>{}
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">_</span>, <span style="color: #eedd82;">it</span> := <span style="color: #00ffff;">range</span> arr {
                  <span style="color: #00ffff;">if</span> <span style="color: #87cefa;">fn</span>(it) {
                          newArray = <span style="color: #b0c4de;">append</span>(newArray, it)
                  }
          }
          <span style="color: #00ffff;">return</span> newArray
}

<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">intset</span> = []<span style="color: #98fb98;">int</span>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
<span style="color: #eedd82;">out</span> := <span style="color: #87cefa;">Filter</span>(intset, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">n</span> <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">bool</span> {
          <span style="color: #00ffff;">return</span> n%2 == 1
})
fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"%v\n"</span>, out)

out = <span style="color: #87cefa;">Filter</span>(intset, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">n</span> <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">bool</span> {
          <span style="color: #00ffff;">return</span> n &gt; 5
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"%v\n"</span>, out)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbd979bf" class="outline-2">
<h2 id="orgbd979bf">业务示例</h2>
<div class="outline-text-2" id="text-orgbd979bf">
<pre class="example" id="org86f9b09">
通过上面的一些示例，可能有一些明白，Map/Reduce/Filter只是一种控制逻辑，真正的业务逻辑是在传给他们的数据和那个函数来定义的

这是一个很经典的“业务逻辑”和“控制逻辑”分离解耦的编程模式
</pre>

<p>
下面来看一个有业务意义的代码，来让大家强化理解一下什么叫“控制逻辑”与”业务逻辑“分离 
</p>
</div>
<div id="outline-container-org6499c63" class="outline-3">
<h3 id="org6499c63">员工信息</h3>
<div class="outline-text-3" id="text-org6499c63">
<p>
首先，有一个员工对象，以及一些数据：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Employee</span> <span style="color: #00ffff;">struct</span> {
          Name     <span style="color: #98fb98;">string</span>
          Age      <span style="color: #98fb98;">int</span>
          Vacation <span style="color: #98fb98;">int</span>
          Salary   <span style="color: #98fb98;">int</span>
}
<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">list</span> = []<span style="color: #98fb98;">Employee</span>{
          {<span style="color: #ffa07a;">"Hao"</span>, 44, 0, 8000},
          {<span style="color: #ffa07a;">"Bob"</span>, 34, 10, 5000},
          {<span style="color: #ffa07a;">"Alice"</span>, 23, 5, 9000},
          {<span style="color: #ffa07a;">"Jack"</span>, 26, 0, 4000},
          {<span style="color: #ffa07a;">"Tom"</span>, 48, 9, 7500},
          {<span style="color: #ffa07a;">"Marry"</span>, 29, 0, 6000},
          {<span style="color: #ffa07a;">"Mike"</span>, 32, 8, 4000},
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org04e6f31" class="outline-3">
<h3 id="org04e6f31">相关的Reduce/Fitler函数</h3>
<div class="outline-text-3" id="text-org04e6f31">
<p>
然后有如下的几个函数：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">EmployeeCountIf</span>(<span style="color: #eedd82;">list</span> []<span style="color: #98fb98;">Employee</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">bool</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #eedd82;">count</span> := 0
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">_</span> := <span style="color: #00ffff;">range</span> list {
                  <span style="color: #00ffff;">if</span> <span style="color: #87cefa;">fn</span>(&amp;list[i]) {
                          count += 1
                  }
          }
          <span style="color: #00ffff;">return</span> count
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">EmployeeFilterIn</span>(<span style="color: #eedd82;">list</span> []<span style="color: #98fb98;">Employee</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">bool</span>) []<span style="color: #98fb98;">Employee</span> {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">newList</span> []<span style="color: #98fb98;">Employee</span>
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">_</span> := <span style="color: #00ffff;">range</span> list {
                  <span style="color: #00ffff;">if</span> <span style="color: #87cefa;">fn</span>(&amp;list[i]) {
                          newList = <span style="color: #b0c4de;">append</span>(newList, list[i])
                  }
          }
          <span style="color: #00ffff;">return</span> newList
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">EmployeeSumIf</span>(<span style="color: #eedd82;">list</span> []<span style="color: #98fb98;">Employee</span>, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">sum</span> = 0
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">_</span> := <span style="color: #00ffff;">range</span> list {
                  sum += <span style="color: #87cefa;">fn</span>(&amp;list[i])
          }
          <span style="color: #00ffff;">return</span> sum
}
</pre>
</div>

<p>
简单说明一下：
</p>
<ul class="org-ul">
<li><span class="underline">EmployeeConutIf</span> 和 <span class="underline">EmployeeSumIf</span> 分别用于统满足某个条件的个数或总数。它们都是Filter + Reduce的语义</li>
<li><span class="underline">EmployeeFilterIn</span> 就是按某种条件过虑。就是Fitler的语义</li>
</ul>
</div>
</div>
<div id="outline-container-org60aab94" class="outline-3">
<h3 id="org60aab94">各种自定义的统计示例</h3>
<div class="outline-text-3" id="text-org60aab94">
<p>
现在就可以有如下的代码：
</p>
<ul class="org-ul">
<li>统计有多少员工大于40岁</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">old</span> := <span style="color: #87cefa;">EmployeeCountIf</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">bool</span> {
          <span style="color: #00ffff;">return</span> e.Age &gt; 40
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"old people: %d\n"</span>, old) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">old people: 2</span>
</pre>
</div>
<ul class="org-ul">
<li>统计有多少员工薪水大于6000</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">high_pay</span> := <span style="color: #87cefa;">EmployeeCountIf</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">bool</span> {
          <span style="color: #00ffff;">return</span> e.Salary &gt;= 6000
})
fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"High Salary people: %d\n"</span>, high_pay) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">High Salary people: 4</span>
</pre>
</div>
<ul class="org-ul">
<li>列出有没有休假的员工</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">no_vacation</span> := <span style="color: #87cefa;">EmployeeFilterIn</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">bool</span> {
          <span style="color: #00ffff;">return</span> e.Vacation == 0
})
fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"People no vacation: %v\n"</span>, no_vacation) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">People no vacation: [{Hao 44 0 8000} {Jack 26 0 4000} {Marry 29 0 6000}]</span>
</pre>
</div>
<ul class="org-ul">
<li>统计所有员工的薪资总和</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">total_pay</span> := <span style="color: #87cefa;">EmployeeSumIf</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">return</span> e.Salary
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"Total Salary: %d\n"</span>, total_pay) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">Total Salary: 43500</span>
</pre>
</div>
<ul class="org-ul">
<li>统计30岁以下员工的薪资总和</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">younger_pay</span> := <span style="color: #87cefa;">EmployeeSumIf</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">int</span> {
    <span style="color: #00ffff;">if</span> e.Age &lt; 30 {
          <span style="color: #00ffff;">return</span> e.Salary
    } 
    <span style="color: #00ffff;">return</span> 0
})

fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"Younger Salary: %d\n"</span>, younger_pay) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Younger Salary: 19000</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6a66f3b" class="outline-2">
<h2 id="org6a66f3b">泛型Map-Reduce</h2>
<div class="outline-text-2" id="text-org6a66f3b">
<p>
上面的Map-Reduce都因为要处理数据的类型不同而需要写出不同版本的Map-Reduce，虽然他们的代码看上去是很类似的。所以，这里就要带出来泛型编程了
</p>

<pre class="example" id="org425c147">
Go开发团队技术负责人Russ Cox在golang-dev上的mail确认了Go泛型(type parameter)将在Go 1.18版本落地，即2022.2月份
</pre>
</div>
<div id="outline-container-org7545338" class="outline-3">
<h3 id="org7545338">简单版 Generic Map</h3>
<div class="outline-text-3" id="text-org7545338">
<p>
目前的Go语言的泛型只能用 <span class="underline">interface{} + reflect</span> 来完成：
</p>
<ul class="org-ul">
<li>interface{}： 可以理解为C中的 <span class="underline">void*</span> ，Java中的 <span class="underline">Object</span></li>
<li>reflect：Go的 <span class="underline">反射机制包</span> ，用于在运行时检查类型</li>
</ul>

<p>
先来看一下一个非常简单 <b>不作任何类型检查</b> 的 <span class="underline">泛型的</span> Map函数： 
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Map</span>(<span style="color: #eedd82;">data</span> <span style="color: #00ffff;">interface</span>{}, <span style="color: #eedd82;">fn</span> <span style="color: #00ffff;">interface</span>{}) []<span style="color: #00ffff;">interface</span>{} {
          <span style="color: #eedd82;">vfn</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(fn)
          <span style="color: #eedd82;">vdata</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(data)
          <span style="color: #eedd82;">result</span> := <span style="color: #b0c4de;">make</span>([]<span style="color: #00ffff;">interface</span>{}, vdata.<span style="color: #87cefa;">Len</span>())

          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span> := 0; i &lt; vdata.<span style="color: #87cefa;">Len</span>(); i++ {
                  result[i] = vfn.<span style="color: #87cefa;">Call</span>([]<span style="color: #98fb98;">reflect.Value</span>{vdata.<span style="color: #87cefa;">Index</span>(i)})[0].<span style="color: #87cefa;">Interface</span>()
          }
          <span style="color: #00ffff;">return</span> result
}
</pre>
</div>

<p>
上面的代码中，
</p>
<ul class="org-ul">
<li>通过 <span class="underline">reflect.ValueOf()</span> 来获得 <span class="underline">interface{}</span> 的值：
<ul class="org-ul">
<li>一个是数据 <span class="underline">vdata</span></li>
<li>另一个是函数 <span class="underline">vfn</span></li>
</ul></li>
<li>通过 <span class="underline">vfn.Call()</span> 方法来 <b>调用函数</b></li>
<li>通过 <span class="underline">[]refelct.Value{vdata.Index(i)}</span> 来 <b>获得数据</b></li>
</ul>

<pre class="example" id="org182256b">
Go语言中的反射的语法还是有点令人费解的，但是简单看一下手册还是能够读懂的
</pre>

<p>
现在对于不同类型的数据可以使用相同逻辑的Map()代码：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">square</span> := <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">x</span> <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">return</span> x * x
}
<span style="color: #eedd82;">nums</span> := []<span style="color: #98fb98;">int</span>{1, 2, 3, 4}

<span style="color: #eedd82;">squared_arr</span> := <span style="color: #87cefa;">Map</span>(nums,square)
fmt.<span style="color: #87cefa;">Println</span>(squared_arr) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">[1 4 9 16]</span>

<span style="color: #eedd82;">upcase</span> := <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">s</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">string</span> {
          <span style="color: #00ffff;">return</span> strings.<span style="color: #87cefa;">ToUpper</span>(s)
}

<span style="color: #eedd82;">strs</span> := []<span style="color: #98fb98;">string</span>{<span style="color: #ffa07a;">"Hao"</span>, <span style="color: #ffa07a;">"Chen"</span>, <span style="color: #ffa07a;">"MegaEase"</span>}
<span style="color: #eedd82;">upstrs</span> := <span style="color: #87cefa;">Map</span>(strs, upcase);
fmt.<span style="color: #87cefa;">Println</span>(upstrs) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">[HAO CHEN MEGAEASE]</span>
</pre>
</div>

<p>
但是因为反射是运行时的事，所以，如果类型什么出问题的话，就会有运行时的错误。比如：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">x</span> := <span style="color: #87cefa;">Map</span>(5, 5)
fmt.<span style="color: #87cefa;">Println</span>(x)
</pre>
</div>
<p>
上面的代码可以编译通过，但是在运行时就出问题：
</p>

<div class="org-src-container">
<pre class="src src-sh">panic: reflect: call of reflect.Value.Len on int Value

goroutine 1 [running]:
<span style="color: #87cefa;">reflect.Value.Len</span>(0x4a6240, 0x4dcda0, 0x82, 0x4708fc)
          /usr/local/go/src/reflect/value.go:1163 +0x185
<span style="color: #87cefa;">main.Map</span>(0x4a6240, 0x4dcda0, 0x4a6240, 0x4dcda8, 0x1, 0x14, 0x0)
          /home/klose/Documents/programming/html/klose911.github.io/src/go/go-patterns/src/map_reduce/simple_generic_map.go:12 +0x16b
<span style="color: #87cefa;">main.main</span>()
          /home/klose/Documents/programming/html/klose911.github.io/src/go/go-patterns/src/map_reduce/simple_generic_map.go:36 +0x25c
<span style="color: #00ffff;">exit</span> status 2
</pre>
</div>
</div>
</div>
<div id="outline-container-org1904ebb" class="outline-3">
<h3 id="org1904ebb">健壮版的Generic Map</h3>
<div class="outline-text-3" id="text-org1904ebb">
<pre class="example" id="orgfd54525">
因此如果要写一个健壮的程序，对于这种用interface{} 的“过度泛型”，就需要自己来做类型检查
</pre>
<p>
下面是一个有类型检查的Map代码：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Transform</span>(<span style="color: #eedd82;">slice</span>, <span style="color: #eedd82;">function</span> <span style="color: #00ffff;">interface</span>{}) <span style="color: #00ffff;">interface</span>{} {
          <span style="color: #00ffff;">return</span> <span style="color: #87cefa;">transform</span>(slice, function, <span style="color: #7fffd4;">false</span>)
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">TransformInPlace</span>(<span style="color: #eedd82;">slice</span>, <span style="color: #eedd82;">function</span> <span style="color: #00ffff;">interface</span>{}) <span style="color: #00ffff;">interface</span>{} {
          <span style="color: #00ffff;">return</span> <span style="color: #87cefa;">transform</span>(slice, function, <span style="color: #7fffd4;">true</span>)
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">transform</span>(<span style="color: #eedd82;">slice</span>, <span style="color: #eedd82;">function</span> <span style="color: #00ffff;">interface</span>{}, <span style="color: #eedd82;">inPlace</span> <span style="color: #98fb98;">bool</span>) <span style="color: #00ffff;">interface</span>{} {

          <span style="color: #ff4500;">//</span><span style="color: #ff4500;">check the `slice` type is Slice</span>
          <span style="color: #eedd82;">sliceInType</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(slice)
          <span style="color: #00ffff;">if</span> sliceInType.<span style="color: #87cefa;">Kind</span>() != reflect.Slice {
                  <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"transform: not slice"</span>)
          }

          <span style="color: #ff4500;">//</span><span style="color: #ff4500;">check the function signature</span>
          <span style="color: #eedd82;">fn</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(function)
          <span style="color: #eedd82;">elemType</span> := sliceInType.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">Elem</span>()
          <span style="color: #00ffff;">if</span> !<span style="color: #87cefa;">verifyFuncSignature</span>(fn, elemType, <span style="color: #7fffd4;">nil</span>) {
                  <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"trasform: function must be of type func("</span> + sliceInType.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">Elem</span>().<span style="color: #87cefa;">String</span>() + <span style="color: #ffa07a;">") outputElemType"</span>)
          }

          <span style="color: #eedd82;">sliceOutType</span> := sliceInType
          <span style="color: #00ffff;">if</span> !inPlace {
                  sliceOutType = reflect.<span style="color: #87cefa;">MakeSlice</span>(reflect.<span style="color: #87cefa;">SliceOf</span>(fn.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">Out</span>(0)), sliceInType.<span style="color: #87cefa;">Len</span>(), sliceInType.<span style="color: #87cefa;">Len</span>())
          }

          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span> := 0; i &lt; sliceInType.<span style="color: #87cefa;">Len</span>(); i++ {
                  sliceOutType.<span style="color: #87cefa;">Index</span>(i).<span style="color: #87cefa;">Set</span>(fn.<span style="color: #87cefa;">Call</span>([]<span style="color: #98fb98;">reflect.Value</span>{sliceInType.<span style="color: #87cefa;">Index</span>(i)})[0])
          }
          <span style="color: #00ffff;">return</span> sliceOutType.<span style="color: #87cefa;">Interface</span>()

}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">verifyFuncSignature</span>(<span style="color: #eedd82;">fn</span> <span style="color: #98fb98;">reflect.Value</span>, <span style="color: #eedd82;">types</span> ...<span style="color: #98fb98;">reflect.Type</span>) <span style="color: #98fb98;">bool</span> {

          <span style="color: #ff4500;">//</span><span style="color: #ff4500;">Check it is a funciton</span>
          <span style="color: #00ffff;">if</span> fn.<span style="color: #87cefa;">Kind</span>() != reflect.Func {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>
          }

          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">NumIn() - returns a function type's input parameter count.</span>
          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">NumOut() - returns a function type's output parameter count.</span>
          <span style="color: #00ffff;">if</span> (fn.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">NumIn</span>() != <span style="color: #b0c4de;">len</span>(types)-1) || (fn.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">NumOut</span>() != 1) {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>
          }

          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">In() - returns the type of a function type's i'th input parameter.</span>
          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span> := 0; i &lt; <span style="color: #b0c4de;">len</span>(types)-1; i++ {
                  <span style="color: #00ffff;">if</span> fn.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">In</span>(i) != types[i] {
                          <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>
                  }
          }

          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Out() - returns the type of a function type's i'th output parameter.</span>
          <span style="color: #eedd82;">outType</span> := types[<span style="color: #b0c4de;">len</span>(types)-1]
          <span style="color: #00ffff;">if</span> outType != <span style="color: #7fffd4;">nil</span> &amp;&amp; fn.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">Out</span>(0) != outType {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>
          }
          <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>
}
</pre>
</div>

<pre class="example" id="org17839f8">
上面的代码一下子就复杂起来了，可见，复杂的代码都是在处理异常的地方
</pre>
<p>
下面列几个代码中的要点：
</p>
<ul class="org-ul">
<li>代码中没有使用Map函数，因为和数据结构和关键有含义冲突的问题，所以使用 <span class="underline">Transform</span> ，这个来源于 C++ STL库中的命名</li>
<li>有两个版本的函数
<ul class="org-ul">
<li>一个是返回一个全新的数组: Transform()</li>
<li>一个是“就地完成”: TransformInPlace()</li>
</ul></li>
<li>在 <span class="underline">主函数</span> 中，用 <span class="underline">Kind()</span> 方法 <b>检查</b> 了 <span class="underline">数据类型</span> 是不是 <span class="underline">Slice</span> ， <span class="underline">函数类型</span> 是不是 <span class="underline">Func</span></li>
<li><b>检查</b> 函数的 <span class="underline">参数</span> 和 <span class="underline">返回类型</span> 是通过 <span class="underline">verifyFuncSignature()</span>  来完成的，其中：
<ul class="org-ul">
<li>NumIn(): 用来检查函数的“入参”</li>
<li>NumOut() 用来检查函数的“返回值”</li>
</ul></li>
<li>如果需要新生成一个Slice，会使用 <span class="underline">reflect.MakeSlice()</span> 来完成</li>
</ul>

<p>
有了上面的这段代码，就很可以很开心的使用了：
</p>
<ul class="org-ul">
<li>可以用于字符串数组</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">list</span> := []<span style="color: #98fb98;">string</span>{<span style="color: #ffa07a;">"1"</span>, <span style="color: #ffa07a;">"2"</span>, <span style="color: #ffa07a;">"3"</span>, <span style="color: #ffa07a;">"4"</span>, <span style="color: #ffa07a;">"5"</span>, <span style="color: #ffa07a;">"6"</span>}
<span style="color: #eedd82;">result</span> := <span style="color: #87cefa;">Transform</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">a</span> <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">string</span>{
          <span style="color: #00ffff;">return</span> a +a +a
}) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">{"111","222","333","444","555","666"}</span>
</pre>
</div>

<ul class="org-ul">
<li>可以用于整形数组</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">list</span> := []<span style="color: #98fb98;">int</span>{1, 2, 3, 4, 5, 6, 7, 8, 9}
<span style="color: #87cefa;">TransformInPlace</span>(list, <span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">a</span> <span style="color: #98fb98;">int</span>) <span style="color: #98fb98;">int</span> {
          <span style="color: #00ffff;">return</span> a*3
}) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">{3, 6, 9, 12, 15, 18, 21, 24, 27}</span>
</pre>
</div>

<ul class="org-ul">
<li>可以用于结构体</li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">var</span> <span style="color: #eedd82;">list</span> = []<span style="color: #98fb98;">Employee</span>{
          {<span style="color: #ffa07a;">"Hao"</span>, 44, 0, 8000},
          {<span style="color: #ffa07a;">"Bob"</span>, 34, 10, 5000},
          {<span style="color: #ffa07a;">"Alice"</span>, 23, 5, 9000},
          {<span style="color: #ffa07a;">"Jack"</span>, 26, 0, 4000},
          {<span style="color: #ffa07a;">"Tom"</span>, 48, 9, 7500},
}

<span style="color: #eedd82;">result</span> := <span style="color: #87cefa;">TransformInPlace</span>(list, <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">e</span> <span style="color: #98fb98;">Employee</span>) <span style="color: #98fb98;">Employee</span> {
          e.Salary += 1000
          e.Age += 1
          <span style="color: #00ffff;">return</span> e
}) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">// [{Hao 45 0 9000} {Bob 35 10 6000} {Alice 24 5 10000} {Jack 27 0 5000} {Tom 49 9 8500}]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge999abc" class="outline-3">
<h3 id="orge999abc">健壮版的 Generic Reduce</h3>
<div class="outline-text-3" id="text-orge999abc">
<p>
泛型版的 Reduce 代码如下：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Reduce</span>(<span style="color: #eedd82;">slice</span>, <span style="color: #eedd82;">pairFunc</span>, <span style="color: #eedd82;">zero</span> <span style="color: #00ffff;">interface</span>{}) <span style="color: #00ffff;">interface</span>{} {
          <span style="color: #eedd82;">sliceInType</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(slice)
          <span style="color: #00ffff;">if</span> sliceInType.<span style="color: #87cefa;">Kind</span>() != reflect.Slice {
                  <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"reduce: wrong type, not slice"</span>)
          }

          <span style="color: #eedd82;">len</span> := sliceInType.<span style="color: #87cefa;">Len</span>()
          <span style="color: #00ffff;">if</span> len == 0 {
                  <span style="color: #00ffff;">return</span> zero
          } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> len == 1 {
                  <span style="color: #00ffff;">return</span> sliceInType.<span style="color: #87cefa;">Index</span>(0)
          }

          <span style="color: #eedd82;">elemType</span> := sliceInType.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">Elem</span>()
          <span style="color: #eedd82;">fn</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(pairFunc)
          <span style="color: #00ffff;">if</span> !<span style="color: #87cefa;">verifyFuncSignature</span>(fn, elemType, elemType, elemType) {
                  <span style="color: #eedd82;">t</span> := elemType.<span style="color: #87cefa;">String</span>()
                  <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"reduce: function must be of type func("</span> + t + <span style="color: #ffa07a;">", "</span> + t + <span style="color: #ffa07a;">") "</span> + t)
          }

          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">ins</span> [2]<span style="color: #98fb98;">reflect.Value</span>
          ins[0] = sliceInType.<span style="color: #87cefa;">Index</span>(0)
          ins[1] = sliceInType.<span style="color: #87cefa;">Index</span>(1)
          <span style="color: #eedd82;">out</span> := fn.<span style="color: #87cefa;">Call</span>(ins[:])[0]

          <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span> := 2; i &lt; len; i++ {
                  ins[0] = out
                  ins[1] = sliceInType.<span style="color: #87cefa;">Index</span>(i)
                  out = fn.<span style="color: #87cefa;">Call</span>(ins[:])[0]
          }
          <span style="color: #00ffff;">return</span> out.<span style="color: #87cefa;">Interface</span>()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcf4f5a7" class="outline-3">
<h3 id="orgcf4f5a7">健壮版的 Generic Filter</h3>
<div class="outline-text-3" id="text-orgcf4f5a7">
<p>
泛型版的 Filter 代码如下：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Filter</span>(<span style="color: #eedd82;">slice</span>, <span style="color: #eedd82;">function</span> <span style="color: #00ffff;">interface</span>{}) <span style="color: #00ffff;">interface</span>{} {
             <span style="color: #eedd82;">result</span>, <span style="color: #eedd82;">_</span> := <span style="color: #87cefa;">filter</span>(slice, function, <span style="color: #7fffd4;">false</span>)
             <span style="color: #00ffff;">return</span> result
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">FilterInPlace</span>(<span style="color: #eedd82;">slicePtr</span>, <span style="color: #eedd82;">function</span> <span style="color: #00ffff;">interface</span>{}) {
             <span style="color: #eedd82;">in</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(slicePtr)
             <span style="color: #00ffff;">if</span> in.<span style="color: #87cefa;">Kind</span>() != reflect.Ptr {
                     <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"FilterInPlace: wrong type, "</span> +
                             <span style="color: #ffa07a;">"not a pointer to slice"</span>)
             }
             <span style="color: #eedd82;">_</span>, <span style="color: #eedd82;">n</span> := <span style="color: #87cefa;">filter</span>(in.<span style="color: #87cefa;">Elem</span>().<span style="color: #87cefa;">Interface</span>(), function, <span style="color: #7fffd4;">true</span>)
             in.<span style="color: #87cefa;">Elem</span>().<span style="color: #87cefa;">SetLen</span>(n)
}

<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">boolType</span> = reflect.<span style="color: #87cefa;">ValueOf</span>(<span style="color: #7fffd4;">true</span>).<span style="color: #87cefa;">Type</span>()

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">filter</span>(<span style="color: #eedd82;">slice</span>, <span style="color: #eedd82;">function</span> <span style="color: #00ffff;">interface</span>{}, <span style="color: #eedd82;">inPlace</span> <span style="color: #98fb98;">bool</span>) (<span style="color: #00ffff;">interface</span>{}, <span style="color: #98fb98;">int</span>) {

             <span style="color: #eedd82;">sliceInType</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(slice)
             <span style="color: #00ffff;">if</span> sliceInType.<span style="color: #87cefa;">Kind</span>() != reflect.Slice {
                     <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"filter: wrong type, not a slice"</span>)
             }

             <span style="color: #eedd82;">fn</span> := reflect.<span style="color: #87cefa;">ValueOf</span>(function)
             <span style="color: #eedd82;">elemType</span> := sliceInType.<span style="color: #87cefa;">Type</span>().<span style="color: #87cefa;">Elem</span>()
             <span style="color: #00ffff;">if</span> !<span style="color: #87cefa;">verifyFuncSignature</span>(fn, elemType, boolType) {
                     <span style="color: #b0c4de;">panic</span>(<span style="color: #ffa07a;">"filter: function must be of type func("</span> + elemType.<span style="color: #87cefa;">String</span>() + <span style="color: #ffa07a;">") bool"</span>)
             }

             <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">which</span> []<span style="color: #98fb98;">int</span>
             <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span> := 0; i &lt; sliceInType.<span style="color: #87cefa;">Len</span>(); i++ {
                     <span style="color: #00ffff;">if</span> fn.<span style="color: #87cefa;">Call</span>([]<span style="color: #98fb98;">reflect.Value</span>{sliceInType.<span style="color: #87cefa;">Index</span>(i)})[0].<span style="color: #87cefa;">Bool</span>() {
                             which = <span style="color: #b0c4de;">append</span>(which, i)
                     }
             }

             <span style="color: #eedd82;">out</span> := sliceInType

             <span style="color: #00ffff;">if</span> !inPlace {
                     out = reflect.<span style="color: #87cefa;">MakeSlice</span>(sliceInType.<span style="color: #87cefa;">Type</span>(), <span style="color: #b0c4de;">len</span>(which), <span style="color: #b0c4de;">len</span>(which))
             }
             <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span> := <span style="color: #00ffff;">range</span> which {
                     out.<span style="color: #87cefa;">Index</span>(i).<span style="color: #87cefa;">Set</span>(sliceInType.<span style="color: #87cefa;">Index</span>(which[i]))
             }

             <span style="color: #00ffff;">return</span> out.<span style="color: #87cefa;">Interface</span>(), <span style="color: #b0c4de;">len</span>(which)
}
</pre>
</div>

<pre class="example" id="org661ad5b">
1. 使用反射来做这些东西，会有一个问题，那就是代码的性能会很差。所以，上面的代码不能用于需要高性能的地方

2. 上面的代码大量的参考了 Rob Pike的版本，他的代码在 https://github.com/robpike/filter

3. 其实，在全世界范围内，有大量的程序员都在问Go语言官方什么时候在标准库中支持 Map/Reduce，Rob Pike说，这种东西难写吗？还要官方来帮你们写么？这种代码我多少年前就写过了，但是，我从来一次都没有用过，我还是喜欢用“For循环”，我觉得你最好也跟我一起用 “For循环” 
</pre>

<p>
<a href="code_generation.html">Next：代码生成器</a>
</p>

<p>
<a href="proxy.html">Previous：委托模式</a> 
</p>

<p>
<a href="go-patterns.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
