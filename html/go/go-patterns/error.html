<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>错误处理</title>
<meta name="author" content="Wu, Shanliang" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="basic.html"> UP </a>
 |
 <a accesskey="H" href="go-patterns.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">错误处理</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge915292">C</a></li>
<li><a href="#org259af9e">Java</a></li>
<li><a href="#org3cf1c26">Go</a>
<ul>
<li><a href="#org63a3f7b">错误检查噩梦</a></li>
<li><a href="#org8017842">包装错误</a></li>
</ul>
</li>
<li><a href="#orgdf1f09f">资源清理</a></li>
</ul>
</div>
</div>
<pre class="example" id="org033ea67">
错误处理一直以一是编程必需要面对的问题，错误处理如果做的好的话，代码的稳定性会很好

不同的语言有不同的出现处理的方式，Go语言也一样
</pre>

<p>
在本篇文章中讨论一下Go语言的出错出处，尤其是那令人抓狂的 if err != nil 
</p>

<pre class="example" id="orgdd904fa">
在正式讨论Go代码里满屏的 if err != nil 怎么办这个事之前，想先说一说编程中的错误处理

这样可以在更高的层面理解编程中的错误处理
</pre>
<div id="outline-container-orge915292" class="outline-2">
<h2 id="orge915292">C</h2>
<div class="outline-text-2" id="text-orge915292">
<p>
首先，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如 C 语言，基本上来说：
</p>
<ul class="org-ul">
<li>通过 <span class="underline">函数的返回值标识</span> 是否有错</li>
<li>通过 <b>全局的 errno 变量</b> 并配合一个 <span class="underline">errstr 的数组</span> 来告诉为什么出错</li>
</ul>

<pre class="example" id="orge97cbff">
为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协

比如：read(), write(), open() 这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如 open() 返回的文件句柄指针 FILE* ，或是错误 NULL

这样会导致调用者并不知道是什么原因出错了，需要去检查 errno 来获得出错的原因，从而可以正确地处理错误
</pre>

<p>
一般而言，这样的错误处理方式在大多数情况下是没什么问题的。但是也有例外的情况，来看一下下面这个 C 语言的函数：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">atoi</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>)
</pre>
</div>

<p>
这个函数是把一个字符串转成整型
</p>

<pre class="example" id="org99f47b1">
但是问题来了，如果一个要传的字符串是非法的（不是数字的格式），如 “ABC” 或者整型溢出了，那么这个函数应该返回什么呢？

出错返回，返回什么数都不合理，因为这会和正常的结果混淆在一起

比如，返回 0，那么会和正常的对 “0” 字符的返回值完全混淆在一起。这样就无法判断出错的情况

</pre>
<p>
可能会说，是不是要检查一下 errno，按道理说应该是要去检查的，但是，在 C99 的规格说明书中可以看到这样的描述：
</p>

<pre class="example" id="org6a2d6cd">
7.20.1 The functions atof, atoi, atol, and atoll need not affect the value of the integer expression errno on an error. If the value of the result cannot be represented, the behavior is undefined.
</pre>

<p>
像atoi(), atof(), atol() 或是 atoll() 这样的函数是不会设置 errno的，而且还说了，如果结果无法计算的话，行为是undefined。所以，后来 libc 又给出了一个新的函数strtol()，这个函数在出错的时会设置全局变量 errno ：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">long</span> <span style="color: #eedd82;">val</span> = strtol(in_str, &amp;endptr, 10);  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">10&#30340;&#24847;&#24605;&#26159;10&#36827;&#21046;</span>
<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#26080;&#27861;&#36716;&#25442;</span>
<span style="color: #00ffff;">if</span> (endptr == str) {
          fprintf(stderr, <span style="color: #ffa07a;">"No digits were found\n"</span>);
          exit(EXIT_FAILURE);
}

<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#25972;&#22411;&#28322;&#20986;&#20102;</span>
<span style="color: #00ffff;">if</span> (errno == ERANGE &amp;&amp; (val == LONG_MAX || val == LONG_MIN)) {
          fprintf(stderr, <span style="color: #ffa07a;">"ERROR: number out of range for LONG\n"</span>);
          exit(EXIT_FAILURE);
}

<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#26159;&#20854;&#23427;&#38169;&#35823;</span>
<span style="color: #00ffff;">if</span> (errno != 0 &amp;&amp; val == 0) {
          perror(<span style="color: #ffa07a;">"strtol"</span>);
          exit(EXIT_FAILURE);
}        
</pre>
</div>

<pre class="example" id="org3c67426">
虽然，strtol() 函数解决了 atoi() 函数的问题，但是还是能感觉到不是很舒服和自然
</pre>

<p>
因为，这种用 返回值 + errno 的错误检查方式会有一些问题:
</p>
<ul class="org-ul">
<li>程序员一不小心就会忘记返回值的检查，从而造成代码的 Bug</li>
<li>函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。</li>
</ul>

<p>
所以后来，有一些类库就开始区分这样的事情。比如，Windows 的系统调用开始使用 HRESULT 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误
</p>
<pre class="example" id="org7aac845">
但这样一来，函数的 input 和 output 只能通过函数的参数来完成，于是出现了所谓的 入参 和 出参这样的区别

然而这又使得函数接入中参数的语义变得复杂，一些参数是入参，一些参数是出参，函数接口变得复杂了一些

而且依然没有解决函数的成功或失败可以被人为忽略的问题
</pre>
</div>
</div>
<div id="outline-container-org259af9e" class="outline-2">
<h2 id="org259af9e">Java</h2>
<div class="outline-text-2" id="text-org259af9e">
<p>
Java语言使用 <span class="underline">try-catch-finally</span> 通过使用异常的方式来处理错误，这比起C语言的错处理进了一大步，使用抛异常和抓异常的方式可以让代码有这样的一些好处：
</p>
<ul class="org-ul">
<li>函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的</li>
<li>正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性</li>
<li>异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）</li>
<li>在面向对象的语言中（如 Java），异常是个对象，可以实现多态式的 catch</li>
<li>与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。比如：</li>
</ul>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = add(a, div(b,c));

<span style="color: #98fb98;">Pizza</span> <span style="color: #eedd82;">p</span> = PizzaBuilder().SetSize(sz).SetPrice(p);
</pre>
</div>
</div>
</div>
<div id="outline-container-org3cf1c26" class="outline-2">
<h2 id="org3cf1c26">Go</h2>
<div class="outline-text-2" id="text-org3cf1c26">
<p>
Go 语言的函数支持多返回值，所以，可以在返回接口把业务语义（业务返回值）和控制语义（出错返回值）区分开来。Go 语言的很多函数都会返回 <span class="underline">result, err</span> 两个值，于是:
</p>
<ul class="org-ul">
<li>参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰</li>
<li>Go 语言中的错误参数如果要忽略，需要显式地忽略，用 _ 这样的变量来忽略</li>
<li>因为返回的 error 是个接口（其中只有一个方法 Error()，返回一个 string ），所以可以扩展自定义的错误处理</li>
</ul>

<p>
另外，如果一个函数返回了多个不同类型的 error，可以使用下面这样的方式：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
  <span style="color: #00ffff;">switch</span> err.(<span style="color: #00ffff;">type</span>) {
    <span style="color: #00ffff;">case</span> *<span style="color: #98fb98;">json.SyntaxError</span>:
        ...
    <span style="color: #00ffff;">case</span> *<span style="color: #98fb98;">ZeroDivisionError</span>:
        ...
    <span style="color: #00ffff;">case</span> *<span style="color: #98fb98;">NullPointerError</span>:
        ...
    <span style="color: #00ffff;">default</span>:
        ...
  }
}
</pre>
</div>

<pre class="example" id="org5c931e8">
Go语言的错误处理的的方式，本质上是返回值检查，但是也兼顾了异常的一些好处：对错误的扩展
</pre>
</div>
<div id="outline-container-org63a3f7b" class="outline-3">
<h3 id="org63a3f7b">错误检查噩梦</h3>
<div class="outline-text-3" id="text-org63a3f7b">
<pre class="example" id="org6496f8a">
好了，说到 Go 语言的 if err !=nil 的代码了，这样的代码的确是能让人写到吐。那么有没有什么好的方式呢
</pre>
<p>
先看如下的一个令人崩溃的代码：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">parse</span>(<span style="color: #eedd82;">r</span> <span style="color: #98fb98;">io.Reader</span>) (*<span style="color: #98fb98;">Point</span>, <span style="color: #98fb98;">error</span>) {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">p</span> <span style="color: #98fb98;">Point</span>

          <span style="color: #00ffff;">if</span> <span style="color: #eedd82;">err</span> := binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, &amp;p.Longitude); err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">nil</span>, err
          }
          <span style="color: #00ffff;">if</span> <span style="color: #eedd82;">err</span> := binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, &amp;p.Latitude); err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">nil</span>, err
          }
          <span style="color: #00ffff;">if</span> <span style="color: #eedd82;">err</span> := binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, &amp;p.Distance); err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">nil</span>, err
          }
          <span style="color: #00ffff;">if</span> <span style="color: #eedd82;">err</span> := binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, &amp;p.ElevationGain); err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">nil</span>, err
          }
          <span style="color: #00ffff;">if</span> <span style="color: #eedd82;">err</span> := binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, &amp;p.ElevationLoss); err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">nil</span>, err
          }
}
</pre>
</div>

<p>
要解决这个事，可以用函数式编程的方式，如下代码示例：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">parse</span>(<span style="color: #eedd82;">r</span> <span style="color: #98fb98;">io.Reader</span>) (*<span style="color: #98fb98;">Point</span>, <span style="color: #98fb98;">error</span>) {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">p</span> <span style="color: #98fb98;">Point</span>
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">err</span> <span style="color: #98fb98;">error</span>
          <span style="color: #eedd82;">read</span> := <span style="color: #00ffff;">func</span>(<span style="color: #eedd82;">data</span> <span style="color: #00ffff;">interface</span>{}) {
                  <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                          <span style="color: #00ffff;">return</span>
                  }
                  err = binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, data)
          }

          <span style="color: #87cefa;">read</span>(&amp;p.Longitude)
          <span style="color: #87cefa;">read</span>(&amp;p.Latitude)
          <span style="color: #87cefa;">read</span>(&amp;p.Distance)
          <span style="color: #87cefa;">read</span>(&amp;p.ElevationGain)
          <span style="color: #87cefa;">read</span>(&amp;p.ElevationLoss)

          <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> &amp;p, err
          }
          <span style="color: #00ffff;">return</span> &amp;p, <span style="color: #7fffd4;">nil</span>
}
</pre>
</div>

<p>
通过使用 <span class="underline">闭包</span> 的方式把相同的代码给抽出来重新定义一个函数，这样大量的  if err!=nil 处理的很干净了
</p>
<pre class="example" id="orgbdf3926">
但是会带来一个问题，那就是有一个 err 变量和一个内部的函数，感觉不是很干净 
</pre>

<p>
从Go 语言的 bufio.Scanner()中似乎可以学习到一些东西：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #eedd82;">scanner</span> := bufio.<span style="color: #87cefa;">NewScanner</span>(input)

<span style="color: #00ffff;">for</span> scanner.<span style="color: #87cefa;">Scan</span>() {
    <span style="color: #eedd82;">token</span> := scanner.<span style="color: #87cefa;">Text</span>()
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">process token</span>
}

<span style="color: #00ffff;">if</span> <span style="color: #eedd82;">err</span> := scanner.<span style="color: #87cefa;">Err</span>(); err != <span style="color: #7fffd4;">nil</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">process the error</span>
}
</pre>
</div>

<pre class="example" id="org27ea498">
scanner在操作底层的I/O的时候，那个for-loop中没有任何的 if err !=nil 的情况，退出循环后有一个 scanner.Err() 的检查
</pre>

<p>
这是使用了 <span class="underline">结构体</span> 的方式。现在来模仿它，首先定义一个结构体和函数： 
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Reader</span> <span style="color: #00ffff;">struct</span> {
          r   <span style="color: #98fb98;">io.Reader</span>
          err <span style="color: #98fb98;">error</span>
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">r</span> *<span style="color: #98fb98;">Reader</span>) <span style="color: #87cefa;">read</span>(<span style="color: #eedd82;">data</span> <span style="color: #00ffff;">interface</span>{}) {
          <span style="color: #00ffff;">if</span> r.err == <span style="color: #7fffd4;">nil</span> {
                  r.err = binary.<span style="color: #87cefa;">Read</span>(r.r, binary.BigEndian, data)
          }
}
</pre>
</div>

<p>
然后代码就可以变成下面这样：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">parse</span>(<span style="color: #eedd82;">input</span> <span style="color: #98fb98;">io.Reader</span>) (*<span style="color: #98fb98;">Point</span>, <span style="color: #98fb98;">error</span>) {
          <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">p</span> <span style="color: #98fb98;">Point</span>
          <span style="color: #eedd82;">r</span> := <span style="color: #98fb98;">Reader</span>{<span style="color: #7fffd4;">r</span>: input}

          r.<span style="color: #87cefa;">read</span>(&amp;p.Longitude)
          r.<span style="color: #87cefa;">read</span>(&amp;p.Latitude)
          r.<span style="color: #87cefa;">read</span>(&amp;p.Distance)
          r.<span style="color: #87cefa;">read</span>(&amp;p.ElevationGain)
          r.<span style="color: #87cefa;">read</span>(&amp;p.ElevationLoss)

          <span style="color: #00ffff;">if</span> r.err != <span style="color: #7fffd4;">nil</span> {
                  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">nil</span>, r.err
          }

          <span style="color: #00ffff;">return</span> &amp;p, <span style="color: #7fffd4;">nil</span>
}
</pre>
</div>

<p>
有了上面这个技术，我们的 <span class="underline">流式接口</span> ，也就很容易处理了。如下所示：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">package</span> main

<span style="color: #00ffff;">import</span> (
          <span style="color: #ffa07a;">"bytes"</span>
          <span style="color: #ffa07a;">"encoding/binary"</span>
          <span style="color: #ffa07a;">"fmt"</span>
)

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38271;&#24230;&#19981;&#22815;&#65292;&#23569;&#19968;&#20010;Weight</span>
<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">b</span> = []<span style="color: #98fb98;">byte</span> {0x48, 0x61, 0x6f, 0x20, 0x43, 0x68, 0x65, 0x6e, 0x00, 0x00, 0x2c} 
<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">r</span> = bytes.<span style="color: #87cefa;">NewReader</span>(b)

<span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Person</span> <span style="color: #00ffff;">struct</span> {
          Name [10]<span style="color: #98fb98;">byte</span>
          Age <span style="color: #98fb98;">uint8</span>
          Weight <span style="color: #98fb98;">uint8</span>
          err <span style="color: #98fb98;">error</span>
}
<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">p</span> *<span style="color: #98fb98;">Person</span>) <span style="color: #87cefa;">read</span>(<span style="color: #eedd82;">data</span> <span style="color: #00ffff;">interface</span>{}) {
          <span style="color: #00ffff;">if</span> p.err == <span style="color: #7fffd4;">nil</span> {
                  p.err = binary.<span style="color: #87cefa;">Read</span>(r, binary.BigEndian, data)
          }
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">p</span> *<span style="color: #98fb98;">Person</span>) <span style="color: #87cefa;">ReadName</span>() *<span style="color: #98fb98;">Person</span> {
          p.<span style="color: #87cefa;">read</span>(&amp;p.Name) 
          <span style="color: #00ffff;">return</span> p
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">p</span> *<span style="color: #98fb98;">Person</span>) <span style="color: #87cefa;">ReadAge</span>() *<span style="color: #98fb98;">Person</span> {
          p.<span style="color: #87cefa;">read</span>(&amp;p.Age) 
          <span style="color: #00ffff;">return</span> p
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">p</span> *<span style="color: #98fb98;">Person</span>) <span style="color: #87cefa;">ReadWeight</span>() *<span style="color: #98fb98;">Person</span> {
          p.<span style="color: #87cefa;">read</span>(&amp;p.Weight) 
          <span style="color: #00ffff;">return</span> p
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">p</span> *<span style="color: #98fb98;">Person</span>) <span style="color: #87cefa;">Print</span>() *<span style="color: #98fb98;">Person</span> {
          <span style="color: #00ffff;">if</span> p.err == <span style="color: #7fffd4;">nil</span> {
                  fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"Name=%s, Age=%d, Weight=%d\n"</span>,p.Name, p.Age, p.Weight)
          }
          <span style="color: #00ffff;">return</span> p
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">main</span>() {   
          <span style="color: #eedd82;">p</span> := <span style="color: #98fb98;">Person</span>{}
          p.<span style="color: #87cefa;">ReadName</span>().<span style="color: #87cefa;">ReadAge</span>().<span style="color: #87cefa;">ReadWeight</span>().<span style="color: #87cefa;">Print</span>()
          fmt.<span style="color: #87cefa;">Println</span>(p.err)  <span style="color: #ff4500;">// </span><span style="color: #ff4500;">EOF &#38169;&#35823;</span>
}
</pre>
</div>

<pre class="example" id="org6468b61">
但是，其使用场景也就只能在对于同一个业务对象的不断操作下可以简化错误处理

对于多个业务对象的话，还是得需要各种 if err != nil的方式
</pre>
</div>
</div>
<div id="outline-container-org8017842" class="outline-3">
<h3 id="org8017842">包装错误</h3>
<div class="outline-text-3" id="text-org8017842">
<pre class="example" id="org795c2b0">
最后，需要包装一下错误，而不是干巴巴地把err给返回到上层，而是把一些执行的上下文加入
</pre>

<p>
通常来说，会使用 <span class="underline">fmt.Errorf()</span> 来完成这个事，比如：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
          <span style="color: #00ffff;">return</span> fmt.<span style="color: #87cefa;">Errorf</span>(<span style="color: #ffa07a;">"something failed: %v"</span>, err)
}
</pre>
</div>

<p>
另外，在Go语言的开发者中，更为普遍的做法是将 <span class="underline">错误</span> <b>包装</b> 在 <span class="underline">另一个错误</span> 中，同时 <b>保留</b> <span class="underline">原始内容</span> ：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">authorizationError</span> <span style="color: #00ffff;">struct</span> {
          operation <span style="color: #98fb98;">string</span>
          err <span style="color: #98fb98;">error</span>   <span style="color: #ff4500;">// </span><span style="color: #ff4500;">original error</span>
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">authorizationError</span>) <span style="color: #87cefa;">Error</span>() <span style="color: #98fb98;">string</span> {
          <span style="color: #00ffff;">return</span> fmt.<span style="color: #87cefa;">Sprintf</span>(<span style="color: #ffa07a;">"authorization failed during %s: %v"</span>, e.operation, e.err)
}
</pre>
</div>

<p>
当然，更好的方式是通过一种标准的访问方法，这样，最好使用一个接口，比如 causer接口中实现 Cause() 方法来暴露原始错误，以供进一步检查：
</p>

<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">causer</span> <span style="color: #00ffff;">interface</span> {
          <span style="color: #87cefa;">Cause</span>() <span style="color: #98fb98;">error</span>
}

<span style="color: #00ffff;">func</span> (<span style="color: #eedd82;">e</span> *<span style="color: #98fb98;">authorizationError</span>) <span style="color: #87cefa;">Cause</span>() <span style="color: #98fb98;">error</span> {
          <span style="color: #00ffff;">return</span> e.err
}
</pre>
</div>

<p>
这里有个好消息是，这样的代码不必再写了，有一个第三方的错误库 <span class="underline">github.com/pkg/errors</span> 
</p>
<pre class="example" id="org05d03b5">
对于这个库，无论到哪都能看到他的存在，所以，这个基本上来说就是事实上的标准了
</pre>

<p>
代码示例如下：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">import</span> <span style="color: #ffa07a;">"github.com/pkg/errors"</span>

<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#38169;&#35823;&#21253;&#35013;</span>
<span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
          <span style="color: #00ffff;">return</span> errors.<span style="color: #87cefa;">Wrap</span>(err, <span style="color: #ffa07a;">"read failed"</span>)
}

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">Cause&#25509;&#21475;</span>
<span style="color: #00ffff;">switch</span> <span style="color: #eedd82;">err</span> := errors.<span style="color: #87cefa;">Cause</span>(err).(<span style="color: #00ffff;">type</span>) {
<span style="color: #00ffff;">case</span> *<span style="color: #98fb98;">MyError</span>:
          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">handle specifically</span>
<span style="color: #00ffff;">default</span>:
          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">unknown error</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdf1f09f" class="outline-2">
<h2 id="orgdf1f09f">资源清理</h2>
<div class="outline-text-2" id="text-orgdf1f09f">
<p>
出错后是需要做资源清理的，不同的编程语言有不同的资源清理的编程模式：
</p>
<ul class="org-ul">
<li>C：使用的是 <span class="underline">goto fail;</span> 的方式到一个集中的地方进行清理</li>
<li>C++：一般来说使用 <span class="underline">RAII</span> 模式，通过面向对象的 <b>代理</b> 模式，把需要清理的资源交给一个 <span class="underline">代理类</span> ，然后在 <span class="underline">析构函数</span> 来解决</li>
<li>Java：可以在 <span class="underline">finally</span> 语句块里进行清理</li>
<li>Go：使用 <span class="underline">defer</span> 关键词进行清理</li>
</ul>

<p>
下面是一个Go语言的资源清理的示例：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Close</span>(<span style="color: #eedd82;">c</span> <span style="color: #98fb98;">io.Closer</span>) {
          <span style="color: #eedd82;">err</span> := c.<span style="color: #87cefa;">Close</span>()
          <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                  log.<span style="color: #87cefa;">Fatal</span>(err)
          }
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">main</span>() {
          <span style="color: #eedd82;">r</span>, <span style="color: #eedd82;">err</span> := <span style="color: #87cefa;">Open</span>(<span style="color: #ffa07a;">"a"</span>)
          <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                  log.<span style="color: #87cefa;">Fatalf</span>(<span style="color: #ffa07a;">"error opening 'a'\n"</span>)
          }
          <span style="color: #00ffff;">defer</span> <span style="color: #87cefa;">Close</span>(r) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20351;&#29992;defer&#20851;&#38190;&#23383;&#22312;&#20989;&#25968;&#36864;&#20986;&#26102;&#20851;&#38381;&#25991;&#20214;&#12290;</span>

          r, err = <span style="color: #87cefa;">Open</span>(<span style="color: #ffa07a;">"b"</span>)
          <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                  log.<span style="color: #87cefa;">Fatalf</span>(<span style="color: #ffa07a;">"error opening 'b'\n"</span>)
          }
          <span style="color: #00ffff;">defer</span> <span style="color: #87cefa;">Close</span>(r) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20351;&#29992;defer&#20851;&#38190;&#23383;&#22312;&#20989;&#25968;&#36864;&#20986;&#26102;&#20851;&#38381;&#25991;&#20214;&#12290;</span>
}
</pre>
</div>

<p>
<a href="function.html">Next：函数式配置</a>
</p>

<p>
<a href="basic.html">Previous：基础概念</a>
</p>

<p>
<a href="go-patterns.html">Home：目录</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
