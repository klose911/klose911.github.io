<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>分布式编程</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="error_handle.html"> UP </a>
 |
 <a accesskey="H" href="concurrency.html"> HOME </a>
</div><div id="content">
<h1 class="title">分布式编程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb16d51e">分布式模型</a></li>
<li><a href="#orgdf48b68">编写分布式程序</a>
<ul>
<li><a href="#org8be42df">创建名称服务器</a>
<ul>
<li><a href="#orgf42aae7">简单的名称服务器</a></li>
<li><a href="#orgd61143f">客户端在一个节点,服务器在相同主机的另一个节点</a></li>
<li><a href="#org7764c9e">同一局域网内不同机器上的客户端和服务器</a></li>
<li><a href="#org0f8da30">跨互联网不同主机上的客户端和服务器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7199074">分布式编程的库和内置函数</a>
<ul>
<li><a href="#orgfff63dd">rpc 模块</a>
<ul>
<li><a href="#org29afb4c">远程创建进程</a></li>
<li><a href="#orgcfca20c">远程连接</a></li>
<li><a href="#orgbb15f93">断开连接</a></li>
<li><a href="#orgacd9080">远程监视</a></li>
<li><a href="#org818795e">节点管理</a></li>
<li><a href="#org1965886">远程消息</a></li>
</ul>
</li>
<li><a href="#org9efd5f6">实例</a>
<ul>
<li><a href="#org829c489">文件操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4ef1a79">cookie 保护系统</a>
<ul>
<li><a href="#orgd034db9">设置 Cookie</a>
<ul>
<li><a href="#orgfd49e32">文件系统</a></li>
<li><a href="#orgbf6d503">启动参数</a></li>
<li><a href="#org1f9a460">内置函数</a></li>
</ul>
</li>
<li><a href="#orgf8cee1e">安全性</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  用Erlang编写分布式程序和编写并发程序只有一步之遥
</pre>

<p>
在分布式Erlang里,可以在远程节点和机器上创建进程。创建出远程进程之后,会看到其他所有的基本函数( send 、 receive和 link 等)都能透明运作在网络中,就像在单个节点上一样
</p>

<pre class="example">
  在本章将介绍用于编写分布式Erlang程序的库与Erlang基本函数
</pre>

<p>
<span class="underline">分布式</span> 程序是那些被设计运行在 <span class="underline">计算机网络</span> 上的程序,并且可以仅靠 <span class="underline">传递消息</span> 来协调彼此的活动。下面是一些想要编写分布式应用程序的原因：
</p>
<ul class="org-ul">
<li><span class="underline">性能</span> ：可以通过安排程序的不同部分在不同的机器上并行运行来让程序跑得更快</li>
<li><span class="underline">可靠性</span> ：可以通过让系统运行在数台机器上来实现容错式系统。如果一台机器出了故障,可以在另一台机器上继续</li>
<li><span class="underline">可扩展性</span> ：随着把应用程序越做越大,即使机器的处理能力再强大也迟早会耗尽。到那时,就必须添加更多的机器来提升处理能力。添加一台新机器应当是一次简单的操作,不需要对应用程序的架构做出大的修改</li>
<li><span class="underline">天生分布式</span> ：许多应用程序天生就是分布式的。如果编写一个多用户游戏或聊天系统,就会有来自世界各地的分散用户。如果在某个地理位置上拥有大量的用户,就会希望把计算资源放置在接近这些用户的地方</li>
<li>fun：我想要编写的fun程序大部分都是分布式的。其中许多涉及与全世界各地的人与机器进行交互</li>
</ul>
<div id="outline-container-orgb16d51e" class="outline-2">
<h2 id="orgb16d51e">分布式模型</h2>
<div class="outline-text-2" id="text-orgb16d51e">
<p>
这里将讨论两种主要的分布式模型：
</p>
<ol class="org-ol">
<li>分布式Erlang：在分布式Erlang里,编写的程序会在Erlang的 <b>节点</b> ( <span class="underline">node</span> )上运行
<ul class="org-ul">
<li>节点：一个独立的Erlang系统,包含一个 <span class="underline">自带地址空间</span> 和 <span class="underline">进程组</span> 的 <b>完整虚拟机</b> 
<ul class="org-ul">
<li>可以在任何节点上创建进程,所有消息传递和错误处理基本函数也都能像在单节点上那样工作</li>
</ul></li>
<li>分布式Erlang应用程序运行在一个 <b>可信环境</b> 中。因为任何节点都可以在其他Erlang节点上执行任意操作,所以这涉及高度的信任
<ul class="org-ul">
<li>虽然分布式Erlang应用程序可以运行在开放式网络上,但它们通常是运行在属于同一个 <span class="underline">局域网的集群</span> 上,并受 <span class="underline">防火墙</span> 保护</li>
</ul></li>
</ul></li>
<li>基于套接字：可以用TCP/IP套接字来编写运行在不可信环境中的分布式应用程序
<ul class="org-ul">
<li>这个编程模型不如分布式Erlang那样强大,但是更安全</li>
</ul></li>
</ol>

<pre class="example">
    如果回想一下前面的内容,就一定还记得构建程序的基本单位是进程。编写分布式Erlang程序是很容易的,要做的就是在正确的机器上创建出进程,然后一切就能像之前那样运作了

    人们都习惯了编写顺序程序,而编写分布式程序通常会困难得多。下面将介绍编写简单分布式程序的若干技巧。这些程序很简单,但是非常有用
</pre>

<p>
接下来将从一些小范例起步。只需先学习两件事,就可以开始创建第一个分布式程序了：
</p>
<ul class="org-ul">
<li>如何启动一个Erlang节点</li>
<li>如何在远程Erlang节点上执行远程过程调用</li>
</ul>
</div>
</div>
<div id="outline-container-orgdf48b68" class="outline-2">
<h2 id="orgdf48b68">编写分布式程序</h2>
<div class="outline-text-2" id="text-orgdf48b68">
<p>
当开发一个分布式应用程序时,总是会按照特定的顺序来编写它：
</p>
<ol class="org-ol">
<li>在一个 <span class="underline">常规的非分布式</span> 会话里编写和测试我的程序：这是我们到目前为止一直在做的,所以不会有什么新问题</li>
<li>在运行于 <span class="underline">同一台计算机</span> 上的 <span class="underline">两个不同的Erlang节点</span> 里测试程序</li>
<li>在运行于 <span class="underline">两台物理隔离计算机</span> 上的 <span class="underline">两个不同的Erlang节点</span> 里测试程序,这两台计算机或者属于同一个局域网,或者来自互联网的任何地方</li>
<li>如果所运行的机器属于 <span class="underline">相同的管理域</span> ,就很少会出问题
<ul class="org-ul">
<li>但当相关节点属于 <span class="underline">不同域上</span> 的机器时,就可能会遇到 <b>连接性</b> 问题,而且必须确保系统 <span class="underline">防火墙</span> 和 <span class="underline">安全设置</span> 都已得到正确配置</li>
</ul></li>
</ol>

<pre class="example">
    为了演示这些步骤,将制作一个简单的名称服务器(name server)
</pre>
<p>
具体而言,将执行下列步骤：
</p>
<ul class="org-ul">
<li>第1阶段：在一个常规的非分布式Erlang系统上编写和测试名称服务器</li>
<li>第2阶段：在同一台机器的两个节点上测试名称服务器</li>
<li>第3阶段：在同一局域网内分属两台不同机器的节点上测试名称服务器</li>
<li>第4阶段：在分属两个不同国家和域的两台机器上测试名称服务器</li>
</ul>
</div>
<div id="outline-container-org8be42df" class="outline-3">
<h3 id="org8be42df">创建名称服务器</h3>
<div class="outline-text-3" id="text-org8be42df">
<p>
<span class="underline">名称服务器</span> 这种程序会返回一个给定名称的关联值。也可以修改某个名称所关联的值 
</p>
<pre class="example">
     我们的第一个名称服务器极其简单。它不是容错式的，所以如果它崩溃了，保存的数据就会全部丢失

     这个练习的目的不是创建一个容错式名称服务器，而是开始运用分布式编程的技巧
</pre>
</div>
<div id="outline-container-orgf42aae7" class="outline-4">
<h4 id="orgf42aae7">简单的名称服务器</h4>
<div class="outline-text-4" id="text-orgf42aae7">
<p>
我们的名称服务器 kvs 是一个简单的 Key &#x2013;&gt; Value 服务器，它的接口如下：
</p>
<ul class="org-ul">
<li>启动服务器，它将创建一个注册名为 kvs 的服务器：</li>
</ul>
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #98fb98;">kvs</span>:<span style="color: #98fb98;">start</span>() -&gt;<span style="color: #87cefa;"> </span>true 
</pre>
</div>
<ul class="org-ul">
<li>关联 Key 和 Value</li>
</ul>
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #98fb98;">kvs</span>:<span style="color: #98fb98;">store</span>(<span style="color: #eedd82;">Key</span>, <span style="color: #eedd82;">Value</span>) -&gt;<span style="color: #87cefa;"> </span>true 
</pre>
</div>
<ul class="org-ul">
<li>查询 Key 的值：如果 Key 带有关联值就返回 {ok, Value} ，否则返回 undefined</li>
</ul>
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #98fb98;">kvs</span>:<span style="color: #98fb98;">lookup</span>(<span style="color: #eedd82;">Key</span>) -&gt;<span style="color: #87cefa;"> </span>{ok, <span style="color: #eedd82;">Value</span>} | undefined 
</pre>
</div>

<p>
这个键-值服务器是用进程字典里的基本函数 get 和 put 实现的，它的代码如下：
</p>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-module</span>(kvs).
<span style="color: #7fffd4;">-export</span>([<span style="color: #98fb98;">start/0</span>, <span style="color: #98fb98;">store/2</span>, <span style="color: #98fb98;">lookup/1</span>]).

<span style="color: #87cefa;">start</span>() -&gt;<span style="color: #87cefa;"> </span><span style="color: #b0c4de;">register</span>(kvs, <span style="color: #b0c4de;">spawn</span>(<span style="color: #00ffff;">fun</span>() -&gt;<span style="color: #87cefa;"> </span><span style="color: #98fb98;">loop</span>() <span style="color: #00ffff;">end</span>)).

<span style="color: #87cefa;">store</span>(<span style="color: #eedd82;">Key</span>, <span style="color: #eedd82;">Value</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #98fb98;">rpc</span>({store, <span style="color: #eedd82;">Key</span>, <span style="color: #eedd82;">Value</span>}). 

<span style="color: #87cefa;">lookup</span>(<span style="color: #eedd82;">Key</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #98fb98;">rpc</span>({lookup, <span style="color: #eedd82;">Key</span>}). 

<span style="color: #87cefa;">rpc</span>(<span style="color: #eedd82;">Q</span>) -&gt;
    kvs ! {<span style="color: #b0c4de;">self</span>(), <span style="color: #eedd82;">Q</span>},
    <span style="color: #00ffff;">receive</span>
        {kvs, <span style="color: #eedd82;">Reply</span>} -&gt;
            <span style="color: #eedd82;">Reply</span>
    <span style="color: #00ffff;">end</span>.

<span style="color: #87cefa;">loop</span>() -&gt;<span style="color: #87cefa;"> </span> 
    <span style="color: #00ffff;">receive</span>
        {<span style="color: #eedd82;">From</span>, {store, <span style="color: #eedd82;">Key</span>, <span style="color: #eedd82;">Value</span>}} -&gt;<span style="color: #87cefa;"> </span> 
            <span style="color: #b0c4de;">put</span>(<span style="color: #eedd82;">Key</span>, {ok, <span style="color: #eedd82;">Value</span>}),
            <span style="color: #eedd82;">From</span> ! {kvs, true},
            <span style="color: #98fb98;">loop</span>();
        {<span style="color: #eedd82;">From</span>, {lookup, <span style="color: #eedd82;">Key</span>}} -&gt;<span style="color: #87cefa;"> </span>
            <span style="color: #eedd82;">From</span> ! {kvs, <span style="color: #b0c4de;">get</span>(<span style="color: #eedd82;">Key</span>)},
            <span style="color: #98fb98;">loop</span>()
    <span style="color: #00ffff;">end</span>.
</pre>
</div>

<ul class="org-ul">
<li>保存键值的消息在第6行发送，并在第19行接收</li>
<li>主服务器在第17行的 loop 函数中启动：
<ul class="org-ul">
<li>它调用了 receive 并等待一个保存或查询消息</li>
<li>保存数据或从本地进程字典里取出被请求的数据</li>
<li>向客户端发送回复</li>
</ul></li>
</ul>

<p>
先在本地测试这个服务器，看看它是否能正常工作：
</p>

<div class="org-src-container">
<pre class="src src-sh">2&gt; kvs:start() <span style="color: #b0c4de;">.</span> 
true
3&gt; 
3&gt; kvs:store({location, joe}, <span style="color: #ffa07a;">"Stockholm"</span>) <span style="color: #b0c4de;">.</span> 
true
4&gt; 
4&gt; kvs:store(weather, raining) <span style="color: #b0c4de;">.</span> 
true
5&gt; 
5&gt; kvs:lookup(weather) <span style="color: #b0c4de;">.</span> 
{ok,raining}
6&gt; 
6&gt; kvs:lookup({location, joe}) <span style="color: #b0c4de;">.</span>  
{ok,<span style="color: #ffa07a;">"Stockholm"</span>}
7&gt;  
7&gt; kvs:lookup({location, jane}) <span style="color: #b0c4de;">.</span>  
undefined
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd61143f" class="outline-4">
<h4 id="orgd61143f">客户端在一个节点,服务器在相同主机的另一个节点</h4>
<div class="outline-text-4" id="text-orgd61143f">
<pre class="example">
      现在在同一台计算机上启动两个Erlang节点，为此，需要打开两个终端窗口，然后启动两套Erlang系统
</pre>

<p>
首先，将开启一个终端shell，并在这个shell里启动一个名为 gandalf 的分布式Erlang节点。然后启动服务器：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ erl -sname gandalf 
Erlang/OTP 23 [erts-11.1.7] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Eshell V11.1.7  (abort with ^G)
(gandalf@gentoo)1&gt; kvs:start() <span style="color: #b0c4de;">.</span> 
true
</pre>
</div>

<p>
参数 <span class="underline">-sname gandalf</span> 的意思是“在本地主机上启动一个名为 gandalf 的Erlang节点”
</p>

<pre class="example">
      注意以下Erlang shell是如何把Erlang节点名打印在命令提示符前面的

      节点名的形式是 Name@Host ，Name 和 Host 都是原子，所以如果它们包含任何非原子的字符，就必须加上引号
</pre>

<p>
接下来将开启第二个终端会话，然后启动一个名为 bilbo 的Erlang节点。这样就可以用库模块 rpc 来调用 kvs 里的函数了
</p>

<div class="org-src-container">
<pre class="src src-sh">$ erl -sname bilbo 
Erlang/OTP 23 [erts-11.1.7] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Eshell V11.1.7  (abort with ^G)
(bilbo@gentoo)1&gt; rpc:call(gandalf@gentoo, kvs, store, [weather, fine]) <span style="color: #b0c4de;">.</span> 
true
(bilbo@gentoo)2&gt; 
(bilbo@gentoo)2&gt; rpc:call(gandalf@gentoo, kvs, lookup, [weather]) <span style="color: #b0c4de;">.</span>      
{ok,fine}
</pre>
</div>

<pre class="example">
      虽然看起来不太起眼，但实际上已经执行了我们的第一次分布式计算：服务器运行在我们启动的第一个节点上，客户端则运行在第二个节点上 
</pre>

<p>
<span class="underline">rpc:call(Node, Mod, Func, [Arg1, Arg2, &#x2026;, ArgN])</span> 会在 <span class="underline">Node</span> 上执行一次 <b>远程过程调用</b> ，调用的函数是 <span class="underline">Mod:Func(Arg1, Arg2, &#x2026;, ArgN)</span> 
</p>

<pre class="example">
      请注意， rpc 是一个标准的Erlang库模块，和之前编写的 rpc 函数不是一回事
</pre>

<p>
设置 weather 值的调用是由 bilbo 节点发出的 ，可以切换回 gandalf 来检查一下天气 (weather) 的值：
</p>

<div class="org-src-container">
<pre class="src src-sh">(gandalf@gentoo)2&gt; kvs:lookup(weather) <span style="color: #b0c4de;">.</span> 
{ok,fine}
</pre>
</div>

<pre class="example">
      如你所见，这个程序的工作方式和非分布式Erlang一致

      唯一的区别在于客户端运行在一个节点上，而服务器运行在另一个不同的节点上
</pre>
</div>
</div>

<div id="outline-container-org7764c9e" class="outline-4">
<h4 id="org7764c9e">同一局域网内不同机器上的客户端和服务器</h4>
<div class="outline-text-4" id="text-org7764c9e">
<p>
下一步是在不同的机器上运行客户端和服务器：
</p>

<pre class="example">
      第一个名为 gandalf 的节点在 gentoo.klose.com 上，第二个名为 bilbo 的节点在 raspberrypi.klose.com 上

      开始工作之前，我们先用ssh或vnc等工具在两台不同的机器上各启动一个终端

      我们把这两个窗口称为doris和george。做完这些之后，就可以在两台机器上轻松输入命令了
</pre>

<p>
首先是在 gentoo 上启动一个Erlang节点：
</p>
<div class="org-src-container">
<pre class="src src-sh">gentoo$ erl -name gandalf@gentoo.klose.com --setcookie abc 
Erlang/OTP 23 [erts-11.1.7] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Eshell V11.1.7  (abort with ^G)
(gandalf@gentoo.klose.com)1&gt; kvs:start() <span style="color: #b0c4de;">.</span> 
true
</pre>
</div>

<p>
接着在 raspberrypi 上启动一个Erlang节点并向 gandalf 发送一些命令：
</p>

<div class="org-src-container">
<pre class="src src-sh">raspberrypi$ erl -name bilbo@raspberrypi.klose.com --setcookie abc 
Erlang/OTP 21 [erts-10.2.4] [source] [smp:4:4] [ds:4:4:10] [async-threads:1]

Eshell V10.2.4  (abort with ^G)
(bilbo@raspberrypi.klose.com)1&gt; rpc:call(<span style="color: #ffa07a;">'gandalf@gentoo.klose.com'</span>, kvs, store, [weather, cold]) <span style="color: #b0c4de;">.</span> 
true
(bilbo@raspberrypi.klose.com)2&gt; 
(bilbo@raspberrypi.klose.com)2&gt; rpc:call(<span style="color: #ffa07a;">'gandalf@gentoo.klose.com'</span>, kvs, lookup, [weather]) <span style="color: #b0c4de;">.</span>       
{ok,cold}
</pre>
</div>

<pre class="example">
      它们的行为和同一机器上两个不同节点的情况完全一致
</pre>

<p>
要实现这一切，我们的操作会比在同一台机器上运行两个节点时略微复杂一些。必须分4步走：
</p>
<ol class="org-ol">
<li>用 <span class="underline">-name</span> 参数启动Erlang：
<ul class="org-ul">
<li>在同一台机器上运行两个节点时使用了“短”名称（通过 -sname 标识体现），当两台机器位于同一个子网时也可以使用 -sname</li>
<li>但如果它们属于不同的网络，就要使用 -name，如果没有DNS服务， -sname 就是唯一可行的方式</li>
</ul></li>
<li>确保两个节点拥有 <b>相同的 cookie</b> ：这正是启动两个节点时都使用命令行参数 -setcookie abc 的原因</li>
<li>确保相关节点的 <span class="underline">完全限定主机名</span> （fully qualified hostname）可以 <b>被DNS解析</b> 
<ul class="org-ul">
<li>对于我来说，域名 klose.com 完全属于我的家庭网络，通过在 /etc/hosts 里添加一个条目来实现本地解析</li>
</ul></li>
<li>确保两个系统拥有 <b>相同版本的代码</b> 和 <b>相同版本的Erlang</b></li>
</ol>

<pre class="example">
      如果不这么做，就可能会得到严重而离奇的错误

      避免问题的最简单的方法是在所有地方都运行相同版本的Erlang

      不同版本的Erlang可以一起运行，但是无法保证能正常工作，所以最好事先检查一下 
</pre>
</div>
</div>

<div id="outline-container-org0f8da30" class="outline-4">
<h4 id="org0f8da30">跨互联网不同主机上的客户端和服务器</h4>
<div class="outline-text-4" id="text-org0f8da30">
<pre class="example">
      原则上，这和第3阶段是一样的，但现在我们必须更加关注安全性。运行同一局域网内的两个节点时，多半不会过于担心安全性

      在大多数机构里，局域网都是通过防火墙与互联网隔离的，可以在防火墙后面自由分配临时IP地址，对机器的设置也很随意
</pre>

<p>
当跨互联网连接Erlang集群里的几台机器时，可以预料到会出现防火墙不允许传入连接的问题，必须正确 <b>配置防火墙</b> ，让它接受传入连接
</p>
<pre class="example">
      这一点没有通用的做法，因为每一种防火墙都是不同的
</pre>

<p>
要让系统准备好运行分布式Erlang，需执行以下步骤：
</p>
<ul class="org-ul">
<li>确保 <span class="underline">4369</span> 端口对 <span class="underline">TCP</span> 和 <span class="underline">UDP</span> 流量都开放。这个端口会被一个名为 <span class="underline">epmd</span> 的程序使用（它是Erlang Port Mapper Daemon的缩写，即Erlang端口映射守护进程）</li>
<li>选择一个或一段连续端口给分布式Erlang使用，并确保这些端口是开放的。如果这些端口位于 Min 和 Max 之间（只想用一个端口就让 Min=Max ），就用以下命令启动 Erlang:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ erl -name ... --setcookie ... -kernerl inet_dist_listen_min MIN <span style="color: #ffa07a;">\</span>
                                         inet_dist_listen_max MAX
</pre>
</div>

<pre class="example">
      现在，已经了解了如何在一组Erlang节点上运行程序，以及如何通过局域网和互联网运行它们

      下面来看看操作节点的基本函数
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7199074" class="outline-2">
<h2 id="org7199074">分布式编程的库和内置函数</h2>
<div class="outline-text-2" id="text-org7199074">
<pre class="example">
    编写分布式程序时很少从头开始。标准库里有许多模块可以用于编写分布式程序

    虽然这些模块是用内置分布式函数编写的，但是它们能对程序员隐藏大量繁琐的细节
</pre>
<p>
标准分发套装里的两个模块能够满足大多数需求。
</p>
<ul class="org-ul">
<li><span class="underline">rpc</span> : 提供了许多 <b>远程过程调用</b> 服务</li>
<li><span class="underline">global</span> : 里的函数可以用来在分布式系统里 <span class="underline">注册名称</span> 和 <span class="underline">加锁</span> ，以及维护一个全连接网络</li>
</ul>
</div>

<div id="outline-container-orgfff63dd" class="outline-3">
<h3 id="orgfff63dd">rpc 模块</h3>
<div class="outline-text-3" id="text-orgfff63dd">
<p>
rpc 模块里最重要的函数就是下面这个。
</p>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #98fb98;">call</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #eedd82;">Mod</span>, <span style="color: #eedd82;">Func</span>, <span style="color: #eedd82;">Args</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #eedd82;">Result</span> | {badrpc, <span style="color: #eedd82;">Reason</span>}
</pre>
</div>
<p>
它会在 Node 上执行 apply(Mod, Func, Args) ，然后：
</p>
<ul class="org-ul">
<li>如果调用成功返回结果 Result</li>
<li>如果调用失败则返回 {badrpc, Reason}</li>
</ul>


<p>
以下是编写分布式程序的基本函数：
</p>
</div>
<div id="outline-container-org29afb4c" class="outline-4">
<h4 id="org29afb4c">远程创建进程</h4>
<div class="outline-text-4" id="text-org29afb4c">
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">spawn</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #eedd82;">Func</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #eedd82;">Pid</span> 
</pre>
</div>

<p>
它的工作方式和 spawn(Func) 完全一致，只是新进程是在 Node 上创建的
</p>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">spawn</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #eedd82;">Mod</span>, <span style="color: #eedd82;">Func</span>, <span style="color: #eedd82;">Args</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #eedd82;">Pid</span>
</pre>
</div>

<p>
它的工作方式和 spawn(Mod, Func, Args) 完全一致，只是新进程是在 Node 上创建的 
</p>

<pre class="example">
      这种形式的 spawn 比 spawn(Node, Func) 更加健壮

      如果运行在多个分布式节点上的特定模块不是完全相同的版本， spawn(Node, Func) 就可能会出错
</pre>
</div>
</div>
<div id="outline-container-orgcfca20c" class="outline-4">
<h4 id="orgcfca20c">远程连接</h4>
<div class="outline-text-4" id="text-orgcfca20c">
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">spawn_link</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #eedd82;">Fun</span>) -&gt;<span style="color: #87cefa;"> </span>true 
</pre>
</div>

<p>
它的工作方式和 spawn_link(Fun) 完全一致，只是新进程是在 Node 上创建的 
</p>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">spawn_link</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #eedd82;">Mod</span>, <span style="color: #eedd82;">Fun</span>, <span style="color: #eedd82;">Args</span>) -&gt;<span style="color: #87cefa;"> </span>true
</pre>
</div>
<p>
它的工作方式类似 spawn(Node, Mod, Fun, Args) ，但是新进程会与当前进程相连 
</p>
</div>
</div>

<div id="outline-container-orgbb15f93" class="outline-4">
<h4 id="orgbb15f93">断开连接</h4>
<div class="outline-text-4" id="text-orgbb15f93">
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">disconnect_node</span>(<span style="color: #eedd82;">Node</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #98fb98;">bool</span>() | ignored 
</pre>
</div>

<p>
它会强制断开与某个节点的连接 
</p>
</div>
</div>

<div id="outline-container-orgacd9080" class="outline-4">
<h4 id="orgacd9080">远程监视</h4>
<div class="outline-text-4" id="text-orgacd9080">
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">monitor_node</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #eedd82;">Flag</span>) -&gt;<span style="color: #87cefa;"> </span>true
</pre>
</div>

<ul class="org-ul">
<li>如果 Flag 是 <span class="underline">true</span> 就会 <b>开启监视</b> 
<ul class="org-ul">
<li>如果开启了监视，那么当Node 加入或离开Erlang互连节点组时，执行这个内置函数的进程就会收到 <span class="underline">{nodeup, Node}</span> 或 <span class="underline">{nodedown, Node}</span> 的消息</li>
</ul></li>
<li>如果 Flag 是 <span class="underline">false</span> 就会 <b>关闭监视</b></li>
</ul>
</div>
</div>

<div id="outline-container-org818795e" class="outline-4">
<h4 id="org818795e">节点管理</h4>
<div class="outline-text-4" id="text-org818795e">
<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">node</span>() -&gt;<span style="color: #87cefa;"> </span><span style="color: #eedd82;">Node</span> 
</pre>
</div>
<p>
它会返回本地节点的名称：
</p>
<ul class="org-ul">
<li>如果节点不是分布式的则会返回 <span class="underline">nonode@nohost</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">node</span>(<span style="color: #eedd82;">Arg</span>) -&gt;<span style="color: #87cefa;"> </span><span style="color: #eedd82;">Node</span> 
</pre>
</div>

<p>
它会返回 Arg 所在的节点：
</p>
<ul class="org-ul">
<li>Arg 可以是 <span class="underline">PID</span> 、 <span class="underline">引用</span> 或者 <span class="underline">端口</span></li>
<li>如果本地节点不是分布式的，则会返回 nonode@nohost</li>
</ul>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">nodes</span>() -&gt;<span style="color: #87cefa;"> </span>[<span style="color: #eedd82;">Nodes</span>] 
</pre>
</div>

<p>
它会返回一个列表，内含网络里其他所有与我们相连的节点 
</p>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-spec</span> <span style="color: #b0c4de;">is_alive</span>() -&gt;<span style="color: #87cefa;"> </span><span style="color: #98fb98;">bool</span>() 
</pre>
</div>

<p>
如果本地节点是活动的，并且可以成为分布式系统的一部分，就返回 true ，否则返回 false 
</p>
</div>
</div>

<div id="outline-container-org1965886" class="outline-4">
<h4 id="org1965886">远程消息</h4>
<div class="outline-text-4" id="text-org1965886">
<p>
send 可以用来向一组分布式Erlang节点里的某个本地注册进程发送消息：
</p>

<div class="org-src-container">
<pre class="src src-erlang">{<span style="color: #eedd82;">Regname</span>, <span style="color: #eedd82;">Node</span>} ! <span style="color: #eedd82;">Msg</span> 
</pre>
</div>
<p>
把消息 Msg 发送给节点 Node 上的注册进程 RegName  
</p>
</div>
</div>
</div>

<div id="outline-container-org9efd5f6" class="outline-3">
<h3 id="org9efd5f6">实例</h3>
<div class="outline-text-3" id="text-org9efd5f6">
<pre class="example">
     作为一个简单的示例，将展示如何在某个远程节点上创建进程
</pre>
<p>
从下面这个程序开始：
</p>

<div class="org-src-container">
<pre class="src src-erlang"><span style="color: #7fffd4;">-module</span>(dist_demo).

<span style="color: #7fffd4;">-export</span>([<span style="color: #98fb98;">rpc/4</span>, <span style="color: #98fb98;">start/1</span>]).

<span style="color: #87cefa;">start</span>(<span style="color: #eedd82;">Node</span>) -&gt;
    <span style="color: #b0c4de;">spawn</span>(<span style="color: #eedd82;">Node</span>, <span style="color: #00ffff;">fun</span>() -&gt;<span style="color: #87cefa;"> </span><span style="color: #98fb98;">loop</span>() <span style="color: #00ffff;">end</span>).

<span style="color: #87cefa;">rpc</span>(<span style="color: #eedd82;">Pid</span>, <span style="color: #eedd82;">M</span>, <span style="color: #eedd82;">F</span>, <span style="color: #eedd82;">A</span>) -&gt;
    <span style="color: #eedd82;">Pid</span> ! {rpc, <span style="color: #b0c4de;">self</span>(), <span style="color: #eedd82;">M</span>, <span style="color: #eedd82;">F</span>, <span style="color: #eedd82;">A</span>},
    <span style="color: #00ffff;">receive</span>
        {<span style="color: #eedd82;">Pid</span>, <span style="color: #eedd82;">Response</span>} -&gt;
            <span style="color: #eedd82;">Response</span>
    <span style="color: #00ffff;">end</span>.

<span style="color: #87cefa;">loop</span>() -&gt;
    <span style="color: #00ffff;">receive</span>
        {rpc, <span style="color: #eedd82;">Pid</span>, <span style="color: #eedd82;">M</span>, <span style="color: #eedd82;">F</span>, <span style="color: #eedd82;">A</span>} -&gt;
            <span style="color: #eedd82;">Pid</span> ! {<span style="color: #b0c4de;">self</span>(), (<span style="color: #00ffff;">catch</span> <span style="color: #b0c4de;">apply</span>(<span style="color: #eedd82;">M</span>, <span style="color: #eedd82;">F</span>, <span style="color: #eedd82;">A</span>))},
            <span style="color: #98fb98;">loop</span>()
    <span style="color: #00ffff;">end</span>.
</pre>
</div>
<p>
然后启动两个节点，它们都必须能够载入这段代码
</p>

<pre class="example">
     如果这两个节点在同一台主机上，这就不成问题。只需从同一个目录里启动两个Erlang节点就可以了

     如果节点分别属于两台物理隔离且文件系统不同的主机，这个程序就必须被复制到所有节点上，编译之后才能启动节点（或者也可以把 .beam 文件复制到所有节点上）

     在这个例子里，我假定这一切都已完成
</pre>

<p>
在主机 gentoo 上，启动一个名为 gandalf 的节点：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ erl -name gandalf@gentoo.klose.com -setcookie abc 
Erlang/OTP 23 [erts-11.1.7] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Eshell V11.1.7  (abort with ^G)
(gandalf@gentoo.klose.com)1&gt; 
</pre>
</div>

<p>
在主机 raspberrypi 上，启动一个名为 bilbo 的节点，要记得使用同一个cookie：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ erl -name bilbo@raspberrypi.klose.com -setcookie abc 
Erlang/OTP 21 [erts-10.2.4] [source] [smp:4:4] [ds:4:4:10] [async-threads:1]

Eshell V10.2.4  (abort with ^G)
</pre>
</div>

<p>
现在（在 bilbo 上），让远程节点（ gandalf ）创建一个进程：
</p>

<div class="org-src-container">
<pre class="src src-sh">(bilbo@raspberrypi.klose.com)1&gt; Pid = dist_demo:start(<span style="color: #ffa07a;">'gandalf@gentoo.klose.com'</span>) <span style="color: #b0c4de;">.</span> 
&lt;8209.92.0&gt;
</pre>
</div>

<p>
Pid 是这个 <span class="underline">远程节点</span> 进程的标识符，接着再调用 dist_demo:rpc/4 ，在远程节点(gandalf)上执行一次 <span class="underline">远程过程</span> 调用：
</p>

<div class="org-src-container">
<pre class="src src-sh">(bilbo@raspberrypi.klose.com)2&gt; dist_demo:rpc(Pid, erlang, node, []) <span style="color: #b0c4de;">.</span> 
<span style="color: #ffa07a;">'gandalf@gentoo.klose.com'</span>
</pre>
</div>

<p>
它在远程节点上执行 erlang:node() 并返回一个值 
</p>
</div>

<div id="outline-container-org829c489" class="outline-4">
<h4 id="org829c489">文件操作</h4>
<div class="outline-text-4" id="text-org829c489">
<p>
下面这些操作是上一个示例的延续：
</p>

<div class="org-src-container">
<pre class="src src-sh">(bilbo@raspberrypi.klose.com)4&gt; dist_demo:rpc(Pid, file, get_cwd, []) <span style="color: #b0c4de;">.</span>  
{ok,<span style="color: #ffa07a;">"/home/klose/tmp"</span>}

(bilbo@raspberrypi.klose.com)6&gt; dist_demo:rpc(Pid, file, list_dir, [<span style="color: #ffa07a;">"."</span>]) <span style="color: #b0c4de;">.</span>    
{ok,[<span style="color: #ffa07a;">"dist_demo.erl"</span>,<span style="color: #ffa07a;">"dist_demo.beam"</span>,<span style="color: #ffa07a;">"hello.txt"</span>]}

(bilbo@raspberrypi.klose.com)9&gt; dist_demo:rpc(Pid, file, read_file, [<span style="color: #ffa07a;">"dist_demo.erl"</span>]) <span style="color: #b0c4de;">.</span>     
{ok,&lt;&lt;<span style="color: #ffa07a;">"%% ---\n%%  Excerpted from \"Programming Erlang, Second Edition\",\n%%  published by The Pragmatic Bookshelf.\n%%"</span>...&gt;&gt;}
</pre>
</div>

<p>
在 bilbo 上发起的一些请求形成了对 gandalf 上标准库的远程过程调用。使用 file 模块里的三个函数来访问 gandalf 的文件系统 ：
</p>
<ul class="org-ul">
<li>get_cwd(): 返回文件服务器的当前工作目录</li>
<li>list_dir(Dir): 返回 Dir 里所有文件的列表</li>
<li>read_file(File): 读取文件 File</li>
</ul>

<pre class="example">
      仔细回味一下，你会意识到刚才所做的相当神奇

      没有编写任何代码就创建了一个文件服务器，只是重用了 file 模块里的库代码，并使它可以通过一个简单的远程过程调用接口访问
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4ef1a79" class="outline-2">
<h2 id="org4ef1a79">cookie 保护系统</h2>
<div class="outline-text-2" id="text-org4ef1a79">
<p>
<span class="underline">cookie</span> 系统让访问单个或一组节点变得更安全。每个节点都有一个cookie，如果它想与其他任何节点通信，它的cookie就必须和对方节点的cookie相同
</p>

<pre class="example">
为了确保cookie相同，分布式Erlang系统里的所有节点都必须以相同的“神奇”（magic）cookie启动，或者通过执行 erlang:set_cookie 把它们的cookie修改成相同的值 

Erlang集群的定义就是一组带有相同cookie的互连节点
</pre>
</div>

<div id="outline-container-orgd034db9" class="outline-3">
<h3 id="orgd034db9">设置 Cookie</h3>
<div class="outline-text-3" id="text-orgd034db9">
<p>
可以用以下三种方法设置cookie
</p>
</div>

<div id="outline-container-orgfd49e32" class="outline-4">
<h4 id="orgfd49e32">文件系统</h4>
<div class="outline-text-4" id="text-orgfd49e32">
<p>
在文件 <span class="underline">$HOME/.erlang.cookie</span> 里存放相同的cookie。这个文件包含一个随机字符串，是Erlang第一次在你的机器上运行时自动创建的：
</p>
<ul class="org-ul">
<li>这个文件可以被复制到所有想要参与分布式Erlang会话的机器上</li>
<li>也可以显式设置它的值</li>
</ul>

<pre class="example">
      注意：.erlang.cookie 文件只能被它的所有者访问，它的权限必须设置为 400 
</pre>
</div>
</div>

<div id="outline-container-orgbf6d503" class="outline-4">
<h4 id="orgbf6d503">启动参数</h4>
<div class="outline-text-4" id="text-orgbf6d503">
<p>
当Erlang启动时，可以用命令行参数 <span class="underline">-setcookie C</span> 
</p>
</div>
</div>

<div id="outline-container-org1f9a460" class="outline-4">
<h4 id="org1f9a460">内置函数</h4>
<div class="outline-text-4" id="text-org1f9a460">
<p>
<span class="underline">erlang:set_cookie(node(), C)</span> 能把本地节点的cookie设成原子 C 
</p>

<pre class="example">
      如果你的环境不够安全，那么方法1和3要优于方法2

      因为Unix系统里的任何用户都可以用 ps 命令来查看你的cookie，启动参数只适用于测试
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8cee1e" class="outline-3">
<h3 id="orgf8cee1e">安全性</h3>
<div class="outline-text-3" id="text-orgf8cee1e">
<pre class="example">
cookie保护系统被设计用来创建运行在局域网（LAN）上的分布式系统，LAN本身应该受防火墙保护，与互联网隔开

跨互联网运行的分布式Erlang应用程序应该先在主机之间建立安全连接，然后再使用cookie保护系统
</pre>

<p>
cookie从不会在网络中明文传输，它只用来对某次会话进行初始认证
</p>

<pre class="example">
     此外，分布式Erlang会话不是加密的，但可以被设置成在加密通道中运行
</pre>

<p>
<a href="otp.html">Next：OTP库</a>
</p>

<p>
<a href="error_handle.html">Previous：错误处理</a>
</p>

<p>
<a href="concurrency.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
