<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Docker基础技术</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Docker基础技术</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Namespace</a>
<ul>
<li><a href="#sec-1-1">系统调用</a>
<ul>
<li><a href="#sec-1-1-1">clone</a></li>
</ul>
</li>
<li><a href="#sec-1-2">UTS Namespace</a></li>
<li><a href="#sec-1-3">IPC Namespace</a></li>
<li><a href="#sec-1-4">PID Namespace</a></li>
<li><a href="#sec-1-5">Mount Namespace</a>
<ul>
<li><a href="#sec-1-5-1">Docker的 Mount Namespace</a></li>
</ul>
</li>
<li><a href="#sec-1-6">User Namespace</a>
<ul>
<li><a href="#sec-1-6-1">实例</a></li>
</ul>
</li>
<li><a href="#sec-1-7">Network Namespace</a></li>
<li><a href="#sec-1-8">Namespace文件</a></li>
</ul>
</li>
<li><a href="#sec-2">CGroup</a>
<ul>
<li><a href="#sec-2-1">入门</a></li>
<li><a href="#sec-2-2">CPU 限制</a>
<ul>
<li><a href="#sec-2-2-1">线程实例</a></li>
</ul>
</li>
<li><a href="#sec-2-3">内存使用限制</a></li>
<li><a href="#sec-2-4">磁盘I/O限制</a></li>
<li><a href="#sec-2-5">CGroup的子系统</a></li>
<li><a href="#sec-2-6">CGroup术语</a></li>
</ul>
</li>
<li><a href="#sec-3">Aufs</a>
<ul>
<li><a href="#sec-3-1">示例</a></li>
<li><a href="#sec-3-2">用途</a>
<ul>
<li><a href="#sec-3-2-1">docker分层</a></li>
</ul>
</li>
<li><a href="#sec-3-3">Aufs的特性</a>
<ul>
<li><a href="#sec-3-3-1">whiteout</a>
<ul>
<li><a href="#sec-3-3-1-1">whiteout实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-4">术语</a></li>
<li><a href="#sec-3-5">问题</a></li>
<li><a href="#sec-3-6">性能</a></li>
</ul>
</li>
<li><a href="#sec-4">DeviceMapper</a>
<ul>
<li><a href="#sec-4-1">简介</a></li>
<li><a href="#sec-4-2">Thin Provisioning</a>
<ul>
<li><a href="#sec-4-2-1">Thin Provisioning Snapshot</a>
<ul>
<li><a href="#sec-4-2-1-1">创建loopback设备</a></li>
<li><a href="#sec-4-2-1-2">创建pool</a></li>
<li><a href="#sec-4-2-1-3">创建volume</a></li>
<li><a href="#sec-4-2-1-4">格式化volume</a></li>
<li><a href="#sec-4-2-1-5">挂载volume</a></li>
<li><a href="#sec-4-2-1-6">创建snapshot</a></li>
<li><a href="#sec-4-2-1-7">挂载snapshot</a></li>
<li><a href="#sec-4-2-1-8">多层snapshot</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4-3">Docker的DeviceMapper</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Namespace</h2>
<div class="outline-text-2" id="text-1">
<p>
Linux Namespace是Linux提供的一种内核级别环境隔离的方法。很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制 
</p>

<p>
Linux Namespace 有如下种类：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> Linux Namespace种类</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">分类</td>
<td class="left">系统调用</td>
<td class="left">内核版本</td>
</tr>

<tr>
<td class="left">Mount namespaces</td>
<td class="left">CLONE_NEWNS</td>
<td class="left">Linux 2.4.19</td>
</tr>

<tr>
<td class="left">UTS namespaces</td>
<td class="left">CLONE_NEWUTS</td>
<td class="left">Linux 2.6.19</td>
</tr>

<tr>
<td class="left">IPC namespaces</td>
<td class="left">CLONE_NEWIPC</td>
<td class="left">Linux 2.6.19</td>
</tr>

<tr>
<td class="left">PID namespaces</td>
<td class="left">CLONE_NEWPID</td>
<td class="left">Linux 2.6.24</td>
</tr>

<tr>
<td class="left">Network namespaces</td>
<td class="left">CLONE_NEWNET</td>
<td class="left">始于Linux 2.6.24 完成于 Linux 2.6.29</td>
</tr>

<tr>
<td class="left">User namespaces</td>
<td class="left">CLONE_NEWUSER</td>
<td class="left">始于 Linux 2.6.23 完成于 Linux 3.8</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">系统调用</h3>
<div class="outline-text-3" id="text-1-1">
<p>
主要是三个系统调用：
</p>
<ul class="org-ul">
<li>clone()：实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离
</li>
<li>unshare()：使某进程脱离某个namespace
</li>
<li>setns()：把某进程加入到某个namespace
</li>
</ul>

<p>
unshare() 和 setns() 都比较简单 
</p>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">clone</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
首先，我们来看一下一个最简单的clone()系统调用的示例：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sched.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#23450;&#20041;&#19968;&#20010;&#32473; clone &#29992;&#30340;&#26632;&#65292;&#26632;&#22823;&#23567;1M </span><span style="color: #ff4500;">*/</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STACK_SIZE</span> (1024 * 1024)
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">container_stack</span>[STACK_SIZE];

<span style="color: #98fb98;">char</span>* <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">container_args</span>[] = {
    <span style="color: #ffa07a;">"/bin/bash"</span>,
    <span style="color: #7fffd4;">NULL</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container - inside the container!\n"</span>);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#30452;&#25509;&#25191;&#34892;&#19968;&#20010;shell&#65292;&#20197;&#20415;&#25105;&#20204;&#35266;&#23519;&#36825;&#20010;&#36827;&#31243;&#31354;&#38388;&#37324;&#30340;&#36164;&#28304;&#26159;&#21542;&#34987;&#38548;&#31163;&#20102; </span><span style="color: #ff4500;">*/</span>
    execv(container_args[0], container_args); 
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent - start a container!\n"</span>);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#35843;&#29992;clone&#20989;&#25968;&#65292;&#20854;&#20013;&#20256;&#20986;&#19968;&#20010;&#20989;&#25968;&#65292;&#36824;&#26377;&#19968;&#20010;&#26632;&#31354;&#38388;&#30340;&#65288;&#20026;&#20160;&#20040;&#20256;&#23614;&#25351;&#38024;&#65292;&#22240;&#20026;&#26632;&#26159;&#21453;&#30528;&#30340;&#65289; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#31561;&#24453;&#23376;&#36827;&#31243;&#32467;&#26463; </span><span style="color: #ff4500;">*/</span>
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
从上面的程序，可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">UTS Namespace</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container - inside the container!\n"</span>);
    sethostname(<span style="color: #ffa07a;">"container"</span>,10); <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#35774;&#32622;hostname </span><span style="color: #ff4500;">*/</span>
    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent - start a container!\n"</span>);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | SIGCHLD, <span style="color: #7fffd4;">NULL</span>); <span style="color: #ff4500;">/*</span><span style="color: #ff4500;">&#21551;&#29992;CLONE_NEWUTS Namespace&#38548;&#31163; </span><span style="color: #ff4500;">*/</span>
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
运行上面的程序你会发现（需要root权限）
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./uts
Parent - start a container!
Container - inside the container!

root@container:~$ hostname
container

root@container:~$ uname -n
container
</pre>
</div>

<p>
子进程的hostname变成了 container。
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">IPC Namespace</h3>
<div class="outline-text-3" id="text-1-3">
<p>
IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到
</p>

<p>
要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
              CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
</pre>
</div>

<p>
首先，我们先创建一个IPC的Queue：
</p>
<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ ipcmk -Q 
Message queue id: 0

klose@gentoo:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0
</pre>
</div>

<p>
如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue：
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./uts
Parent - start a container!
Container - inside the container!

root@container:~$ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0
</pre>
</div>

<p>
但是，如果我们运行加上了CLONE_NEWIPC的程序，就会看到下面的结果：
</p>
<div class="org-src-container">

<pre class="src src-sh">root@ubuntu:~$ sudo./ipc
Parent - start a container!
Container - inside the container!

root@container:~/linux_namespace$ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</pre>
</div>

<p>
这说明IPC已经被隔离
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">PID Namespace</h3>
<div class="outline-text-3" id="text-1-4">
<p>
继续修改上面的程序：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#26597;&#30475;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;&#20854;&#36755;&#20986;&#23376;&#36827;&#31243;&#30340; pid &#20026; 1 </span><span style="color: #ff4500;">*/</span>
    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);
    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());
    <span style="color: #ff4500;">/*</span><span style="color: #ff4500;">&#21551;&#29992;PID namespace - CLONE_NEWPID</span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, <span style="color: #7fffd4;">NULL</span>); 
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
运行结果如下，可以看到，子进程的pid是1了：
</p>
<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./pid
Parent [ 3474] - start a container!
Container [    1] - inside the container!

root@container:~$  echo $<span style="color: #eedd82;">$</span> 1
</pre>
</div>
<p>
在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1
</p>

<p>
但是，我们会发现，在子进程的shell里输入ps, top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的.。因此我们还需要对文件系统进行隔离
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Mount Namespace</h3>
<div class="outline-text-3" id="text-1-5">
<p>
下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#37325;&#26032;mount proc&#25991;&#20214;&#31995;&#32479;&#21040; /proc&#19979; </span><span style="color: #ff4500;">*/</span>
    system(<span style="color: #ffa07a;">"mount -t proc proc /proc"</span>);
    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#21551;&#29992;Mount Namespace - &#22686;&#21152;CLONE_NEWNS&#21442;&#25968; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
运行结果如下：
</p>
<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./pid.mnt
Parent [ 3502] - start a container!
Container [    1] - inside the container!

root@container:~$ ps -elf 
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash
0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf
</pre>
</div>

<p>
我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：
</p>
<div class="org-src-container">

<pre class="src src-sh">root@container:~$ ls /proc
1          dma          key-users   net            sysvipc
16         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
</pre>
</div>
<p>
下图，我们也可以看到在子进程中的top命令只看得到两个进程了：
</p>

<div class="figure">
<p><img src="pic/mount-namespace.jpg" alt="mount-namespace.jpg" width="90%" />
</p>
</div>

<p>
注意：在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离
</p>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Docker的 Mount Namespace</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
首先，需要一个rootfs，也就是需要把要做的镜像中的那些命令什么的copy到一个rootfs的目录下，模仿Linux构建如下的目录：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls
bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var
</pre>
</div>

<p>
然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin

./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount
chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</pre>
</div>

<p>
注意：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs/bin$ ldd bash

    linux-vdso.so.1 =&gt;  (0x00007fffd33fc000)
    libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)
</pre>
</div>

<p>
下面是我的rootfs中的一些so文件：
</p>

<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
</pre>
</div>

<p>
包括这些命令依赖的一些配置文件：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
</pre>
</div>

<p>
你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中：
</p>

<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ ls ./conf
hostname     hosts     resolv.conf
</pre>
</div>

<p>
这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。
</p>

<p>
好了，终于到了我们的程序：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/mount.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sched.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STACK_SIZE</span> (1024 * 1024)

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">container_stack</span>[STACK_SIZE];
<span style="color: #98fb98;">char</span>* <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">container_args</span>[] = {
    <span style="color: #ffa07a;">"/bin/bash"</span>,
    <span style="color: #ffa07a;">"-l"</span>,
    <span style="color: #7fffd4;">NULL</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">set hostname</span>
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">remount "/proc" to make sure the "top" and "ps" show container's information</span>
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"proc"</span>, <span style="color: #ffa07a;">"rootfs/proc"</span>, <span style="color: #ffa07a;">"proc"</span>, 0, <span style="color: #7fffd4;">NULL</span>) !=0 ) {
        perror(<span style="color: #ffa07a;">"proc"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"sysfs"</span>, <span style="color: #ffa07a;">"rootfs/sys"</span>, <span style="color: #ffa07a;">"sysfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"sys"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"none"</span>, <span style="color: #ffa07a;">"rootfs/tmp"</span>, <span style="color: #ffa07a;">"tmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"tmp"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"udev"</span>, <span style="color: #ffa07a;">"rootfs/dev"</span>, <span style="color: #ffa07a;">"devtmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"dev"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"devpts"</span>, <span style="color: #ffa07a;">"rootfs/dev/pts"</span>, <span style="color: #ffa07a;">"devpts"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"dev/pts"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"shm"</span>, <span style="color: #ffa07a;">"rootfs/dev/shm"</span>, <span style="color: #ffa07a;">"tmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"dev/shm"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"tmpfs"</span>, <span style="color: #ffa07a;">"rootfs/run"</span>, <span style="color: #ffa07a;">"tmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"run"</span>);
    }
    <span style="color: #ff4500;">/* </span>
<span style="color: #ff4500;">     * &#27169;&#20223;Docker&#30340;&#20174;&#22806;&#21521;&#23481;&#22120;&#37324;mount&#30456;&#20851;&#30340;&#37197;&#32622;&#25991;&#20214; </span>
<span style="color: #ff4500;">     * &#20320;&#21487;&#20197;&#26597;&#30475;&#65306;/var/lib/docker/containers/&lt;container_id&gt;/&#30446;&#24405;&#65292;</span>
<span style="color: #ff4500;">     * &#20320;&#20250;&#30475;&#21040;docker&#30340;&#36825;&#20123;&#25991;&#20214;&#30340;&#12290;</span>
<span style="color: #ff4500;">     </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"conf/hosts"</span>, <span style="color: #ffa07a;">"rootfs/etc/hosts"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0 ||
        mount(<span style="color: #ffa07a;">"conf/hostname"</span>, <span style="color: #ffa07a;">"rootfs/etc/hostname"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0 ||
        mount(<span style="color: #ffa07a;">"conf/resolv.conf"</span>, <span style="color: #ffa07a;">"rootfs/etc/resolv.conf"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0 ) {
        perror(<span style="color: #ffa07a;">"conf"</span>);
    }
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#27169;&#20223;docker run&#21629;&#20196;&#20013;&#30340; -v, --volume=[] &#21442;&#25968;&#24178;&#30340;&#20107; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"/tmp/t1"</span>, <span style="color: #ffa07a;">"rootfs/mnt"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"mnt"</span>);
    }

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">chroot &#38548;&#31163;&#30446;&#24405; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> ( chdir(<span style="color: #ffa07a;">"./rootfs"</span>) != 0 || chroot(<span style="color: #ffa07a;">"./"</span>) != 0 ){
        perror(<span style="color: #ffa07a;">"chdir/chroot"</span>);
    }

    execv(container_args[0], container_args);
    perror(<span style="color: #ffa07a;">"exec"</span>);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
sudo运行上面的程序，会看到下面的挂载信息以及一个所谓的“镜像”：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ sudo ./mount
Parent [ 4517] - start a container!
Container [    1] - inside the container!

root@container:/$ mount
proc on /proc type proc (rw,relatime)
sysfs on /sys type sysfs (rw,relatime)
none on /tmp type tmpfs (rw,relatime)
udev on /dev type devtmpfs (rw,relatime,<span style="color: #eedd82;">size</span>=493976k,<span style="color: #eedd82;">nr_inodes</span>=123494,<span style="color: #eedd82;">mode</span>=755)
devpts on /dev/pts type devpts (rw,relatime,<span style="color: #eedd82;">mode</span>=600,<span style="color: #eedd82;">ptmxmode</span>=000)
tmpfs on /run type tmpfs (rw,relatime)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,<span style="color: #eedd82;">errors</span>=remount-ro,<span style="color: #eedd82;">data</span>=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,<span style="color: #eedd82;">errors</span>=remount-ro,<span style="color: #eedd82;">data</span>=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,<span style="color: #eedd82;">errors</span>=remount-ro,<span style="color: #eedd82;">data</span>=ordered)

root@container:/$ ls /bin /usr/bin
/bin:
bash   chmod  echo  hostname  less  more    mv   ping  rm   sleep  tail  test     top    truncate  uname
cat    chown  grep  ip        ln    mount   nc   ps    sed  tabs   tar   timeout  touch  tty       which
chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe      tr     umount

/usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</pre>
</div>
<p>
关于如何做一个chroot的目录，有个工具叫DebootstrapChroot
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">User Namespace</h3>
<div class="outline-text-3" id="text-1-6">
<p>
User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）
</p>

<p>
要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc/&lt;pid&gt;/uid_map 和 /proc/&lt;pid&gt;/gid_map 这两个文件，这两个文件的格式为：
</p>

<pre class="example">
ID-inside-ns ID-outside-ns length
</pre>
<ul class="org-ul">
<li>ID-inside-ns：表示在容器显示的UID或GID
</li>
<li>ID-outside-ns：表示容器外映射的真实的UID或GID
</li>
<li>length：表示映射的范围，一般填1，表示一一对应
</li>
</ul>

<p>
比如，把真实的uid=1000映射成容器内的uid=0：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cat /proc/2465/uid_map

0       1000          1
</pre>
</div>

<p>
再比如，把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cat /proc/$<span style="color: #eedd82;">$</span>/uid_map

0          0          4294967295
</pre>
</div>

<p>
需要注意的是：
</p>
<ul class="org-ul">
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限
</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程
</li>
<li>另外需要满如下条件之一：
<ol class="org-ol">
<li>父进程将effective uid/gid映射到子进程的user namespace中
</li>
<li>父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid
</li>
</ol>
</li>
</ul>
</div>

<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">实例</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
我们用了一个pipe来对父子进程进行同步，这是因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/mount.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;linux/capability.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sched.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STACK_SIZE</span> (1024 * 1024)

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">container_stack</span>[STACK_SIZE];
<span style="color: #98fb98;">char</span>* <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">container_args</span>[] = {
    <span style="color: #ffa07a;">"/bin/bash"</span>,
    <span style="color: #7fffd4;">NULL</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pipefd</span>[2];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_map</span>(<span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">file</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">outside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
    <span style="color: #98fb98;">FILE</span>* <span style="color: #eedd82;">mapfd</span> = fopen(file, <span style="color: #ffa07a;">"w"</span>);
    <span style="color: #00ffff;">if</span> (<span style="color: #7fffd4;">NULL</span> == mapfd) {
        perror(<span style="color: #ffa07a;">"open file error"</span>);
        <span style="color: #00ffff;">return</span>;
    }
    fprintf(mapfd, <span style="color: #ffa07a;">"%d %d %d"</span>, inside_id, outside_id, len);
    fclose(mapfd);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_uid_map</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">outside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">file</span>[256];
    sprintf(file, <span style="color: #ffa07a;">"/proc/%d/uid_map"</span>, pid);
    set_map(file, inside_id, outside_id, len);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_gid_map</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">outside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">file</span>[256];
    sprintf(file, <span style="color: #ffa07a;">"/proc/%d/gid_map"</span>, pid);
    set_map(file, inside_id, outside_id, len);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{

    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());

    printf(<span style="color: #ffa07a;">"Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n"</span>,
           (<span style="color: #98fb98;">long</span>) geteuid(), (<span style="color: #98fb98;">long</span>) getegid(), (<span style="color: #98fb98;">long</span>) getuid(), (<span style="color: #98fb98;">long</span>) getgid());

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#31561;&#24453;&#29238;&#36827;&#31243;&#36890;&#30693;&#21518;&#20877;&#24448;&#19979;&#25191;&#34892;&#65288;&#36827;&#31243;&#38388;&#30340;&#21516;&#27493;&#65289; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ch</span>;
    close(pipefd[1]);
    read(pipefd[0], &amp;ch, 1);

    printf(<span style="color: #ffa07a;">"Container [%5d] - setup hostname!\n"</span>, getpid());
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">set hostname</span>
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">remount "/proc" to make sure the "top" and "ps" show container's information</span>
    mount(<span style="color: #ffa07a;">"proc"</span>, <span style="color: #ffa07a;">"/proc"</span>, <span style="color: #ffa07a;">"proc"</span>, 0, <span style="color: #7fffd4;">NULL</span>);

    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gid</span>=getgid(), <span style="color: #eedd82;">uid</span>=getuid();

    printf(<span style="color: #ffa07a;">"Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n"</span>,
           (<span style="color: #98fb98;">long</span>) geteuid(), (<span style="color: #98fb98;">long</span>) getegid(), (<span style="color: #98fb98;">long</span>) getuid(), (<span style="color: #98fb98;">long</span>) getgid()); 
    pipe(pipefd);
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());

    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    printf(<span style="color: #ffa07a;">"Parent [%5d] - Container [%5d]!\n"</span>, getpid(), container_pid);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">To map the uid/gid, </span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span>
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">The file format is</span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">ID-inside-ns   ID-outside-ns   length</span>
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">if no mapping, </span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">the uid will be taken from /proc/sys/kernel/overflowuid</span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">the gid will be taken from /proc/sys/kernel/overflowgid</span>
    set_uid_map(container_pid, 0, uid, 1);
    set_gid_map(container_pid, 0, gid, 1);

    printf(<span style="color: #ffa07a;">"Parent [%5d] - user/group mapping done!\n"</span>, getpid());

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#36890;&#30693;&#23376;&#36827;&#31243; </span><span style="color: #ff4500;">*/</span>
    close(pipefd[1]);

    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
整个程序的运行效果如下：
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@ubuntu16-188 ~/$ id
<span style="color: #eedd82;">uid</span>=1002(klose) <span style="color: #eedd82;">gid</span>=1002(klose) <span style="color: #eedd82;">groups</span>=1002(klose),100(users),999(docker)

klose@ubuntu16-188 ~/ $ ./user_namespace
Parent: eUID = 1002;  eGID = 1002, <span style="color: #eedd82;">UID</span>=1002, <span style="color: #eedd82;">GID</span>=1002
Parent [ 5994] - start a container!
Parent [ 5994] - Container [ 5996]!
Container [    1] - inside the container!
Container: eUID = 0;  eGID = 65534, <span style="color: #eedd82;">UID</span>=0, <span style="color: #eedd82;">GID</span>=65534
Parent [ 5994] - user/group mapping done!
Container [    1] - setup hostname!

container namespace <span style="color: #ff4500;"># </span><span style="color: #ff4500;">id</span>
<span style="color: #eedd82;">uid</span>=0(root) <span style="color: #eedd82;">gid</span>=65534(nogroup) <span style="color: #eedd82;">groups</span>=65534(nogroup)
</pre>
</div>
<p>
虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，容器的安全性会得到提高。
</p>

<p>
User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Network Namespace</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Network的Namespace比较啰嗦，在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能，通过使用了Raw Socket发些“奇怪”的数据）
</p>

<p>
首先，先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）：
</p>


<div class="figure">
<p><img src="pic/docker-network-namespace.jpg" alt="docker-network-namespace.jpg" width="70%" />
</p>
</div>

<p>
上图中，Docker使用了一个私有网段 172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了
</p>

<p>
当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：
</p>

<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ ip link show
</pre>
</div>

<pre class="example">
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff
</pre>

<p>
那么，要如何才能做成这个样子呢？我们来看一组命令： 
</p>


<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff4500;">## </span><span style="color: #ff4500;">&#39318;&#20808;&#65292;&#25105;&#20204;&#20808;&#22686;&#21152;&#19968;&#20010;&#32593;&#26725;lxcbr0&#65292;&#27169;&#20223;docker0</span>
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#20026;&#32593;&#26725;&#35774;&#32622;IP&#22320;&#22336;</span>

<span style="color: #ff4500;">## </span><span style="color: #ff4500;">&#25509;&#19979;&#26469;&#65292;&#25105;&#20204;&#35201;&#21019;&#24314;&#19968;&#20010;network namespace - ns1</span>

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#22686;&#21152;&#19968;&#20010;namesapce &#21629;&#20196;&#20026; ns1 &#65288;&#20351;&#29992;ip netns add&#21629;&#20196;&#65289;</span>
ip netns add ns1 

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#28608;&#27963;namespace&#20013;&#30340;loopback&#65292;&#21363;127.0.0.1&#65288;&#20351;&#29992;ip netns exec ns1&#26469;&#25805;&#20316;ns1&#20013;&#30340;&#21629;&#20196;&#65289;</span>
ip netns exec ns1   ip link set dev lo up 

<span style="color: #ff4500;">## </span><span style="color: #ff4500;">&#28982;&#21518;&#65292;&#25105;&#20204;&#38656;&#35201;&#22686;&#21152;&#19968;&#23545;&#34394;&#25311;&#32593;&#21345;</span>

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#22686;&#21152;&#19968;&#20010;pair&#34394;&#25311;&#32593;&#21345;&#65292;&#27880;&#24847;&#20854;&#20013;&#30340;veth&#31867;&#22411;&#65292;&#20854;&#20013;&#19968;&#20010;&#32593;&#21345;&#35201;&#25353;&#36827;&#23481;&#22120;&#20013;</span>
ip link add veth-ns1 type veth peer name lxcbr0.1

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25226; veth-ns1 &#25353;&#21040;namespace ns1&#20013;&#65292;&#36825;&#26679;&#23481;&#22120;&#20013;&#23601;&#20250;&#26377;&#19968;&#20010;&#26032;&#30340;&#32593;&#21345;&#20102;</span>
ip link set veth-ns1 netns ns1

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25226;&#23481;&#22120;&#37324;&#30340; veth-ns1&#25913;&#21517;&#20026; eth0 &#65288;&#23481;&#22120;&#22806;&#20250;&#20914;&#31361;&#65292;&#23481;&#22120;&#20869;&#23601;&#19981;&#20250;&#20102;&#65289;</span>
ip netns exec ns1  ip link set dev veth-ns1 name eth0 

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#20026;&#23481;&#22120;&#20013;&#30340;&#32593;&#21345;&#20998;&#37197;&#19968;&#20010;IP&#22320;&#22336;&#65292;&#24182;&#28608;&#27963;&#23427;</span>
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#19978;&#38754;&#25105;&#20204;&#25226;veth-ns1&#36825;&#20010;&#32593;&#21345;&#25353;&#21040;&#20102;&#23481;&#22120;&#20013;&#65292;&#28982;&#21518;&#25105;&#20204;&#35201;&#25226;lxcbr0.1&#28155;&#21152;&#19978;&#32593;&#26725;&#19978;</span>
brctl addif lxcbr0 lxcbr0.1

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#20026;&#23481;&#22120;&#22686;&#21152;&#19968;&#20010;&#36335;&#30001;&#35268;&#21017;&#65292;&#35753;&#23481;&#22120;&#21487;&#20197;&#35775;&#38382;&#22806;&#38754;&#30340;&#32593;&#32476;</span>
ip netns exec ns1     ip route add default via 192.168.10.1

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#22312;/etc/netns&#19979;&#21019;&#24314;network namespce&#21517;&#31216;&#20026;ns1&#30340;&#30446;&#24405;&#65292;</span>
<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#28982;&#21518;&#20026;&#36825;&#20010;namespace&#35774;&#32622;resolv.conf&#65292;&#36825;&#26679;&#65292;&#23481;&#22120;&#20869;&#23601;&#21487;&#20197;&#35775;&#38382;&#22495;&#21517;&#20102;</span>
mkdir -p /etc/netns/ns1
<span style="color: #b0c4de;">echo</span> <span style="color: #ffa07a;">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf
</pre>
</div>
<p>
上面基本上就是docker网络的原理了，只不过：
</p>
<ul class="org-ul">
<li>Docker的resolv.conf没有用这样的方式，而是用了Mount Namesapce的那种方式
</li>
<li>docker是用进程的PID来做Network Namespace的名称的
</li>
</ul>

<p>
甚至可以为正在运行的docker容器增加一个新的网卡：
</p>

<div class="org-src-container">

<pre class="src src-sh">ip link add peerA type veth peer name peerB 
brctl addif docker0 peerA 
ip link set peerA up 
ip link set peerB netns ${<span style="color: #eedd82;">container</span>-pid} 
ip netns exec ${<span style="color: #eedd82;">container</span>-pid} ip link set dev peerB name eth1 
ip netns exec ${<span style="color: #eedd82;">container</span>-pid} ip link set eth1 up ; 
ip netns exec ${<span style="color: #eedd82;">container</span>-pid} ip addr add ${<span style="color: #eedd82;">ROUTEABLE_IP</span>} dev eth1 ;
</pre>
</div>

<p>
上面的示例是为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址
</p>

<p>
这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了
</p>

<p>
无论是Docker的NAT方式，还是混杂模式都会有性能上的问题：
</p>
<ul class="org-ul">
<li>NAT不用说了，存在一个转发的开销
</li>
<li>混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响
</li>
</ul>

<p>
这两种方式都不够完美，真正解决这种网络问题需要使用VLAN技术，于是Google为Linux内核实现了一个IPVLAN的驱动，这基本上就是为Docker量身定制的
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Namespace文件</h3>
<div class="outline-text-3" id="text-1-8">
<p>
让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ sudo ./pid.mnt
</pre>
</div>

<pre class="example">
Parent [ 4599] - start a container!
Container [  1] - inside the container!
</pre>

<p>
到另一个shell中查看一下父子进程的PID：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ pstree -p 4599
</pre>
</div>

<pre class="example">
pid.mnt(4599)───bash(4600)
</pre>

<p>
可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。下面是父进程的：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ sudo ls -l /proc/4599/ns
</pre>
</div>

<pre class="example">
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026531838]
</pre>

<p>
下面是子进程的：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ sudo ls -l /proc/4600/ns
</pre>
</div>

<pre class="example">
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026532520]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026532522]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026532521]
</pre>

<p>
可以看到，其中的 <b>ipc, net, user是同一个ID，而mnt, pid, uts都是不一样的</b> 。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面
</p>

<p>
这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过下面命令来hold这个namespace：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ mount -bind /proc/4600/ns/uts ~/uts
</pre>
</div>

<p>
另外，曾经描述过一个setns的系统调用，其函数声明如下：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setns</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nstype</span>);
</pre>
</div>

<p>
其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：
</p>

<div class="org-src-container">

<pre class="src src-C">fd = open(<span style="color: #ffa07a;">"/proc/4600/ns/nts"</span>, O_RDONLY);  <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#33719;&#21462;namespace&#25991;&#20214;&#25551;&#36848;&#31526;</span>
setns(fd, 0); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21152;&#20837;&#26032;&#30340;namespace</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">CGroup</h2>
<div class="outline-text-2" id="text-2">
<p>
Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因
</p>

<p>
Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起，最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展
</p>

<p>
Cgroup可让您为系统中所运行任务（进程）的用户定义组群分配资源，比如CPU时间、系统内存、网络带宽或者这些资源的组合。你可以监控您配置的cgroup，拒绝cgroup访问某些资源，甚至在运行的系统中动态配置cgroup
</p>

<p>
主要提供了如下功能：
</p>
<ul class="org-ul">
<li>Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制
</li>
<li>Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐
</li>
<li>Accounting: 一些审计或一些统计，主要目的是为了计费
</li>
<li>Control: 挂起进程，恢复执行进程
</li>
</ul>

<p>
使用cgroup，系统管理员可更具体地控制对系统资源的分配、优先顺序、拒绝gc、管理和监控。可更好地根据任务和用户分配硬件资源，提高总体效率
</p>

<p>
在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：
</p>
<ul class="org-ul">
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核
</li>
<li>为这组进程分配其足够使用的内存
</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制
</li>
<li>限制访问某些设备（通过设置设备的白名单）
</li>
</ul>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">入门</h3>
<div class="outline-text-3" id="text-2-1">
<p>
首先，Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ mount -t cgroup
</pre>
</div>

<pre class="example">
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)
</pre>

<p>
或者使用lssubsys命令：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ lssubsys  -m
</pre>
</div>

<pre class="example">
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
net_cls /sys/fs/cgroup/net_cls
net_prio /sys/fs/cgroup/net_prio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
</pre>

<p>
我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。
</p>

<p>
如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：
</p>
<div class="org-src-container">

<pre class="src src-sh">mkdir cgroup
mount -t tmpfs cgroup_root ./cgroup
mkdir cgroup/cpuset
mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/
mkdir cgroup/cpu
mount -t cgroup -ocpu cpu ./cgroup/cpu/
mkdir cgroup/memory
mount -t cgroup -omemory memory ./cgroup/memory/
</pre>
</div>

<p>
一旦mount成功，你就会看到这些目录下就有好些文件了，比如，如下所示的cpu和cpuset的子系统：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/
</pre>
</div>

<pre class="example">
/sys/fs/cgroup/cpu:
cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent
cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks
cgroup.procs           cpu.cfs_quota_us      notify_on_release  user

/sys/fs/cgroup/cpuset/:
cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance
cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level
cgroup.procs           cpuset.memory_pressure          notify_on_release
cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent
cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks
cpuset.cpus            cpuset.memory_spread_slab       user
cpuset.mem_exclusive   cpuset.mems
</pre>

<p>
你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel
hchen@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel
</pre>
</div>

<pre class="example">
cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks
cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">CPU 限制</h3>
<div class="outline-text-3" id="text-2-2">
<p>
假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
    <span style="color: #00ffff;">for</span>(;;) i++;
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
用sudo执行起来后，毫无疑问，CPU被干到了100%，下面是top命令的输出：
</p>

<div class="org-src-container">

<pre class="src src-sh">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop
</pre>
</div>

<p>
然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：
</p>

<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 
-1
root@ubuntu:~# echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us
</pre>
</div>
<p>
这个进程的PID是3529，把这个进程加到这个cgroup中：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ echo 3529 &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks
</pre>
</div>
<p>
然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）：
</p>

<div class="org-src-container">

<pre class="src src-sh">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop
</pre>
</div>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">线程实例</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
下面的代码是一个线程的示例：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">See feature_test_macros(7) </span><span style="color: #ff4500;">*/</span>

<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/syscall.h&gt;</span>


<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">NUM_THREADS</span> = 5;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">thread_main</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">threadid</span>)
{
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#25226;&#33258;&#24049;&#21152;&#20837;cgroup&#20013;&#65288;syscall(SYS_gettid)&#20026;&#24471;&#21040;&#32447;&#31243;&#30340;&#31995;&#32479;tid&#65289; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">cmd</span>[128];
    sprintf(cmd, <span style="color: #ffa07a;">"echo %ld &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks"</span>, syscall(SYS_gettid));
    system(cmd); 
    sprintf(cmd, <span style="color: #ffa07a;">"echo %ld &gt;&gt; /sys/fs/cgroup/cpuset/haoel/tasks"</span>, syscall(SYS_gettid));
    system(cmd);

    <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">tid</span>;
    tid = (<span style="color: #98fb98;">long</span>)threadid;
    printf(<span style="color: #ffa07a;">"Hello World! It's me, thread #%ld, pid #%ld!\n"</span>, tid, syscall(SYS_gettid));

    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>=0; 
    <span style="color: #00ffff;">while</span>(1) {
        a++;
    }
    pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_threads</span>;
    <span style="color: #00ffff;">if</span> (argc &gt; 1){
        num_threads = atoi(argv[1]);
    }
    <span style="color: #00ffff;">if</span> (num_threads&lt;=0 || num_threads&gt;=100){
        num_threads = NUM_THREADS;
    }

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#35774;&#32622;CPU&#21033;&#29992;&#29575;&#20026;50% </span><span style="color: #ff4500;">*/</span>
    mkdir(<span style="color: #ffa07a;">"/sys/fs/cgroup/cpu/haoel"</span>, 755);
    system(<span style="color: #ffa07a;">"echo 50000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us"</span>);

    mkdir(<span style="color: #ffa07a;">"/sys/fs/cgroup/cpuset/haoel"</span>, 755);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#38480;&#21046;CPU&#21482;&#33021;&#20351;&#29992;#2&#26680;&#21644;#3&#26680; </span><span style="color: #ff4500;">*/</span>
    system(<span style="color: #ffa07a;">"echo \"2,3\" &gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus"</span>);

    <span style="color: #98fb98;">pthread_t</span>* <span style="color: #eedd82;">threads</span> = (<span style="color: #98fb98;">pthread_t</span>*) malloc (<span style="color: #00ffff;">sizeof</span>(pthread_t)*num_threads);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rc</span>;
    <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">t</span>;
    <span style="color: #00ffff;">for</span>(t=0; t&lt;num_threads; t++){
        printf(<span style="color: #ffa07a;">"In main: creating thread %ld\n"</span>, t);
        rc = pthread_create(&amp;threads[t], <span style="color: #7fffd4;">NULL</span>, thread_main, (<span style="color: #98fb98;">void</span> *)t);
        <span style="color: #00ffff;">if</span> (rc){
            printf(<span style="color: #ffa07a;">"ERROR; return code from pthread_create() is %d\n"</span>, rc);
            exit(-1);
        }
    }

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Last thing that main() should do </span><span style="color: #ff4500;">*/</span>
    pthread_exit(<span style="color: #7fffd4;">NULL</span>);
    free(threads);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">内存使用限制</h3>
<div class="outline-text-3" id="text-2-3">
<p>
再来看一个限制内存的例子，下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chunk_size</span> = 512;
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span> = <span style="color: #7fffd4;">NULL</span>;

    <span style="color: #00ffff;">while</span>(1) {

        <span style="color: #00ffff;">if</span> ((p = malloc(p, chunk_size)) == <span style="color: #7fffd4;">NULL</span>) {
            printf(<span style="color: #ffa07a;">"out of memory!!\n"</span>);
            <span style="color: #00ffff;">break</span>;
        }
        memset(p, 1, chunk_size);
        size += chunk_size;
        printf(<span style="color: #ffa07a;">"[%d] - memory is allocated [%8d] bytes \n"</span>, getpid(), size);
        sleep(1);
    }
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
然后，我们：
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21019;&#24314;memory cgroup</span>
$ mkdir /sys/fs/cgroup/memory/haoel
$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25226;&#19978;&#38754;&#30340;&#36827;&#31243;&#30340;pid&#21152;&#20837;&#36825;&#20010;cgroup</span>
$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks
</pre>
</div>

<p>
一会上面的进程就会因为内存问题被kill掉了
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">磁盘I/O限制</h3>
<div class="outline-text-3" id="text-2-4">
<p>
我们先看一下我们的硬盘IO，我们的模拟命令如下：从/dev/sda1上读入数据，输出到/dev/null上
</p>
<div class="org-src-container">

<pre class="src src-sh">$ sudo dd <span style="color: #eedd82;">if</span>=/dev/sda1 <span style="color: #eedd82;">of</span>=/dev/null
</pre>
</div>

<p>
我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：
</p>

<div class="org-src-container">

<pre class="src src-sh">TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd <span style="color: #eedd82;">if</span>=/de~=/dev/null...
</pre>
</div>
<p>
然后，我们先创建一个blkio（块设备IO）的cgroup：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ mkdir /sys/fs/cgroup/blkio/haoel
</pre>
</div>

<p>
并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：
</p>

<div class="org-src-container">

<pre class="src src-sh">root@ubuntu:~$ echo <span style="color: #ffa07a;">'8:0 1048576'</span>  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 
root@ubuntu:~$ echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks
</pre>
</div>

<p>
再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右：
</p>

<div class="org-src-container">

<pre class="src src-sh">TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd <span style="color: #eedd82;">if</span>=/de~=/dev/null...
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">CGroup的子系统</h3>
<div class="outline-text-3" id="text-2-5">
<p>
好了，有了以上的感性认识我们来，再来看看control group有哪些子系统：
</p>
<ul class="org-ul">
<li>blkio:  这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）
</li>
<li>cpu:  这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问
</li>
<li>cpuacct:  这个子系统自动生成 cgroup 中任务所使用的 CPU 报告
</li>
<li>cpuset:  这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点
</li>
<li>devices:  这个子系统可允许或者拒绝 cgroup 中的任务访问设备
</li>
<li>freezer:  这个子系统挂起或者恢复 cgroup 中的任务
</li>
<li>memory:  这个子系统设定 cgroup 中任务使用的内存限制，并自动生成内存资源使用报告
</li>
<li>net_cls:  这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包
</li>
<li>net_prio:  这个子系统用来设计网络流量的优先级
</li>
<li>hugetlb:  这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统
</li>
</ul>

<p>
注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ sudo modprobe cls_cgroup
$ sudo mkdir /sys/fs/cgroup/net_cls
$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls

$ sudo modprobe netprio_cgroup
$ sudo mkdir /sys/fs/cgroup/net_prio
$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">CGroup术语</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>任务（Tasks）：就是系统的一个进程
</li>
<li>控制组（Control Group）：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件
</li>
<li>层级（Hierarchy）：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树
</li>
<li>子系统（Subsystem）：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Aufs</h2>
<div class="outline-text-2" id="text-3">
<p>
AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）
</p>


<div class="figure">
<p><img src="pic/docker-filesystems-busyboxrw.png" alt="docker-filesystems-busyboxrw.png" width="30%" />
</p>
</div>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">示例</h3>
<div class="outline-text-3" id="text-3-1">
<p>
首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄 
</p>


<div class="org-src-container">

<pre class="src src-sh">klose@ubuntu16-188 ~/Documents/programming/C/aufs $ tree .
</pre>
</div>

<pre class="example">
.
├── fruits
│  ├── apple
│  └── tomato
└── vegetables
    ├── carrots
    └── tomato

2 directories, 4 files
</pre>

<p>
然后，输入以下命令：
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21019;&#24314;&#19968;&#20010;mount&#30446;&#24405;</span>
$ mkdir mnt

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25226;&#27700;&#26524;&#30446;&#24405;&#21644;&#34092;&#33756;&#30446;&#24405;union mount&#21040; ./mnt&#30446;&#24405;&#20013;</span>
$ sudo mount -t aufs -o <span style="color: #eedd82;">dirs</span>=./fruits:./vegetables none ./mnt

<span style="color: #ff4500;">#  </span><span style="color: #ff4500;">&#26597;&#30475;./mnt&#30446;&#24405;</span>
$ tree ./mnt
</pre>
</div>

<pre class="example">
./mnt/
├── apple
├── carrots
└── tomato

0 directories, 3 files
</pre>

<p>
可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了
</p>

<p>
来修改一下其中的文件内容：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ echo mnt &gt; ./mnt/apple
$ cat ./mnt/apple
mnt
$ cat ./fruits/apple
mnt
</pre>
</div>
<p>
上面的示例，可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了 
</p>

<div class="org-src-container">

<pre class="src src-sh">$ echo mnt_carrots &gt; ./mnt/carrots
$ cat ./vegetables/carrots

$ cat ./fruits/carrots
mnt_carrots
</pre>
</div>
<p>
可以看到修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是在./mnt/carrots里的内容 
</p>

<p>
也就是说，在mount aufs命令中，没有指它vegetables和fruits的目录权限。默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）
</p>

<p>
所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ sudo mount -t aufs -o <span style="color: #eedd82;">dirs</span>=./fruits=rw:./vegetables=rw none ./mnt

$ echo <span style="color: #ffa07a;">"mnt_carrots"</span> &gt; ./mnt/carrots

$ cat ./vegetables/carrots
mnt_carrots

$ cat ./fruits/carrots
cat: ./fruits/carrots: No such file or directory
</pre>
</div>
<p>
在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？
</p>

<div class="org-src-container">

<pre class="src src-sh">$ echo <span style="color: #ffa07a;">"mnt_tomato"</span> &gt; ./mnt/tomato

$ cat ./fruits/tomato
mnt_tomato

$ cat ./vegetables/tomato
I am a vegetable
</pre>
</div>

<p>
可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">用途</h3>
<div class="outline-text-3" id="text-3-2">
<p>
历史上，有一个叫Knoppix的Linux发行版，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西
</p>

<p>
可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">docker分层</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
下图来自Docker的官方文档Layer，其很好的展示了Docker用UnionFS搭建的分层镜像：
</p>

<div class="figure">
<p><img src="pic/docker-filesystems-multilayer.png" alt="docker-filesystems-multilayer.png" width="50%" />
</p>
</div>

<p>
关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 -storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ /var/lib/docker/aufs/diff/&lt;id&gt;
</pre>
</div>

<p>
在docker执行起来后（比如：docker run -it ubuntu /bin/bash），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ls /sys/fs/aufs/si_b71b209f85ff8e75/
br0      br2      br4      br6      brid1    brid3    brid5    xi_path
br1      br3      br5      brid0    brid2    brid4    brid6 

$ cat /sys/fs/aufs/si_b71b209f85ff8e75/*
/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw
/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh
/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh
/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh
/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh
/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh
/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh
64
65
66
67
68
69
70
/run/shm/aufs.xino
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Aufs的特性</h3>
<div class="outline-text-3" id="text-3-3">
<p>
AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡
</p>

<p>
被union的目录（分支）的相关权限：
</p>
<ul class="org-ul">
<li>rw: 可写可读read-write
</li>
<li>ro: read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作
</li>
<li>rr: real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知
</li>
</ul>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">whiteout</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
一般来说ro的分支都会有wh的属性，比如 “[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的
</p>
</div>

<div id="outline-container-sec-3-3-1-1" class="outline-5">
<h5 id="sec-3-3-1-1">whiteout实例</h5>
<div class="outline-text-5" id="text-3-3-1-1">
<p>
假设我们有三个目录和文件如下所示，其中test是个空目录：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ tree
.
&#9500;&#9472;&#9472; fruits
&#9474;   &#9500;&#9472;&#9472; apple
&#9474;   &#9492;&#9472;&#9472; tomato
&#9500;&#9472;&#9472; test
&#9492;&#9472;&#9472; vegetables
    &#9500;&#9472;&#9472; carrots
    &#9492;&#9472;&#9472; tomato
</pre>
</div>

<p>
如下mount：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ mkdir mnt

$ mount -t aufs -o <span style="color: #eedd82;">dirs</span>=./test=rw:./fruits=ro:./vegetables=ro none ./mnt

$ ls ./mnt/
apple  carrots  tomato
</pre>
</div>

<p>
现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了：
</p>

<div class="org-src-container">

<pre class="src src-sh">$  touch ./test/.wh.apple

$ ls ./mnt
carrots  tomato
</pre>
</div>

<p>
上面这个操作和 rm ./mnt/apple是一样的
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">术语</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>Branch: 就是各个要被union起来的目录
<ul class="org-ul">
<li>Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的
</li>
<li>Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限
</li>
</ul>
</li>
<li>如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了
<ul class="org-ul">
<li>Whiteout: 某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支
<ul class="org-ul">
<li>在隐藏低层档的情况下，whiteout的名字是 <b>.wh.&lt;filename&gt;</b>
</li>
</ul>
</li>
<li>Opaque: 不允许任何下层的某个目录显示出来。
<ul class="org-ul">
<li>在阻止readdir的情况下，名字是 <b>.wh..wh..opq</b> 或者 <b>.wh.__dir_opaque</b>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">问题</h3>
<div class="outline-text-3" id="text-3-5">
<ol class="org-ol">
<li><b>要有文件在原来的地方被修改了会怎么样？</b> mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数(User's Direct Branch Access)，这个参数有三个取值：
<ul class="org-ul">
<li><b>udba=none</b> 设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题
</li>
<li><b>udba=reval</b> 设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内
</li>
<li><b>udba=notify</b> 这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些
</li>
</ul>
</li>

<li>如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？ aufs提供了一个叫create的参数可以供你来配置相当的创建策略：
<ul class="org-ul">
<li><b>create=rr | round-robin</b> 轮询，下面的示例可以看到，新创建的文件轮流写到三个目录中：

<div class="org-src-container">

<pre class="src src-sh">hchen$ sudo mount -t aufs  -o <span style="color: #eedd82;">dirs</span>=./1=rw:./2=rw:./3=rw -o <span style="color: #eedd82;">create</span>=rr none ./mnt
hchen$ touch ./mnt/a ./mnt/b ./mnt/c
hchen$ tree
.
&#9500;&#9472;&#9472; 1
&#9474;   &#9492;&#9472;&#9472; a
&#9500;&#9472;&#9472; 2
&#9474;   &#9492;&#9472;&#9472; c
&#9492;&#9472;&#9472; 3
&#9492;&#9472;&#9472; b
</pre>
</div>
</li>

<li><b>create=mfs[:second] | most-free-space[:second]</b> 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间
</li>
<li><b>create=mfsrr:low[:second]</b> 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用 round-robin 方式
</li>
</ul>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">性能</h3>
<div class="outline-text-3" id="text-3-6">
<p>
AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的
</p>

<p>
所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化
</p>

<p>
IBM的研究中心对Docker的性能给了一份非常不错的性能报告，我截了两张图出来：
</p>

<div class="figure">
<p><img src="pic/docker-seq-io.jpg" alt="docker-seq-io.jpg" width="50%" />
</p>
</div>


<div class="figure">
<p><img src="pic/docker-rand-io.jpg" alt="docker-rand-io.jpg" width="50%" />
</p>
</div>

<p>
第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">DeviceMapper</h2>
<div class="outline-text-2" id="text-4">
<p>
因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">简介</h3>
<div class="outline-text-3" id="text-4-1">
<p>
DeviceMapper自Linux 2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念： <b>Mapped Device</b>,  <b>Mapping Table</b>,  <b>Target Device</b>
</p>
<ul class="org-ul">
<li>Mapped Device是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备
</li>
<li>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）
</li>
<li>DeviceMapper 中的逻辑设备Mapped Device不但可以映射一个或多个物理设备Target Device，还可以映射另一个Mapped Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去
</li>
</ul>

<p>
DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。如下图所示：
</p>


<div class="figure">
<p><img src="pic/device-mapper.gif" alt="device-mapper.gif" width="80%" />
</p>
</div>

<p>
从图中可以看到 <b>DeviceMapper只是一个框架，在这个框架上可以插入各种各样的策略</b> ，在这诸多“插件”中，有一个东西叫 <b>Thin Provisioning Snapshot</b> ，这是Docker使用DeviceMapper中最重要的模块
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Thin Provisioning</h3>
<div class="outline-text-3" id="text-4-2">
<p>
这个技术是虚拟化技术中的一种。你可以联想一下我们计算机中的内存管理中用到的 <b>虚拟内存技术</b> 。操作系统给每个进程N多N多用不完的内址地址（32位下，每个进程可以有最多2GB的内存空间），但是呢，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，意思是 <b>我逻辑上给你无限多的内存，但是实际上是实报实销</b> ，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果
</p>

<p>
对于这里说的是存储。看下面两个图, 很好的说明了怎么一回事：
</p>
<ul class="org-ul">
<li>fat provisioning:

<div class="figure">
<p><img src="pic/fat-provisioning.jpg" alt="fat-provisioning.jpg" width="70%" />
</p>
</div>
</li>

<li>thin provisioning:  

<div class="figure">
<p><img src="pic/thin-provisioning.jpg" alt="thin-provisioning.jpg" width="70%" />
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">Thin Provisioning Snapshot</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
下面用一系列的命令来演示一下Device Mapper的Thin Provisioning Snapshot。首先，需要先建两个文件，一个是data.img，一个是meta.data.img：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo dd <span style="color: #eedd82;">if</span>=/dev/zero <span style="color: #eedd82;">of</span>=/tmp/data.img <span style="color: #eedd82;">bs</span>=1K <span style="color: #eedd82;">count</span>=1 <span style="color: #eedd82;">seek</span>=10M
1+0 records<span style="color: #00ffff;"> in</span>
1+0 records out
1024 bytes (1.0 kB, 1.0 KiB) copied, 0.000235208 s, 4.4 MB/s

wu@ubuntu16-188:~$ sudo dd <span style="color: #eedd82;">if</span>=/dev/zero <span style="color: #eedd82;">of</span>=/tmp/meta.data.img <span style="color: #eedd82;">bs</span>=1K <span style="color: #eedd82;">count</span>=1 <span style="color: #eedd82;">seek</span>=1G
1+0 records<span style="color: #00ffff;"> in</span>
1+0 records out
1024 bytes (1.0 kB, 1.0 KiB) copied, 0.000493576 s, 2.1 MB/s
</pre>
</div>

<p>
注意命令中 <b>seek</b> 选项，其表示为略过 <b>of</b> 选项指定的输出文件的前10G个output的blocksize的空间后再写入内容。因为bs是1个字节，所以也就是10G的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有1k的内容。当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下，实际分配了都是只有4K：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ ls -lsh /tmp/data.img
4.0K -rw-r--r-- 1 root root 11G Oct 16 15:17 /tmp/data.img

wu@ubuntu16-188:~$ ls -lsh /tmp/meta.data.img
4.0K -rw-r--r-- 1 root root 1.1T Oct 16 15:17 /tmp/meta.data.img
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-1-1" class="outline-5">
<h5 id="sec-4-2-1-1">创建loopback设备</h5>
<div class="outline-text-5" id="text-4-2-1-1">
<p>
然后，我们为每个文件分别创建一个loopback设备：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo losetup /dev/loop2015 /tmp/data.img

wu@ubuntu16-188:~$ sudo losetup /dev/loop2016 /tmp/meta.data.img

wu@ubuntu16-188:~$ sudo losetup -a
/dev/loop2016: [64768]:131127 (/tmp/meta.data.img)
/dev/loop2015: [64768]:131126 (/tmp/data.img)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-1-2" class="outline-5">
<h5 id="sec-4-2-1-2">创建pool</h5>
<div class="outline-text-5" id="text-4-2-1-2">
<p>
现在，为这个设备建一个Thin Provisioning的Pool，用dmsetup命令：
</p>
<div class="org-src-container">

<pre class="src src-sh">sudo dmsetup create klose-thin-pool <span style="color: #ffa07a;">\</span>
                  --table <span style="color: #ffa07a;">"0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \</span>
<span style="color: #ffa07a;">                           128 65536 1 skip_block_zeroing"</span>
</pre>
</div>

<p>
其中的参数解释如下：
</p>
<ul class="org-ul">
<li>dmsetup create：用来创建thin pool的命令
</li>
<li>klose-thin-pool 是自定义的一个pool名，不冲突就好
</li>
<li>&#x2013;table是这个pool的参数设置：
<ul class="org-ul">
<li>0: 开始的sector位置
</li>
<li>20971522: 结尾的sector号，前面说过，一个sector是512字节，所以，20971522个正好是10GB
</li>
<li>/dev/loop2016: meta文件的设备
</li>
<li>/dev/loop2015: data文件的设备
</li>
<li>128: 最小的可分配的sector数
</li>
<li>65536: 最少可用sector的water mark，也就是一个threshold
</li>
<li>1: 有一个附加参数
<ul class="org-ul">
<li>skip_block_zeroing: 附加参数，表示略过用0填充的块
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
现在就可以看到一个Device Mapper的设备了：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo ls -l  /dev/mapper/klose-thin-pool
lrwxrwxrwx 1 root root 7 Oct 16 15:27 /dev/mapper/klose-thin-pool -&gt; ../dm-2
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-1-3" class="outline-5">
<h5 id="sec-4-2-1-3">创建volume</h5>
<div class="outline-text-5" id="text-4-2-1-3">
<p>
然而初始还没有完成，还要创建一个Thin Provisioning 的 Volume：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo dmsetup message /dev/mapper/klose-thin-pool 0 <span style="color: #ffa07a;">"create_thin 0"</span>
wu@ubuntu16-188:~$ sudo dmsetup create klose-thin-volumn-001 <span style="color: #ffa07a;">\</span>
&gt;             --table <span style="color: #ffa07a;">"0 2097152 thin /dev/mapper/klose-thin-pool 0"</span>
</pre>
</div>

<p>
其中：
</p>
<ul class="org-ul">
<li>第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的 id
</li>
<li>第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫klose-thin-volumn-001。2097152只有1GB
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-4-2-1-4" class="outline-5">
<h5 id="sec-4-2-1-4">格式化volume</h5>
<div class="outline-text-5" id="text-4-2-1-4">
<p>
在mount前，还要格式化一下：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo mkfs.ext4 /dev/mapper/klose-thin-volumn-001
</pre>
</div>

<pre class="example">
mke2fs 1.43.3 (04-Sep-2016)
Discarding device blocks: done
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: 08c52fdf-ad29-437a-9957-9e8a23149088
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-1-5" class="outline-5">
<h5 id="sec-4-2-1-5">挂载volume</h5>
<div class="outline-text-5" id="text-4-2-1-5">
<p>
接下来可以mount了：
</p>
<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo mkdir -p /mnt/base
wu@ubuntu16-188:~$ sudo mount /dev/mapper/klose-thin-volumn-001 /mnt/base/

root@ubuntu16-188:~#  echo <span style="color: #ffa07a;">"hello world, I am a base"</span> &gt; /mnt/base/id.txt
root@ubuntu16-188:~# cat /mnt/base/id.txt
hello world, I am a base
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-1-6" class="outline-5">
<h5 id="sec-4-2-1-6">创建snapshot</h5>
<div class="outline-text-5" id="text-4-2-1-6">
<p>
终于可以来看看snapshot怎么搞：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo dmsetup message /dev/mapper/klose-thin-pool 0 <span style="color: #ffa07a;">"create_snap 1 0"</span>
wu@ubuntu16-188:~$ sudo dmsetup create mysnap1 <span style="color: #ffa07a;">\</span>
&gt;                    --table <span style="color: #ffa07a;">"0 2097152 thin /dev/mapper/klose-thin-pool 1"</span>
wu@ubuntu16-188:~$ sudo ls -l  /dev/mapper/mysnap1
lrwxrwxrwx 1 root root 7 Oct 16 17:09 /dev/mapper/mysnap1 -&gt; ../dm-4
</pre>
</div>

<p>
上面的命令中：
</p>
<ul class="org-ul">
<li>第一条命令是向klose-thin-pool发一个create_snap的消息，后面跟两个id：
<ul class="org-ul">
<li>第一个是新的dev id
</li>
<li>第二个是要从哪个已有的dev id上做snapshot，0这个dev id是我们前面就创建了的
</li>
</ul>
</li>
<li>第二条命令是创建一个mysnap1的device，并可以被mount
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-4-2-1-7" class="outline-5">
<h5 id="sec-4-2-1-7">挂载snapshot</h5>
<div class="outline-text-5" id="text-4-2-1-7">
<p>
mount这个新创建的snapshot：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo mkdir -p /mnt/mysnap1
wu@ubuntu16-188:~$ sudo mount /dev/mapper/mysnap1 /mnt/mysnap1/
wu@ubuntu16-188:~$ sudo ls -l /mnt/mysnap1/
total 20
-rw-r--r-- 1 root root    25 Oct 16 15:48 id.txt
drwx------ 2 root root 16384 Oct 16 15:38 lost+found
wu@ubuntu16-188:~$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base
</pre>
</div>

<p>
我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：
</p>

<div class="org-src-container">

<pre class="src src-sh">root@ubuntu16-188:~# echo <span style="color: #ffa07a;">"I am snap1"</span> &gt;&gt; /mnt/mysnap1/id.txt
root@ubuntu16-188:~# echo <span style="color: #ffa07a;">"I am snap1"</span> &gt;&gt; /mnt/mysnap1/snap1.txt
root@ubuntu16-188:~# cat /mnt/mysnap1/id.txt
hello world, I am a base
I am snap1

root@ubuntu16-188:~# cat /mnt/mysnap1/snap1.txt
I am snap1
</pre>
</div>

<p>
再看一下/mnt/base，会发现没有什么变化，这就已经可以看到了分层镜像的样子了
</p>
<div class="org-src-container">

<pre class="src src-sh">root@ubuntu16-188:~#ls /mnt/base/
id.txt  lost+found

root@ubuntu16-188:~# cat /mnt/base/id.txt
hello world, I am a base
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-1-8" class="outline-5">
<h5 id="sec-4-2-1-8">多层snapshot</h5>
<div class="outline-text-5" id="text-4-2-1-8">
<p>
还可以继续在刚才的snapshot上再建一个snapshot：
</p>

<div class="org-src-container">

<pre class="src src-sh">wu@ubuntu16-188:~$ sudo dmsetup message /dev/mapper/klose-thin-pool 0 <span style="color: #ffa07a;">"create_snap 2 1"</span>
wu@ubuntu16-188:~$  sudo dmsetup create mysnap2 <span style="color: #ffa07a;">\</span>
&gt;                    --table <span style="color: #ffa07a;">"0 2097152 thin /dev/mapper/klose-thin-pool 2"</span>
wu@ubuntu16-188:~$ sudo ls -l /dev/mapper/mysnap2
lrwxrwxrwx 1 root root 7 Oct 16 17:31 /dev/mapper/mysnap2 -&gt; ../dm-5
wu@ubuntu16-188:~$ sudo mkdir -p /mnt/
base/    mysnap1/
wu@ubuntu16-188:~$ sudo mkdir -p /mnt/mysnap2
wu@ubuntu16-188:~$ sudo mount /dev/mapper/mysnap2 /mnt/mysnap2/
wu@ubuntu16-188:~$ sudo ls /mnt/mysnap2/
id.txt  lost+found  snap1.txt
</pre>
</div>

<p>
最后补点理论知识吧：
</p>
<ul class="org-ul">
<li>Snapshot来自LVM（Logic Volumn Manager），它可以在不中断服务的情况下为某个device打一个快照
</li>
<li>Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内存进行拷贝
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Docker的DeviceMapper</h3>
<div class="outline-text-3" id="text-4-3">
<p>
可以看一下docker的loopback设备：
</p>

<div class="org-src-container">

<pre class="src src-sh">[root@xen12-166 ~]$ losetup -a
/dev/loop0: [64768]:268449090 (/var/lib/docker/devicemapper/devicemapper/data)
/dev/loop1: [64768]:268449091 (/var/lib/docker/devicemapper/devicemapper/metadata)
</pre>
</div>

<p>
其中data 100GB，metadata 2.0GB：
</p>
<div class="org-src-container">

<pre class="src src-sh">[root@xen12-166 ~]$ ls -alhs /var/lib/docker/devicemapper/devicemapper
total 17G
0 drwx------ 2 root root   32 Jun  1 12:08 .
0 drwx------ 5 root root   50 Jun  1 13:42 ..
17G -rw------- 1 root root 100G Oct 16 17:42 data
59M -rw------- 1 root root 2.0G Oct 16 17:41 metadata
</pre>
</div>

<p>
下面是相关的thin-pool， 其中一大串hash串的device是正在启动的容器：
</p>
<div class="org-src-container">

<pre class="src src-sh">  [root@xen12-166 ~]$ ls -l /dev/mapper/docker*

  lrwxrwxrwx 1 root root 8 Oct 16 17:06 /dev/mapper/docker-253:0-144069364-066e0a37b7e7e4bec72d4ff342a34e56ab8e4fd8338c5853b6d0cf7a78518656 -&gt; ../dm-37
.......
  lrwxrwxrwx 1 root root 8 Sep 26 13:04 /dev/mapper/docker-253:0-144069364-e48c295abcaa8bac8fc23e0454d3879c5a2f351c514588f21c2b650be3b95dcd -&gt; ../dm-10
  lrwxrwxrwx 1 root root 7 Sep 26 13:04 /dev/mapper/docker-253:0-144069364-e51d640bf993763f542231df21226074cd8538e2f172f59812e2c9f6e32d0e7f -&gt; ../dm-5
  lrwxrwxrwx 1 root root 7 Sep 26 13:05 /dev/mapper/docker-253:0-144069364-fafd411a11413b4d0f2f02ff6a4b93a6bf8419dbd028e8c93516d4f1d04298af -&gt; ../dm-9
  lrwxrwxrwx 1 root root 7 Sep 26 13:04 /dev/mapper/docker-253:0-144069364-ff31f1db928b9820c6e73f63021c1dd772dde490340349a69438b8ed0986cf66 -&gt; ../dm-7
  lrwxrwxrwx 1 root root 7 Sep 26 13:02 /dev/mapper/docker-253:0-144069364-pool -&gt; ../dm-2
</pre>
</div>

<p>
可以看一下它的device id：
</p>
<div class="org-src-container">

<pre class="src src-sh">[root@xen12-166 ~]$ cat /var/lib/docker/devicemapper/metadata/066e0a37b7e7e4bec72d4ff342a34e56ab8e4fd8338c5853b6d0cf7a78518656
{<span style="color: #ffa07a;">"device_id"</span>:6715,<span style="color: #ffa07a;">"size"</span>:10737418240,<span style="color: #ffa07a;">"transaction_id"</span>:22227,<span style="color: #ffa07a;">"initialized"</span>:false,<span style="color: #ffa07a;">"deleted"</span>:false}
</pre>
</div>

<p>
device_id是6715，size是10737418240，除以512，就是20971520 个 sector 
</p>

<p>
<b>Thin Provisioning的文档中说，这还处理实验阶段，不要上Production</b> 
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
