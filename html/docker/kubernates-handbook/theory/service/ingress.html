<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ingress</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../css/main.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="toplogy.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Ingress</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1e6cea3">定义</a></li>
<li><a href="#org56bf4f4">前提</a></li>
<li><a href="#org55986e7">Ingress 资源</a></li>
<li><a href="#org3370269">Ingress controller</a></li>
<li><a href="#org943f7dd">Ingress 类型</a>
<ul>
<li><a href="#orgb5ed8d6">单 Service Ingress</a></li>
<li><a href="#orga21bf90">简单展开</a></li>
<li><a href="#org778d882">基于名称的虚拟主机</a>
<ul>
<li><a href="#org6fc1922">TLS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4a8d964">更新</a></li>
<li><a href="#org5fc66c8">跨可用域故障</a></li>
<li><a href="#org1f90001">未来</a></li>
<li><a href="#org40f8659">替代方案</a></li>
<li><a href="#orga2b957a">Traefik</a>
<ul>
<li><a href="#org1d0bc8b">与nginx 共存</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<span class="underline">Ingress</span> 是从 <span class="underline">Kubernetes 集群外部</span> 访问 <span class="underline">集群内部服务</span> 的入口。先澄清几个术语：
</p>
<ul class="org-ul">
<li><span class="underline">节点</span> ：Kubernetes 集群中的一台物理机或者虚拟机</li>
<li><p>
<span class="underline">集群</span> ：位于 Internet 防火墙后的节点
</p>
<pre class="example" id="orgd63969e">
这是 kubernetes 管理的主要计算资源
</pre></li>
<li><p>
<span class="underline">边界路由器</span> ：为集群强制执行防火墙策略的路由器
</p>
<pre class="example" id="org926fb80">
这可能是由云提供商或物理硬件管理的网关
</pre></li>
<li><p>
<span class="underline">集群网络</span> ：一组逻辑或物理链接，可根据 Kubernetes 网络模型实现集群内的通信
</p>
<pre class="example" id="orgb1b06dc">
集群网络的实现包括 Overlay 模型的 flannel 和基于 SDN 的 OVS
</pre></li>
<li><p>
<span class="underline">服务</span> ：使用标签选择器标识一组 pod 成为的 Kubernetes 服务
</p>
<pre class="example" id="org7600ea4">
除非另有说明，否则服务假定在集群网络内仅可通过虚拟 IP 访问
</pre></li>
</ul>

<pre class="example" id="orgca2a1f9">
接下来还会讲到使用 Traefik 来做 Ingress controller，并给出了几个相关链接
</pre>

<div id="outline-container-org1e6cea3" class="outline-2">
<h2 id="org1e6cea3">定义</h2>
<div class="outline-text-2" id="text-org1e6cea3">
<p>
通常情况下，service 和 pod 仅可在集群内部网络中通过 IP 地址访问。所有到达边界路由器的流量或被丢弃或被转发到其他地方。从概念上讲，可能像下面这样：
</p>
<pre class="example" id="orgd6d5871">
  internet
      |
------------
[Services]
</pre>

<p>
<span class="underline">Ingress</span> 是 <b>授权</b> <span class="underline">入站连接</span> 到达 <span class="underline">集群服务</span> 的 <b>规则集合</b>
</p>

<pre class="example" id="org708f4e5">
 internet
     |
[Ingress]
--|-----|--
[Services]
</pre>

<p>
可以给 Ingress 配置提供外部可访问的 <span class="underline">URL</span> 、 <span class="underline">负载均衡</span> 、 <span class="underline">SSL</span> 、 <span class="underline">基于名称的虚拟主机</span> 等：
</p>
<ul class="org-ul">
<li>用户通过 POST Ingress 资源到 API server 的方式来请求 ingress</li>
<li><span class="underline">Ingress controller</span> 负责实现 Ingress，通常使用 <span class="underline">负载均衡器</span> 
<ul class="org-ul">
<li>还可以配置边界路由和其他前端，这有助于以高可用的方式处理流量</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org56bf4f4" class="outline-2">
<h2 id="org56bf4f4">前提</h2>
<div class="outline-text-2" id="text-org56bf4f4">
<p>
在使用 Ingress 资源之前，有必要先了解下面几件事情：
</p>
<ul class="org-ul">
<li>Ingress 资源对象在 Kubernetes 1.1 之前还没有</li>
<li>需要一个 Ingress Controller 来实现 Ingress，单纯的创建一个 Ingress 没有任何意义
<ul class="org-ul">
<li>GCE/GKE 会在 master 节点上部署一个 ingress controller
<ul class="org-ul">
<li>可以在一个 pod 中部署任意个自定义的 ingress controller</li>
<li>必须正确地注解每个 ingress，比如运行多个 ingress controller 和关闭 glbc</li>
</ul></li>
<li>在非 GCE/GKE 的环境中，需要在 pod 中 部署一个 controller，例如 Nginx Ingress Controller</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org55986e7" class="outline-2">
<h2 id="org55986e7">Ingress 资源</h2>
<div class="outline-text-2" id="text-org55986e7">
<p>
最简化的 Ingress 配置如下：
</p>

<pre class="example" id="org5c9ce4c">
1: apiVersion: extensions/v1beta1
2: kind: Ingress
3: metadata:
4:   name: test-ingress
5: spec:
6:   rules:
7:   - http:
8:       paths:
9:       - path: /testpath
10:        backend:
11:           serviceName: test
12:           servicePort: 80
</pre>

<ul class="org-ul">
<li>1-4 行 ：跟 Kubernetes 的其他配置一样，ingress 的配置也需要 apiVersion，kind 和 metadata 字段</li>
<li>5-7 行 : Ingress spec 中包含配置一个 <span class="underline">loadbalancer</span> 或 <span class="underline">proxy server</span> 的所有信息
<ul class="org-ul">
<li><p>
最重要的是，它包含了一个匹配 <span class="underline">所有入站请求</span> 的 <b>规则列表</b> 
</p>
<pre class="example" id="org7e0ab1d">
目前 ingress 只支持 http 规则
</pre></li>
</ul></li>
<li>8-9 行 ：每条 http 规则包含以下信息：
<ul class="org-ul">
<li><p>
一个 <span class="underline">host</span> 配置项
</p>
<pre class="example" id="orgedf5fc5">
比如 for.bar.com，在这个例子中默认是 *
</pre></li>
<li><p>
<span class="underline">path</span> 列表
</p>
<pre class="example" id="orga5ea69b">
比如：/testpath
</pre>
<ul class="org-ul">
<li><p>
每个 path 都关联一个 backend
</p>
<pre class="example" id="orgb7b0898">
比如 test:80
</pre></li>
</ul></li>
<li>在 loadbalancer 将流量转发到 backend 之前， <span class="underline">所有的入站请求</span> 都要先 <b>匹配</b>  <span class="underline">host</span> 和 <span class="underline">path</span></li>
</ul></li>
<li>10-12 行 ：backend 是一个 service:port 的组合。Ingress 的流量被转发到它所匹配的 backend</li>
</ul>

<pre class="example" id="orgc84b19c">
如果没有配置 Ingress controller 就将其 POST 到 API server 不会有任何用处

为了简单起见，示例中没有全局参数：在所有请求都不能跟 spec 中的 path 匹配的情况下，请求被发送到 Ingress controller 的默认后端，可以指定全局缺省 backend
</pre>
</div>
</div>

<div id="outline-container-org3370269" class="outline-2">
<h2 id="org3370269">Ingress controller</h2>
<div class="outline-text-2" id="text-org3370269">
<p>
为了使 Ingress 正常工作，集群中必须运行 Ingress controller：
</p>
<ul class="org-ul">
<li>Kubernetes 当前支持并维护 GCE 和 nginx 两种 controller</li>
<li>F5 公司 支持并维护 F5 BIG-IP Controller for Kubernetes</li>
<li>Kong 同时支持并维护 社区版 与 企业版 的 Kong Ingress Controller for Kubernetes</li>
<li>Traefik 是功能齐全的 ingress controller (Let’s Encrypt, secrets, http2, websocket…), Containous 也对其提供商业支持</li>
<li>Istio 使用 CRD Gateway 来 控制 Ingress 流量</li>
</ul>

<pre class="example" id="org103523e">
这与其他类型的控制器不同，其他类型的控制器通常作为 kube-controller-manager 二进制文件的一部分运行，在集群启动时自动启动

用户需要选择最适合自己集群的 Ingress controller 或者自己实现一个

确保使用前查看控制器特定的文档，以便了解每个文档的注意事项
</pre>
</div>
</div>

<div id="outline-container-org943f7dd" class="outline-2">
<h2 id="org943f7dd">Ingress 类型</h2>
<div class="outline-text-2" id="text-org943f7dd">
</div>
<div id="outline-container-orgb5ed8d6" class="outline-3">
<h3 id="orgb5ed8d6">单 Service Ingress</h3>
<div class="outline-text-3" id="text-orgb5ed8d6">
<pre class="example" id="org07b54df">
Kubernetes 中已经存在一些概念可以暴露单个 service，但是仍然可以通过 Ingress 来实现
</pre>
<p>
通过指定一个 <span class="underline">没有 rule</span> 的默认 backend 的方式：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: extensions/v1beta1
<span style="color: #4eee94;">kind</span>: Ingress
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: test-ingress
  <span style="color: #4eee94;">spec</span>:
    <span style="color: #4eee94;">backend</span>:
      <span style="color: #4eee94;">serviceName</span>: testsvc
      <span style="color: #4eee94;">servicePort</span>: 80
</pre>
</div>

<p>
使用kubectl create -f命令创建，然后查看 ingress：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl get ing
NAME                RULE          BACKEND        ADDRESS
test-ingress        -             testsvc:80     107.178.254.228
</pre>
</div>

<pre class="example" id="orgd136a5a">
107.178.254.228 就是 Ingress controller 为了实现 Ingress 而分配的 IP 地址

RULE 列表示所有发送给该 IP 的流量都被转发到了 BACKEND 所列的 Kubernetes service 上
</pre>
</div>
</div>

<div id="outline-container-orga21bf90" class="outline-3">
<h3 id="orga21bf90">简单展开</h3>
<div class="outline-text-3" id="text-orga21bf90">
<pre class="example" id="orgccd143d">
如前面描述的那样，kubernetes pod 中的 IP 只在集群网络内部可见，需要在边界设置一个东西，让它能够接收 ingress 的流量并将它们转发到正确的端点上
</pre>
<p>
这个东西一般是高可用的 loadbalancer。使用 Ingress 能够允许你将 loadbalancer 的个数降低到最少，例如，假如想要创建这样的一个设置：
</p>

<pre class="example" id="org5cca9cc">
foo.bar.com -&gt; 178.91.123.132 -&gt; /foo    s1:80
				 /bar    s2:80
</pre>

<p>
需要一个这样的 ingress：
</p>
<pre class="example" id="org705adf5">
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: test
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - path: /foo
	backend:
	  serviceName: s1
	  servicePort: 80
      - path: /bar
	backend:
	  serviceName: s2
	  servicePort: 80
</pre>

<p>
使用 kubectl create -f 创建完 ingress 后：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl get ing
NAME      RULE          BACKEND   ADDRESS
<span style="color: #f08080;">test</span>      -
foo.bar.com
/foo          s1:80
/bar          s2:80
</pre>
</div>

<pre class="example" id="orgae6cc00">
只要服务（s1，s2）存在，Ingress controller 就会将提供一个满足该 Ingress 的特定 loadbalancer 实现

这一步完成后，将在 Ingress 的最后一列看到 loadbalancer 的地址
</pre>
</div>
</div>

<div id="outline-container-org778d882" class="outline-3">
<h3 id="org778d882">基于名称的虚拟主机</h3>
<div class="outline-text-3" id="text-org778d882">
<p>
Name-based 的虚拟主机在同一个 IP 地址下拥有多个主机名：
</p>

<pre class="example" id="orgfe6635f">
foo.bar.com --|                 |-&gt; foo.bar.com s1:80
	      | 178.91.123.132  |
bar.foo.com --|                 |-&gt; bar.foo.com s2:80
</pre>

<p>
下面这个 ingress 说明基于 Host header 的后端 loadbalancer 的路由请求：
</p>

<pre class="example" id="orgce31684">
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: test
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - backend:
	  serviceName: s1
	  servicePort: 80
  - host: bar.foo.com
    http:
      paths:
      - backend:
	  serviceName: s2
	  servicePort: 80
</pre>

<p>
默认 backend：一个没有 rule 的 ingress
</p>

<pre class="example" id="orge89e30e">
如前面所示，所有流量都将发送到一个默认 backend。可以用该技巧通知 loadbalancer 如何找到你网站的 404 页面，通过制定一些列 rule 和一个默认 backend 的方式

如果请求 header 中的 host 不能跟 ingress 中的 host 匹配，并且 / 或请求的 URL 不能与任何一个 path 匹配，则流量将路由到你的默认 backend
</pre>
</div>

<div id="outline-container-org6fc1922" class="outline-4">
<h4 id="org6fc1922">TLS</h4>
<div class="outline-text-4" id="text-org6fc1922">
<p>
可以通过指定包含 <span class="underline">TLS 私钥</span> 和 <span class="underline">证书的 secret</span> 来加密 Ingress
</p>
<pre class="example" id="org67cf36f">
目前，Ingress 仅支持单个 TLS 端口 443，并假定 TLS termination
</pre>
<ul class="org-ul">
<li>如果 Ingress 中的 TLS 配置部分指定了不同的主机，则它们将根据通过 SNI TLS 扩展指定的主机名在多个相同端口上进行复用</li>
<li><p>
TLS secret 中必须包含名为 <span class="underline">tls.crt</span> 和 <span class="underline">tls.key</span> 的密钥，这里面包含了用于 TLS 的证书和私钥，例如：
</p>

<pre class="example" id="orgcc5a409">
apiVersion: v1
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
kind: Secret
metadata:
  name: testsecret
  namespace: default
type: Opaque
</pre>

<p>
在 Ingress 中引用这个 secret 将通知 Ingress controller 使用 TLS 加密从将客户端到 loadbalancer 的 channel：
</p>

<pre class="example" id="org4d34ec9">
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: no-rules-map
spec:
  tls:
    - secretName: testsecret
  backend:
    serviceName: s1
    servicePort: 80
</pre>

<p>
请注意：
</p>
<ul class="org-ul">
<li>各种 Ingress controller 支持的 TLS 功能之间存在差距</li>
<li><p>
Ingress controller 启动时附带一些适用于所有 Ingress 的负载平衡策略设置，例如负载均衡算法，后端权重方案等
</p>
<pre class="example" id="org602805f">
更高级的负载平衡概念（例如持久会话，动态权重）尚未在 Ingress 中公开，只能通过 service loadbalancer 获取这些功能

随着时间的推移，计划将适用于跨平台的负载平衡模式加入到 Ingress 资源中
</pre></li>
<li><p>
尽管健康检查不直接通过 Ingress 公开
</p>
<pre class="example" id="orga1e3a11">
Kubernetes 中存在类似概念，例如 可用性探针，可以达成相同的最终结果
</pre></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org4a8d964" class="outline-2">
<h2 id="org4a8d964">更新</h2>
<div class="outline-text-2" id="text-org4a8d964">
<p>
假如想要向已有的 ingress 中增加一个新的 Host，可以编辑和更新该 ingress：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl get ing
NAME      RULE          BACKEND   ADDRESS
<span style="color: #f08080;">test</span>      -                       178.91.123.132
foo.bar.com
/foo          s1:80
$ kubectl edit ing test
</pre>
</div>

<p>
这会弹出一个包含已有的 yaml 文件的编辑器，修改它，增加新的 Host 配置：
</p>

<pre class="example" id="orgc3f9fa9">
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - backend:
	  serviceName: s1
	  servicePort: 80
	path: /foo
  - host: bar.baz.com
    http:
      paths:
      - backend:
	  serviceName: s2
	  servicePort: 80
	path: /foo
..
</pre>

<p>
保存它会更新 API server 中的资源，这会触发 ingress controller 重新配置 loadbalancer：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl get ing
NAME      RULE          BACKEND   ADDRESS
<span style="color: #f08080;">test</span>      -                       178.91.123.132
foo.bar.com
/foo          s1:80
bar.baz.com
/foo          s2:80
</pre>
</div>

<p>
在一个修改过的 ingress yaml 文件上调用 <span class="underline">kubectl replace -f</span> 命令一样可以达到同样的效果
</p>
</div>
</div>

<div id="outline-container-org5fc66c8" class="outline-2">
<h2 id="org5fc66c8">跨可用域故障</h2>
<div class="outline-text-2" id="text-org5fc66c8">
<p>
在不同云供应商之间，跨故障域的流量传播技术有所不同
</p>
<pre class="example" id="org7d85fa7">
有关详细信息，请查看相关 Ingress controller 的文档

有关在 federation 集群中部署 Ingress 的详细信息，请参阅 federation 文档
</pre>
</div>
</div>

<div id="outline-container-org1f90001" class="outline-2">
<h2 id="org1f90001">未来</h2>
<div class="outline-text-2" id="text-org1f90001">
<ul class="org-ul">
<li>多样化的 HTTPS/TLS 模型支持（如 SNI，re-encryption）</li>
<li>通过声明来请求 IP 或者主机名</li>
<li>结合 L4 和 L7 Ingress</li>
<li>更多的 Ingress controller</li>
</ul>
</div>
</div>

<div id="outline-container-org40f8659" class="outline-2">
<h2 id="org40f8659">替代方案</h2>
<div class="outline-text-2" id="text-org40f8659">
<p>
可以通过很多种方式暴露 service 而不必直接使用 ingress：
</p>
<ul class="org-ul">
<li>使用 Service.Type=LoadBalancer</li>
<li>使用 Service.Type=NodePort</li>
<li>使用 Port Proxy</li>
<li>部署一个 Service loadbalancer 这允许在多个 service 之间共享单个 IP，并通过 Service Annotations 实现更高级的负载平衡</li>
</ul>
</div>
</div>

<div id="outline-container-orga2b957a" class="outline-2">
<h2 id="orga2b957a">Traefik</h2>
<div class="outline-text-2" id="text-orga2b957a">
<p>
如果部署了 <span class="underline">Traefik</span> 作为 Ingress Controller，集群外部直接访问 Kubenetes 内部服务的话，可以直接创建 Ingress 如下所示：
</p>

<pre class="example" id="orgd3767ee">
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: traefik-ingress
  namespace: default
spec:
  rules:
  - host: traefik.nginx.io
    http:
      paths:
      - path: /
	backend:
	  serviceName: my-nginx
	  servicePort: 80
</pre>
</div>

<div id="outline-container-org1d0bc8b" class="outline-3">
<h3 id="org1d0bc8b">与nginx 共存</h3>
<div class="outline-text-3" id="text-org1d0bc8b">
<p>
当处于迁移应用到 Kubernetes 上的阶段时，可能有部分服务实例不在 Kubernetes上，服务的路由使用 Nginx 配置，这时处于 nginx 和 ingress 共存的状态。参考下面的配置：
</p>

<pre class="example" id="orgd27aebd">
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: td-ingress
  namespace: default
  annotations:
    traefik.frontend.rule.type: PathPrefixStrip
    kubernetes.io/ingress.class: traefik
spec:
  rules:
  - host: "*.jimmysong.io"
    http:
      paths:
      - path: /docGenerate
	backend:
	  serviceName: td-sdmk-docgenerate
	  servicePort: 80
</pre>

<p>
annotation 的配置：
</p>
<ul class="org-ul">
<li><span class="underline">traefik.frontend.rule.type: PathPrefixStrip</span> 表示将截掉 URL 中的 path</li>
<li><span class="underline">kubernetes.io/ingress.class：traefik</span> 表示使用的 ingress 类型</li>
</ul>

<p>
在 Nginx 中增加配置：
</p>

<pre class="example" id="org059cae8">
upstream docGenerate {
       server 172.20.0.119:80;
       keepalive 200;
}
</pre>

<p>
<span class="underline">172.20.0.119</span> 是 <b>边缘节点的 VIP</b> 
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="api-object.html">Next: Service API</a></td>
<td class="org-left"><a href="toplogy.html">Previous：拓扑感知路由</a></td>
<td class="org-left"><a href="index.html">Home：服务发现和路由</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
