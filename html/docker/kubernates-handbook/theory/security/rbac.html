<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>基于角色的访问控制</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../css/main.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="service_account.html"> UP </a>
 |
 <a accesskey="H" href="security.html"> HOME </a>
</div><div id="content">
<h1 class="title">基于角色的访问控制</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2f9fa01">API</a>
<ul>
<li><a href="#org8180d5a">Role 与 ClusterRole</a></li>
<li><a href="#orga037f17">RoleBinding 与 ClusterRoleBinding</a></li>
<li><a href="#orgc05ff7f">对资源的引用</a></li>
<li><a href="#org5e6a12b">例子</a>
<ul>
<li><a href="#orgb6d66dd">角色定义</a></li>
<li><a href="#orgd7c5175">角色绑定</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org02aa63a">默认角色与默认角色绑定</a>
<ul>
<li><a href="#org1a0b97e">自动更新</a></li>
<li><a href="#orge767f47">发现类角色</a></li>
<li><a href="#org7f668b0">面向用户的角色</a></li>
<li><a href="#org7186b28">核心组件角色</a></li>
<li><a href="#org88d8642">其它组件角色</a></li>
<li><a href="#orgf13730a">控制器角色</a></li>
</ul>
</li>
<li><a href="#orgd983326">初始化与预防权限升级</a></li>
<li><a href="#orgbca7088">命令行工具</a></li>
<li><a href="#org5ea5759">服务账户权限</a>
<ul>
<li><a href="#org205059e">对某一特定应用程序的服务账户授予角色（最佳实践）</a></li>
<li><a href="#org56ccff9">在某一命名空间中授予 default 服务账号一个角色</a></li>
<li><a href="#org519cd81">为命名空间中所有的服务账号授予角色</a></li>
<li><a href="#org5ffb720">对集群范围内的所有服务账户授予一个受限角色（不鼓励）</a></li>
<li><a href="#orge027b44">授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
基于角色的访问控制（ <span class="underline">Role-Based Access Control</span> ）使用 <span class="underline">rbac.authorization.k8s.io</span> API Group 实现 <b>授权</b> 决策，允许管理员通过 Kubernetes API 动态配置策略
</p>

<pre class="example" id="org1fee044">
要启用 RBAC，请使用 --authorization-mode=RBAC 启动 API Server
</pre>
<div id="outline-container-org2f9fa01" class="outline-2">
<h2 id="org2f9fa01">API</h2>
<div class="outline-text-2" id="text-org2f9fa01">
<p>
接下来将介绍 RBAC API 所定义的四种顶级类型
</p>

<pre class="example" id="orgb94e616">
用户可以像使用其他 Kubernetes API 资源一样 （例如通过 kubectl、API 调用等）与这些资源进行交互

例如，命令 kubectl create -f (resource).yml 可以被用于以下所有的例子
</pre>
</div>
<div id="outline-container-org8180d5a" class="outline-3">
<h3 id="org8180d5a">Role 与 ClusterRole</h3>
<div class="outline-text-3" id="text-org8180d5a">
<p>
在 RBAC API 中，一个 <span class="underline">角色</span> 包含了一套表示 <span class="underline">一组权限</span> 的规则：
</p>
<ul class="org-ul">
<li>权限以纯粹的 <b>累加</b> 形式累积（没有” 否定” 的规则）
<ul class="org-ul">
<li>角色可以由 <span class="underline">namespace</span> 内的 <b>Role</b> 对象定义</li>
<li>整个 <span class="underline">Kubernetes 集群</span> 范围内有效的角色则通过 <b>ClusterRole</b> 对象实现</li>
</ul></li>
</ul>

<p>
一个 Role 对象只能用于授予对某一单一命名空间中资源的访问权限
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">kind</span>: Role
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">namespace</span>: default
  <span style="color: #4eee94;">name</span>: pod-reader
<span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>] <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#31354;&#23383;&#31526;&#20018;"" &#34920;&#26126;&#20351;&#29992; core API group</span>
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"pods"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"watch"</span>, <span style="color: #deb887;">"list"</span>]
</pre>
</div>

<pre class="example" id="org0cb8c8f">
以上示例描述了 _default_ 命名空间中的一个 Role 对象的定义，用于授予对 pod 的读访问权限
</pre>

<p>
ClusterRole 对象可以授予与 Role 对象相同的权限，但由于它们属于集群范围对象， 用它们授予对以下几种资源的访问权限：
</p>
<ul class="org-ul">
<li><p>
集群范围资源
</p>
<pre class="example" id="org2e4027f">
例如节点，即 node
</pre></li>
<li><p>
非资源类型 endpoint
</p>
<pre class="example" id="org802d3ae">
例如”/healthz”
</pre></li>
<li><p>
跨所有命名空间的命名空间范围资源
</p>
<pre class="example" id="orgc515fd5">
例如 pod，需要运行命令 kubectl get pods --all-namespaces 来查询集群中所有的 pod
</pre></li>
</ul>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">kind</span>: ClusterRole
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#37492;&#20110; ClusterRole &#26159;&#38598;&#32676;&#33539;&#22260;&#23545;&#35937;&#65292;&#25152;&#20197;&#36825;&#37324;&#19981;&#38656;&#35201;&#23450;&#20041; "namespace" &#23383;&#27573;</span>
  <span style="color: #4eee94;">name</span>: secret-reader
<span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"secrets"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"watch"</span>, <span style="color: #deb887;">"list"</span>]
</pre>
</div>

<pre class="example" id="orge9a8f21">
示例中的 ClusterRole 定义可用于授予用户对某一特定命名空间，或者所有命名空间中的 secret（取决于其 绑定 方式）的读访问权限
</pre>
</div>
</div>
<div id="outline-container-orga037f17" class="outline-3">
<h3 id="orga037f17">RoleBinding 与 ClusterRoleBinding</h3>
<div class="outline-text-3" id="text-orga037f17">
<p>
角色绑定将一个角色中定义的各种权限授予一个或者一组用户：
</p>
<ul class="org-ul">
<li>角色绑定包含了一组相关主体：
<ul class="org-ul">
<li>用户 User</li>
<li>用户组 Group</li>
<li>服务账户 Service Account</li>
<li>对被授予角色的引用</li>
</ul></li>
<li>在命名空间中可以通过 RoleBinding 对象授予权限</li>
<li>集群范围的权限授予则通过 ClusterRoleBinding 对象完成</li>
</ul>

<p>
RoleBinding 可以引用在同一命名空间内定义的 Role 对象
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">kind</span>: RoleBinding
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: read-pods
  <span style="color: #4eee94;">namespace</span>: default
<span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: User
  <span style="color: #4eee94;">name</span>: jane
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
<span style="color: #4eee94;">roleRef</span>:
  <span style="color: #4eee94;">kind</span>: Role
  <span style="color: #4eee94;">name</span>: pod-reader
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<pre class="example" id="org0ea25d3">
示例中定义的 RoleBinding 对象在 ”default” 命名空间中将 ”pod-reader” 角色授予用户”jane”

这一授权将允许用户”jane” 从”default” 命名空间中读取 pod
</pre>

<p>
RoleBinding 对象也可以引用一个 ClusterRole 对象
</p>

<pre class="example" id="org1047124">
这一点允许管理员在整个集群范围内首先定义一组通用的角色，然后再在不同的命名空间中复用这些角色
</pre>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20197;&#19979;&#35282;&#33394;&#32465;&#23450;&#20801;&#35768;&#29992;&#25143; "dave" &#35835;&#21462; "development" &#21629;&#21517;&#31354;&#38388;&#20013;&#30340; secret&#12290;</span>
<span style="color: #4eee94;">kind</span>: RoleBinding
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: read-secrets
  <span style="color: #4eee94;">namespace</span>: development <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#36825;&#37324;&#34920;&#26126;&#20165;&#25480;&#26435;&#35835;&#21462; "development" &#21629;&#21517;&#31354;&#38388;&#20013;&#30340;&#36164;&#28304;&#12290;</span>
<span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: User
  <span style="color: #4eee94;">name</span>: dave
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
<span style="color: #4eee94;">roleRef</span>:
  <span style="color: #4eee94;">kind</span>: ClusterRole
  <span style="color: #4eee94;">name</span>: secret-reader
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<pre class="example" id="orgbe2a8cf">
尽管示例中的 RoleBinding 引用的是一个 ClusterRole 对象，但是用户”dave”（即角色绑定主体）还是只能读取”development” 命名空间中的 secret（即 RoleBinding 所在的命名空间）
</pre>

<p>
也可以使用ClusterRoleBinding在集群级别和所有命名空间中授予权限
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">kind</span>: ClusterRoleBinding
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: read-secrets-global
<span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: manager
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
<span style="color: #4eee94;">roleRef</span>:
  <span style="color: #4eee94;">kind</span>: ClusterRole
  <span style="color: #4eee94;">name</span>: secret-reader
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<pre class="example" id="org5990812">
示例中所定义的ClusterRoleBinding允许在用户组”manager” 中的任何用户都可以读取集群中任何命名空间中的 secret
</pre>
</div>
</div>
<div id="outline-container-orgc05ff7f" class="outline-3">
<h3 id="orgc05ff7f">对资源的引用</h3>
<div class="outline-text-3" id="text-orgc05ff7f">
<p>
大多数资源由代表其 <span class="underline">名字的字符串</span> 表示
</p>
<pre class="example" id="orgca53807">
例如”pods”，就像它们出现在相关 API endpoint 的 URL 中一样
</pre>

<p>
然而，有一些 Kubernetes API 还 包含了 <span class="underline">子资源</span> 
</p>

<pre class="example" id="orgec17b66">
比如 pod 的 logs，在 Kubernetes 中 pod logs endpoint 的 URL 格式为：

GET /api/v1/namespaces/{namespace}/pods/{name}/log
</pre>

<p>
在这种情况下，”pods” 是 <span class="underline">命名空间资源</span> ，而 ”log” 是 pods 的子资源。为了在 RBAC 角色中表示出这一点，需要使用 <span class="underline">斜线</span> 来划分资源 与子资源。如果需要角色绑定主体读取 pods 以及 pod log，需要定义以下角色：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">kind</span>: Role
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1beta1
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">namespace</span>: default
  <span style="color: #4eee94;">name</span>: pod-and-pod-logs-reader
<span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"pods"</span>, <span style="color: #deb887;">"pods/log"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"list"</span>]
</pre>
</div>

<p>
通过 <span class="underline">resourceNames</span> 列表，角色可以针对不同种类的请求根据资源名引用资源实例。当指定了resourceNames列表时，不同 <span class="underline">动作</span> 种类的请求的权限将被 <b>限定</b> 到资源列表中所包含的资源实例上
</p>
<pre class="example" id="orgcde56d6">
如使用”get”、”delete”、”update” 以及”patch” 等动词的请求
</pre>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">kind</span>: Role
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">namespace</span>: default
  <span style="color: #4eee94;">name</span>: configmap-updater
<span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"configmap"</span>]
  <span style="color: #4eee94;">resourceNames</span>: [<span style="color: #deb887;">"my-configmap"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"update"</span>, <span style="color: #deb887;">"get"</span>]
</pre>
</div>

<pre class="example" id="org12adecb">
如果需要限定一个角色绑定主体只能”get” 或者”update” 一个 configmap 时，可以定义上面这个角色
</pre>

<p>
注意：如果设置了 <span class="underline">resourceNames</span> ，则请求所使用的动词 <b>不能</b> 是 <span class="underline">list</span> 、 <span class="underline">watch</span> 、 <span class="underline">create</span> 或者 <span class="underline">deletecollection</span> 
</p>

<pre class="example" id="org3bc10d1">
由于资源名不会出现在 create、list、watch 和 deletecollection 等 API 请求的 URL 中，所以这些请求动词不会被设置了 resourceNames 的规则所允许，因为规则中的resourceNames 部分不会匹配这些请求
</pre>
</div>
</div>
<div id="outline-container-org5e6a12b" class="outline-3">
<h3 id="org5e6a12b">例子</h3>
<div class="outline-text-3" id="text-org5e6a12b">
</div>
<div id="outline-container-orgb6d66dd" class="outline-4">
<h4 id="orgb6d66dd">角色定义</h4>
<div class="outline-text-4" id="text-orgb6d66dd">
<p>
允许读取 core API Group 中定义的资源”pods”：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"pods"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"list"</span>, <span style="color: #deb887;">"watch"</span>]
</pre>
</div>

<p>
允许读写在”extensions” 和”apps” API Group 中定义的”deployments”：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">"extensions"</span>, <span style="color: #deb887;">"apps"</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"deployments"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"list"</span>, <span style="color: #deb887;">"watch"</span>, <span style="color: #deb887;">"create"</span>, <span style="color: #deb887;">"update"</span>, <span style="color: #deb887;">"patch"</span>, <span style="color: #deb887;">"delete"</span>]
</pre>
</div>

<p>
允许读取一个名为”my-config” 的ConfigMap实例（需要将其通过RoleBinding绑定从而限制针对某一个命名空间中定义的一个ConfigMap实例的访问）：
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"configmaps"</span>]
  <span style="color: #4eee94;">resourceNames</span>: [<span style="color: #deb887;">"my-config"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>]
</pre>
</div>

<p>
允许读取 core API Group 中的”nodes” 资源（由于Node是集群级别资源，所以此ClusterRole定义需要与一个ClusterRoleBinding绑定才能有效）：
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">""</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"nodes"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"list"</span>, <span style="color: #deb887;">"watch"</span>]
</pre>
</div>

<p>
允许对非资源 endpoint “/healthz” 及其所有子路径的”GET” 和”POST” 请求（此ClusterRole定义需要与一个ClusterRoleBinding绑定才能有效）：
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">nonResourceURLs</span>: [<span style="color: #deb887;">"/healthz"</span>, <span style="color: #deb887;">"/healthz/*"</span>] <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#22312;&#38750;&#36164;&#28304; URL &#20013;&#65292;'*' &#20195;&#34920;&#21518;&#32512;&#36890;&#37197;&#31526;</span>
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"get"</span>, <span style="color: #deb887;">"post"</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7c5175" class="outline-4">
<h4 id="orgd7c5175">角色绑定</h4>
<div class="outline-text-4" id="text-orgd7c5175">
<p>
角色绑定主体 <span class="underline">Subject</span> 可以是用户组 <span class="underline">Group_、用户 _User</span> 或者服务账户 <span class="underline">Service Accounts</span> 
</p>
<ul class="org-ul">
<li><p>
用户：字符串表示
</p>
<pre class="example" id="orgceab3da">
可以是纯粹的用户名，例如”alice”、电子邮件风格的名字，如 “bob@example.com” 或者是用字符串表示的数字 id

由 Kubernetes 管理员配置 认证模块 以产生所需格式的用户名，对于用户名，RBAC 授权系统不要求任何特定的格式

然而，前缀 system: 是 为 Kubernetes 系统使用而保留的，所以管理员应该确保用户名不会意外地包含这个前缀
</pre></li>
<li><p>
用户组：信息由授权模块提供
</p>
<pre class="example" id="orgdb75d5c">
用户组与用户一样由字符串表示。Kubernetes 对用户组 字符串没有格式要求，但前缀 system: 同样是被系统保留的
</pre></li>
<li><p>
服务账户
</p>
<pre class="example" id="orge279f30">
拥有包含 system:serviceaccount: 前缀的用户名，并属于拥有 system:serviceaccounts: 前缀的用户组 
</pre></li>
</ul>

<p>
一个名为”alice@example.com” 的用户：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: User
  <span style="color: #4eee94;">name</span>: <span style="color: #deb887;">"alice@example.com"</span>
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<p>
一个名为”frontend-admins” 的用户组：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: <span style="color: #deb887;">"frontend-admins"</span>
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<p>
kube-system 命名空间中的默认服务账户：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: ServiceAccount
  <span style="color: #4eee94;">name</span>: default
  <span style="color: #4eee94;">namespace</span>: kube-system
</pre>
</div>

<p>
名为”qa” 命名空间中的所有服务账户：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: system:serviceaccounts:qa
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
&#8203;```&#22312;&#38598;&#32676;&#20013;&#30340;&#25152;&#26377;&#26381;&#21153;&#36134;&#25143;&#65306;

&#8203;```yaml
<span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: system:serviceaccounts
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<p>
所有认证过的用户：
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: system:authenticated
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
&#8203;```&#25152;&#26377;&#26410;&#35748;&#35777;&#30340;&#29992;&#25143;&#65288;version 1.5+&#65289;&#65306;

&#8203;```yaml
<span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: system:unauthenticated
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>

<p>
所有用户：
</p>
<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: system:authenticated
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
- <span style="color: #4eee94;">kind</span>: Group
  <span style="color: #4eee94;">name</span>: system:unauthenticated
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org02aa63a" class="outline-2">
<h2 id="org02aa63a">默认角色与默认角色绑定</h2>
<div class="outline-text-2" id="text-org02aa63a">
<p>
API Server 会创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。 这些默认对象中有许多包含 <span class="underline">system:</span> 前缀，表明这些资源由 Kubernetes 基础组件拥有
</p>

<pre class="example" id="org8c302c6">
对这些资源的修改可能导致集群无法工作（non-functional cluster）

一个例子是 system:node ClusterRole 对象，这个角色定义了 kubelets 的权限。如果这个角色被修改，可能会导致 kubelets 无法正常工作
</pre>

<p>
所有默认的 ClusterRole 和 ClusterRoleBinding 对象都会被标记为 <span class="underline">kubernetes.io/bootstrapping=rbac-defaults</span> 
</p>
</div>

<div id="outline-container-org1a0b97e" class="outline-3">
<h3 id="org1a0b97e">自动更新</h3>
<div class="outline-text-3" id="text-org1a0b97e">
<p>
每次启动时，API Server 都会更新默认 ClusterRole 所缺乏的各种权限，并更新默认 ClusterRoleBinding 所缺乏的各个角色绑定主体
</p>

<pre class="example" id="org936431c">
这种自动更新机制允许集群修复一些意外的修改，由于权限和角色绑定主体在新的 Kubernetes 释出版本中可能变化，这也能够保证角色和角色 绑定始终保持是最新的
</pre>

<p>
如果需要禁用自动更新，请将默认 ClusterRole 以及 ClusterRoleBinding 的 <span class="underline">rbac.authorization.kubernetes.io/autoupdate</span> 设置成为 false
</p>

<pre class="example" id="org07f3cd0">
注意，缺乏默认权限和角色绑定主体可能会导致非功能性集群问题
</pre>
</div>
</div>

<div id="outline-container-orge767f47" class="outline-3">
<h3 id="orge767f47">发现类角色</h3>
<div class="outline-text-3" id="text-orge767f47">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 发现类角色</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">默认 ClusterRole</td>
<td class="org-left">默认 ClusterRoleBinding</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">system:basic-user</td>
<td class="org-left">system:authenticated and system:unauthenticatedgroups</td>
<td class="org-left">允许用户只读访问有关自己的基本信息</td>
</tr>

<tr>
<td class="org-left">system:discovery</td>
<td class="org-left">system:authenticated and system:unauthenticatedgroups</td>
<td class="org-left">允许只读访问 API discovery endpoints, 用于在 API 级别进行发现和协商</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org7f668b0" class="outline-3">
<h3 id="org7f668b0">面向用户的角色</h3>
<div class="outline-text-3" id="text-org7f668b0">
<p>
一些默认角色并不包含 system: 前缀，它们是面向用户的角色。 这些角色包含 <span class="underline">超级用户</span> 角色（cluster-admin），即旨在利用 ClusterRoleBinding（cluster-status）在集群范围内授权的角色， 以及那些使用 RoleBinding（admin、edit 和 view）在特定命名空间中授权的角色 
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 面向用户的角色</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">默认 ClusterRole</td>
<td class="org-left">默认 ClusterRoleBinding</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">cluster-admin</td>
<td class="org-left">system:masters group</td>
<td class="org-left">超级用户权限，允许对任何资源执行任何操作。 在 ClusterRoleBinding 中使用时，可以完全控制集群和所有命名空间中的所有资源。 在 RoleBinding 中使用时，可以完全控制 RoleBinding 所在命名空间中的所有资源，包括命名空间自己</td>
</tr>

<tr>
<td class="org-left">admin</td>
<td class="org-left">None</td>
<td class="org-left">管理员权限，利用 RoleBinding 在某一命名空间内部授予。 在 RoleBinding 中使用时，允许针对命名空间内大部分资源的读写访问， 包括在命名空间内创建角色与角色绑定的能力。 但不允许对资源配额（resource quota）或者命名空间本身的写访问</td>
</tr>

<tr>
<td class="org-left">edit</td>
<td class="org-left">None</td>
<td class="org-left">允许对某一个命名空间内大部分对象的读写访问，但不允许查看或者修改角色或者角色绑定</td>
</tr>

<tr>
<td class="org-left">view</td>
<td class="org-left">None</td>
<td class="org-left">允许对某一个命名空间内大部分对象的只读访问。 不允许查看角色或者角色绑定。 由于可扩散性等原因，不允许查看 secret 资源</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org7186b28" class="outline-3">
<h3 id="org7186b28">核心组件角色</h3>
<div class="outline-text-3" id="text-org7186b28">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 核心组件角色</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">默认 ClusterRole</td>
<td class="org-left">默认 ClusterRoleBinding</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">system:kube-scheduler</td>
<td class="org-left">system:kube-scheduler user</td>
<td class="org-left">允许访问 kube-scheduler 组件所需要的资源</td>
</tr>

<tr>
<td class="org-left">system:kube-controller-manager</td>
<td class="org-left">system:kube-controller-manager user</td>
<td class="org-left">允许访问 kube-controller-manager 组件所需要的资源</td>
</tr>

<tr>
<td class="org-left">system:node</td>
<td class="org-left">system:nodes group (deprecated in 1.7)</td>
<td class="org-left">允许对 kubelet 组件所需要的资源的访问，包括读取所有 secret 和对所有 pod 的写访问</td>
</tr>

<tr>
<td class="org-left">system:node-proxier</td>
<td class="org-left">system:kube-proxy user</td>
<td class="org-left">允许对 kube-proxy 组件所需要资源的访问</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org88d8642" class="outline-3">
<h3 id="org88d8642">其它组件角色</h3>
<div class="outline-text-3" id="text-org88d8642">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> 其他组件角色</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">默认 ClusterRole</td>
<td class="org-left">默认 ClusterRoleBinding</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">system:auth-delegator</td>
<td class="org-left">None</td>
<td class="org-left">允许委托认证和授权检查。 通常由附加 API Server 用于统一认证和授权</td>
</tr>

<tr>
<td class="org-left">system:heapster</td>
<td class="org-left">None</td>
<td class="org-left">Heapster 组件的角色</td>
</tr>

<tr>
<td class="org-left">system:kube-aggregator</td>
<td class="org-left">None</td>
<td class="org-left">kube-aggregator 组件的角色</td>
</tr>

<tr>
<td class="org-left">system:kube-dns</td>
<td class="org-left">kube-dns service account in the kube-systemnamespace</td>
<td class="org-left">kube-dns 组件的角色</td>
</tr>

<tr>
<td class="org-left">system:node-bootstrapper</td>
<td class="org-left">None</td>
<td class="org-left">允许对执行 Kubelet TLS 引导（Kubelet TLS bootstrapping） 所需要资源的访问</td>
</tr>

<tr>
<td class="org-left">system:node-problem-detector</td>
<td class="org-left">None</td>
<td class="org-left">node-problem-detector 组件的角色</td>
</tr>

<tr>
<td class="org-left">system:persistent-volume-provisioner</td>
<td class="org-left">None</td>
<td class="org-left">允许对大部分动态存储卷创建组件（dynamic volume provisioner）所需要资源的访问</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf13730a" class="outline-3">
<h3 id="orgf13730a">控制器角色</h3>
<div class="outline-text-3" id="text-orgf13730a">
<p>
Kubernetes controller manager 负责运行核心控制循环：
</p>
<ul class="org-ul">
<li>当使用 <span class="underline">&#x2013;use-service-account-credentials</span> 选项运行 controller manager 时，每个 <span class="underline">控制循环</span> 都将使用 <b>单独的服务账户</b> 启动。 而每个控制循环都存在对应的 <span class="underline">角色</span> ，前缀名为 <span class="underline">system:controller:</span></li>
<li>如果不使用 &#x2013;use-service-account-credentials 选项时，controller manager 将会使用 <b>自己的凭证</b> 运行所有控制循环，而这些凭证必须被 <b>授予</b> 相关的角色</li>
</ul>

<p>
这些控制器角色包括：
</p>
<ul class="org-ul">
<li>system:controller:attachdetach-controller</li>
<li>system:controller:certificate-controller</li>
<li>system:controller:cronjob-controller</li>
<li>system:controller:daemon-set-controller</li>
<li>system:controller:deployment-controller</li>
<li>system:controller:disruption-controller</li>
<li>system:controller:endpoint-controller</li>
<li>system:controller:generic-garbage-collector</li>
<li>system:controller:horizontal-pod-autoscaler</li>
<li>system:controller:job-controller</li>
<li>system:controller:namespace-controller</li>
<li>system:controller:node-controller</li>
<li>system:controller:persistent-volume-binder</li>
<li>system:controller:pod-garbage-collector</li>
<li>system:controller:replicaset-controller</li>
<li>system:controller:replication-controller</li>
<li>system:controller:resourcequota-controller</li>
<li>system:controller:route-controller</li>
<li>system:controller:service-account-controller</li>
<li>system:controller:service-controller</li>
<li>system:controller:statefulset-controller</li>
<li>system:controller:ttl-controller</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd983326" class="outline-2">
<h2 id="orgd983326">初始化与预防权限升级</h2>
<div class="outline-text-2" id="text-orgd983326">
<p>
RBAC API 会 <b>阻止</b> 用户通过 <span class="underline">编辑角色</span> 或者 <span class="underline">角色绑定</span> 来 <b>升级权限</b> 
</p>
<pre class="example" id="org957f659">
由于这一点是在 API 级别实现的，所以在 RBAC 授权器（RBAC authorizer）未启用的状态下依然可以正常工作
</pre>

<p>
用户只有在 <b>拥有</b> 了 <span class="underline">角色</span> 所包含的 <b>所有权限的条件</b> 下才能创建／更新一个 <span class="underline">角色</span> ，这些操作还必须在 <b>角色所处的相同范围</b> 内进行
</p>
<pre class="example" id="orgfe98619">
对于 ClusterRole 来说是集群范围，对于 Role 来说是在与角色相同的命名空间或者集群范围

例如，如果用户”user-1” 没有权限读取集群范围内的 secret 列表，那么他也不能创建包含这种权限的 ClusterRole
</pre>
<p>
为了能够让用户创建／更新角色，需要：
</p>
<ol class="org-ol">
<li>授予用户一个角色以允许他们根据需要创建／更新 Role 或者 ClusterRole 对象</li>
<li>授予用户一个角色包含他们在 Role 或者 ClusterRole 中所能够设置的所有权限
<ul class="org-ul">
<li>如果用户尝试创建或者修改 Role 或者 ClusterRole 以设置那些他们未被授权的权限时，这些 API 请求将被禁止</li>
</ul></li>
</ol>

<p>
用户只有在拥有 <span class="underline">所引用的角色</span> 中包含的 <b>所有权限</b> 时才可以创建／更新 <span class="underline">角色绑定</span> ，这些操作也必须在角色绑定所处的相同范围内进行 或者 用户被明确授权可以在所引用的角色上执行绑定操作
</p>

<pre class="example" id="org8084d78">
例如，如果用户”user-1” 没有权限读取集群范围内的 secret 列表，那么他将不能创建 ClusterRole 来引用那些授予了此项权限的角色
</pre>

<p>
为了能够让用户创建／更新角色绑定，需要：
</p>
<ol class="org-ol">
<li>授予用户一个角色以允许他们根据需要创建／更新 RoleBinding 或者 ClusterRoleBinding 对象</li>
<li>授予用户绑定某一特定角色所需要的权限：
<ul class="org-ul">
<li>隐式地，通过授予用户所有所引用的角色中所包含的权限</li>
<li>显式地，通过授予用户在特定 Role（或者 ClusterRole）对象上执行 bind 操作的权限</li>
</ul></li>
</ol>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1beta1
<span style="color: #4eee94;">kind</span>: ClusterRole
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: role-grantor
<span style="color: #4eee94;">rules</span>:
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">"rbac.authorization.k8s.io"</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"rolebindings"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"create"</span>]
- <span style="color: #4eee94;">apiGroups</span>: [<span style="color: #deb887;">"rbac.authorization.k8s.io"</span>]
  <span style="color: #4eee94;">resources</span>: [<span style="color: #deb887;">"clusterroles"</span>]
  <span style="color: #4eee94;">verbs</span>: [<span style="color: #deb887;">"bind"</span>]
  <span style="color: #4eee94;">resourceNames</span>: [<span style="color: #deb887;">"admin"</span>,<span style="color: #deb887;">"edit"</span>,<span style="color: #deb887;">"view"</span>]
<span style="color: #5f9ea0; font-style: italic;">---</span>
<span style="color: #4eee94;">apiVersion</span>: rbac.authorization.k8s.io/v1beta1
<span style="color: #4eee94;">kind</span>: RoleBinding
<span style="color: #4eee94;">metadata</span>:
  <span style="color: #4eee94;">name</span>: role-grantor-binding
  <span style="color: #4eee94;">namespace</span>: user-1-namespace
<span style="color: #4eee94;">roleRef</span>:
  <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
  <span style="color: #4eee94;">kind</span>: ClusterRole
  <span style="color: #4eee94;">name</span>: role-grantor
<span style="color: #4eee94;">subjects</span>:
- <span style="color: #4eee94;">apiGroup</span>: rbac.authorization.k8s.io
  <span style="color: #4eee94;">kind</span>: User
  <span style="color: #4eee94;">name</span>: user-1
</pre>
</div>

<p>
当初始化第一个角色和角色绑定时，初始用户需要能够授予他们尚未拥有的权限。 初始化初始角色和角色绑定时需要：
</p>
<ul class="org-ul">
<li>使用包含 <span class="underline">system：masters</span> 用户组的 <b>凭证</b> ，该用户组通过默认绑定绑定到 <span class="underline">cluster-admin</span> <b>超级用户</b> 角色</li>
<li>如果 API Server 在运行时启用了非安全端口 <span class="underline">&#x2013;insecure-port</span> ，也可以通过这个没有施行认证或者授权的端口发送角色或者角色绑定请求</li>
</ul>
</div>
</div>

<div id="outline-container-orgbca7088" class="outline-2">
<h2 id="orgbca7088">命令行工具</h2>
<div class="outline-text-2" id="text-orgbca7088">
<pre class="example" id="orgf53a3bb">
有两个 kubectl 命令可以用于在命名空间内或者整个集群内授予角色
</pre>

<p>
在某一特定命名空间内授予 Role 或者 ClusterRole 
</p>
<pre class="example" id="orgb2c1aeb">
kubectl create rolebinding
</pre>

<p>
示例如下：
</p>
<ul class="org-ul">
<li><p>
在名为”acme” 的命名空间中将 admin ClusterRole 授予用户”bob”：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ kubectl create rolebinding bob-admin-binding --clusterrole=admin --user=bob --namespace=acme
</pre>
</div></li>
<li><p>
在名为”acme” 的命名空间中将 view ClusterRole 授予服务账户”myapp”：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ kubectl create rolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp --namespace=acme
</pre>
</div></li>
</ul>

<p>
在整个集群中授予 ClusterRole，包括所有命名空间：
</p>
<pre class="example" id="org7e6f357">
$ kubectl create clusterrolebinding
</pre>

<p>
示例如下：
</p>
<ul class="org-ul">
<li><p>
在整个集群范围内将 cluster-admin ClusterRole 授予用户”root”：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --user=root
</pre>
</div></li>
<li><p>
在整个集群范围内将 system:node ClusterRole 授予用户”kubelet”：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ kubectl create clusterrolebinding kubelet-node-binding --clusterrole=system:node --user=kubelet
</pre>
</div></li>
<li><p>
在整个集群范围内将 view ClusterRole 授予命名空间”acme” 内的服务账户”myapp”：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ kubectl create clusterrolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org5ea5759" class="outline-2">
<h2 id="org5ea5759">服务账户权限</h2>
<div class="outline-text-2" id="text-org5ea5759">
<pre class="example" id="orgc62ae15">
默认的 RBAC 策略将授予控制平面组件 control-plane component 、节点 node 和控制器 controller一组范围受限的权限

但对于 ”kube-system” 命名空间以外的服务账户，则 不授予任何权限 （超出授予所有认证用户的发现权限）
</pre>
<p>
这一点允许根据需要向 <span class="underline">特定服务账号</span> 授予 <span class="underline">特定权限</span> 
</p>

<pre class="example" id="orga3c71fe">
细粒度的角色绑定将提供更好的安全性，但需要更多精力管理

更粗粒度的授权可能授予服务账号不需要的 API 访问权限（甚至导致潜在授权扩散），但更易于管理
</pre>

<p>
从最安全到最不安全可以排序以下方法
</p>
</div>
<div id="outline-container-org205059e" class="outline-3">
<h3 id="org205059e">对某一特定应用程序的服务账户授予角色（最佳实践）</h3>
<div class="outline-text-3" id="text-org205059e">
<p>
要求应用程序在其 pod spec 中指定 serviceAccountName 字段，并且要创建相应服务账户
</p>
<pre class="example" id="orge52f8cf">
例如，在”my-namespace” 命名空间中授予服务账户”my-sa” 只读权限
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl create rolebinding my-sa-view <span style="color: #deb887;">\</span>
  --clusterrole=view <span style="color: #deb887;">\</span>
  --serviceaccount=my-namespace:my-sa <span style="color: #deb887;">\</span>
  --namespace=my-namespace
</pre>
</div>
</div>
</div>
<div id="outline-container-org56ccff9" class="outline-3">
<h3 id="org56ccff9">在某一命名空间中授予 default 服务账号一个角色</h3>
<div class="outline-text-3" id="text-org56ccff9">
<p>
如果一个应用程序没有在其 pod 规范中指定 serviceAccountName，它将默认使用 <span class="underline">default</span> 服务账号
</p>
<pre class="example" id="org01d6907">
注意：授予 default 服务账号的权限将可用于命名空间内任何没有指定 serviceAccountName 的 pod 

下面的例子将在”my-namespace” 命名空间内授予 ”default” 服务账号只读权限
</pre>

<div class="org-src-container">
<pre class="src src-sh">kubectl create rolebinding default-view <span style="color: #deb887;">\</span>
  --clusterrole=view <span style="color: #deb887;">\</span>
  --serviceaccount=my-namespace:default <span style="color: #deb887;">\</span>
  --namespace=my-namespace
</pre>
</div>

<p>
目前 许多 加载项（addon） 作为 <span class="underline">kube-system</span> 命名空间中的 <span class="underline">default</span> 服务帐户运行。 要允许这些加载项使用超级用户访问权限，请将 <span class="underline">cluster-admin</span> 权限授予 <span class="underline">kube-system</span> 命名空间中的 <span class="underline">default</span> 服务帐户
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl create clusterrolebinding add-on-cluster-admin <span style="color: #deb887;">\</span>
  --clusterrole=cluster-admin <span style="color: #deb887;">\</span>
  --serviceaccount=kube-system:default 
</pre>
</div>

<pre class="example" id="orgeeda54d">
注意：启用上述操作意味着 ”kube-system” 命名空间将包含允许超级用户访问 API 的秘钥
</pre>
</div>
</div>

<div id="outline-container-org519cd81" class="outline-3">
<h3 id="org519cd81">为命名空间中所有的服务账号授予角色</h3>
<div class="outline-text-3" id="text-org519cd81">
<p>
如果希望命名空间内的所有应用程序都拥有同一个角色，无论它们使用什么服务账户，可以为该命名空间的服务账户用户组授予角色 
</p>

<pre class="example" id="org78cdb77">
下面的例子将授予 ”my-namespace” 命名空间中的所有服务账户只读权限
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl create rolebinding serviceaccounts-view <span style="color: #deb887;">\</span>
  --clusterrole=view <span style="color: #deb887;">\</span>
  --group=system:serviceaccounts:my-namespace <span style="color: #deb887;">\</span>
  --namespace=my-namespace
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ffb720" class="outline-3">
<h3 id="org5ffb720">对集群范围内的所有服务账户授予一个受限角色（不鼓励）</h3>
<div class="outline-text-3" id="text-org5ffb720">
<p>
如果不想管理每个命名空间的权限，则可以将集群范围角色授予所有服务帐户 
</p>

<pre class="example" id="org9683f77">
下面的例子将所有命名空间中的只读权限授予集群中的所有服务账户
</pre>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl create clusterrolebinding serviceaccounts-view <span style="color: #deb887;">\</span>
  --clusterrole=view <span style="color: #deb887;">\</span>
  --group=system:serviceaccounts
</pre>
</div>
</div>
</div>

<div id="outline-container-orge027b44" class="outline-3">
<h3 id="orge027b44">授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</h3>
<div class="outline-text-3" id="text-orge027b44">
<p>
如果根本不关心权限分块，可以对所有服务账户授予超级用户访问权限。
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style="color: #deb887;">\</span>
  --clusterrole=cluster-admin <span style="color: #deb887;">\</span>
  --group=system:serviceaccounts
</pre>
</div>

<pre class="example" id="org6c1dd3d">
警告：这种做法将允许任何具有读取权限的用户访问 secret 或者通过创建一个容器的方式来访问超级用户的凭据
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="network_policy.html">Next：网络策略</a></td>
<td class="org-left"><a href="service_account.html">Previous: Service Account</a></td>
<td class="org-left"><a href="security.html">Home：安全</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
