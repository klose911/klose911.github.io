<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kubernetes 中的用户与身份认证授权</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../css/main.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="authentication.html"> UP </a>
 |
 <a accesskey="H" href="security.html"> HOME </a>
</div><div id="content">
<h1 class="title">Kubernetes 中的用户与身份认证授权</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7a25e73">用户</a></li>
<li><a href="#orgd2766c8">策略</a>
<ul>
<li><a href="#org45a77a0">X509 客户端证书</a></li>
<li><a href="#orgaf18453">静态 Token 文件</a>
<ul>
<li><a href="#org3458d50">在请求中放置 Bearer Token</a></li>
</ul>
</li>
<li><a href="#org22bf315">Bootstrap Token</a></li>
<li><a href="#orgb3ef653">静态密码文件</a></li>
<li><a href="#orgb7c600f">Service Account Token</a></li>
<li><a href="#org2fdef6f">OpenID Connect Token</a>
<ul>
<li><a href="#org8eb0274">配置 API Server</a></li>
<li><a href="#org4752b88">使用</a>
<ul>
<li><a href="#org4a379bc">选项 1 - OIDC 身份验证器</a></li>
<li><a href="#org4c5f400">选项 2 - 使用 &#x2013;token 选项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org90e19cd">Webhook Token 认证</a></li>
<li><a href="#org7f8c3ee">认证代理</a></li>
<li><a href="#orgbb75cd2">Keystone密码</a></li>
</ul>
</li>
<li><a href="#orgaf36473">匿名请求</a></li>
<li><a href="#orga09f89f">用户模拟</a></li>
</ul>
</div>
</div>
<pre class="example" id="org54f0ccf">
在安装集群的时候在 master 节点上生成了一堆证书、token，还在 kubelet 的配置中用到了 bootstrap token

安装各种应用时，为了能够与 API server 通信创建了各种 service account

在 Dashboard 中使用了 kubeconfig 或 token 登陆

那么这些都属于什么认证方式？如何区分用户的？
</pre>

<p>
重点查看 bearer token 和 HTTP 认证中的 token 如 <a href="authentication.html">身份认证</a>
</p>
<div id="outline-container-org7a25e73" class="outline-2">
<h2 id="org7a25e73">用户</h2>
<div class="outline-text-2" id="text-org7a25e73">
<p>
Kubernetes 集群中包含两类用户：
</p>
<ul class="org-ul">
<li>由 Kubernetes 管理的 service account：
<ul class="org-ul">
<li>service account 是由 Kubernetes API 管理的帐户</li>
<li>绑定到了特定的 namespace</li>
<li>由 API server 自动创建，或者通过 API 调用手动创建</li>
<li>关联了一套凭证，存储在 Secret，这些凭证同时被挂载到 pod 中，从而允许 pod 与 kubernetes API 之间的调用</li>
</ul></li>
<li><p>
普通用户：普通用户被假定为由外部独立服务管理
</p>
<pre class="example" id="orga42487c">
管理员分发私钥，用户存储（如 Keystone 或 Google 帐户），甚至包含用户名和密码列表的文件

在这方面，Kubernetes 没有代表普通用户帐户的对象，无法通过 API 调用的方式向集群中添加普通用户
</pre></li>
</ul>


<p>
API 请求被绑定到普通用户或 serivce account 上，或者作为匿名请求对待
</p>

<pre class="example" id="org9d9f9d0">
这意味着集群内部或外部的每个进程，无论从：
1. 在工作站上输入 kubectl 的人类用户
2. 节点上的 kubelet
3. 控制平面的成员

都必须在向 API Server 发出请求时进行身份验证，或者被视为匿名用户 
</pre>
</div>
</div>
<div id="outline-container-orgd2766c8" class="outline-2">
<h2 id="orgd2766c8">策略</h2>
<div class="outline-text-2" id="text-orgd2766c8">
<p>
Kubernetes 使用 <span class="underline">客户端证书</span> 、 <span class="underline">bearer token</span> 、 <span class="underline">身份验证代理</span> 或者 <span class="underline">HTTP 基本身份验证</span> 等 <b>身份认证插件</b> 来对 API 请求进行身份验证。当有 HTTP 请求发送到 API server 时，插件会尝试将以下属性关联到请求上：
</p>
<ul class="org-ul">
<li><p>
<b>用户名</b> ：标识最终用户的字符串
</p>
<pre class="example" id="org33766f6">
常用值可能是 kube-admin 或 jane@example.com
</pre></li>
<li><p>
<b>UID</b> ：标识最终用户的字符串
</p>
<pre class="example" id="orgdf4bbfd">
比用户名更加一致且唯一
</pre></li>
<li><b>组</b> ：一组将用户和常规用户组相关联的字符串</li>
<li>额外字段：包含其他有用认证信息的字符串列表的映射</li>
</ul>

<pre class="example" id="org1f3c425">
所有的值对于认证系统都是不透明的，只有 授权人 才能解释这些值的重要含义
</pre>

<p>
可以一次性启用多种身份验证方式。通常使用至少以下两种认证方式：
</p>
<ul class="org-ul">
<li>服务帐户的 service account token</li>
<li>至少一种其他的用户认证的方式</li>
</ul>

<pre class="example" id="org04db25b">
当启用了多个认证模块时，第一个认证模块成功认证后将短路请求，不会进行第二个模块的认证

API server 不会保证认证的顺序
</pre>

<p>
<span class="underline">system:authenticated</span> 组包含在所有已验证用户的组列表中 
</p>

<pre class="example" id="org1249f6d">
与其他身份验证协议（LDAP、SAML、Kerberos、x509 方案等）的集成可以使用身份验证代理或身份验证 webhook来实现
</pre>
</div>
<div id="outline-container-org45a77a0" class="outline-3">
<h3 id="org45a77a0">X509 客户端证书</h3>
<div class="outline-text-3" id="text-org45a77a0">
<p>
通过将 <span class="underline">&#x2013;client-ca-file=SOMEFILE</span> 选项传递给 API server 来启用客户端证书认证：
</p>
<ul class="org-ul">
<li>引用的文件必须包含一个或多个证书颁发机构，用于验证提交给 API server 的客户端证书</li>
<li>如果客户端证书已提交并验证，则使用 <span class="underline">subject</span> 的 <span class="underline">Common Name</span> （CN）作为请求的 <span class="underline">用户名</span></li>
<li><p>
客户端证书还可以使用证书的 <span class="underline">organization</span> 字段来指示用户的 <span class="underline">组成员</span> 身份
</p>
<pre class="example" id="orgbd6599c">
要为用户包含多个组成员身份，请在证书中包含多个 organization 字段
</pre></li>
</ul>

<p>
例如，使用 openssl 命令工具生成用于签名认证请求的证书：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style="color: #ffa07a;">"/CN=jbeda/O=app1/O=app2"</span>
</pre>
</div>

<pre class="example" id="orgdab66dc">
这将为一个用户名为 ”jbeda“ 的 CSR，属于两个组“app1”和“app2”
</pre>
</div>
</div>
<div id="outline-container-orgaf18453" class="outline-3">
<h3 id="orgaf18453">静态 Token 文件</h3>
<div class="outline-text-3" id="text-orgaf18453">
<p>
当在命令行上指定 <span class="underline">&#x2013;token-auth-file=SOMEFILE</span> 选项时，API server 从文件读取 bearer token
</p>

<pre class="example" id="org2b3c1e1">
目前，token 会无限期地持续下去，并且不重新启动 API server 的话就无法更改令牌列表 
</pre>

<p>
token 文件是一个 csv 文件，每行至少包含三列：token、用户名、用户 uid，其次是可选的组名
</p>
<pre class="example" id="orgcca203a">
token,user,uid,"group1,group2,group3"
</pre>

<p>
请注意，如果有多个组，则该列必须使用双引号
</p>
</div>
<div id="outline-container-org3458d50" class="outline-4">
<h4 id="org3458d50">在请求中放置 Bearer Token</h4>
<div class="outline-text-4" id="text-org3458d50">
<p>
当使用来自 http 客户端的 bearer token 时，API server 期望 Authorization header 中包含 Bearer token 的值。Bearer token 必须是一个字符串序列，只需使用 HTTP 的编码和引用功能就可以将其放入到 HTTP header 中
</p>

<pre class="example" id="org806f2bb">
例如：如果 bearer token 是 31ada4fd-adec-460c-809a-9e56ceb75269
</pre>

<p>
那么它将出现在 HTTP header 中，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org22bf315" class="outline-3">
<h3 id="org22bf315">Bootstrap Token</h3>
<div class="outline-text-3" id="text-org22bf315">
<p>
为了简化新集群的初始化引导过程，Kubernetes 中包含了一个名为 Bootstrap Token 的动态管理的 bearer token：
</p>
<ul class="org-ul">
<li>这些 token 使用 Secret 存储在 kube-system namespace 中，在那里它们可以被动态管理和创建</li>
<li>Controller Manager 中包含了一个 TokenCleaner 控制器，用于在 bootstrap token 过期时删除将其删除。</li>
</ul>

<p>
这些 token 的形式是 <span class="underline">[a-z0-9]{6}.[a-z0-9]{16}</span> ：
</p>
<ol class="org-ol">
<li>第一部分是 Token ID</li>
<li>第二部分是 Token Secret</li>
</ol>

<p>
在 HTTP header 中指定的 token 如下所示：
</p>

<div class="org-src-container">
<pre class="src src-sh">Authorization: Bearer 781292.db7bc3a58fc5f07e
</pre>
</div>

<p>
在 API server 的启动参数中加上 <span class="underline">&#x2013;experimental-bootstrap-token-auth</span> 标志以启用 Bootstrap Token Authenticator
</p>

<pre class="example" id="org7d128e7">
必须通过 Controller Manager 上的 --controllers 标志启用 TokenCleaner 控制器，如 --controllers=*,tokencleaner

如果使用它来引导集群， kubeadm 会自己完成
</pre>

<p>
用户被认证为 <span class="underline">system:bootstrap:&lt;Token ID&gt;</span> 。被包含在 <span class="underline">system:bootstrappers</span> 组中
</p>

<pre class="example" id="org4e6b35b">
命名和组是有意限制用户使用过去的 bootstap token

可以使用用户名和组（kubeadm 使用）来制定适当的授权策略以支持引导集群
</pre>
</div>
</div>
<div id="outline-container-orgb3ef653" class="outline-3">
<h3 id="orgb3ef653">静态密码文件</h3>
<div class="outline-text-3" id="text-orgb3ef653">
<p>
通过将 <span class="underline">&#x2013;basic-auth-file=SOMEFILE</span> 选项传递给 API server 来启用基本身份验证
</p>

<pre class="example" id="org77ae3dd">
目前，基本身份验证凭证将无限期地保留，并且密码在不重新启动API服务器的情况下无法更改

请注意，目前支持基本身份验证只是为了方便使用，而其他模式更安全 
</pre>

<p>
基本身份认证是一个 csv 文件，至少包含3列：密码、用户名和用户 ID
</p>

<div class="org-src-container">
<pre class="src src-sh">password,user,uid,<span style="color: #ffa07a;">"group1,group2,group3"</span>
</pre>
</div>

<pre class="example" id="org275da05">
可以指定包含以逗号分隔的组名称的可选第四列

如果有多个组，则必须将第四列值用双引号括起来
</pre>

<p>
当使用来自 HTTP 客户端的基本身份验证时，API server 需要Authorization header 中包含 Basic BASE64ENCODED(USER:PASSWORD) 的值
</p>
</div>
</div>
<div id="outline-container-orgb7c600f" class="outline-3">
<h3 id="orgb7c600f">Service Account Token</h3>
<div class="outline-text-3" id="text-orgb7c600f">
<p>
Service account 是一个 <b>自动启用</b> 的 <span class="underline">验证器</span> ，它使用签名的 bearer token 来验证请求。该插件包括两个可选的标志：
</p>
<ul class="org-ul">
<li><p>
<span class="underline">&#x2013;service-account-key-file</span> : 一个包含签名 bearer token 的 PEM 编码文件
</p>
<pre class="example" id="orgb999aee">
如果未指定，将使用 API server 的 TLS 私钥
</pre></li>
<li><span class="underline">&#x2013;service-account-lookup</span> : 如果启用，从 API 中删除掉的 token 将被撤销</li>
</ul>

<p>
Service account:
</p>
<ul class="org-ul">
<li>通常 API server 自动创建，</li>
<li>通过 ServiceAccount 注入控制器 关联到集群中运行的 Pod 上</li>
<li>Bearer token 挂载到 pod 中，并允许集群进程与 API server 通信</li>
<li>可以使用 PodSpec 的 serviceAccountName 字段显式地与Pod关联</li>
</ul>

<pre class="example" id="orgdc11d03">
注意： serviceAccountName 通常被省略，因为这会自动生成
</pre>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #eedd82;">apiVersion</span>: apps/v1beta2
<span style="color: #eedd82;">kind</span>: Deployment
<span style="color: #eedd82;">metadata</span>:
  <span style="color: #eedd82;">name</span>: nginx-deployment
  <span style="color: #eedd82;">namespace</span>: default
  <span style="color: #eedd82;">spec</span>:
    <span style="color: #eedd82;">replicas</span>: 3
    <span style="color: #eedd82;">template</span>:
      <span style="color: #eedd82;">metadata</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #ff4500;"># </span><span style="color: #ff4500;">...</span>
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">spec</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  containers</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">    - name</span>: nginx
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">      image</span>: nginx:1.7.9
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">      serviceAccountName</span>: bob-the-bot
</pre>
</div>

<pre class="example" id="orgfbec84f">
Service account bearer token 在集群外使用也是完全有效的，并且可以用于为希望与 Kubernetes 通信的长期运行作业创建身份
</pre>

<p>
要手动创建 service account，只需要使用 <span class="underline">kubectl create serviceaccount</span> (NAME) 命令。这将在当前的 namespace 和相关连的 secret 中创建一个 service account:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl create serviceaccount jenkins
serviceaccount <span style="color: #ffa07a;">"jenkins"</span> created
$ kubectl get serviceaccounts jenkins -o yaml
apiVersion: v1
kind: ServiceAccount
metadata:
<span style="color: #ff4500;"># </span><span style="color: #ff4500;">...</span>
secrets:
- name: jenkins-token-1yvwg
</pre>
</div>

<p>
创建出的 secret 中拥有 API server 的公共 CA 和前面的 JSON Web Token（JWT）:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl get secret jenkins-token-1yvwg -o yaml
apiVersion: v1
data:
ca.crt: (APISERVER<span style="color: #ffa07a;">'S CA BASE64 ENCODED)</span>
<span style="color: #ffa07a;">  namespace: ZGVmYXVsdA==</span>
<span style="color: #ffa07a;">  token: (BEARER TOKEN BASE64 ENCODED)</span>
<span style="color: #ffa07a;">kind: Secret</span>
<span style="color: #ffa07a;">metadata:</span>
<span style="color: #ffa07a;">  # ...</span>
<span style="color: #ffa07a;">type: kubernetes.io/service-account-token</span>
</pre>
</div>

<pre class="example" id="orgd2bd4c4">
注意：所有值是基于 base64 编码的，因为 secret 总是基于 base64 编码
</pre>

<p>
经过签名的 JWT 可以用作 bearer token 与给定的 service account 进行身份验证
</p>

<pre class="example" id="org87827e6">
通常情况下，这些 secret 被挂载到 pod 中，以便对集群内的 API server 进行访问，但也可以从集群外访问
</pre>

<p>
Service account 被验证后：
</p>
<ul class="org-ul">
<li>用户名: <span class="underline">system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</span></li>
<li>被指定到组 <span class="underline">system:serviceaccounts</span> 和 <span class="underline">system:serviceaccounts:(NAMESPACE)</span></li>
</ul>

<pre class="example" id="org2f030fd">
由于 service account 的 token 存储在 secret 中，所以具有对这些 secret 的读取权限的任何用户都可以作为 service account 进行身份验证

授予 service account 权限和读取 secret 功能时要谨慎
</pre>
</div>
</div>
<div id="outline-container-org2fdef6f" class="outline-3">
<h3 id="org2fdef6f">OpenID Connect Token</h3>
<div class="outline-text-3" id="text-org2fdef6f">
<pre class="example" id="orgd8ffae3">
OpenID Connect 是由 OAuth2 供应商提供的 OAuth2，特别是 Azure Active Directory、Salesforce 和 Google

对 OAuth2 协议的主要扩展是返回一个称作 ID Token 的格外字段，该 token 是一个 JSON Web Token (JWT) ，有服务器签名，具有众所周知的字段，如用户的电子邮件
</pre>

<p>
为了识别用户，认证者使用 OAuth2 token 响应 中的 <b>id_token</b> （而不是 access_token）作为 bearer token
</p>


<div id="orgce6aab1" class="figure">
<p><img src="../../pic/kubernetes-oidc-login.jpg" alt="kubernetes-oidc-login.jpg" width="90%" />
</p>
</div>

<ol class="org-ol">
<li>登陆到身份提供商</li>
<li>身份提供商将提供一个 <span class="underline">access_token</span> ，一个 <span class="underline">id_token</span> 和一个 <span class="underline">refresh_token</span></li>
<li>当使用 kubectl 时，使用 <span class="underline">&#x2013;token</span> 标志和 <b>id_token</b> ，或者直接加入到 <span class="underline">kubeconfig</span> 文件中</li>
<li>kubectl 在调用 API server 时将 id_token 置于 HTTP header 中</li>
<li>API server 将通过 <b>检查</b> <span class="underline">配置</span> 中指定的 <span class="underline">证书</span> 来确保 JWT 签名有效</li>
<li>检查以 <b>确保</b> id_token <span class="underline">没有过期</span></li>
<li><b>确保</b> 用户已 <span class="underline">授权</span></li>
<li>授权 API server 后向 kubectl 返回结果</li>
<li>kubectl 向用户提供反馈</li>
</ol>

<pre class="example" id="org58f73fe">
由于所有需要验证您身份的数据都在 id_token 中，Kubernetes 不需要向身份提供商 “phone home”

在每个请求都是无状态的模型中，这为认证提供了非常可扩展的解决方案
</pre>
<p>
然而它确实提供了一些挑战：
</p>
<ul class="org-ul">
<li><p>
Kubernetes 没有 ”web 接口“ 来出发验证进程。没有浏览器或界面来收集凭据
</p>
<pre class="example" id="orgd69db84">
这就是为什么您需要首先认证身份提供商
</pre></li>
<li><p>
id_token 无法撤销，就像一个证书，所以它应该是短暂的（只有几分钟）
</p>
<pre class="example" id="org4fef0b8">
所以每隔几分钟就得到一个新的令牌是非常烦人的
</pre></li>
<li><p>
没有使用 kubectl proxy 命令或注入 id_token 的反向代理
</p>
<pre class="example" id="orgb77e000">
无法简单地对 Kubernetes dashboard 进行身份验证 
</pre></li>
</ul>
</div>
<div id="outline-container-org8eb0274" class="outline-4">
<h4 id="org8eb0274">配置 API Server</h4>
<div class="outline-text-4" id="text-org8eb0274">
<p>
要启用该插件，需要在 API server 中配置如下标志：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> API server OIDC 配置</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">参数</td>
<td class="org-left">描述</td>
<td class="org-left">示例</td>
<td class="org-left">必需</td>
</tr>

<tr>
<td class="org-left">&#x2013;oidc-issuer-url</td>
<td class="org-left">允许 API server 发现 <span class="underline">公共签名密钥</span> 的 <span class="underline">提供者的 URL</span> 。只接受使用 <a href="https://">https://</a> 的方案</td>
<td class="org-left">通常是提供商的 URL 地址，不包含路径，例如“<a href="https://accounts.google.com">https://accounts.google.com</a>” 或者 “<a href="https://login.salesforce.com">https://login.salesforce.com</a>" 这个URL 应该指向下面的 .well-known/openid-configuration。如果发现 URL 是 <a href="https://accounts.google.com/.well-known/openid-configuration">https://accounts.google.com/.well-known/openid-configuration</a>  这个值应该是<a href="https://accounts.google.com">https://accounts.google.com</a></td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">&#x2013;oidc-client-id</td>
<td class="org-left">所有的 token 必须为其颁发的 <span class="underline">客户端 ID</span></td>
<td class="org-left">kubernetes</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">&#x2013;oidc-username-claim</td>
<td class="org-left">JWT声明使用的 <span class="underline">用户名</span> 。默认情况下，sub 是最终用户的唯一标识符。管理员可以选择其他声明，如email 或 name，具体取决于他们的提供者。不过，email 以外的其他声明将以发行者的 URL 作为前缀，以防止与其他插件命名冲突</td>
<td class="org-left">sub</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">&#x2013;oidc-groups-claim</td>
<td class="org-left">JWT声明使用的 <span class="underline">用户组</span> 。它必须是一个字符串数组</td>
<td class="org-left">groups</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">&#x2013;oidc-ca-file</td>
<td class="org-left">用来签名身份提供商的 <span class="underline">网络 CA 证书的路径</span> 。默认为主机的根 CA</td>
<td class="org-left">/etc/kubernetes/ssl/kc-ca.pem</td>
<td class="org-left">否</td>
</tr>
</tbody>
</table>

<p>
如果为 &#x2013;oidc-username-claim 选择了除 email 以外的其他声明，则该值将以 <span class="underline">&#x2013;oidc-issuer-url</span> 作为前缀，以防止与现有 Kubernetes 名称（例如 system:users）冲突
</p>

<pre class="example" id="orgf43a408">
例如，如果提供商网址是 https://accounts.google.com 而用户名声明映射到 jane

则插件会将用户身份验证为： https://accounts.google.com#jane
</pre>

<p>
重要的一点是：API server 不是 OAuth2 客户端，而只能配置为信任单个发行者
</p>
<pre class="example" id="org1eaafe0">
这允许使用 Google 等公共提供者，而不必信任第三方发行的凭据

希望利用多个 OAuth 客户端的管理员应该探索支持 azp（授权方）声明的提供者，这是允许一个客户端代表另一个客户端发放令牌的机制
</pre>

<p>
Kubernetes不提供 OpenID Connect 身份提供商
</p>

<pre class="example" id="org3f47ea2">
可以使用现有的公共 OpenID Connect 标识提供程序（例如Google 或 其他）

或者，可以运行自己的身份提供程序，例如 CoreOS dex、Keycloak、CloudFoundry UAA 或 Tremolo Security 的 OpenUnison
</pre>

<p>
对于身份提供商能够适用于 Kubernetes，必须满足如下条件：
</p>
<ol class="org-ol">
<li>支持 OpenID connect 发现，不必是全部</li>
<li>使用非过时密码在TLS中运行</li>
<li><p>
拥有 CA 签名证书（即使 CA 不是商业 CA 或自签名）
</p>
<pre class="example" id="org4a811e4">
有关上述要求3的说明，需要 CA 签名证书：

如果部署自己的身份提供商（而不是像 Google 或 Microsoft 之类的云提供商），则必须让自己的身份提供商的 Web 服务器证书由 CA 标志设置为 TRUE 的证书签名，即使是自签名的

这是由于 GoLang 的 TLS 客户端实现对证书验证的标准非常严格　
</pre></li>
</ol>
</div>
</div>
<div id="outline-container-org4752b88" class="outline-4">
<h4 id="org4752b88">使用</h4>
<div class="outline-text-4" id="text-org4752b88">
</div>
<div id="outline-container-org4a379bc" class="outline-5">
<h5 id="org4a379bc">选项 1 - OIDC 身份验证器</h5>
<div class="outline-text-5" id="text-org4a379bc">
<p>
oidc 身份验证器将 id_token、refresh_token 和 OIDC client_secret 自动刷新 token。命令范例如下：
</p>

<pre class="example" id="orgadf762e">
kubectl config set-credentials USER_NAME \
     --auth-provider=oidc \
     --auth-provider-arg=idp-issuer-url=( issuer url ) \
     --auth-provider-arg=client-id=( your client id ) \
     --auth-provider-arg=client-secret=( your client secret ) \
     --auth-provider-arg=refresh-token=( your refresh token ) \
     --auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
     --auth-provider-arg=id-token=( your id_token ) \
     --auth-provider-arg=extra-scopes=( comma separated list of scopes to add to "openid email profile", optional )
</pre>
<p>
例如，在向身份提供者进行身份验证之后运行以下命令：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl config set-credentials mmosley  <span style="color: #ffa07a;">\</span>
  --auth-provider=oidc  <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=idp-issuer-url=https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=client-id=kubernetes  <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=client-secret=1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=refresh-token=q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+<span style="color: #eedd82;">slBFpZKtQA</span>= <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=idp-certificate-authority=/root/ca.pem <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=extra-scopes=groups <span style="color: #ffa07a;">\</span>
  --auth-provider-arg=id-token=eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</pre>
</div>

<p>
将产生下面的配置：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #eedd82;">users</span>:
  - <span style="color: #eedd82;">name</span>: mmosley
    <span style="color: #eedd82;">user</span>:
      <span style="color: #eedd82;">auth-provider</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">config</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  client-id</span>: kubernetes
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  client-secret</span>: 1db158f6-177d-4d9c-8a8b-d36869918ec5
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  extra-scopes</span>: groups
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  id-token</span>: eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  idp-certificate-authority</span>: /root/ca.pem
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  idp-issuer-url</span>: https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  refresh-token</span>: q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  name</span>: oidc
</pre>
</div>

<p>
一旦 id_token 过期，kubectl 将使用 refresh_token 刷新 id_token，然后在 kube/.config 文件的client_secret 中存储 id_token 的值和refresh_token 的新值
</p>
</div>
</div>
<div id="outline-container-org4c5f400" class="outline-5">
<h5 id="org4c5f400">选项 2 - 使用 &#x2013;token 选项</h5>
<div class="outline-text-5" id="text-org4c5f400">
<p>
可以在 kubectl 命令的 &#x2013;token 选项中传入 token。简单的拷贝和复制 id_token 到该选项中：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl --token=eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org90e19cd" class="outline-3">
<h3 id="org90e19cd">Webhook Token 认证</h3>
<div class="outline-text-3" id="text-org90e19cd">
<p>
Webhook 认证是用来认证 bearer token 的 hook：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;authentication-token-webhook-config-file</span> 是一个用来描述如何访问远程 webhook 服务的 kubeconfig 文件</li>
<li><span class="underline">&#x2013;authentication-token-webhook-cache-ttl</span> 缓存身份验证策略的时间。默认为两分钟</li>
</ul>

<p>
配置文件使用 kubeconfig 文件格式。文件中的 <span class="underline">user</span> 指的是 API server 的 webhook， <span class="underline">clusters</span> 是指远程服务。见下面的例子：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #ff4500;"># </span><span style="color: #ff4500;">clusters refers to the remote service.</span>
<span style="color: #eedd82;">clusters</span>:
  - <span style="color: #eedd82;">name</span>: name-of-remote-authn-service
    <span style="color: #eedd82;">cluster</span>:
      <span style="color: #eedd82;">certificate-authority</span>: /path/to/ca.pem         <span style="color: #ff4500;"># </span><span style="color: #ff4500;">CA for verifying the remote service.</span>
      <span style="color: #eedd82;">server</span>: https://authn.example.com/authenticate <span style="color: #ff4500;"># </span><span style="color: #ff4500;">URL of remote service to query. Must use 'https'.</span>

      <span style="color: #ff4500;"># </span><span style="color: #ff4500;">users refers to the API server's webhook configuration.</span>
      <span style="color: #eedd82;">users</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">- name</span>: name-of-api-server
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">  user</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">    client-certificate</span>: /path/to/cert.pem <span style="color: #ff4500;"># </span><span style="color: #ff4500;">cert for the webhook plugin to use</span>
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">    client-key</span>: /path/to/key.pem          <span style="color: #ff4500;"># </span><span style="color: #ff4500;">key matching the cert</span>

<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span>    <span style="color: #ff4500;"># </span><span style="color: #ff4500;">kubeconfig files require a context. Provide one for the API server.</span>
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">    current-context</span>: webhook
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">    contexts</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">        </span><span style="color: #eedd82;">      - context</span>:
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">                </span><span style="color: #eedd82;">  cluster</span>: name-of-remote-authn-service
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">                </span><span style="color: #eedd82;">  user</span>: name-of-api-sever
<span style="color: #ff0000; background-color: #ff0000; font-weight: bold;">                </span><span style="color: #eedd82;">  name</span>: webhook
</pre>
</div>

<p>
当客户端尝试使用 bearer token 与API server 进行认证是，认证 webhook 用该 token 的对象 <b>查询</b> <span class="underline">远程服务</span> 
</p>

<pre class="example" id="org8ffc388">
请注意，webhook API对象与其他 Kubernetes API 对象具有相同的 版本控制兼容性规则

实现者应该意识到 Beta 对象的宽松兼容性承诺，并检查请求的 “apiVersion” 字段以确保正确的反序列化

此外，API server 必须启用 authentication.k8s.io/v1beta1 API 扩展组 --runtime config =authentication.k8s.io/v1beta1=true 
</pre>

<p>
请求远程服务的body类似下面的格式：
</p>

<div class="org-src-container">
<pre class="src src-js">{
    <span style="color: #ffa07a;">"apiVersion"</span>: <span style="color: #ffa07a;">"authentication.k8s.io/v1beta1"</span>,
    <span style="color: #ffa07a;">"kind"</span>: <span style="color: #ffa07a;">"TokenReview"</span>,
    <span style="color: #ffa07a;">"spec"</span>: {
        <span style="color: #ffa07a;">"token"</span>: <span style="color: #ffa07a;">"(BEARERTOKEN)"</span>
    }
}
</pre>
</div>

<p>
远程服务将填写请求的 status 字段以指示登录成功。成功验证后的 bearer token 将返回：
</p>

<div class="org-src-container">
<pre class="src src-js">{
    <span style="color: #ffa07a;">"apiVersion"</span>: <span style="color: #ffa07a;">"authentication.k8s.io/v1beta1"</span>,
    <span style="color: #ffa07a;">"kind"</span>: <span style="color: #ffa07a;">"TokenReview"</span>,
    <span style="color: #ffa07a;">"status"</span>: {
        <span style="color: #ffa07a;">"authenticated"</span>: <span style="color: #7fffd4;">true</span>,
        <span style="color: #ffa07a;">"user"</span>: {
            <span style="color: #ffa07a;">"username"</span>: <span style="color: #ffa07a;">"janedoe@example.com"</span>,
            <span style="color: #ffa07a;">"uid"</span>: <span style="color: #ffa07a;">"42"</span>,
            <span style="color: #ffa07a;">"groups"</span>: [
                <span style="color: #ffa07a;">"developers"</span>,
                <span style="color: #ffa07a;">"qa"</span>
            ],
            <span style="color: #ffa07a;">"extra"</span>: {
                <span style="color: #ffa07a;">"extrafield1"</span>: [
                    <span style="color: #ffa07a;">"extravalue1"</span>,
                    <span style="color: #ffa07a;">"extravalue2"</span>
                ]
            }
        }
    }
}
</pre>
</div>

<pre class="example" id="org8c5915e">
响应主体的 spec 字段被忽略，可以省略
</pre>

<p>
未成功的请求将返回：
</p>

<div class="org-src-container">
<pre class="src src-js">{
    <span style="color: #ffa07a;">"apiVersion"</span>: <span style="color: #ffa07a;">"authentication.k8s.io/v1beta1"</span>,
    <span style="color: #ffa07a;">"kind"</span>: <span style="color: #ffa07a;">"TokenReview"</span>,
    <span style="color: #ffa07a;">"status"</span>: {
        <span style="color: #ffa07a;">"authenticated"</span>: <span style="color: #7fffd4;">false</span>
    }
}
</pre>
</div>

<p>
HTTP状态代码可以用来提供额外的错误上下文 
</p>
</div>
</div>
<div id="outline-container-org7f8c3ee" class="outline-3">
<h3 id="org7f8c3ee">认证代理</h3>
<div class="outline-text-3" id="text-org7f8c3ee">
<p>
可以配置 API server 从请求 header 的值中识别用户，例如 <span class="underline">X-Remote-User</span> 。这样的设计是用来与请求 header 值的验证代理结合使用。
</p>
<ul class="org-ul">
<li><p>
&#x2013;requestheader-username-headers: 必需，大小写敏感。按 header 名称和顺序检查用户标识
</p>
<pre class="example" id="org81ce76a">
包含值的第一个 header 将被作为用户名
</pre></li>
<li><p>
&#x2013;requestheader-group-headers: 可选。大小写敏感。建议为 <span class="underline">X-Remote-Group</span> 按 header 名称和顺序检查用户组
</p>
<pre class="example" id="org2e6b92d">
所有指定的 header 中的所有值都将作为组名
</pre></li>
<li><p>
&#x2013;requestheader-extra-headers-prefix: 可选，大小写敏感。建议为 <span class="underline">X-Remote-Extra-</span>  标题前缀可用于查找有关用户的额外信息（通常由配置的授权插件使用）
</p>
<pre class="example" id="orgab0e9e1">
以任何指定的前缀开头的 header 都会删除前缀，header 名称的其余部分将成为额外的键值，而 header 值则是额外的值 
</pre></li>
</ul>

<p>
例如下面的配置：
</p>
<pre class="example" id="org2528868">
--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</pre>

<p>
该请求：
</p>

<div class="org-src-container">
<pre class="src src-sh">GET / HTTP/1.1
X-Remote-User: fido
X-Remote-Group: dogs
X-Remote-Group: dachshunds
X-Remote-Extra-Scopes: openid
X-Remote-Extra-Scopes: profile
</pre>
</div>

<p>
将产生如下的用户信息：
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span style="color: #eedd82;">name</span>: fido
<span style="color: #eedd82;">groups</span>:
  - dogs
  - dachshunds
  <span style="color: #eedd82;">extra</span>:
    <span style="color: #eedd82;">scopes</span>:
      - openid
      - profile
</pre>
</div>

<p>
为了防止 header 欺骗，验证代理需要在验证请求 header 之前向 API server 提供 <b>有效的</b> <span class="underline">客户端证书</span> ，以对照指定的 CA 进行验证：
</p>
<ul class="org-ul">
<li>&#x2013;requestheader-client-ca-file: 必需。PEM 编码的证书包。在检查用户名的请求 header 之前，必须针对指定文件中的证书颁发机构提交并验证有效的客户端证书</li>
<li>&#x2013;requestheader-allowed-names: 可选。Common Name （cn）列表
<ul class="org-ul">
<li>如果设置了，则在检查用户名的请求 header 之前， 必须提供指定列表中 Common Name（cn）的有效客户端证书</li>
<li>如果为空，则允许使用任何 Common Name</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgbb75cd2" class="outline-3">
<h3 id="orgbb75cd2">Keystone密码</h3>
<div class="outline-text-3" id="text-orgbb75cd2">
<p>
通过在启动过程中将 <span class="underline">&#x2013;experimental-keystone-url=&lt;AuthURL&gt;</span> 选项传递给 API server 来启用 Keystone 认证：
</p>
<ul class="org-ul">
<li>该插件在 <span class="underline">plugin/pkg/auth/authenticator/password/keystone/keystone.go</span> 中实现</li>
<li>目前使用基本身份验证通过用户名和密码验证用户</li>
<li>如果为 Keystone 服务器配置了自签名证书，则在启动 Kubernetes API server 时可能需要设置 &#x2013;experimental-keystone-ca-file=SOMEFILE 选项
<ul class="org-ul">
<li>如果设置了该选项，Keystone 服务器的证书将由experimental-keystone-ca-file 中的某个权威机构验证</li>
<li>否则，证书由主机的根证书颁发机构验证</li>
</ul></li>
</ul>

<pre class="example" id="org7cc9fd1">
有关如何使用 keystone 来管理项目和用户的详细信息，请参阅 Keystone 文档 http://docs.openstack.org/developer/keystone/

请注意，这个插件仍处于试验阶段，正在积极开发之中，并可能在后续版本中进行更改
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaf36473" class="outline-2">
<h2 id="orgaf36473">匿名请求</h2>
<div class="outline-text-2" id="text-orgaf36473">
<p>
启用时，未被其他已配置身份验证方法拒绝的请求将被视为匿名请求，并给予 <span class="underline">system:anonymous</span> 的用户名和 <span class="underline">system:unuthenticated</span> 的组名 
</p>

<pre class="example" id="org53faaa3">
例如，在配置了令牌认证和启用了匿名访问的服务器上，提供无效的 bearer token 的请求将收到 401 Unauthorized 错误

提供 bearer token 的请求将被视为匿名请求 
</pre>

<p>
如果使用 AlwaysAllow 以外的授权模式，则默认启用匿名访问，并且可以通过将 &#x2013;anonymous-auth=false选项传递给API服务器来禁用
</p>

<pre class="example" id="org03654af">
ABAC 和 RBAC 授权人需要明确授权 system:annoymous 或 system:unauthenticated 组，因此授予对 * 用户或 * 组访问权的传统策略规则不包括匿名用户
</pre>
</div>
</div>

<div id="outline-container-orga09f89f" class="outline-2">
<h2 id="orga09f89f">用户模拟</h2>
<div class="outline-text-2" id="text-orga09f89f">
<p>
用户可以通过模拟 header 充当另一个用户。该请求会覆盖请求认证的用户信息
</p>
<pre class="example" id="org1e7dac6">
例如，管理员可以使用此功能通过暂时模拟其他用户并查看请求是否被拒绝来调试授权策略
</pre>

<p>
模拟请求首先认证为请求用户，然后切换到模拟的用户信息。
</p>
<ol class="org-ol">
<li>用户使用他们的凭证和模拟 header 进行 API 调用</li>
<li>API server 认证用户</li>
<li>API server 确保经过身份验证的用户具有模拟权限</li>
<li>请求用户的信息被替换为模拟值</li>
<li>请求被评估，授权作用于模拟的用户信息</li>
</ol>

<p>
以下 HTTP header 可用户执行模拟请求：
</p>
<ul class="org-ul">
<li>Impersonate-User：充当的用户名</li>
<li>Impersonate-Group：作为组名。可以多次使用来设置多个组。可选的</li>
<li>Impersonate-Extra-( extra name )：用于将额外字段与用户关联的动态 header。可选</li>
</ul>

<p>
一组示例 header：
</p>

<pre class="example" id="orgfe8a010">
Impersonate-User: jane.doe@example.com
Impersonate-Group: developers
Impersonate-Group: admins
Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
Impersonate-Extra-scopes: view
Impersonate-Extra-scopes: development
</pre>

<p>
当使用 kubectl 的 <span class="underline">&#x2013;as</span> 标志来配置 Impersonate-User header 时，可以使用 <span class="underline">&#x2013;as-group</span> 标志来配置 Impersonate-Group header 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kubectl drain mynode
Error from server (Forbidden): User <span style="color: #ffa07a;">"clark"</span> cannot get nodes at the cluster scope. (get nodes mynode)

$ kubectl drain mynode --as=superman --as-group=system:masters
node <span style="color: #ffa07a;">"mynode"</span> cordoned
node <span style="color: #ffa07a;">"mynode"</span> draine
</pre>
</div>

<pre class="example" id="org73dad41">
为模仿用户、组或设置额外字段，模拟用户必须能够对正在模拟的属性的种类（“用户”，“组”等）执行“模拟”动词
</pre>

<p>
对于启用了 RBAC 授权插件的集群，以下 ClusterRole 包含设置用户和组模拟 header 所需的规则：
</p>

<pre class="example" id="orgbf3c167">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: impersonator
rules:
- apiGroups: [""]
  resources: ["users", "groups", "serviceaccounts"]
  verbs: ["impersonate"]
</pre>

<p>
额外的字段被评估为资源 “userextras” 的子资源。为了允许用户使用额外字段 “scope” 的模拟 header，应授予用户以下角色：
</p>

<pre class="example" id="orgfb79ad5">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: scopes-impersonator
# Can set "Impersonate-Extra-scopes" header.
- apiGroups: ["authentication.k8s.io"]
  resources: ["userextras/scopes"]
  verbs: ["impersonate"]
</pre>

<p>
模拟 header 的可用值可以通过设置 resourceNames 可以使用的资源来限制:
</p>

<pre class="example" id="orgb06b9bc">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: limited-impersonator
rules:
# Can impersonate the user "jane.doe@example.com"
- apiGroups: [""]
  resources: ["users"]
  verbs: ["impersonate"]
  resourceNames: ["jane.doe@example.com"]

# Can impersonate the groups "developers" and "admins"
- apiGroups: [""]
  resources: ["groups"]
- verbs: ["impersonate"]
  resourceNames: ["developers","admins"]

# Can impersonate the extras field "scopes" with the values "view" and "development"
- apiGroups: ["authentication.k8s.io"]
  resources: ["userextras/scopes"]
  verbs: ["impersonate"]
  resourceNames: ["view", "development"]
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="best_practise.html">Next：最佳实践</a></td>
<td class="org-left"><a href="authentication.html">Previous：身份认证</a></td>
<td class="org-left"><a href="security.html">Home：安全</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
