<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>规则</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="save_restore.html"> UP </a>
 |
 <a accesskey="H" href="iptables.html"> HOME </a>
</div><div id="content">
<h1 class="title">规则</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">基础</a></li>
<li><a href="#sec-2">Tables</a>
<ul>
<li><a href="#sec-2-1">nat</a></li>
<li><a href="#sec-2-2">mangle</a></li>
<li><a href="#sec-2-3">filter</a></li>
</ul>
</li>
<li><a href="#sec-3">Commands</a>
<ul>
<li><a href="#sec-3-1">命令</a>
<ul>
<li><a href="#sec-3-1-1">append</a></li>
<li><a href="#sec-3-1-2">delete</a></li>
<li><a href="#sec-3-1-3">replace</a></li>
<li><a href="#sec-3-1-4">insert</a></li>
<li><a href="#sec-3-1-5">list</a></li>
<li><a href="#sec-3-1-6">flush</a></li>
<li><a href="#sec-3-1-7">zero</a></li>
<li><a href="#sec-3-1-8">new-chain</a></li>
<li><a href="#sec-3-1-9">delete-chain</a></li>
<li><a href="#sec-3-1-10">policy</a></li>
<li><a href="#sec-3-1-11">rename-chain</a></li>
</ul>
</li>
<li><a href="#sec-3-2">选项</a>
<ul>
<li><a href="#sec-3-2-1">verbose</a></li>
<li><a href="#sec-3-2-2">exact</a></li>
<li><a href="#sec-3-2-3">numeric</a></li>
<li><a href="#sec-3-2-4">line-numbers</a></li>
<li><a href="#sec-3-2-5">set-counters</a></li>
<li><a href="#sec-3-2-6">modprobe</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Matches</a>
<ul>
<li><a href="#sec-4-1">通用匹配</a>
<ul>
<li><a href="#sec-4-1-1">protocol</a></li>
<li><a href="#sec-4-1-2">source</a></li>
<li><a href="#sec-4-1-3">destination</a></li>
<li><a href="#sec-4-1-4">in-interface</a></li>
<li><a href="#sec-4-1-5">out-interface</a></li>
<li><a href="#sec-4-1-6">fragment</a></li>
</ul>
</li>
<li><a href="#sec-4-2">隐含匹配</a>
<ul>
<li><a href="#sec-4-2-1">TCP</a>
<ul>
<li><a href="#sec-4-2-1-1">source-port</a></li>
<li><a href="#sec-4-2-1-2">destination-port</a></li>
<li><a href="#sec-4-2-1-3">tcp-flags</a></li>
<li><a href="#sec-4-2-1-4">syn</a></li>
<li><a href="#sec-4-2-1-5">tcp-option</a></li>
</ul>
</li>
<li><a href="#sec-4-2-2">UDP</a>
<ul>
<li><a href="#sec-4-2-2-1">source-port</a></li>
<li><a href="#sec-4-2-2-2">destination-port</a></li>
</ul>
</li>
<li><a href="#sec-4-2-3">ICMP</a>
<ul>
<li><a href="#sec-4-2-3-1">icmp-type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4-3">显示匹配</a>
<ul>
<li><a href="#sec-4-3-1">Limit</a>
<ul>
<li><a href="#sec-4-3-1-1">limit</a></li>
<li><a href="#sec-4-3-1-2">limit-burst</a></li>
</ul>
</li>
<li><a href="#sec-4-3-2">MAC</a>
<ul>
<li><a href="#sec-4-3-2-1">mac-source</a></li>
</ul>
</li>
<li><a href="#sec-4-3-3">Mark</a>
<ul>
<li><a href="#sec-4-3-3-1">mark</a></li>
</ul>
</li>
<li><a href="#sec-4-3-4">Multiport</a>
<ul>
<li><a href="#sec-4-3-4-1">source-port</a></li>
<li><a href="#sec-4-3-4-2">destination-port</a></li>
<li><a href="#sec-4-3-4-3">port</a></li>
</ul>
</li>
<li><a href="#sec-4-3-5">Owner</a>
<ul>
<li><a href="#sec-4-3-5-1">uid-owner</a></li>
<li><a href="#sec-4-3-5-2">gid-owner</a></li>
<li><a href="#sec-4-3-5-3">pid-owner</a></li>
<li><a href="#sec-4-3-5-4">sid-owner</a></li>
</ul>
</li>
<li><a href="#sec-4-3-6">State</a>
<ul>
<li><a href="#sec-4-3-6-1">state</a></li>
</ul>
</li>
<li><a href="#sec-4-3-7">TOS</a>
<ul>
<li><a href="#sec-4-3-7-1">tos</a></li>
</ul>
</li>
<li><a href="#sec-4-3-8">TTL</a>
<ul>
<li><a href="#sec-4-3-8-1">ttl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4-4">非正常包的匹配</a></li>
</ul>
</li>
<li><a href="#sec-5">Target/Jump</a>
<ul>
<li><a href="#sec-5-1">ACCEPT</a></li>
<li><a href="#sec-5-2">DNAT</a>
<ul>
<li><a href="#sec-5-2-1">to-destination</a>
<ul>
<li><a href="#sec-5-2-1-1">更详细的例子</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5-3">DROP</a></li>
<li><a href="#sec-5-4">LOG</a>
<ul>
<li><a href="#sec-5-4-1">log-level</a></li>
<li><a href="#sec-5-4-2">log-prefix</a></li>
<li><a href="#sec-5-4-3">log-tcp-sequence</a></li>
<li><a href="#sec-5-4-4">log-tcp-options</a></li>
<li><a href="#sec-5-4-5">log-ip-options</a></li>
</ul>
</li>
<li><a href="#sec-5-5">MARK</a>
<ul>
<li><a href="#sec-5-5-1">set-mark</a></li>
</ul>
</li>
<li><a href="#sec-5-6">MASQUERADE</a>
<ul>
<li><a href="#sec-5-6-1">to-ports</a></li>
</ul>
</li>
<li><a href="#sec-5-7">REDIRECT</a>
<ul>
<li><a href="#sec-5-7-1">to-ports</a></li>
</ul>
</li>
<li><a href="#sec-5-8">REJECT</a>
<ul>
<li><a href="#sec-5-8-1">reject-with</a></li>
</ul>
</li>
<li><a href="#sec-5-9">RETURN</a></li>
<li><a href="#sec-5-10">SNAT</a>
<ul>
<li><a href="#sec-5-10-1">to-source</a></li>
</ul>
</li>
<li><a href="#sec-5-11">TOS</a>
<ul>
<li><a href="#sec-5-11-1">set-tos</a></li>
</ul>
</li>
<li><a href="#sec-5-12">TTL</a>
<ul>
<li><a href="#sec-5-12-1">ttl-set</a></li>
<li><a href="#sec-5-12-2">ttl-dec</a></li>
<li><a href="#sec-5-12-3">ttl-inc</a></li>
</ul>
</li>
<li><a href="#sec-5-13">ULOG</a>
<ul>
<li><a href="#sec-5-13-1">ulog-nlgroup</a></li>
<li><a href="#sec-5-13-2">ulog-prefix</a></li>
<li><a href="#sec-5-13-3">ulog-cprange</a></li>
<li><a href="#sec-5-13-4">ulog-qthreshold</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
在内核看来，规则就是决定如何处理一个包的语句
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">基础</h2>
<div class="outline-text-2" id="text-1">
<p>
如果一个包符合所有的条件（就是符合matche语句），就运行target或jump指令。书写规则的语法格式是：
</p>

<pre class="example">
iptables [-t table] command [match] [target/jump]
</pre>

<ul class="org-ul">
<li><span class="underline">table</span> ：指定表名
<ul class="org-ul">
<li>一般情况下没有必要指定使用的表，iptables默认使用 <b>filter</b> 表来执行所有的命令
</li>
<li>没有必要非得在这里指定表名，当然 <span class="underline">把表名在开始处已经是约定俗成的标准</span>
</li>
</ul>
</li>
<li><span class="underline">command</span> : 告诉程序该做什么
<ul class="org-ul">
<li>插入一个规则
</li>
<li>在链的末尾增加一个规则
</li>
<li>删除一个规则
</li>
</ul>
</li>
<li><span class="underline">match</span> : 细致地描述了包的某个特点，以使这个包区别于其它所有的包
<ul class="org-ul">
<li><span class="underline">来源IP地址</span>
</li>
<li><span class="underline">网络接口</span>
</li>
<li><span class="underline">端口</span>
</li>
<li><span class="underline">协议类型</span> 或者其他什么
</li>
</ul>
</li>
<li><span class="underline">target</span> : 数据包的目标所在。 <b>若数据包符合所有的match，内核就用target来处理它</b> ，或者说把包发往 target 
<ul class="org-ul">
<li>让内核把包发送到当前表中的其他链（可能是自己建立的）
</li>
<li>丢弃这个包而没有什么处理
</li>
<li>向发送者返回某个特殊的应答
</li>
</ul>
</li>
</ul>

<p>
注意： <span class="underline">target</span> 指令必须在最后。为了易读，一般用这种语法。大部分规则都是按这种语法写的
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Tables</h2>
<div class="outline-text-2" id="text-2">
<p>
选项 <span class="underline">-t</span> 用来指定使用哪个表，它可以是下面介绍的表中的任何一个，默认的是 <b>filter</b> 表
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">nat</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<b>网络地址转换</b> ，即 <span class="underline">Network Address Translation</span> ，缩写为 <b>NAT</b> 。做过NAT操作的数据包的地址就被改变了，当然这种改变是根据定义的规则进行的 
</p>

<p>
<b>属于一个流的包只会经过这个表一次。如果第一个包被允许做NAT或Masqueraded，那么余下的包都会自动地被做相同的操作</b> 。也就是说，余下的包不会再通过这个表，一个一个的被NAT，而是自动地完成。这就是为什么 <span class="underline">不应该在这个表中做任何过滤的主要原因</span> 。
</p>

<ul class="org-ul">
<li><span class="underline">PREROUTING</span> 链：在包刚刚到达防火墙时改变它的目的地址，如果需要的话
</li>
<li><span class="underline">OUTPUT</span> 链：改变本地产生的包的目的地址
</li>
<li><span class="underline">POSTROUTING</span> 链：包就要离开防火墙之前改变其源地址
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">mangle</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<b>改变不同的包及包头的内容</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">TTL</span>
</li>
<li><span class="underline">TOS</span>
</li>
<li><span class="underline">MARK</span> 
</li>
</ul>

<pre class="example">
MARK并没有真正地改动数据包，它只是在内核空间为包设了一个标记

防火墙内的其他的规则或程序可以使用这种标记对包进行过滤或高级路由
</pre>

<p>
这个表有五个内建的链： 
</p>
<ul class="org-ul">
<li><span class="underline">PREROUTING</span> : 包进入防火墙之后、路由判断之前改变包
</li>
<li><span class="underline">POSTROUTING</span> : 在所有路由判断之后
</li>
<li><span class="underline">OUTPUT</span> : 在确定包的目的之前更改数据包
</li>
<li><span class="underline">INPUT</span> : 在包被路由到本地之后，但在用户空间的程序看到它之前改变包
</li>
<li><span class="underline">FORWARD</span> : 在最初的路由判断之后、最后一次更改包的目的之前mangle包
</li>
</ul>

<pre class="example">
mangle表不能做任何NAT，它只是改变数据包的 TTL，TOS或MARK，而不是其源目地址
</pre>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">filter</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<b>专门过滤包</b> 的，可以毫无问题地对包进行 
</p>
<ul class="org-ul">
<li><span class="underline">DROP</span>
</li>
<li><span class="underline">LOG</span>
</li>
<li><span class="underline">ACCEPT</span>
</li>
<li><span class="underline">REJECT</span>  
</li>
</ul>

<p>
内建三个链：
</p>
<ul class="org-ul">
<li><span class="underline">FORWARD</span>  :  过滤所有不是本地产生的并且目的地不是本地（所谓本地就是防火墙了）的包
</li>
<li><span class="underline">INPUT</span> : 针对那些目的地是本地的包
</li>
<li><span class="underline">OUTPUT</span> : 过滤所有本地生成的包的
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Commands</h2>
<div class="outline-text-2" id="text-3">
<p>
<span class="underline">command</span> 指定iptables对 <b>提交的规则要做什么样的操作</b> 
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">命令</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">append</h4>
<div class="outline-text-4" id="text-3-1-1">
<pre class="example">
-A, --append
</pre>

<p>
在所选择的链末添加规则。当源地址或目的地址是以名字而不是ip地址的形式出现时，若这些名字可以被解析为多个地址，则这条规则会和所有可用的地址结合
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT ...
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">delete</h4>
<div class="outline-text-4" id="text-3-1-2">
<pre class="example">
-D, --delete
</pre>

<p>
从所选链中删除规则。有两种方法指定要删除的规则：
</p>
<ol class="org-ol">
<li>把规则完完整整地写出来
</li>
<li>指定规则在所选链中的序号：每条链的规则都各自从1被编号
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -D INPUT --dport 80 -j DROP

iptables -D INPUT 1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">replace</h4>
<div class="outline-text-4" id="text-3-1-3">
<pre class="example">
-R, --replace
</pre>

<p>
在所选中的链里指定的行上（每条链的规则都各自从1被编号）替换规则
</p>

<p>
主要的用处是 <span class="underline">试验不同的规则</span> 。当源地址或目的地址是以名字而不是ip地址的形式出现时，若这些名字可以被解析为多个地址，则 <b>这条command会失败</b> 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -R INPUT 1 -s 192.168.0.1 -j DROP
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4">insert</h4>
<div class="outline-text-4" id="text-3-1-4">
<pre class="example">
-I, --insert
</pre>

<p>
根据给出的规则序号向所选链中插入规则。 <b>如果序号为1， 规则会被插入链的头部</b> ， 默认序号就是1 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -I INPUT 1 --dport 80 -j ACCEPT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5">list</h4>
<div class="outline-text-4" id="text-3-1-5">
<pre class="example">
-L, --list
</pre>

<p>
显示所选链的所有规则：
</p>
<ul class="org-ul">
<li>如果没有指定链，则显示指定表中的所有链
</li>
<li>如果什么都没有指定，就显示默认表所有的链
</li>
</ul>

<p>
精确输出受其它参数影响，如 <span class="underline">-n</span> 和 <span class="underline">-v</span> 等参数
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -L INPUT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6">flush</h4>
<div class="outline-text-4" id="text-3-1-6">
<pre class="example">
-F, --flush
</pre>

<p>
清空所选的链：
</p>
<ul class="org-ul">
<li>如果没有指定链，则清空指定表中的所有 链
</li>
<li>如果什么都没有指定，就清空默认表所有的链
</li>
</ul>

<p>
也可以一条一条地删，但用这个command会快些
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -F INPUT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-7" class="outline-4">
<h4 id="sec-3-1-7">zero</h4>
<div class="outline-text-4" id="text-3-1-7">
<pre class="example">
-Z, --zero
</pre>

<p>
把指定链（如未指定，则认为是所有链）的所有计数器归零
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -Z INPUT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-8" class="outline-4">
<h4 id="sec-3-1-8">new-chain</h4>
<div class="outline-text-4" id="text-3-1-8">
<pre class="example">
-N, --new-chain
</pre>

<p>
根据用户指定的名字建立新的链
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -N allowed
</pre>
</div>

<p>
注意：所用的名字不能和已有的链、target同名
</p>
</div>
</div>

<div id="outline-container-sec-3-1-9" class="outline-4">
<h4 id="sec-3-1-9">delete-chain</h4>
<div class="outline-text-4" id="text-3-1-9">
<pre class="example">
-X, --delete-chain
</pre>

<p>
删除指定的用户自定义链：
</p>
<ul class="org-ul">
<li>如果没有给出参数，这条命令将会 <b>删除默认表所有非内建的链</b> 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -X allowed
</pre>
</div>

<p>
注意： <b>这个链必须没有被引用</b> ，如果被引用，在删除之前你必须删除或者替换与之有关的规则
</p>
</div>
</div>

<div id="outline-container-sec-3-1-10" class="outline-4">
<h4 id="sec-3-1-10">policy</h4>
<div class="outline-text-4" id="text-3-1-10">
<pre class="example">
-P, --policy
</pre>

<p>
为链设置默认的target（可用的是DROP 和ACCEPT），这个target称作策略
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -P INPUT DROP
</pre>
</div>

<ul class="org-ul">
<li>所有不符合规则的包都被强制使用这个策略
</li>
<li>只有内建的链才可以使用规则
</li>
<li>但内建的链和用户自定义链都不能被作为策略使用，也就是说不能象这样使用： 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -P INPUT allowed&#65288;&#25110;&#32773;&#26159;&#20869;&#24314;&#30340;&#38142;&#65289;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-11" class="outline-4">
<h4 id="sec-3-1-11">rename-chain</h4>
<div class="outline-text-4" id="text-3-1-11">
<pre class="example">
-E, --rename-chain
</pre>

<p>
对自定义的链进行重命名，原来的名字在前，新名字在后
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -E allowed disallowed
</pre>
</div>

<p>
把 <span class="underline">allowed</span> 改为 <span class="underline">disallowed</span> 。这仅仅是改变链的名字，对整个表的结构、工作没有任何影响
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">选项</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">verbose</h4>
<div class="outline-text-4" id="text-3-2-1">
<pre class="example">
-v, --verbose
</pre>

<p>
这个选项使输出详细化，常与 <span class="underline">&#x2013;list</span> 连用: 
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;list</span> 连用时：输出中包括
<ul class="org-ul">
<li>网络接口的地址
</li>
<li>规则的选项
</li>
<li>TOS掩码
</li>
<li>字节和包计数器: 
<ul class="org-ul">
<li>计数器是以K、M、G（这里用的是10的幂而不是2的幂哦）为单位的
</li>
</ul>
</li>
</ul>
</li>
<li>和 <span class="underline">&#x2013;append</span> 、 <span class="underline">&#x2013;insert</span> 、 <span class="underline">&#x2013;delete</span>  或 <span class="underline">&#x2013;replace</span> 连用，iptables会输出详细的信息告诉规则是如何被解释的、是否正确地插入等等
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">exact</h4>
<div class="outline-text-4" id="text-3-2-2">
<pre class="example">
-X --exact
</pre>

<p>
使 <span class="underline">&#x2013;list</span> 输出中的计数器显示准确的数值，而不用K、M、G等估值
</p>

<p>
注意：此选项只能和&#x2013;list连用
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">numeric</h4>
<div class="outline-text-4" id="text-3-2-3">
<pre class="example">
-n, --numeric
</pre>

<p>
使输出中的IP地址和端口以数值的形式显示，而不是默认的名字：
</p>
<ul class="org-ul">
<li>主机名
</li>
<li>网络名
</li>
<li>程序名等
</li>
</ul>

<p>
注意：此选项也只能和 <span class="underline">&#x2013;list</span> 连用
</p>
</div>
</div>

<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4">line-numbers</h4>
<div class="outline-text-4" id="text-3-2-4">
<pre class="example">
--line-numbers
</pre>

<p>
显示出每条规则在相应链中的序号。这样可以知道序号了，这对插入新规则很有用
</p>

<p>
注意：此选项也只能和 <span class="underline">&#x2013;list</span> 连用
</p>
</div>
</div>

<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5">set-counters</h4>
<div class="outline-text-4" id="text-3-2-5">
<pre class="example">
-c, --set-counters
</pre>

<p>
在创建或更改规则时设置计数器
</p>

<div class="org-src-container">

<pre class="src src-sh">--set-counters 20 4000
</pre>
</div>

<p>
让内核把包计数器设为20，把字节计数器设为4000
</p>

<p>
可以搭配的命令：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;insert</span> 
</li>
<li><span class="underline">&#x2013;append</span>
</li>
<li><span class="underline">&#x2013;replace</span>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-6" class="outline-4">
<h4 id="sec-3-2-6">modprobe</h4>
<div class="outline-text-4" id="text-3-2-6">
<pre class="example">
--modprobe
</pre>

<p>
告诉iptables探测并装载要使用的模块。万一modprobe命令不在搜索路径中，就要用到了。有了这个选项， 在装载模块时，即使有一个需要用到的模块没装载上，iptables也知道要去搜索
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Matches</h2>
<div class="outline-text-2" id="text-4">
<p>
可以把匹配归为五类：
</p>
<ol class="org-ol">
<li><b>通用</b> 匹配 ：适用于所有的规则
</li>
<li><b>TCP</b> 匹配 : 只能用于TCP包
</li>
<li><b>UDP</b> 匹配 : 只能用在UDP包上了
</li>
<li><b>ICMP</b> 匹配：针对ICMP包的
</li>
<li><b>特殊</b> 匹配：针对
<ul class="org-ul">
<li>状态（ <span class="underline">state</span> ）
</li>
<li>所有者（ <span class="underline">owner</span> ）
</li>
<li>访问的频率限制（ <span class="underline">limit</span> ）等
</li>
</ul>
</li>
</ol>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">通用匹配</h3>
<div class="outline-text-3" id="text-4-1">
<p>
无论使用的是何种协议，也不管装入了匹配的何种扩展，通用匹配都使可用的。也就是说， 它们可以直接使用，而不需要什么前提条件
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">protocol</h4>
<div class="outline-text-4" id="text-4-1-1">
<pre class="example">
-p, --protocol
</pre>

<p>
匹配 <b>指定的协议</b> 。指定协议的形式有以下几种：
</p>
<ol class="org-ol">
<li>名字，不分大小写，但必须是在 <span class="underline">/etc/protocols</span> 中定义的
</li>
<li>可以使用它们相应的整数值。例如
<ul class="org-ul">
<li><span class="underline">ICMP</span> : 1
</li>
<li><span class="underline">TCP</span> : 6
</li>
<li><span class="underline">UDP</span> : 17
</li>
</ul>
</li>
<li>缺省设置， <b>ALL</b> ，相应数值是 <span class="underline">0</span> ，但要注意这只代表匹配TCP、UDP、ICMP，而不是/etc/protocols中定义的所有协议
</li>
<li>可以是协议列表，以英文逗号为分隔符，如： <span class="underline">udp,tcp</span>
</li>
<li>可以在协议前加英文的感叹号表示取反，注意 <b>有空格</b> ，如: 
<ul class="org-ul">
<li><span class="underline">&#x2013;protocol ! tcp</span>  表示非tcp协议，也就是 <span class="underline">UDP和ICMP</span> 。可以看出这个取反的范围只是TCP、UDP和ICMP
</li>
</ul>
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">source</h4>
<div class="outline-text-4" id="text-4-1-2">
<pre class="example">
-s, --src, --source
</pre>

<p>
以 <b>IP源地址</b> 匹配包。地址的形式如下：
</p>
<ol class="org-ol">
<li>单个地址，如 
<ul class="org-ul">
<li><span class="underline">192.168.1.1</span>
</li>
<li><span class="underline">192.168.1.1/255.255.255.255</span>
</li>
<li><span class="underline">192.168.1.1/32</span>
</li>
</ul>
</li>
<li>网络，如
<ul class="org-ul">
<li><span class="underline">192.168.0.0/24</span>
</li>
<li><span class="underline">192.168.0.0/255.255.255.0</span> 
</li>
</ul>
</li>
<li>在地址前加 <span class="underline">感叹号</span> 表示取反，注意 <span class="underline">空格</span> 
<ul class="org-ul">
<li><span class="underline">&#x2013;source ! 192.168.0.0/24</span>  表示除此地址外的所有地址
</li>
</ul>
</li>
<li>缺省: <b>所有地址</b>
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -s 192.168.1.1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">destination</h4>
<div class="outline-text-4" id="text-4-1-3">
<pre class="example">
-d, --dst, --destination
</pre>

<p>
以 <b>IP目的地址</b> 匹配包。地址的形式和 <span class="underline">&#x2013;source</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -d 192.168.1.1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">in-interface</h4>
<div class="outline-text-4" id="text-4-1-4">
<pre class="example">
-i, --in-interface
</pre>

<p>
以 <b>包进入本地所使用的网络接口</b> 来匹配包。这个匹配操作只能用于 <span class="underline">INPUT</span> ， <span class="underline">FORWARD</span> 和 <span class="underline">PREROUTING</span> 这三个链，用在其他任何地方都会提示错误信息。指定接口有以下方法：
</p>
<ol class="org-ol">
<li>指定接口名称，如：
<ul class="org-ul">
<li>eth0
</li>
<li>ppp0等
</li>
</ul>
</li>
<li>使用 <b>通配符</b> ，即 <span class="underline">加号，它代表字符数字串</span> 
<ul class="org-ul">
<li><span class="underline">iptables -A INPUT -i +</span> : 匹配所有的包，而不考虑使用哪个接口。这也是不指定接口的默认行为
</li>
<li><span class="underline">eth+</span> : 所有Ethernet接口，也就是说，匹配所有从Ethernet接口进入的包
</li>
</ul>
</li>
<li>在接口前加 <span class="underline">感叹号</span> 表示取反，注意 _空格<sub>，</sub>
<ul class="org-ul">
<li><span class="underline">-i ! eth0</span> ：匹配来自除eth0外的所有包
</li>
</ul>
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -i eth0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5">out-interface</h4>
<div class="outline-text-4" id="text-4-1-5">
<pre class="example">
-o, --out-interface
</pre>

<p>
以 <b>包离开本地所使用的网络接口</b> 来匹配包。指定接口的方法与 <span class="underline">&#x2013;in-interface</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A FORWARD -o eth0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-6" class="outline-4">
<h4 id="sec-4-1-6">fragment</h4>
<div class="outline-text-4" id="text-4-1-6">
<pre class="example">
-f, --fragment
</pre>

<p>
用来匹配 <b>一个被分片的包的第二片或及以后的部分</b> 。因为它们不包含源或目的地址，或ICMP类型等信息，其他规则无法匹配到它，所以才有这个匹配操作：
</p>
<ul class="org-ul">
<li>防止碎片攻击
</li>
<li>可以加 <span class="underline">感叹号</span> 表示取反，但注意 <span class="underline">位置</span> 
<ul class="org-ul">
<li><span class="underline">! -f</span>  :  只能匹配到没有分片的包或者是被分片的包的第一个碎片，其后的片都不行
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -f
</pre>
</div>

<pre class="example">
  现在内核有完善的碎片重组功能，可以防止碎片攻击，所以不必使用取反的功能来防止碎片通过

  如果使用连接跟踪，是不会看到任何碎片的，因为在它们到达任何链之前就被处理过了
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">隐含匹配</h3>
<div class="outline-text-3" id="text-4-2">
<p>
这种匹配操作是 <b>自动地或隐含地</b> 装载入内核的。例如使用 <span class="underline">&#x2013;protocol tcp</span> 时，不需再装入任何东西就可以匹配只有IP包才有的一些特点。现在有三种隐含的匹配针对三种不同的协 议，即 
</p>
<ul class="org-ul">
<li>TCP
</li>
<li>UDP 
</li>
<li>ICMP 
</li>
</ul>

<p>
它们分别包括一套只适用于相应协议的判别标准
</p>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">TCP</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
TCP matches只能匹配 <b>TCP包或流</b> 的细节，必须有 <span class="underline">&#x2013;protocol tcp</span> 作为前提条件
</p>
</div>

<div id="outline-container-sec-4-2-1-1" class="outline-5">
<h5 id="sec-4-2-1-1">source-port</h5>
<div class="outline-text-5" id="text-4-2-1-1">
<pre class="example">
--sport, --source-port
</pre>

<p>
基于TCP包的 <b>源端口</b> 来匹配包，端口的指定形式如下：
</p>
<ol class="org-ol">
<li>不指定此项: 默认 <b>所有端口</b> 
</li>
<li>使用 <b>服务名或端口号</b> ，但名字必须是在 <span class="underline">/etc/services</span>  中定义的，因为iptables从这个文件里查找相应的端口号。从这可以看出，使用端口号会使规则装入快一点 儿，当然，可读性就差些了
</li>
<li>使用 <b>连续的端口</b> ，
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port 22:80</span> : 从22到80的所有端 口，包括22和80。如果两个号的顺序反了也没关系， <span class="underline">&#x2013;source-port 80:22</span> 这和 <span class="underline">&#x2013;source-port 22:80</span> 的效果一样
</li>
</ul>
</li>
<li>省略第一个号， <span class="underline">默认第一个是0</span>  
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port :80</span> :  从0到80的 所有端口
</li>
</ul>
</li>
<li>省略第二个号， <span class="underline">默认是65535</span> 
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port 22:</span> :  从22到 65535的所有端口
</li>
</ul>
</li>
<li>在端口号前加 <span class="underline">感叹号</span> 表示取反，注意 <span class="underline">空格</span> 
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port ! 22</span> : 除22号之外的所有端口
</li>
<li><span class="underline">&#x2013;source-port ! 22:80</span> :  从22到80（包括22和80）之外的所有端口
</li>
</ul>
</li>
</ol>


<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp --sport 22
</pre>
</div>
<p>
注意：这个匹配操作不能识别不连续的端口列表，如： <span class="underline">&#x2013;source-port ! 22, 36, 80</span> 这样的操作
</p>
</div>
</div>

<div id="outline-container-sec-4-2-1-2" class="outline-5">
<h5 id="sec-4-2-1-2">destination-port</h5>
<div class="outline-text-5" id="text-4-2-1-2">
<pre class="example">
--dport, --destination-port
</pre>

<p>
基于TCP包的 <b>目的端口</b> 来匹配包，端口的指定形式和 <span class="underline">&#x2013;sport</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp --dport 22
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-1-3" class="outline-5">
<h5 id="sec-4-2-1-3">tcp-flags</h5>
<div class="outline-text-5" id="text-4-2-1-3">
<pre class="example">
--tcp-flags
</pre>

<p>
匹配 <b>指定的TCP标记</b> 。有两个参数，它们都是列表，列表内部用 <span class="underline">逗号作分隔符，这两个列表之间用空格分开</span> 
</p>
<ul class="org-ul">
<li>第一个参数： 要 <span class="underline">检查的标记</span>  ，作用就象掩码。提供 <b>检查范围</b>  
</li>
<li>第二个参数： <span class="underline">在第一个列表中出现过的且必须被设为1 （即状态是打开的）标记（第一个列表中其他的标记必须置0）</span> 。提供被 <b>设置的条件</b> , 就是哪些位置为设置
</li>
</ul>

<p>
这个匹配操作可以识别以下标记：
</p>
<ul class="org-ul">
<li>SYN
</li>
<li>ACK
</li>
<li>FIN
</li>
<li>RST
</li>
<li>URG
</li>
<li>PSH
</li>
<li>ALL : 选定所有的标记
</li>
<li>NONE : 未选定任何标记
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --tcp-flags SYN,FIN,ACK SYN
</pre>
</div>
<p>
匹配那些 <b>SYN标记被设置而FIN和ACK标记没有设置</b> 的包
</p>

<p>
注意： 标记之间只有一个逗号而没有空格
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables --tcp-flags ALL NONE
</pre>
</div>

<p>
匹配所有标记都未置1的包
</p>

<p>
也可在参数前加 <span class="underline">感叹号</span> 表示取反。例如： 
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --tcp-flags ! SYN,FIN,ACK SYN
</pre>
</div>
<p>
匹配那些 <b>FIN和ACK标记被设置而SYN标记没有设置</b> 的包
</p>
</div>
</div>

<div id="outline-container-sec-4-2-1-4" class="outline-5">
<h5 id="sec-4-2-1-4">syn</h5>
<div class="outline-text-5" id="text-4-2-1-4">
<pre class="example">
--syn

这个匹配或多或少算是ipchains时代的遗留物，之所以还保留它，是为了向后兼容，也是为了方便规则在iptables和ipchains间的转换
</pre>

<p>
<b>匹配那些SYN标记被设置而ACK和RST标记没有设置的包</b> ，这和 <span class="underline">iptables -p tcp &#x2013;tcp-flags SYN,RST,ACK SYN</span> 的作用毫无二样。主要用在 <b>TCP连接初始化时发出请求</b> 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --syn
</pre>
</div>

<pre class="example">
     如果你阻止了这样的包，也就阻止了所有由外向内的连接企图，这在一定程度上防止了一些攻击
     
     但外出的连接不受影响，恰恰现在有很多攻击就利用这一点
     
     比如有些攻击黑掉服务器之后安装会一些软件，它们能够利用已存的连接到达你的机子，而不要再新开一个端口
</pre>

<p>
这个匹配也可用 <span class="underline">感叹号</span> 取反： 
</p>
<ul class="org-ul">
<li><span class="underline">! &#x2013;syn</span> : 那些RST或ACK被置位的包，就是 <b>状态为已建立的连接</b> 的包
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2-1-5" class="outline-5">
<h5 id="sec-4-2-1-5">tcp-option</h5>
<div class="outline-text-5" id="text-4-2-1-5">
<pre class="example">
--tcp-option
</pre>

<p>
<b>TCP选项</b> 是TCP头中的特殊部分，有三个不同的 部分
</p>
<ul class="org-ul">
<li>第一个8位组： <b>选项的类型</b>
</li>
<li>第二个8位组： <b>选项的长度</b> （这个长度是整个选项的长度，但不包含填充部分所占的字节，而且要注意不是每个TCP选项都有这一部分的）
</li>
<li>第三部分： <b>选项的内容</b> 
</li>
</ul>

<p>
为了适应标准，不必执行所有的选项，但可以查看选项的类型，如果不是所支持的，那就只是看看长度然后跳过数据部分。这个操作是根据 <span class="underline">选项的十进制值</span> 来匹配的，它也可以用 <span class="underline">感叹号</span> 取反
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --tcp-option 16
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">UDP</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
UDP matches是在指定 <span class="underline">&#x2013;protocol UDP</span> 时自动装入的。UDP是一种 <b>无连接协议</b> ，所以在它打开、关闭连接以及在发送数据时没有多少标记要设置，它也不需要任何类型的确认。数据丢失了， 就丢失了（不会发送ICMP错误信息的）。这就说明UDP matches要比TCP matches少多了。 <span class="underline">即使UDP和ICMP是无连接协议，状态机制也可以很好的工作</span> ，就象在TCP上一样
</p>
</div>

<div id="outline-container-sec-4-2-2-1" class="outline-5">
<h5 id="sec-4-2-2-1">source-port</h5>
<div class="outline-text-5" id="text-4-2-2-1">
<pre class="example">
--sport, --source-port
</pre>

<p>
基于 <b>UDP包的源端口</b> 来匹配包，端口的指定形式和TCP matches中的 <span class="underline">&#x2013;sport</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p udp --sport 53
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-2" class="outline-5">
<h5 id="sec-4-2-2-2">destination-port</h5>
<div class="outline-text-5" id="text-4-2-2-2">
<pre class="example">
--dport, --destination-port
</pre>

<p>
基于 <b>UDP包的目的端口</b> 来匹配包，端口的指定形式和TCP matches中的 <span class="underline">&#x2013;sport</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p udp --dport 53
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">ICMP</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
ICMP协议也是无连接协议，ICMP包更是短命鬼，比UDP的还短。ICMP协议不是IP协议的下属协议，而是它的辅助者，其主要作用是 <b>报告错误和连接控制</b> 。ICMP包的头和IP的很相似，但又有很多不同。这个协议最主要的特点是它有很多类型，以应对不同的情况。比如，想访问一个无法访问的地址，就会收到一个ICMP host unreachable信息，它的意思是主机无法到达。虽然有这么多类型，但只有一个 ICMP matche，这就足够对付它们了。这个matche是在指定 <span class="underline">&#x2013;protocol ICMP</span> 时自动 装入的。注意所有的通用匹配都可以使用，这样就可以匹配 <b>ICMP包的源、目地址</b>
</p>
</div>

<div id="outline-container-sec-4-2-3-1" class="outline-5">
<h5 id="sec-4-2-3-1">icmp-type</h5>
<div class="outline-text-5" id="text-4-2-3-1">
<pre class="example">
--icmp-type
</pre>

<p>
根据 <b>ICMP类型</b> 匹配包，类型的指定可以使用 <span class="underline">十进制数值</span> 或 <span class="underline">相应的名字</span> ：
</p>
<ul class="org-ul">
<li>数值：在 <span class="underline">RFC792</span> 中有定义
</li>
<li>名字：用 <span class="underline">iptables &#x2013;protocol icmp &#x2013;help</span> 查看
</li>
</ul>

<p>
这个匹配也可用 <span class="underline">感叹号</span> 取反
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;icmp-type ! 8</span> : 匹配除类型8之外的所有ICMP包
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p icmp --icmp-type 8
</pre>
</div>

<pre class="example">
  有些ICMP类型已经废弃不用了

  还有一些可能会对无防护的主机带来危险，因为它们可能把包重定向到错误的地方
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">显示匹配</h3>
<div class="outline-text-3" id="text-4-3">
<p>
显式匹配必须用 <span class="underline">-m</span> 或 <span class="underline">&#x2013;match</span> 装载，比如要使用状态匹配就必须使用 <span class="underline">-m state</span> 
</p>

<p>
有些匹配还需要指定协议，有些就不需要，比如连接状态就不要。这些状态是
</p>
<ul class="org-ul">
<li>NEW : 还未建立好的连接的第一个包
</li>
<li>ESTABLISHED: 已建立的连接，也就是已经在内核里注册过的
</li>
<li>RELATED: 已经存在的、处于已建立状态的连接生成的新连接
</li>
</ul>

<p>
隐含匹配和显式匹配最大的区别就是 <b>一个是跟随协议匹配自动装载的，一个是显式装载的</b> 
</p>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Limit</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
这个匹配操作必须由 <span class="underline">-m limit</span> 明确指定才能使用：
</p>
<ul class="org-ul">
<li>对指定的规则的日志数量加以限制，以免你被信息的洪流淹没哦。比如，你可以事先设定一个限定值，当符合条件的包的数量不超过它时，就记录；超过了，就不记录了
</li>
<li>可以控制某条规则在一段时间内的匹配次数 （也就是可以匹配的包的数量），这样就能够减少 <span class="underline">DoS syn flood</span> 攻击的影响
</li>
</ul>

<p>
imit match也可以用 <span class="underline">感叹号</span> 取反：
<span class="underline">-m limit ! &#x2013;limit 5/s</span> ： 表示在数量超过限定值后，所有的包都会被匹配
</p>

<pre class="example">
limit match的工作方式就像一个单位大门口的保安，当有人要进入时，需要找他办理通行证

早上上班时，保安手里有一定数量的通行证，来一个人，就签发一个，当通行证用完后，再来人就进不去了，但他们不会等，而是到别的地方去

在iptables里，这相当于一个包不符合某条规则，就会由后面的规则来处理，如果都不符合，就由缺省的策略处理

但有个规定，每隔一段时间保安就要签发一个新的通行证。这样，后面来的人如果恰巧赶上，也就可以进去了

如果没有人来，那通行证就保留下来，以备来的人用

如果一直没人来，可用的通行证的数量就增加了，但不是无限增大的，最多也就是刚开始时保安手里有的那个数量

也就是说，刚开始时，通行证的数量是有限的，但每隔一段时间就有新的通行证可用
</pre>

<p>
limit match有两个参数就对应这种情况：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;limit-burst</span> ：刚开始时有多少通行证可用
</li>
<li><span class="underline">&#x2013;limit</span> ：要隔多长时间才能签发一个新的通行证
</li>
</ul>

<p>
这里强调的是 <span class="underline">签发一个新的通行证</span> ，这是 <b>以iptables的角度</b> 考虑的。在自己写规则时，就要从这个角度考虑。比如，指定了 <span class="underline">&#x2013;limit 3/minute &#x2013;limit-burst 5</span>  : 
</p>
<ul class="org-ul">
<li>iptables的角度：开始时有5个通行证，用完之后每20秒增加一个
</li>
<li>以用户的角度看：说法就是每一分钟增加三个或者每分钟只能过三个
</li>
</ul>

<p>
要是想每20分钟过一个，只能写成 <span class="underline">&#x2013;limit 3/hour &#x2013;limit-burst 5</span> ，也就是说 <b>要把时间单位凑成整</b>
</p>
</div>
<div id="outline-container-sec-4-3-1-1" class="outline-5">
<h5 id="sec-4-3-1-1">limit</h5>
<div class="outline-text-5" id="text-4-3-1-1">
<pre class="example">
--limit
</pre>

<p>
<b>为limit match设置最大平均匹配速率</b> ，也就是单位时间内limit match可以匹配几个包。它的形式是 <b>一个数值加一个时间单位</b> : 
</p>
<ul class="org-ul">
<li>/second
</li>
<li>/minute
</li>
<li>/hour
</li>
<li>/day 
</li>
</ul>

<p>
默认值是 <b>每小时3次</b> （用户角度），即 <span class="underline">3/hour</span> ，也就是 <b>每20分钟一次</b> （iptables角度）
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m limit --limit 3/hour
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-1-2" class="outline-5">
<h5 id="sec-4-3-1-2">limit-burst</h5>
<div class="outline-text-5" id="text-4-3-1-2">
<pre class="example">
--limit-burst
</pre>

<p>
定义的是 <b>limit match的峰值</b> ， 就是在单位时间（这个时间由上面的&#x2013;limit指定）内最多可匹配几个包（&#x2013;limit-burst的值要比&#x2013;limit的大）。默认值是5 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m limit --limit-burst 5
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">MAC</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
基于 <b>包的MAC源地址</b> 匹配包
</p>

<pre class="example">
    这个match是由-m mac装入的，而不是一些人想当然的-m mac-source，后者只是前者的选项而已
</pre>
</div>

<div id="outline-container-sec-4-3-2-1" class="outline-5">
<h5 id="sec-4-3-2-1">mac-source</h5>
<div class="outline-text-5" id="text-4-3-2-1">
<pre class="example">
--mac-source
</pre>

<p>
基于包的MAC源地址匹配包，地址格式只能是 <span class="underline">XX:XX:XX:XX:XX:XX</span> ，当然也可以用 <span class="underline">感叹号</span> 取反
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;mac- source ! 00:00:00:00:00:01</span> : 除此之外的地址都可接受嘛
</li>
<li>MAC addresses只用于 <span class="underline">Ethernet</span> 类型的网络，所以这个match只能用于Ethernet接口。而且，它还只能在
<ul class="org-ul">
<li><span class="underline">PREROUTING</span>
</li>
<li><span class="underline">FORWARD</span>
</li>
<li><span class="underline">INPUT</span> 链里使用
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m mac --mac-source 00:00:00:00:00:01
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3">Mark</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
以 <b>包被设置的mark</b> 来匹配包，这个值只能由内核更改
</p>

<pre class="example">
mark比较特殊，它不是包本身的一部分，而是在包穿越计算机的过程中由内核分配的和它相关联的一个字段

它可能被用来改变包的传输路径或过滤

时至今日，在linux里只有一种方法能设置mark，即iptables的MARK target

以前在ipchains里是FWMARK target。这就是为什么在高级路由里仍要参照FWMARK的原因
</pre>

<p>
mark字段的值是一个 <b>无符号的整数</b> ， 在32位系统上最大可以是 <span class="underline">4294967296</span> ，就是2的32次方
</p>
</div>

<div id="outline-container-sec-4-3-3-1" class="outline-5">
<h5 id="sec-4-3-3-1">mark</h5>
<div class="outline-text-5" id="text-4-3-3-1">
<pre class="example">
--mark value[/mask]
</pre>


<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A INPUT -m mark --mark 1
</pre>
</div>

<p>
以包被设置的mark值来匹配包，这个值是通过 <span class="underline">MARK target</span> 来设置的，它是一个无符号的整数。上面的例子是没有掩码的，如果指定了掩码：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;mark 1/1</span> ：先把 <span class="underline">mark值和掩码取逻辑与</span> ，然后再和包的mark值比较
</li>
</ul>

<pre class="example">
  所有通过Netfilter的包都会被分配一个相关联的mark field

  但是mark值可不是在任何情况下都能使用的，它只能在分配给它值的那台机子里使用

  因为它只是由内核在内存里分配的和包相关的几个字节，并不属于包本身，所以不能在本机之外的路由器上使用
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4">Multiport</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
<b>多端口匹配</b> 扩展能够在一条规则里指定不连续的多个端口，如果没有这个扩展，只能按端口来写规则了
</p>

<pre class="example">
    不能在一条规则里同时使用标准端口匹配和多端口匹配，如--sport 1024:63353 -m multiport --dport 21,23,80
    
    这条规则并不能想你想象的那样工作，但也不是不能工作，iptables会使用第一个合法的条件，那么这里多端口匹配就白写了
</pre>
</div>

<div id="outline-container-sec-4-3-4-1" class="outline-5">
<h5 id="sec-4-3-4-1">source-port</h5>
<div class="outline-text-5" id="text-4-3-4-1">
<pre class="example">
--source-port
</pre>

<p>
<b>源端口多端口</b> 匹配：
</p>
<ul class="org-ul">
<li>最多可以指定 <span class="underline">15</span> 个端口
</li>
<li>以 <span class="underline">逗号</span> 分隔
</li>
<li><span class="underline">没有空格</span>
</li>
<li>必须有 <b>-p tcp</b> 或 <b>-p udp</b> 为前提条件
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m multiport --source-port 22,53,80,110
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4-2" class="outline-5">
<h5 id="sec-4-3-4-2">destination-port</h5>
<div class="outline-text-5" id="text-4-3-4-2">
<pre class="example">
--destination-port
</pre>

<p>
<b>目的端口多端口</b> 匹配，使用方法和 <span class="underline">源端口多端口</span> 匹配一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m multiport --destination-port 22,53,80,110
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4-3" class="outline-5">
<h5 id="sec-4-3-4-3">port</h5>
<div class="outline-text-5" id="text-4-3-4-3">
<pre class="example">
--port
</pre>
<p>
<b>同端口多端口</b> 匹配，意思就是它匹配的是那种 <b>源端口和目的端口是同一个端口</b> 的包，比如： <span class="underline">端口80到端口80</span> 的包。使用方法和 <span class="underline">源端口多端口</span> 匹配一 样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m multiport --port 22,53,80,110
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5" class="outline-4">
<h4 id="sec-4-3-5">Owner</h4>
<div class="outline-text-4" id="text-4-3-5">
<p>
基于 <b>包的生成者</b> （ <span class="underline">owner</span> ）的ID来匹配包，owner可以是：
</p>
<ul class="org-ul">
<li><span class="underline">启动进程的用户的ID</span>
</li>
<li><span class="underline">用户所在的组的ID</span>
</li>
<li><span class="underline">进程的ID</span>
</li>
<li><span class="underline">会话的ID</span> 
</li>
</ul>

<pre class="example">
  只能用在OUTPUT中

  原因显而易见：几乎不可能得到发送端例程的ID的任何信息，或者在去往真正目的地的路上哪儿有路由

  甚至在 OUTPUT链里，这也不是十分可靠，因为有些包根本没有owner，比如 ICMP responses，所以它们从不会被这个match抓到
</pre>
</div>

<div id="outline-container-sec-4-3-5-1" class="outline-5">
<h5 id="sec-4-3-5-1">uid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-1">
<pre class="example">
--uid-owner
</pre>

<p>
按 <b>生成包的用户的ID</b> 来匹配外出的包。使用这个匹配可以做这样一些事：
</p>
<ul class="org-ul">
<li>阻止除root外的用户向防火墙外建立新连接
</li>
<li>阻止除用户http外的任何人使用HTTP端口发送数据
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --uid-owner 500
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5-2" class="outline-5">
<h5 id="sec-4-3-5-2">gid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-2">
<pre class="example">
--gid-owner
</pre>

<p>
按 <b>生成包的用户所在组的ID</b> 来匹配外出的包：
</p>
<ul class="org-ul">
<li>可以只让属于network组的用户上Internet，而其他用户都不 行
</li>
<li>只允许http组的成员能从HTTP端口发送数据
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --gid-owner 0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5-3" class="outline-5">
<h5 id="sec-4-3-5-3">pid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-3">
<pre class="example">
--pid-owner
</pre>

<p>
按 <b>生成包的进程的ID</b> 来匹配外出的包：
</p>
<ul class="org-ul">
<li>可以只允许PID为94的进程（http进程当然不能是多线程的）使用http端口
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --pid-owner 78
</pre>
</div>
<p>
这个匹配使用起来有一点难度，因为要知道进程的ID号。当然，也可以写一个小小的脚本，先从ps的输出中得到PID，再添加相应的规则
</p>
</div>
</div>

<div id="outline-container-sec-4-3-5-4" class="outline-5">
<h5 id="sec-4-3-5-4">sid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-4">
<pre class="example">
--sid-owner
</pre>

<p>
按 <b>生成包的会话的ID</b> 来匹配外出的包。 <span class="underline">一个进程以及它的子进程或它的多个线程都有同一个SID</span> ：
</p>
<ul class="org-ul">
<li>所有的HTTPD进程的SID和它的父进程一样（最初的 httpd进程），即使httpd是多线程的也一样
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --sid-owner 100
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-6" class="outline-4">
<h4 id="sec-4-3-6">State</h4>
<div class="outline-text-4" id="text-4-3-6">
<p>
状态匹配扩展要有 <b>内核里的连接跟踪代码的协助</b> ，因为它是从连接跟踪机制中得到包的状态的。这样就可以了解连接所处的状态。它几乎适用于所有的协议，包括那些无状态的协议，如ICMP和UDP。针对每个连接都有一个 <span class="underline">缺省的超时值</span> ，如果连接的时间超过了这个值，那么这个连接的记录就被会从连接跟踪的记录数据库中删除，也就是说连接就不再存在了。这个match必须有 <b>-m state</b> 作为前提才能使用
</p>
</div>

<div id="outline-container-sec-4-3-6-1" class="outline-5">
<h5 id="sec-4-3-6-1">state</h5>
<div class="outline-text-5" id="text-4-3-6-1">
<pre class="example">
--state
</pre>

<p>
指定要匹配 <b>包的状态</b> ，当前有4种状态可用：
</p>
<ul class="org-ul">
<li>INVALID
</li>
<li>ESTABLISHED
</li>
<li>NEW
</li>
<li>RELATED
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m state --state RELATED,ESTABLISHED
</pre>
</div>

<p>
注意： NEW状态并不在试图建立新连接的TCP包里寻找SYN标 记，因此它不应该不加修改地用在只有一个防火墙或在不同的防火墙之间没有启用负载平衡的地方
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-3-7" class="outline-4">
<h4 id="sec-4-3-7">TOS</h4>
<div class="outline-text-4" id="text-4-3-7">
<p>
根据TOS字段匹配包，必须使用 <b>-m tos</b> 才能装 入。TOS是IP头的一部分，其含义是Type Of Service，由8个二进制位组成：
</p>
<ul class="org-ul">
<li>3 bit： <b>优先权</b> 子字段，现在已被忽略
</li>
<li>4 bit： <b>TOS子字段</b> 
</li>
<li>1 bit： 未用位，必须置 <span class="underline">0</span> 
</li>
</ul>

<pre class="example">
  一般用来把当前流的优先权和需要的服务（比如，最小延时、最大吞吐量 等）通知路由器

  但路由器和管理员对这个值的处理相差很大，有的根本就不理会，而有的就会尽量满足要求
</pre>
</div>
<div id="outline-container-sec-4-3-7-1" class="outline-5">
<h5 id="sec-4-3-7-1">tos</h5>
<div class="outline-text-5" id="text-4-3-7-1">
<pre class="example">
--tos
</pre>

<p>
根据 <b>TOS字段</b> 匹配包。它的参数可以是：
</p>
<ul class="org-ul">
<li><span class="underline">16进制数</span>
</li>
<li><span class="underline">十进制数</span>
</li>
<li><span class="underline">相应的名字</span> : 用 <b>iptables -m tos -h</b> 能查到
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m tos --tos 0x16
</pre>
</div>

<p>
这个match常被 <b>用来mark</b> 包，以便后用，还常和iproute2或高级路由功能一起使用：
</p>
<ul class="org-ul">
<li><span class="underline">Minimize-Delay 16 (0x10)</span>  : 要求找一条路径使延时最小，一些标准服务如telnet、SSH、FTP-control 就需要这个选项
</li>
<li><span class="underline">Maximize-Throughput 8 (0x08)</span> : 要求找一条路径能使吞吐量最大，标准服务FTP-data能用到这个
</li>
<li><span class="underline">Maximize-Reliability 4 (0x04)</span> : 要求找一条路径能使可靠性最高，使用它的有BOOTP和TFTP
</li>
<li><span class="underline">Minimize-Cost 2 (0x02)</span> : 要求找一条路径能使费用最低，一般情况下使用这个选项的是一些视频音频流协议，如RTSP
</li>
<li><span class="underline">Normal-Service 0 (0x00)</span> : 一般服务，没有什么特殊要求
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-8" class="outline-4">
<h4 id="sec-4-3-8">TTL</h4>
<div class="outline-text-4" id="text-4-3-8">
<p>
根据 <b>IP头里的TTL ( <span class="underline">Time To Live</span> )字段</b> 来匹配包，此必须由 <b>-m ttl</b> 装入
</p>
<pre class="example">
TTL field是一个字节（8个二进制位），一旦经过一个处理它的路由器，它的值就减去1它的值

当该字段的值减为0时，报文就被认为是不可转发的，数据报就被丢弃，并发送ICMP报文通知源主机，不可转发的报文被丢弃

这也有两种情况，一是传输期间生存时间为0，使用类型为11代码是0的ICMP报文
                         二是在数据报重组期间生存时间为0，使用类型 为11代码是1的ICMP报文
</pre>
<p>
这个match只是根据TTL匹配包，而对其不做任何更改，所以在它之后可使用任何类型的match
</p>
</div>

<div id="outline-container-sec-4-3-8-1" class="outline-5">
<h5 id="sec-4-3-8-1">ttl</h5>
<div class="outline-text-5" id="text-4-3-8-1">
<pre class="example">
--ttl
</pre>

<p>
根据TTL的值来匹配包，参数的形式只有一种，就是 <span class="underline">十进制</span> 数值：
</p>
<ul class="org-ul">
<li>它可以被用来调试你的局域网，比如解决LAN内的主机到Internet上的主机的连接问题
</li>
<li>找出 <b>Trojan</b> 可能的入口
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m ttl --ttl 60
</pre>
</div>

<p>
这个match的用处相对有限，但它其实是很有用的，这就看你的想象力如何了：
</p>
<ul class="org-ul">
<li>可以用它来发现那些TTL具有错误缺省值的机子：这可能是实现TCP/IP栈功能的那个程序本身的错误，或者是配置有问题
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">非正常包的匹配</h3>
<div class="outline-text-3" id="text-4-4">
<p>
这个匹配没有任何参数，也不需要显式地装载：
</p>
<ul class="org-ul">
<li>一个实验性的匹配，它不总是能正常工作的，对有些不正常的包（unclean package，就是所谓的脏包）或问题，它是视而不见的
</li>
<li>试图匹配那些好象畸形或不正常的包，比如包头错或校验和错，等等
</li>
</ul>

<p>
它可能常用来：
</p>
<ul class="org-ul">
<li>DROP错误的连接
</li>
<li>检查有错的流
</li>
</ul>

<p>
但要知道这样做也可能会中断合法的连接
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Target/Jump</h2>
<div class="outline-text-2" id="text-5">
<p>
<b>target/jump</b> 决定符合条件的包到何处去，语法是
</p>
<pre class="example">
--jump target 或 -j target
</pre>
<p>
Target和Jump唯一的区别：
</p>
<ul class="org-ul">
<li>jump: 目标是一个在同一个表内的链
</li>
<li>target: 目标是具体的操作
</li>
</ul>

<p>
下面在 <span class="underline">filter</span> 表中建一个名为 tcp _ packets 的链：
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -N tcp_packets
</pre>
</div>

<p>
然后再把它作为 <b>jump</b> 的目标：
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -j tcp_packets
</pre>
</div>

<p>
这样就会从 <span class="underline">INPUT</span> 链跳入 tcp _ packets 链，开始在tcp _ packets中的旅行。如果到达了tcp _ packets链的结尾（ <span class="underline">未被链中的任何规则匹配</span> ），则会退到INPUT链的下一条规则继续它的旅行。如果在子链中被ACCEPT了，也就相当于在父链中被ACCEPT了，那么它不会再经过父链中的其他规则。但要注意 <b>这个包能被其他表的链匹配</b> 
</p>

<p>
target指定要对包做的操作，比如 <span class="underline">DROP</span> 和 <span class="underline">ACCEPT</span> 。不同的target有不同的结果：
</p>
<ul class="org-ul">
<li>一些target会使包停止前景，也就是不再继续比较当前链中的其他规则或父链中的其他规则，最好的例子就是DROP和ACCEPT
</li>
<li>另外一些target在对包做完操作之后，包还会继续和其他的规则比较，如LOG，ULOG和TOS。它们会对包进行记 录、mangle，然后让包通过，以便匹配这条链中的其他规则。有了这样的target，就可以对同一个包既改变它的TTL又改变它的TOS
</li>
<li>有些target必须要有准确的参数（如TOS需要确定的数值）
</li>
<li>有些就不是必须要有准确的参数，但如果想指定也可以（如日志的前缀，伪装使用的端口，等等）
</li>
</ul>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">ACCEPT</h3>
<div class="outline-text-3" id="text-5-1">
<pre class="example">
-j ACCEPT
</pre>
<p>
没有任何选项和参数，使用也很简单，指定 <span class="underline">-j ACCEPT</span> 即可：
</p>
<ul class="org-ul">
<li>一旦包满足了指定的匹配条件，就会被ACCEPT，并且不会再去匹配当前链中的其他规则或同一个表内的其他规则
</li>
<li>但它还要通过其他表中的链，而且在那儿可能会被DROP掉
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">DNAT</h3>
<div class="outline-text-3" id="text-5-2">
<p>
用来做 <b>目的网络地址转换</b> 的，就是重写包的目的IP地址。如果一个包被匹配了，那么和它属于同一个流的所有的包都会被自动转换，然后就可以被路由到正确的主机或网络：
</p>
<ul class="org-ul">
<li>Web服务器在LAN内部，而且没有可在Internet上使用的真实IP地址，可以使用这个让防火墙把所有到它自己HTTP端口的包转发给LAN内部真正的Web服务器
</li>
<li>目的地址也可以是一个范 围，这样的话，DNAT会为每一个流随机分配一个地址。因此，可以用这个target做某种类型地负载平 衡。
</li>
</ul>

<pre class="example">
DANT只能用在nat表的PREROUTING和OUTPUT链中，或者是被这两条链调用的链里

包含DANT target的链不能被除此之外的其他链调用，如POSTROUTING
</pre>
</div>

<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">to-destination</h4>
<div class="outline-text-4" id="text-5-2-1">
<pre class="example">
--to-destination
</pre>

<p>
指定要写入IP头的地址，这也是包要被转发到的地方
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.1.1-192.168.1.10
</pre>
</div>

<p>
把所有发往地址 <span class="underline">15.45.23.67</span> 的包都转发到一段LAN使用的私有地址中，即 <span class="underline">192.168.1.1到 192.168.1.10</span> ：
</p>
<ul class="org-ul">
<li>每个流都会被随机分配一个要转发到的地址，但同一个流总是使用同一个地址
</li>
<li>可以只指定一个IP地址作为参数，这样所有的包都被转发到同一台机子
</li>
<li>可以在地址后指定一个或一个范围的端口：
<ul class="org-ul">
<li>&#x2013;to-destination 192.168.1.1:80
</li>
<li>&#x2013;to-destination 192.168.1.1:80-100
</li>
</ul>
</li>
</ul>

<pre class="example">
只有先用--protocol指定了TCP或UDP协议，才能使用端口
</pre>

<p>
<b>SNAT</b> 的语法和这个target的一样，只是目的不同罢了
</p>
</div>

<div id="outline-container-sec-5-2-1-1" class="outline-5">
<h5 id="sec-5-2-1-1">更详细的例子</h5>
<div class="outline-text-5" id="text-5-2-1-1">
<p>
我想通过Internet连接发布我们的网站，但是http server在我们的内网里: 
</p>
<ul class="org-ul">
<li>对外只有一个合法的IP，就是防火墙那个对外的IP:  $INET _ IP
</li>
<li>防火墙还有一个内网的IP: $LAN _ IP 
</li>
<li>Http server的IP: $HTTP _ IP（这当然是内网的了）
</li>
</ul>

<p>
为了完成我们的设想，要做的第一件事就是把下面的这个简单的规则加入到nat表的PREROUTING链中：
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A PREROUTING --dst $<span style="color: #eedd82;">INET_IP</span> -p tcp --dport 80 -j DNAT <span style="color: #ffa07a;">\ </span>--to-destination $<span style="color: #eedd82;">HTTP_IP</span>
</pre>
</div>

<p>
现在，所有从Internet来的、到防火墙的80端口去的包都会被转发（或称做被 <b>DNAT</b> ）到在内网的HTTP服务器上。如果你Internet上试验一下，一切正常吧。再从内网里试验一下，完全不能用吧。这其实是路由的问题。把在外网上访问我们服务器的那台机子的IP地址记为 $EXT _ BOX 
</p>
<ol class="org-ol">
<li>包从地址为 $EXT _BOX的机子出发，去往地址为$INET _ IP的机子
</li>
<li>包到达防火墙
</li>
<li>防火墙DNAT（也就是转发）这个包，而且包会经过很多其他的链检验及处理
</li>
<li>包离开防火墙向$HTTP _ IP前进
</li>
<li>包到达HTTP服务器，服务器就会通过防火墙给以回应，当然，这要求 <b>把防火墙作为 <span class="underline">HTTP</span> 到达 $EXT _ BOX 的网关</b> 。一般情况下，防火墙就是HTTP服务器的缺省网关
</li>
<li>防火墙再对返回包做 <b>Un-DNAT</b> （就是照着DNAT的步骤反过来做一遍），这样就好像是防火墙自己回复了那个来自外网的请求包
</li>
<li>返回包好象没经过这么复杂的处理、没事一样回到 $EXT _ BOX 
</li>
</ol>

<p>
现在，来考虑和HTTP服务器在同一个内网（这里是指所有机子不需要经过路由器而可以直接互相访问的网络，不是那种把服务器和客户机又分在不同子网的情况）的客户访问它时会发生什么。假设客户机的IP为$LAN _ BOX，其他设置同上
</p>
<ol class="org-ol">
<li>包离开$LAN _ BOX，去往$INET _ IP
</li>
<li>包到达防火墙
</li>
<li>包被 <b>DNAT</b> ,而且还会经过其他的处理。但是包没有经过 <b>SNAT</b> 的处理，所以 <b>包还是使用它自己的源地址，就是$LAN _ BOX</b> 
</li>
<li>包离开防火墙，到达HTTP服务器
</li>
<li>HTTP服务器试图回复这个包。它在 <b>路由数据库中看到包是来自同一个网络的一台机子，因此它会把回复包直接发送到请求包的源地址</b> （现在是回复包的目的地址），也就是$LAN _ BOX
</li>
<li>回复包到达客户机，但它会很困惑，因为 <b>这个包不是来自它访问的那台机子</b> 。这样，它就会把这个包 <b>扔掉</b> 而去等待 <span class="underline">真正</span> 的回复包
</li>
</ol>

<pre class="example">
IP传输包的特点：只根据目的地的不同改变目的地址，但不因传输过程中要经过很多路由器而随着路由器改变其源地址，除非你单独进行源地址的改变

这是造成内网无法访问的根本原因
</pre>

<p>
有个简单的解决办法：因为这些包都要进入防火墙，而且它们都去往需要做DNAT才能到达的那个地址，所以只要对这些包做SNAT操作即可。比如，考虑上面的例子，如果对那些进入防火墙而且是去往地址为 $HTTP _ IP、端口为80的包做 <b>SNAT</b> 操作，那么这些包就好象是从 $LAN _ IP来的了，也就是 说，这些包的源地址被改为 <b>$LAN _ IP</b> 了。这样，HTTP服务器就会把回复包发给防火墙，而防火墙会再对包做 Un-DNAT操作，并把包发送到客户机。解决问题的规则如下：
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A POSTROUTING -p tcp --dst $<span style="color: #eedd82;">HTTP_IP</span> --dport 80 -j SNAT <span style="color: #ffa07a;">\ </span>--to-source $<span style="color: #eedd82;">LAN_IP</span>
</pre>
</div>

<pre class="example">
  警告：刚才写的这条规则会对日志产生很大影响，这种影响应该说是很不好的。因为来自Internet包在防火墙内先后经过了DNAT和SNAT处理，才能到达HTTP服务器（上面的例子），所以HTTP服务器就认为包是防火墙发来的，而不知道真正的源头是其他的IP。这样，当它记录服务情况时，所有访问记录的源地址都是防火墙的IP而不是真正的访问源。如果想根据这些记录来了解访问情况就不可能了。因此上面提供的“简单办法”并不是一个明智的选择，但它确实可以解决“能够访问”的问题，只是没有考虑到日志而已

  其他的服务也有类似的问题。比如，你在LAN内建立了SMTP服务器，那你就要设置防火墙以便能转发SMTP的数据流。这样你就创建了一个开放的SMTP中继服务器，随之而来的就是日志的问题了

  这里所说的问题只是针对没有建立DMZ或类似结构的网络，并且内网的用户访问的是服务器的外网地址而言的。因为如果建立了DMZ，或者服务器和客户机又被分在不同的子网里， 那就不需要这么麻烦了。因为所有访问的源头都不在服务器所在的网里，所以就没必要做SNAT去改变包的源地址了，从而记录也就不是问题了。如果内网客户是直接访问服务器的内网地址那就更没事了

  较好的解决办法是为你的LAN在内网建立一台单独的DNS服务器。这样，内网的客户使用网站名访问HTTP服务器时，DNS就可以把它解析成内网地址。客户机就可以直接去访问HTTP服务器的内网地址了， 从而避免了通过防火墙的操作，而且包的源地址也可以被HTTP服务器的日志使用，也就没有上面说的日志问题了。或者干脆建立DMZ得了，这是最好的办法，但你要有钱哦，因为用的设备多啊
</pre>

<p>
对上面的例子应该考虑再全面些，现在还有一个问题没解决， 就是 <b>防火墙自己要访问HTTP服务器时会发生什么</b> ，能正常访问吗？很可惜，现在的配置还是不行，仔细想想就明白了。这里讨论的基础都是假设机子访问的是 <span class="underline">HTTP服务器的外网地址，但这个外网地址其实就是防火墙对外的地址，所以当防火墙访问这个外网地址时，就是访问它自己</span> 。防火墙上如果有HTTP服务，那客户机就会看到页面内容，不过这不是它想看到的（它想要的在DNAT上了），如果没有HTTP服务，客户就只能收到错误信息了。前面给出的规则之所以不起作用是因为从防火墙发出的请求包不会经过那两条链。所以要在nat表的 <span class="underline">OUTPUT</span> 链中添加下面的规则：
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A OUTPUT --dst $<span style="color: #eedd82;">INET_IP</span> -p tcp --dport 80 -j DNAT <span style="color: #ffa07a;">\ </span>--to-destination $<span style="color: #eedd82;">HTTP_IP</span>
</pre>
</div>

<p>
有了最后这条规则，一切都正常了：
</p>
<ul class="org-ul">
<li><b>PREROUTING</b> 链做 <b>DNAT</b> ：和HTTP服务器不在同一个网的机子能正常访问服务了
</li>
<li><b>POSTROUTING</b> 链做 <b>SNAT</b> ：和它在一个网内的机子也可以正常访问服务了：
</li>
<li><b>OUTPUT</b> 链做 <b>DNAT</b> ：防火墙本身也能正常访问服务了
</li>
</ul>

<pre class="example">
  除此之外，在 filter表中还需要其他的规则（在FORWARD链里），以允许特定的包也能经过前面写的（在POSTROUTING链和 OUTPUT链里的）规则

  在写规则时要注意：千万不要忘了，那些包在到达FORWARD链之前已经在PREROUTING链里被DNAT过了，也就是说它们的目的地址已被改写
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">DROP</h3>
<div class="outline-text-3" id="text-5-3">
<p>
如果包符合条件，这个target就会把它丢掉，也就是说包的生命到此结束，不会再向前走一 步，效果就是包被阻塞了：
</p>

<p>
在某些情况下，这个target会引起意外的结果，因为它不会向发送者返回任何信 息，也不会向路由器返回信息，这就可能会使连接的另一方的sockets因苦等响应
</p>

<p>
解决这个问题的较好的办法是使用 <b>REJECT</b> target
</p>
<pre class="example">
   因为它在丢弃包的同时还会向发送者返 回一个错误信息，这样另一方就能正常结束
   
   尤其是在阻止端口扫描工具获得更多的信息时，可以隐蔽被过滤掉的端口等等
   
   因为扫描工具扫描一个端口时，如果没有返回信息，一般会认为端口未打开或被防火墙等设备过滤掉了
</pre>

<p>
注意：如果包在子链中被DROP了，那么它在主链里也不会再继续前进，不管是在当前的表还是在其他表里。总之，包被丢弃了
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">LOG</h3>
<div class="outline-text-3" id="text-5-4">
<p>
专门用来 <b>记录包的有关信息</b> 的。这些信息可能是非法的，那就可以用来除错。LOG会返回包的有关细节，如IP头的大部分和其他有趣的信息。这个功能是通过内核的日志工具完成的，一般是syslogd。返回的信息可用dmesg阅读，或者可以直接查看syslogd的日志文件，也可以用其他的什么程序来看
</p>

<p>
LOG对调试规则有很大的帮助，可以看到包去了哪里、经过了什么规则的处理，什么样的规则处理什么样的包，等等。当你在生产服务器上调试一个不敢保证100%正常的规则集时，用LOG代替DROP是比较好的，因为一个小小的语法错误就可能引起严重的连接问题
</p>

<p>
如果你想使用真正地扩展日志地话，可能会对 <b>ULOG</b> target有些兴趣，因为它可以把日志直接记录到MySQL databases或类似的数据库中
</p>

<pre class="example">
   如果在控制台得到的信息不是你想要的，那不是iptables或Netfilter的问题，而是 syslogd 配置文件的事，这个文件一般都是/etc/syslog.conf
</pre>
</div>

<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">log-level</h4>
<div class="outline-text-4" id="text-5-4-1">
<pre class="example">
--log-level
</pre>

<p>
告诉iptables和 syslog使用哪个记录等级。记录等级的详细信息可以查看文件syslog.conf，一般来说有以下几种，它们的级别依次是：
</p>
<ul class="org-ul">
<li>debug
</li>
<li>info
</li>
<li>notice
</li>
<li>warning/warn
</li>
<li>err/error
</li>
<li>crit
</li>
<li>alert
</li>
<li>emerg/panic
</li>
</ul>

<p>
信息级别说明了 <b>被记录信息所反映的问题的严重程度</b> 。所有信息都是通过内核的功能被记录的：
</p>
<ol class="org-ol">
<li>先在文件 syslog.conf里设置kern.=info /var/log/iptables
</li>
<li>再让所有关于iptables的LOG信息使用级别info，就可以把所有的信息存入文件/var/log/iptables内
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A FORWARD -p tcp -j LOG --log-level debug
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">log-prefix</h4>
<div class="outline-text-4" id="text-5-4-2">
<pre class="example">
--log-prefix
</pre>

<p>
告诉iptables在记录的信息之前加上指定的前缀。这样和grep或其他工具一起使用时就容易追踪特定的问题，而且也方便从不同的规则输出。前缀最多能有29个英文字符，这已经是包括空白字符和其他特殊符号的总长度了 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -j LOG --log-prefix <span style="color: #ffa07a;">"INPUT packets"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">log-tcp-sequence</h4>
<div class="outline-text-4" id="text-5-4-3">
<pre class="example">
--log-tcp-sequence
</pre>

<p>
把包的TCP序列号和其他日志信息一起记录下来。 <span class="underline">TCP序列号</span> 可以唯一标识一个包，在重组时也是用它来确定每个分组在包里的位置
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -j LOG --log-tcp-sequence
</pre>
</div>

<pre class="example">
    这个选项可能会带来危险， 因为这些记录被未授权的用户看到的话，可能会使他们更容易地破坏系统
    
    任何iptables的输出信息都增加了这种危险
</pre>
</div>
</div>

<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">log-tcp-options</h4>
<div class="outline-text-4" id="text-5-4-4">
<pre class="example">
--log-tcp-options
</pre>

<p>
记录TCP包头中的字段大小不变的选项。这对一些除错是很有价值的，通过它提供的信息，可以知道哪里可能出错，或者哪里已经出了错
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A FORWARD -p tcp -j LOG --log-tcp-options
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-5" class="outline-4">
<h4 id="sec-5-4-5">log-ip-options</h4>
<div class="outline-text-4" id="text-5-4-5">
<pre class="example">
--log-ip-options
</pre>

<p>
记录IP包头中的字段大小不变的选项。这对一些除错是很有 价值的，还可以用来跟踪特定地址的包
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A FORWARD -p tcp -j LOG --log-ip-options
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">MARK</h3>
<div class="outline-text-3" id="text-5-5">
<p>
用来设置mark值，这个值只能在 <b>本地</b> 的 <span class="underline">mangle</span> 表里使用，不能用在其他任何地方，就更不用说路由器或另一台机子了。因为mark比较特殊，它不是包本身的一部分，而是在包穿越计算机的过程中由内核分配的和它相关联的一个字段。它可以和本地的高级路由功能联用，以使不同的包能使用不同的队列要求等等
</p>

<p>
如果想在传输过程中也有这种功能，还是用 <span class="underline">TOS</span> target吧
</p>
</div>

<div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">set-mark</h4>
<div class="outline-text-4" id="text-5-5-1">
<pre class="example">
--set-mark
</pre>

<p>
设置mark值，这个值是一个无符号的整数。比如，对一 个流或从某台机子发出的所有的包设置了mark值，就可以利用高级路由功能来对它们进行流量控制等操作
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">MASQUERADE</h3>
<div class="outline-text-3" id="text-5-6">
<p>
和 <span class="underline">SNAT</span> target的作用是一样的，区别就是它不需要指定 <b>&#x2013;to-source</b> 。MASQUERADE是被专门设计 <b>用于那些动态获取IP地址的连接的</b> ：
</p>
<ul class="org-ul">
<li>拨号上网
</li>
<li>DHCP连接 
</li>
</ul>

<p>
如果有固定的IP地址，还是用SNAT target吧
</p>

<p>
伪装一个连接意味着， <b>自动获取网络接口的IP地址</b> ，而不使用 <b>&#x2013;to-source</b>  。当接口停用时，MASQUERADE不会记住任何连接，这在kill掉接口时是有很大好处的。如果我们使用SNAT target，连接跟踪的数据是被保留下来的，而且时间要好几天哦，这可是要占用很多连接跟踪的内存的。一般情况下，这种处理方式对于拨号上网来说是较好 的（这有利于已有那连接继续使用）
</p>

<pre class="example">
。如果我们被分配给了一个不同于前一次的IP，不管怎样已有的连接都要丢失，但或多或少地还是有一些连接记录被保留了
</pre>

<p>
即使你有静态的IP，也可以使用MASQUERADE，而不用SNAT 。这不是被赞成的，因为它会带来额外的开销，而且以后还可能引起矛盾，比如它也许会影响你的脚本，使它们不能用
</p>

<p>
注意：MASQUERADE和SNAT一样，只能 <b>用于nat表的POSTROUTING链</b>
</p>
</div>

<div id="outline-container-sec-5-6-1" class="outline-4">
<h4 id="sec-5-6-1">to-ports</h4>
<div class="outline-text-4" id="text-5-6-1">
<pre class="example">
--to-ports
</pre>

<p>
在指定TCP或UDP的前提下，设置外出包能使用的端口：
</p>
<ul class="org-ul">
<li>单个端口： <span class="underline">&#x2013;to-ports 1025</span>
</li>
<li>端口范围： <span class="underline">&#x2013;to- ports 1024-3000</span>
</li>
<li>不是必需的
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000
</pre>
</div>

<p>
注意：在指定范围时要使用 <span class="underline">连字号</span> 。这改变了SNAT中缺省的端口选择
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7">REDIRECT</h3>
<div class="outline-text-3" id="text-5-7">
<p>
<b>防火墙所在的机子内部转发包或流到另一个端口</b> 。比如，可以把所有去往端口HTTP的包REDIRECT到HTTP proxy（例如squid），当然这都 <b>发生在自己的主机内部</b> 。本地生成的包都会被映射到127.0.0.1。换句话说，这个target把要转发的包的目的地址改写为我们自己机子的IP：
</p>
<ul class="org-ul">
<li>透明代理：LAN内的机子根本不需要知道代理的存在就可以正常上网时，这个target很有用
</li>
</ul>

<p>
注意：它只能用在 <b>nat表的PREROUTING、OUTPUT链和被它们调用的自定义链</b> 里
</p>
</div>

<div id="outline-container-sec-5-7-1" class="outline-4">
<h4 id="sec-5-7-1">to-ports</h4>
<div class="outline-text-4" id="text-5-7-1">
<pre class="example">
--to-ports
</pre>

<p>
在指定TCP或UDP协议的前提下，定义目的端口，方式如下：
</p>
<ol class="org-ol">
<li>不使用这个选项：目的端口不会被改变
</li>
<li>指定一个端口： <span class="underline">&#x2013;to-ports 8080</span> 
</li>
<li>指定端口范围： <span class="underline">&#x2013;to-ports 8080-8090</span> 
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8">REJECT</h3>
<div class="outline-text-3" id="text-5-8">
<p>
<b>REJECT</b> 和 <span class="underline">DROP</span> 基本一样，区别在于它 <b>除了阻塞包之外， 还向发送者返回错误信息</b> 。
</p>

<p>
注意：
</p>
<ul class="org-ul">
<li>只能用在 <b>INPUT、FORWARD、OUTPUT和它们的子链里</b>
</li>
<li>包含 <span class="underline">REJECT</span> 的链也只能被它们调用，否则不能发挥作用
</li>
</ul>
</div>


<div id="outline-container-sec-5-8-1" class="outline-4">
<h4 id="sec-5-8-1">reject-with</h4>
<div class="outline-text-4" id="text-5-8-1">
<p>
它只有一个选项，是用来控制返回的错误信息的种类的
</p>
<pre class="example">
--reject-with
</pre>

<p>
告诉REJECT target应向发送者返回什么样的信息。一旦包满足了设定的条件，就要发送相应的信息，然后再象DROP一样无情地抛弃那些包。可用的信息类型有：
</p>
<ul class="org-ul">
<li>icmp-net-unreachable
</li>
<li>icmp-host-unreachable
</li>
<li>icmp-port-unreachable
</li>
<li>icmp-proto-unreachable
</li>
<li>icmp-net-prohibited
</li>
<li>icmp-host-prohibited 
</li>
<li>echo-reply
</li>
<li>tcp-reset：告诉REJECT返回一个TCP RST包，以文雅的方式关闭TCP连接
</li>
</ul>

<p>
其中缺省的是 <b>port-unreachable</b> 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset
</pre>
</div>

<p>
tcp-reset主要用来 <b>阻塞身份识别探针</b> ，即113/tcp，当向被破坏的邮件主机发送邮件时， 探针常被用到，否则它不会接受你的信
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-9" class="outline-3">
<h3 id="sec-5-9">RETURN</h3>
<div class="outline-text-3" id="text-5-9">
<p>
它使包返回上一层，顺序是： <b>子链 -&gt;父链 -&gt; 缺省的策略</b> 。具体地说，就是若包在子链中遇到了RETURN，则返回父链的下一条规则继续进行条件的比较，若是在父链（或称主链，比如INPUT）中遇到了RETURN，就要被缺省的策略（一般是ACCEPT或DROP）操作了
</p>

<p>
假设一个包进入了INPUT链，匹配了某条target为 <span class="underline">&#x2013;jump EXAMPLE<sub>CHAIN</sub></span> 规则，然后进入了子链 <span class="underline">EXAMPLE<sub>CHAIN</sub></span> 。在子链中又匹配了某条规则，恰巧target是 <span class="underline">&#x2013;jump RETURN</span> ，那包就返回 <span class="underline">INPUT</span> 链了。如果在INPUT链里又遇到了 <span class="underline">&#x2013;jump RETURN</span> ，那这个包就要交由 <span class="underline">缺省的策略</span> 来处理
</p>
</div>
</div>

<div id="outline-container-sec-5-10" class="outline-3">
<h3 id="sec-5-10">SNAT</h3>
<div class="outline-text-3" id="text-5-10">
<p>
用来做 <b>源网络地址</b> 转换的，就是重写包的源IP地址
</p>

<p>
有几个机子共享一个Internet连接时，就能用到它了：
</p>
<ol class="org-ol">
<li>先在内核里打开 <span class="underline">ip转发</span> 功能
</li>
<li>再写一个 <span class="underline">SNAT规则</span> 
</li>
</ol>

<p>
就可以把所有从本地网络出去的包的源地址改为Internet连接的地址了
</p>

<p>
如果我们不这样做而是直接转发本地网的包的话，Internet上的机子就不知道往哪儿发送应答了，因为在 <b>本地网里一般使用的是专门指定的一段地址，它们是不能在Internet上使用的</b> 。SNAT target的作用就是让所有从本地网出发的包看起来都是从一台机子发出的，这台机子一般就是防火墙
</p>

<p>
注意：
</p>
<ul class="org-ul">
<li>SNAT只能 <b>用在nat表的POSTROUTING链里</b>
</li>
<li>只要连接的第一个符合条件的包被SNAT了，那么这个连接的其他所有的包都会自动地被SNAT，这个规则还会应用于这个连接所在流的所有数据包
</li>
</ul>
</div>

<div id="outline-container-sec-5-10-1" class="outline-4">
<h4 id="sec-5-10-1">to-source</h4>
<div class="outline-text-4" id="text-5-10-1">
<pre class="example">
--to-source
</pre>

<p>
指定源地址和端口，有以下几种方式：
</p>
<ul class="org-ul">
<li>单独的地址
</li>
<li>一段连续的地址，用 <span class="underline">连字符</span> 分隔
<ul class="org-ul">
<li><span class="underline">194.236.50.155-194.236.50.160</span> ：可以实现负载平衡。每个流会被随机分配一个IP，但对于同一个流使用的是同一个IP
</li>
</ul>
</li>
<li>在指定 <span class="underline">-p tcp</span> 或 <span class="underline">-p udp</span> 的前提下，可以指定源端口的范围
<ul class="org-ul">
<li><span class="underline">194.236.50.155:1024-32000</span> ：包的源端口就被限制在 <span class="underline">1024-32000</span> 
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -t nat -A POSTROUTING -p tcp -o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000
</pre>
</div>

<p>
注意：
</p>
<ul class="org-ul">
<li>如果可能，iptables总是想 <b>避免任何的端口变更</b> ，换句话说，它总是尽力使用建立连接时所用的 端口。但是如果两台机子使用相同的源端口，iptables 将会把他们的其中之一映射到另外的一个端口。如果没有指定端口范围：
<ul class="org-ul">
<li>所有的在512以内的源端口会被映射到512以内的另一个端口
</li>
<li>512和1023之间的将会被映射到 1024内
</li>
<li>其他的将会被映射到大于或对于1024的端口，也就是说是同范围映射
</li>
<li>这种映射和目的端口无关。因此，如果客户想和防火墙外的HTTP服务器联系，它是不会被映射到FTP control所用的端口的
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5-11" class="outline-3">
<h3 id="sec-5-11">TOS</h3>
<div class="outline-text-3" id="text-5-11">
<p>
<b>用来设置IP头中的 <span class="underline">Type of Service</span> 字段</b> 的。这个字段长一个字节，可以控制包的路由情况。它也是iproute2及其子系统可以直接使用的字段之一。如果你有几个独立的防火墙和路由器，而且还想在他们之间利用包的头部来传递路由信息，TOS是唯 一的办法。前面说过，MARK是不能用来传递这种信息的。如果你需要为某个包或流传递路由信息，就要使用TOS字段，它也正是为这个而被开发的
</p>

<p>
Internet上有很多路由器在这一方面并没有做好工作，因此，在发送包之前改变其TOS没有什么大用处。 最好的情况是路由器根本不理它，最坏的情况是路由器会根据TOS处理，但都是错误的。然而，如果你是在一个很大的WAN或LAN里，而且有很多路由器，TOS还是能有很好的作为的。总的来说，基于TOS的值给包以不同的路由和参数还是可能的，即使在网络里是受限制的
</p>

<pre class="example">
TOS只能用来设置具体的或者说是特定的值，但不管怎么说，不要使用其他的值就是了
</pre>

<p>
注意：只能在 <b>mangle</b> 表内使用
</p>
</div>

<div id="outline-container-sec-5-11-1" class="outline-4">
<h4 id="sec-5-11-1">set-tos</h4>
<div class="outline-text-4" id="text-5-11-1">
<pre class="example">
--set-tos
</pre>

<p>
设置TOS的值，值的形式可以是名字或者使相应的数值（十进制或16进制的）。一般情况下，建议使用名字而不使用数值形式，因为以后这些数值可能会有所改变， 而名字一般是固定的。TOS字段有8个二进制位，所以可能的值是0-255（十进制）或0x00-0xFF（16进制）：
</p>
<ul class="org-ul">
<li>Minimize-Delay 16 (0x10)：要求找一条路径使延时最小，一些标准服务如telnet、SSH、FTP- control 就需要这个选项
</li>
<li>Maximize-Throughput 8 (0x08)：要求找一条路径能使吞吐量最大，标准服务FTP-data能用到这个
</li>
<li>Maximize-Reliability 4 (0x04)：要求找一条路径能使可靠性最高，使用它的有BOOTP和TFTP
</li>
<li>Minimize-Cost 2 (0x02)：要求找一条路径能使费用最低，一般情况下使用这个选项的是一些视频音频流协议，如RTSP
</li>
<li>Normal-Service 0 (0x00)：一般服务，没有什么特殊要求。这个值也是大部分包的缺省值
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A PREROUTING -p TCP --dport 22 -j TOS --set-tos 0x10
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-12" class="outline-3">
<h3 id="sec-5-12">TTL</h3>
<div class="outline-text-3" id="text-5-12">
<p>
TTL可以 <span class="underline">修改IP头中Time To Live字段</span> 的值。它有很大的作用，可以把所有外出包的Time To Live值 都改为一样的，比如 <span class="underline">64</span> ，这是Linux的默认值。有些ISP不允许共享连接（可以通过TTL的值来区分是不是有多个机子使用同一个连接），如果把TTL都改为一样的值，他们就不能再根据TTL来判断了
</p>

<p>
注意：TTL只能在 <b>mangle</b> 表内使用
</p>
</div>

<div id="outline-container-sec-5-12-1" class="outline-4">
<h4 id="sec-5-12-1">ttl-set</h4>
<div class="outline-text-4" id="text-5-12-1">
<pre class="example">
--ttl-set
</pre>

<p>
设置TTL的值
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 64
</pre>
</div>

<p>
这个值不要太大，也不要太小，大约64就很好。值越大，占用的带宽越多，这个target就可以被用来限制包能走多远，一个比较恰当的距离是刚好能到达DNS服务器
</p>

<pre class="example">
    值太大会影响网络，而且有点不道德，为什么这样说呢？
    
    如果有些路由器的配置不太正确，包的TTL又非常大，那它们就会在这些路由器之间往返很多次
</pre>
</div>
</div>

<div id="outline-container-sec-5-12-2" class="outline-4">
<h4 id="sec-5-12-2">ttl-dec</h4>
<div class="outline-text-4" id="text-5-12-2">
<pre class="example">
--ttl-dec
</pre>

<p>
设定TTL要被减掉的值
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-dec 3
</pre>
</div>

<p>
假设一个进来的包的TTL是 <span class="underline">53</span> ，那么当它离开我们这台机子时，TTL就变为 <span class="underline">49</span> 了。因为经过我们这台机子，TTL本身就要减1，还要被TTL target再减3，当然总共就是减去4了
</p>

<pre class="example">
    可以限制使用我们的服务的用户*离我们有多远
    
    比如，用户总是使用比较近的DNS，那我们就可以对我们的DNS服务器发出的包进行几个--ttl-dec
    
    当然用--set-ttl控制更方便些
</pre>
</div>
</div>

<div id="outline-container-sec-5-12-3" class="outline-4">
<h4 id="sec-5-12-3">ttl-inc</h4>
<div class="outline-text-4" id="text-5-12-3">
<pre class="example">
--ttl-inc
</pre>

<p>
设定TTL要被增加的值
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-inc 3
</pre>
</div>
<p>
假设一个进来的包的TTL是53，那么当它离开我们这台机子时，TTL应是多少呢？答案是56。
</p>
<pre class="example">
使用这个选项可以使我们的防火墙更加隐蔽，而不被trace-routes发现， 方法就是设置--ttl-inc 1

原因应该很简单了，包每经过一个设备，TTL就要自动减1，但在我们的防火墙里这个1又被补上了

也就是说，TTL的值没变，那么trace-routes就会认为我们的防火墙是不存在的

Trace-routes让人又爱又恨：
  爱它是因为在连接出问题时，它可以给我们提供极有用的信息，告诉我们哪里有毛病
  恨它是由于它也可以被黑客或骇客用来收集目标机器的资料
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-13" class="outline-3">
<h3 id="sec-5-13">ULOG</h3>
<div class="outline-text-3" id="text-5-13">
<p>
ULOG可以 <b>在用户空间记录被匹配的包的信息</b> ：
</p>
<ol class="org-ol">
<li>这些信息和整个包都会通过 <span class="underline">netlink socket被多播</span>
</li>
<li>一个或多个用户空间的进程就会接受它们
</li>
</ol>

<p>
ULOG是至今iptables和Netfilter下最成熟、最完善的日志工具，它包含了很多更好的工具用于包的记录。这个target可以让我们把信息记录到MySQL或其他数据库中。这样，搜索特定的包或把记录分组就很方便了
</p>
</div>

<div id="outline-container-sec-5-13-1" class="outline-4">
<h4 id="sec-5-13-1">ulog-nlgroup</h4>
<div class="outline-text-4" id="text-5-13-1">
<pre class="example">
--ulog-nlgroup
</pre>

<p>
指定向哪个netlink组发送包
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-nlgroup 2
</pre>
</div>

<p>
一个有32个netlink组，它们被简单地编号位1-32。默认值是1
</p>
</div>
</div>

<div id="outline-container-sec-5-13-2" class="outline-4">
<h4 id="sec-5-13-2">ulog-prefix</h4>
<div class="outline-text-4" id="text-5-13-2">
<pre class="example">
--ulog-prefix
</pre>

<p>
指定记录信息的前缀，以便于区分不同的信息。使用方法和LOG的prefix一样，只是长度可以达到32个字符
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-prefix <span style="color: #ffa07a;">"SSH connection attempt: "</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-13-3" class="outline-4">
<h4 id="sec-5-13-3">ulog-cprange</h4>
<div class="outline-text-4" id="text-5-13-3">
<pre class="example">
--ulog-cprange
</pre>

<p>
指定每个包要向 <span class="underline">ULOG在用户空间的代理</span> 发送的字节数：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;ulog-cprange 100</span> ： 把整个包的前100个字节拷贝到用户空间记录下来，其中包含了这个包头，还有一些包的引导数据。默认值是0，表示拷贝整个包，不管它有多大
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-cprange 100
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-13-4" class="outline-4">
<h4 id="sec-5-13-4">ulog-qthreshold</h4>
<div class="outline-text-4" id="text-5-13-4">
<pre class="example">
--ulog-qthreshold
</pre>

<p>
告诉ULOG在向用户空间发送数据以供记录之前，要在内核里收集的包的数量：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;ulog-qthreshold 10</span> ：表示先在内核里积聚10个包，再把它们发送到用户空间里，它们会被看作同一个netlink的信息，只是由好几部分组成罢了。默认值是1，这是为了向后兼容，因为以前的版本不能处理分段的信息
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-qthreshold 10
</pre>
</div>

<p>
<a href="config.html">Next：配置</a>
</p>

<p>
<a href="save_restore.html">Previous：规则的保存和恢复</a>
</p>

<p>
<a href="iptables.html">目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
